zonSou(redeclare
    TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSCeiling_lowC
    conTypCei, redeclare
    TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSFloor_lowC conTypFlo);

zonNor(redeclare
    TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSCeiling_lowC
    conTypCei, redeclare
    TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSFloor_lowC conTypFlo);

operator record Complex "Complex number with overloaded operators"

  replaceable Real re "Real part of complex number" annotation(Dialog);
  replaceable Real im "Imaginary part of complex number" annotation(Dialog);

  encapsulated operator 'constructor' "Constructor"
    function fromReal "Construct Complex from Real"
      import Complex;
      input Real re "Real part of complex number";
      input Real im=0 "Imaginary part of complex number";
      output Complex result(re=re, im=im) "Complex number";
    algorithm

      annotation(Inline=true, Documentation(info="<html>
<p>This function returns a Complex number defined by real part <em>re</em> and optional imaginary part <em>im</em> (default=0).</p>
</html>"));
    end fromReal;
    annotation (Documentation(info="<html>
<p>Here the constructor operator(s) is/are defined.</p>
</html>"), Icon(graphics={Rectangle(
            lineColor={200,200,200},
            fillColor={248,248,248},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25.0), Rectangle(
            lineColor={128,128,128},
            extent={{-100,-100},{100,100}},
            radius=25.0)}));
  end 'constructor';

  encapsulated operator function '0' "Zero-element of addition (= Complex(0))"
    import Complex;
    output Complex result "Complex(0)";
  algorithm
    result := Complex(0);
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the zero-element of Complex, that is, Complex(0) = 0 + j*0.</p>
</html>"));
  end '0';

  encapsulated operator '-' "Unary and binary minus"
    function negate "Unary minus (multiply complex number by -1)"
      import Complex;
      input Complex c1 "Complex number";
      output Complex c2 "= -c1";
    algorithm
      c2 := Complex(-c1.re, -c1.im);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the binary minus of the given Complex number.</p>
</html>"));
    end negate;

    function subtract "Subtract two complex numbers"
      import Complex;
      input Complex c1 "Complex number 1";
      input Complex c2 "Complex number 2";
      output Complex c3 "= c1 - c2";
    algorithm
      c3 := Complex(c1.re - c2.re, c1.im - c2.im);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the difference of two given Complex numbers.</p>
</html>"));
    end subtract;
    annotation (Documentation(info="<html>
<p>Here the unary and binary minus operator(s) is/are defined.</p>
</html>"), Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
              {100,100}}), graphics={
          Rectangle(
            lineColor={200,200,200},
            fillColor={248,248,248},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Rectangle(
            lineColor={128,128,128},
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Line(
            points={{-50,0},{50,0}})}));
  end '-';

  encapsulated operator '*' "Multiplication"
    function multiply "Multiply two complex numbers"
      import Complex;
      input Complex c1 "Complex number 1";
      input Complex c2 "Complex number 2";
      output Complex c3 "= c1*c2";
    algorithm
      c3 := Complex(c1.re*c2.re - c1.im*c2.im, c1.re*c2.im + c1.im*c2.re);

    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the product of two given Complex numbers.</p>
</html>"));
    end multiply;

    function scalarProduct "Scalar product c1*c2 of two complex vectors"
      import Complex;
      input Complex c1[:] "Vector of Complex numbers 1";
      input Complex c2[size(c1,1)] "Vector of Complex numbers 2";
      output Complex c3 "= c1*c2";
    algorithm
      c3 :=Complex(0);
      for i in 1:size(c1,1) loop
         c3 :=c3 + c1[i]*c2[i];
         /*
       c3 :=Complex(c3.re + c1[i].re*c2[i].re - c1[i].im*c2[i].im,
                    c3.im + c1[i].re*c2[i].im + c1[i].im*c2[i].re);
       */
      end for;

    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the scalar product of two given arrays of Complex numbers.</p>
</html>"));
    end scalarProduct;
    annotation (
      Documentation(info="<html>
<p>Here the multiplication operator(s) is/are defined.</p>
</html>"),
      Icon(coordinateSystem(
          preserveAspectRatio=false,
          extent={{-100,-100},{100,100}}),
          graphics={
          Rectangle(
            lineColor={200,200,200},
            fillColor={248,248,248},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Rectangle(
            lineColor={128,128,128},
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Line(
            points={{-42,36},{39,-34}}),
          Line(
            points={{-42,-35},{39,37}}),
          Line(
            points={{-55,1},{52,1}}),
          Line(
            points={{-1.5,55},{-2,-53}})}));
  end '*';

  encapsulated operator function '+' "Add two complex numbers"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Complex c3 "= c1 + c2";
  algorithm
    c3 := Complex(c1.re + c2.re, c1.im + c2.im);
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the sum of two given Complex numbers.</p>
</html>"));
  end '+';

  encapsulated operator function '/' "Divide two complex numbers"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Complex c3 "= c1/c2";
  algorithm
    c3 := Complex((+c1.re*c2.re + c1.im*c2.im)/(c2.re*c2.re + c2.im*c2.im),
                  (-c1.re*c2.im + c1.im*c2.re)/(c2.re*c2.re + c2.im*c2.im));
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the quotient of two given Complex numbers.</p>
</html>"));
  end '/';

  encapsulated operator function '^' "Complex power of complex number"
    import Complex;
    input Complex c1 "Complex number";
    input Complex c2 "Complex exponent";
    output Complex c3 "= c1^c2";
  protected
    Real lnz=0.5*log(c1.re*c1.re + c1.im*c1.im);
    Real phi=atan2(c1.im, c1.re);
    Real re=lnz*c2.re - phi*c2.im;
    Real im=lnz*c2.im + phi*c2.re;
  algorithm
    c3 := Complex(exp(re)*cos(im), exp(re)*sin(im));
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the given Complex numbers c1 to the power of the Complex number c2.</p>
</html>"));
  end '^';

  encapsulated operator function '=='
    "Test whether two complex numbers are identical"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Boolean result "c1 == c2";
  algorithm
    result := c1.re == c2.re and c1.im == c2.im;
    annotation(Inline=true, Documentation(info="<html>
<p>This function tests whether two given Complex numbers are equal.</p>
</html>"));
  end '==';

  encapsulated operator function '<>'
    "Test whether two complex numbers are not identical"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Boolean result "c1 <> c2";
  algorithm
    result := c1.re <> c2.re or c1.im <> c2.im;
    annotation(Inline=true, Documentation(info="<html>
    <p>This function tests whether two given Complex numbers are not equal.</p>
</html>"));
  end '<>';

  encapsulated operator function 'String'
    "Transform Complex number into a String representation"
    import Complex;
    input Complex c
      "Complex number to be transformed in a String representation";
    input String name="j"
      "Name of variable representing sqrt(-1) in the string";
    input Integer significantDigits=6
      "Number of significant digits that are shown";
    output String s="";
  algorithm
    s := String(c.re, significantDigits=significantDigits);
    if c.im <> 0 then
      if c.im > 0 then
        s := s + " + ";
      else
        s := s + " - ";
      end if;
      s := s + String(abs(c.im), significantDigits=significantDigits) + "*" + name;
    end if;
    annotation(Inline=true, Documentation(info="<html>
<p>This function converts a given Complex number to String representation.</p>
</html>"));
  end 'String';


annotation (
version="3.2.3",
versionBuild=2,
versionDate="2019-01-23",
dateModified = "2019-03-20 12:00:00Z",
revisionId="8f65f621a 2019-03-20 09:22:19 +0100",
conversion(
 noneFromVersion="3.2.2",
 noneFromVersion="3.2.1",
 noneFromVersion="1.0",
 noneFromVersion="1.1"),
Documentation(info="<html>
<p>Complex number defined as a record containing real and imaginary part, utilizing operator overloading.</p>
<p>
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 2010-2019, Modelica Association and <a href=\"modelica://Modelica.UsersGuide.Contact\">contributors</a>
</p>

<p>
<em>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the 3-Clause BSD license. For license conditions (including the disclaimer of warranty) visit <a href=\"https://modelica.org/licenses/modelica-3-clause-bsd\">https://modelica.org/licenses/modelica-3-clause-bsd</a>.</em>
</p></html>"),
    Icon(graphics={Rectangle(
          lineColor={160,160,164},
          fillColor={160,160,164},
          fillPattern=FillPattern.Solid,
          extent={{-100,-100},{100,100}},
          radius=25.0), Text(
          lineColor={255,255,255},
          extent={{-90,-50},{90,50}},
          textString="C")}));

end Complex;

package ModelicaServices
  "ModelicaServices (Default implementation) - Models and functions used in the Modelica Standard Library requiring a tool specific implementation"
extends Modelica.Icons.Package;

package ExternalReferences

  function loadResource
    "Return the absolute path name of a URI or local file name (in this default implementation URIs are not supported, but only local file names)"
    input String uri;
    output String fileReference;
  external "builtin" fileReference=Dymola_ResolveURI(uri);
  annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
fileReference = <b>loadResource</b>(uri);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<b>loadResource</b>(uri)</code>\" returns the
<b>absolute path name</b> of the file that is either defined by an URI or by a local
(e.g. relative) path name. With the returned file name it is possible to
access the file with function calls of the C standard library.
If the data or file is stored in a data-base,
this might require copying the resource to a temporary folder and referencing that.
</p>

<p>
The implementation of this function is tool specific, and this implementation is for Dymola.
However, at least Modelica URIs
(see \"chapter 13.2.3 External Resources\" of the Modelica Specification),
as well as absolute and relative local file path names are supported.
</p>

<h4>Example</h4>
<blockquote><pre>
  file1 = loadResource(\"modelica://Modelica/Resources/Data/Utilities/Examples_readRealParameters.txt\")
          // file1 is the absolute path name of the file
  file2 = loadResource(\"C:\\data\\readParameters.txt\")
          file2 = \"C:/data/readParameters.txt\"
</pre></blockquote>
</html>"));
  end loadResource;
end ExternalReferences;

package Machine

  final constant Real eps=1.e-15 "Biggest number such that 1.0 + eps = 1.0";

  final constant Real small=1.e-60
    "Smallest number such that small and -small are representable on the machine";

  final constant Real inf=1.e+60
    "Biggest Real number such that inf and -inf are representable on the machine";
  annotation (Documentation(info="<html>
<p>
Package in which processor specific constants are defined that are needed
by numerical algorithms. Typically these constants are not directly used,
but indirectly via the alias definition in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.
</p>
</html>"));
end Machine;
annotation (
  Protection(access=Access.hide),
  preferredView="info",
  version="3.2.3",
  versionBuild=0,
  versionDate="2016-01-15",
  dateModified = "2016-01-15 08:44:41Z",
  revisionId="$Id:: package.mo 9141 2016-03-03 19:26:06Z #$",
  uses(Modelica(version="3.2.3")),
  conversion(
    noneFromVersion="1.0",
    noneFromVersion="1.1",
    noneFromVersion="1.2",
    noneFromVersion="3.2.1"),
  Documentation(info="<html>
<p>
This package contains a set of functions and models to be used in the
Modelica Standard Library that requires a tool specific implementation.
These are:
</p>

<ul>
<li> <a href=\"modelica://ModelicaServices.Animation.Shape\">Shape</a>
     provides a 3-dim. visualization of elementary
     mechanical objects. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Animation.Surface\">Surface</a>
     provides a 3-dim. visualization of
     moveable parameterized surface. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.ExternalReferences.loadResource\">loadResource</a>
     provides a function to return the absolute path name of an URI or a local file name. It is used in
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Files.loadResource</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Machine\">ModelicaServices.Machine</a>
     provides a package of machine constants. It is used in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.</li>

<li> <a href=\"modelica://ModelicaServices.Types.SolverMethod\">Types.SolverMethod</a>
     provides a string defining the integration method to solve differential equations in
     a clocked discretized continuous-time partition (see Modelica 3.3 language specification).
     It is not yet used in the Modelica Standard Library, but in the Modelica_Synchronous library
     that provides convenience blocks for the clock operators of Modelica version &ge; 3.3.</li>
</ul>

<p>
This implementation is targeted for Dymola.
</p>

<p>
<b>Licensed by DLR and Dassault Syst&egrave;mes AB under the Modelica License 2</b><br>
Copyright &copy; 2009-2016, DLR and Dassault Syst&egrave;mes AB.
</p>

<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"https://www.modelica.org/licenses/ModelicaLicense2\"> https://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>

</html>"));
end ModelicaServices;

package Modelica "Modelica Standard Library - Version 3.2.3"
extends Modelica.Icons.Package;

  package Blocks
  "Library of basic input/output control blocks (continuous, discrete, logical, table blocks)"
  import SI = Modelica.SIunits;
  extends Modelica.Icons.Package;

    package Continuous
    "Library of continuous control blocks with internal states"
      import Modelica.Blocks.Interfaces;
      import Modelica.SIunits;
      extends Modelica.Icons.Package;

      block Integrator "Output the integral of the input signal with optional reset"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Integrator gain";
        parameter Boolean use_reset = false "=true, if reset port enabled"
          annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
        parameter Boolean use_set = false "=true, if set port enabled and used as reinitialization value when reset"
          annotation(Dialog(enable=use_reset), Evaluate=true, HideResult=true, choices(checkBox=true));

        /* InitialState is the default, because it was the default in Modelica 2.2
     and therefore this setting is backward compatible
  */
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.InitialState
          "Type of initialization (1: no init, 2: steady state, 3,4: initial output)" annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        extends Interfaces.SISO(y(start=y_start));
        Modelica.Blocks.Interfaces.BooleanInput reset if use_reset "Optional connector of reset signal" annotation(Placement(
          transformation(
            extent={{-20,-20},{20,20}},
            rotation=90,
            origin={60,-120})));
        Modelica.Blocks.Interfaces.RealInput set if use_reset and use_set "Optional connector of set signal" annotation(Placement(
          transformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={60,120})));
    protected
        Modelica.Blocks.Interfaces.BooleanOutput local_reset annotation(HideResult=true);
        Modelica.Blocks.Interfaces.RealOutput local_set annotation(HideResult=true);

      initial equation
        if initType == Init.SteadyState then
           der(y) = 0;
        elseif initType == Init.InitialState or
               initType == Init.InitialOutput then
          y = y_start;
        end if;
      equation
        if use_reset then
          connect(reset, local_reset);
          if use_set then
            connect(set, local_set);
          else
            local_set = y_start;
          end if;
          when local_reset then
            reinit(y, local_set);
          end when;
        else
          local_reset = false;
          local_set = 0;
        end if;
        der(y) = k*u;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as
<em>integral</em> of the input <strong>u</strong> multiplied with
the gain <em>k</em>:
</p>
<pre>
         k
     y = - u
         s
</pre>

<p>
It might be difficult to initialize the integrator in steady state.
This is discussed in the description of package
<a href=\"modelica://Modelica.Blocks.Continuous#info\">Continuous</a>.
</p>

<p>
If the <em>reset</em> port is enabled, then the output <strong>y</strong> is reset to <em>set</em>
or to <em>y_start</em> (if the <em>set</em> port is not enabled), whenever the <em>reset</em>
port has a rising edge.
</p>
</html>"),     Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Line(
                  points={{-80.0,78.0},{-80.0,-90.0}},
                  color={192,192,192}),
                Polygon(
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
                Line(
                  points={{-90.0,-80.0},{82.0,-80.0}},
                  color={192,192,192}),
                Polygon(
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
                Text(
                  lineColor={192,192,192},
                  extent={{0.0,-70.0},{60.0,-10.0}},
                  textString="I"),
                Text(
                  extent={{-150.0,-150.0},{150.0,-110.0}},
                  textString="k=%k"),
                Line(
                  points=DynamicSelect({{-80.0,-80.0},{80.0,80.0}}, if use_reset then {{-80.0,-80.0},{60.0,60.0},{60.0,-80.0},{80.0,-60.0}} else {{-80.0,-80.0},{80.0,80.0}}),
                  color={0,0,127}),
                Line(
                  visible=use_reset,
                  points={{60,-100},{60,-80}},
                  color={255,0,255},
                  pattern=LinePattern.Dot),
                Text(
                  visible=use_reset,
                  extent={{-28,-62},{94,-86}},
                  textString="reset")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(extent={{-60,60},{60,-60}}, lineColor={0,0,255}),
              Line(points={{-100,0},{-60,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{-36,60},{32,2}},
                textString="k"),
              Text(
                extent={{-32,0},{36,-58}},
                textString="s"),
              Line(points={{-46,0},{46,0}})}));
      end Integrator;

      block Derivative "Approximated derivative block"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Gains";
        parameter SIunits.Time T(min=Modelica.Constants.small) = 0.01
          "Time constants (T>0 required; T=0 is ideal derivative block)";
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
                                                                                          annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real x_start=0 "Initial or guess value of state"
          annotation (Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial value of output (= state)"
          annotation(Dialog(enable=initType == Init.InitialOutput, group=
                "Initialization"));
        extends Interfaces.SISO;

        output Real x(start=x_start) "State of block";

    protected
        parameter Boolean zeroGain = abs(k) < Modelica.Constants.eps;
      initial equation
        if initType == Init.SteadyState then
          der(x) = 0;
        elseif initType == Init.InitialState then
          x = x_start;
        elseif initType == Init.InitialOutput then
          if zeroGain then
             x = u;
          else
             y = y_start;
          end if;
        end if;
      equation
        der(x) = if zeroGain then 0 else (u - x)/T;
        y = if zeroGain then 0 else (k/T)*(u - x);
        annotation (
          Documentation(info="<html>
<p>
This blocks defines the transfer function between the
input u and the output y
as <em>approximated derivative</em>:
</p>
<pre>
             k * s
     y = ------------ * u
            T * s + 1
</pre>
<p>
If you would like to be able to change easily between different
transfer functions (FirstOrder, SecondOrder, ... ) by changing
parameters, use the general block <strong>TransferFunction</strong> instead
and model a derivative block with parameters<br>
b = {k,0}, a = {T, 1}.
</p>

<p>
If k=0, the block reduces to y=0.
</p>
</html>"),     Icon(
          coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-80.0,78.0},{-80.0,-90.0}},
            color={192,192,192}),
        Polygon(lineColor={192,192,192},
          fillColor={192,192,192},
          fillPattern=FillPattern.Solid,
          points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
        Line(points={{-90.0,-80.0},{82.0,-80.0}},
          color={192,192,192}),
        Polygon(lineColor={192,192,192},
          fillColor={192,192,192},
          fillPattern=FillPattern.Solid,
          points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
        Line(origin = {-24.667,-27.333},
          points = {{-55.333,87.333},{-19.333,-40.667},{86.667,-52.667}},
          color = {0,0,127},
          smooth = Smooth.Bezier),
        Text(lineColor={192,192,192},
          extent={{-30.0,14.0},{86.0,60.0}},
          textString="DT1"),
        Text(extent={{-150.0,-150.0},{150.0,-110.0}},
          textString="k=%k")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-54,52},{50,10}},
                textString="k s"),
              Text(
                extent={{-54,-6},{52,-52}},
                textString="T s + 1"),
              Line(points={{-50,0},{50,0}}),
              Rectangle(extent={{-60,60},{60,-60}}, lineColor={0,0,255}),
              Line(points={{-100,0},{-60,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255})}));
      end Derivative;

      block Filter
        "Continuous low pass, high pass, band pass or band stop IIR-filter of type CriticalDamping, Bessel, Butterworth or ChebyshevI"
        import Modelica.Blocks.Continuous.Internal;

        extends Modelica.Blocks.Interfaces.SISO;

        parameter Modelica.Blocks.Types.AnalogFilter analogFilter=Modelica.Blocks.Types.AnalogFilter.CriticalDamping
          "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI)";
        parameter Modelica.Blocks.Types.FilterType filterType=Modelica.Blocks.Types.FilterType.LowPass
          "Type of filter (LowPass/HighPass/BandPass/BandStop)";
        parameter Integer order(min=1) = 2 "Order of filter";
        parameter Modelica.SIunits.Frequency f_cut "Cut-off frequency";
        parameter Real gain=1.0
          "Gain (= amplitude of frequency response at zero frequency)";
        parameter Real A_ripple(unit="dB") = 0.5
          "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required"
          annotation(Dialog(enable=analogFilter==Modelica.Blocks.Types.AnalogFilter.ChebyshevI));
        parameter Modelica.SIunits.Frequency f_min=0
          "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain)"
          annotation(Dialog(enable=filterType == Modelica.Blocks.Types.FilterType.BandPass or
                                   filterType == Modelica.Blocks.Types.FilterType.BandStop));
        parameter Boolean normalized=true
          "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";
        parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.SteadyState
          "Type of initialization (no init/steady state/initial state/initial output)"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        final parameter Integer nx = if filterType == Modelica.Blocks.Types.FilterType.LowPass or
                                        filterType == Modelica.Blocks.Types.FilterType.HighPass then
                                        order else 2*order;
        parameter Real x_start[nx] = zeros(nx) "Initial or guess values of states"
          annotation(Dialog(tab="Advanced"));
        parameter Real y_start = 0 "Initial value of output"
          annotation(Dialog(tab="Advanced"));
        parameter Real u_nominal = 1.0
          "Nominal value of input (used for scaling the states)"
        annotation(Dialog(tab="Advanced"));
        Modelica.Blocks.Interfaces.RealOutput x[nx] "Filter states";

    protected
        parameter Integer ncr = if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
                                   order else mod(order,2);
        parameter Integer nc0 = if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
                                   0 else integer(order/2);
        parameter Integer na = if filterType == Modelica.Blocks.Types.FilterType.BandPass or
                                  filterType == Modelica.Blocks.Types.FilterType.BandStop then order else
                               if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
                                  0 else integer(order/2);
        parameter Integer nr = if filterType == Modelica.Blocks.Types.FilterType.BandPass or
                                  filterType == Modelica.Blocks.Types.FilterType.BandStop then 0 else
                               if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
                                  order else mod(order,2);

        // Coefficients of prototype base filter (low pass filter with w_cut = 1 rad/s)
        parameter Real cr[ncr](each fixed=false);
        parameter Real c0[nc0](each fixed=false);
        parameter Real c1[nc0](each fixed=false);

        // Coefficients for differential equations.
        parameter Real r[nr](each fixed=false);
        parameter Real a[na](each fixed=false);
        parameter Real b[na](each fixed=false);
        parameter Real ku[na](each fixed=false);
        parameter Real k1[if filterType == Modelica.Blocks.Types.FilterType.LowPass then 0 else na](
                       each fixed = false);
        parameter Real k2[if filterType == Modelica.Blocks.Types.FilterType.LowPass then 0 else na](
                       each fixed = false);

        // Auxiliary variables
        Real uu[na+nr+1];

      initial equation
         if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
            cr = Internal.Filter.base.CriticalDamping(order, normalized);
         elseif analogFilter == Modelica.Blocks.Types.AnalogFilter.Bessel then
            (cr,c0,c1) = Internal.Filter.base.Bessel(order, normalized);
         elseif analogFilter == Modelica.Blocks.Types.AnalogFilter.Butterworth then
            (cr,c0,c1) = Internal.Filter.base.Butterworth(order, normalized);
         elseif analogFilter == Modelica.Blocks.Types.AnalogFilter.ChebyshevI then
            (cr,c0,c1) = Internal.Filter.base.ChebyshevI(order, A_ripple, normalized);
         end if;

         if filterType == Modelica.Blocks.Types.FilterType.LowPass then
            (r,a,b,ku) = Internal.Filter.roots.lowPass(cr,c0,c1,f_cut);
         elseif filterType == Modelica.Blocks.Types.FilterType.HighPass then
            (r,a,b,ku,k1,k2) = Internal.Filter.roots.highPass(cr,c0,c1,f_cut);
         elseif filterType == Modelica.Blocks.Types.FilterType.BandPass then
            (a,b,ku,k1,k2) = Internal.Filter.roots.bandPass(cr,c0,c1,f_min,f_cut);
         elseif filterType == Modelica.Blocks.Types.FilterType.BandStop then
            (a,b,ku,k1,k2) = Internal.Filter.roots.bandStop(cr,c0,c1,f_min,f_cut);
         end if;

         if init == Modelica.Blocks.Types.Init.InitialState then
            x = x_start;
         elseif init == Modelica.Blocks.Types.Init.SteadyState then
            der(x) = zeros(nx);
         elseif init == Modelica.Blocks.Types.Init.InitialOutput then
            y = y_start;
            if nx > 1 then
               der(x[1:nx-1]) = zeros(nx-1);
            end if;
         end if;

      equation
         assert(u_nominal > 0, "u_nominal > 0 required");
         assert(filterType == Modelica.Blocks.Types.FilterType.LowPass or
                filterType == Modelica.Blocks.Types.FilterType.HighPass or
                f_min > 0, "f_min > 0 required for band pass and band stop filter");
         assert(A_ripple > 0, "A_ripple > 0 required");
         assert(f_cut > 0, "f_cut > 0 required");

         /* All filters have the same basic differential equations:
        Real poles:
           der(x) = r*x - r*u
        Complex conjugate poles:
           der(x1) = a*x1 - b*x2 + ku*u;
           der(x2) = b*x1 + a*x2;
   */
         uu[1] = u/u_nominal;
         for i in 1:nr loop
            der(x[i]) = r[i]*(x[i] - uu[i]);
         end for;
         for i in 1:na loop
            der(x[nr+2*i-1]) = a[i]*x[nr+2*i-1] - b[i]*x[nr+2*i] + ku[i]*uu[nr+i];
            der(x[nr+2*i])   = b[i]*x[nr+2*i-1] + a[i]*x[nr+2*i];
         end for;

         // The output equation is different for the different filter types
         if filterType == Modelica.Blocks.Types.FilterType.LowPass then
            /* Low pass filter
           Real poles             :  y = x
           Complex conjugate poles:  y = x2
      */
            for i in 1:nr loop
               uu[i+1] = x[i];
            end for;
            for i in 1:na loop
               uu[nr+i+1] = x[nr+2*i];
            end for;

         elseif filterType == Modelica.Blocks.Types.FilterType.HighPass then
            /* High pass filter
           Real poles             :  y = -x + u;
           Complex conjugate poles:  y = k1*x1 + k2*x2 + u;
      */
            for i in 1:nr loop
               uu[i+1] = -x[i] + uu[i];
            end for;
            for i in 1:na loop
               uu[nr+i+1] = k1[i]*x[nr+2*i-1] + k2[i]*x[nr+2*i] + uu[nr+i];
            end for;

         elseif filterType == Modelica.Blocks.Types.FilterType.BandPass then
            /* Band pass filter
           Complex conjugate poles:  y = k1*x1 + k2*x2;
      */
            for i in 1:na loop
               uu[nr+i+1] = k1[i]*x[nr+2*i-1] + k2[i]*x[nr+2*i];
            end for;

         elseif filterType == Modelica.Blocks.Types.FilterType.BandStop then
            /* Band pass filter
           Complex conjugate poles:  y = k1*x1 + k2*x2 + u;
      */
            for i in 1:na loop
               uu[nr+i+1] = k1[i]*x[nr+2*i-1] + k2[i]*x[nr+2*i] + uu[nr+i];
            end for;

         else
            assert(false, "filterType (= " + String(filterType) + ") is unknown");
            uu = zeros(na+nr+1);
         end if;

         y = (gain*u_nominal)*uu[nr+na+1];

        annotation (
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Line(points={{-80.0,80.0},{-80.0,-88.0}},
              color={192,192,192}),
            Polygon(lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              points={{-80.0,92.0},{-88.0,70.0},{-72.0,70.0},{-80.0,92.0}}),
            Line(points={{-90.0,-78.0},{82.0,-78.0}},
              color={192,192,192}),
            Polygon(lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              points={{90.0,-78.0},{68.0,-70.0},{68.0,-86.0},{90.0,-78.0}}),
            Text(lineColor={192,192,192},
              extent={{-66.0,52.0},{88.0,90.0}},
              textString="%order"),
            Text(
              extent={{-138.0,-140.0},{162.0,-110.0}},
              textString="f_cut=%f_cut"),
            Rectangle(lineColor={160,160,164},
              fillColor={255,255,255},
              fillPattern=FillPattern.Backward,
              extent={{-80.0,-78.0},{22.0,10.0}}),
            Line(origin = {3.333,-6.667}, points = {{-83.333,34.667},{24.667,34.667},{42.667,-71.333}}, color = {0,0,127}, smooth = Smooth.Bezier)}),
          Documentation(info="<html>

<p>
This blocks models various types of filters:
</p>

<blockquote>
<strong>low pass, high pass, band pass, and band stop filters</strong>
</blockquote>

<p>
using various filter characteristics:
</p>

<blockquote>
<strong>CriticalDamping, Bessel, Butterworth, Chebyshev Type I filters</strong>
</blockquote>

<p>
By default, a filter block is initialized in <strong>steady-state</strong>, in order to
avoid unwanted oscillations at the beginning. In special cases, it might be
useful to select one of the other initialization options under tab
\"Advanced\".
</p>

<p>
Typical frequency responses for the 4 supported low pass filter types
are shown in the next figure:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/LowPassOrder4Filters.png\"
     alt=\"LowPassOrder4Filters.png\">
</blockquote>

<p>
The step responses of the same low pass filters are shown in the next figure,
starting from a steady state initial filter with initial input = 0.2:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/LowPassOrder4FiltersStepResponse.png\"
     alt=\"LowPassOrder4FiltersStepResponse.png\">
</blockquote>

<p>
Obviously, the frequency responses give a somewhat wrong impression
of the filter characteristics: Although Butterworth and Chebyshev
filters have a significantly steeper magnitude as the
CriticalDamping and Bessel filters, the step responses of
the latter ones are much better. This means for example, that
a CriticalDamping or a Bessel filter should be selected,
if a filter is mainly used to make a non-linear inverse model
realizable.
</p>

<p>
Typical frequency responses for the 4 supported high pass filter types
are shown in the next figure:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/HighPassOrder4Filters.png\"
     alt=\"HighPassOrder4Filters.png\">
</blockquote>

<p>
The corresponding step responses of these high pass filters are
shown in the next figure:
</p>
<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/HighPassOrder4FiltersStepResponse.png\"
     alt=\"HighPassOrder4FiltersStepResponse.png\">
</blockquote>

<p>
All filters are available in <strong>normalized</strong> (default) and non-normalized form.
In the normalized form, the amplitude of the filter transfer function
at the cut-off frequency f_cut is -3 dB (= 10^(-3/20) = 0.70794..).
Note, when comparing the filters of this function with other software systems,
the setting of \"normalized\" has to be selected appropriately. For example, the signal processing
toolbox of MATLAB provides the filters in non-normalized form and
therefore a comparison makes only sense, if normalized = <strong>false</strong>
is set. A normalized filter is usually better suited for applications,
since filters of different orders are \"comparable\",
whereas non-normalized filters usually require to adapt the
cut-off frequency, when the order of the filter is changed.
See a comparison of \"normalized\" and \"non-normalized\" filters at hand of
CriticalDamping filters of order 1,2,3:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/CriticalDampingNormalized.png\"
     alt=\"CriticalDampingNormalized.png\">
</blockquote>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/CriticalDampingNonNormalized.png\"
     alt=\"CriticalDampingNonNormalized.png\">
</blockquote>

<h4>Implementation</h4>

<p>
The filters are implemented in the following, reliable way:
</p>

<ol>
<li> A prototype low pass filter with a cut-off angular frequency of 1 rad/s is constructed
     from the desired analogFilter and the desired normalization.</li>

<li> This prototype low pass filter is transformed to the desired filterType and the
     desired cut-off frequency f_cut using a transformation on the Laplace variable \"s\".</li>

<li> The resulting first and second order transfer functions are implemented in
     state space form, using the \"eigen value\" representation of a transfer function:
     <pre>

  // second order block with eigen values: a +/- jb
  <strong>der</strong>(x1) = a*x1 - b*x2 + (a^2 + b^2)/b*u;
  <strong>der</strong>(x2) = b*x1 + a*x2;
       y  = x2;
     </pre>
     The dc-gain from the input to the output of this block is one and the selected
     states are in the order of the input (if \"u\" is in the order of \"one\", then the
     states are also in the order of \"one\"). In the \"Advanced\" tab, a \"nominal\" value for
     the input \"u\" can be given. If appropriately selected, the states are in the order of \"one\" and
     then step-size control is always appropriate.</li>
</ol>

<h4>References</h4>

<dl>
<dt>Tietze U., and Schenk C. (2002):</dt>
<dd> <strong>Halbleiter-Schaltungstechnik</strong>.
     Springer Verlag, 12. Auflage, pp. 815-852.</dd>
</dl>

</html>",     revisions="<html>
<dl>
  <dt><strong>Main Author:</strong></dt>
  <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>,
      DLR Oberpfaffenhofen.</dd>
</dl>

<h4>Acknowledgement</h4>

<p>
The development of this block was partially funded by BMBF within the
     <a href=\"http://www.eurosyslib.com/\">ITEA2 EUROSYSLIB</a>
      project.
</p>

</html>"));
      end Filter;

      package Internal
      "Internal utility functions and blocks that should not be directly utilized by the user"
          extends Modelica.Icons.InternalPackage;

        package Filter
        "Internal utility functions for filters that should not be directly used"
            extends Modelica.Icons.InternalPackage;

          package base
          "Prototype low pass filters with cut-off frequency of 1 rad/s (other filters are derived by transformation from these base filters)"
              extends Modelica.Icons.InternalPackage;

          function CriticalDamping
              "Return base filter coefficients of CriticalDamping filter (= low pass filter with w_cut = 1 rad/s)"
            extends Modelica.Icons.Function;

            input Integer order(min=1) "Order of filter";
            input Boolean normalized=true
                "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";

            output Real cr[order] "Coefficients of real poles";
          protected
            Real alpha=1.0 "Frequency correction factor";
            Real alpha2 "= alpha*alpha";
            Real den1[order]
                "[p] coefficients of denominator first order polynomials (a*p + 1)";
            Real den2[0,2]
                "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
            Real c0[0] "Coefficients of s^0 term if conjugate complex pole";
            Real c1[0] "Coefficients of s^1 term if conjugate complex pole";
          algorithm
            if normalized then
               // alpha := sqrt(2^(1/order) - 1);
               alpha := sqrt(10^(3/10/order)-1);
            else
               alpha := 1.0;
            end if;

            for i in 1:order loop
               den1[i] := alpha;
            end for;

            // Determine polynomials with highest power of s equal to one
              (cr,c0,c1) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(
                den1, den2);
          end CriticalDamping;

          function Bessel
              "Return base filter coefficients of Bessel filter (= low pass filter with w_cut = 1 rad/s)"
            extends Modelica.Icons.Function;

            input Integer order(min=1) "Order of filter";
            input Boolean normalized=true
                "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";

            output Real cr[mod(order, 2)] "Coefficient of real pole";
            output Real c0[integer(order/2)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[integer(order/2)]
                "Coefficients of s^1 term if conjugate complex pole";
          protected
            Real alpha=1.0 "Frequency correction factor";
            Real alpha2 "= alpha*alpha";
            Real den1[size(cr,1)]
                "[p] coefficients of denominator first order polynomials (a*p + 1)";
            Real den2[size(c0, 1),2]
                "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
          algorithm
              (den1,den2,alpha) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.BesselBaseCoefficients(
                order);
            if not normalized then
               alpha2 := alpha*alpha;
               for i in 1:size(c0, 1) loop
                 den2[i, 1] := den2[i, 1]*alpha2;
                 den2[i, 2] := den2[i, 2]*alpha;
               end for;
               if size(cr,1) == 1 then
                 den1[1] := den1[1]*alpha;
               end if;
               end if;

            // Determine polynomials with highest power of s equal to one
              (cr,c0,c1) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(
                den1, den2);
          end Bessel;

          function Butterworth
              "Return base filter coefficients of Butterworth filter (= low pass filter with w_cut = 1 rad/s)"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Integer order(min=1) "Order of filter";
            input Boolean normalized=true
                "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";

            output Real cr[mod(order, 2)] "Coefficient of real pole";
            output Real c0[integer(order/2)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[integer(order/2)]
                "Coefficients of s^1 term if conjugate complex pole";
          protected
            Real alpha=1.0 "Frequency correction factor";
            Real alpha2 "= alpha*alpha";
            Real den1[size(cr,1)]
                "[p] coefficients of denominator first order polynomials (a*p + 1)";
            Real den2[size(c0, 1),2]
                "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
          algorithm
            for i in 1:size(c0, 1) loop
              den2[i, 1] := 1.0;
              den2[i, 2] := -2*Modelica.Math.cos(pi*(0.5 + (i - 0.5)/order));
            end for;
            if size(cr,1) == 1 then
              den1[1] := 1.0;
            end if;

            /* Transformation of filter transfer function with "new(p) = alpha*p"
     in order that the filter transfer function has an amplitude of
     -3 db at the cutoff frequency
  */
            /*
    if normalized then
      alpha := Internal.normalizationFactor(den1, den2);
      alpha2 := alpha*alpha;
      for i in 1:size(c0, 1) loop
        den2[i, 1] := den2[i, 1]*alpha2;
        den2[i, 2] := den2[i, 2]*alpha;
      end for;
      if size(cr,1) == 1 then
        den1[1] := den1[1]*alpha;
      end if;
    end if;
  */

            // Determine polynomials with highest power of s equal to one
              (cr,c0,c1) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(
                den1, den2);
          end Butterworth;

          function ChebyshevI
              "Return base filter coefficients of Chebyshev I filter (= low pass filter with w_cut = 1 rad/s)"
            import Modelica.Math.asinh;
            import Modelica.Constants.pi;

            extends Modelica.Icons.Function;

            input Integer order(min=1) "Order of filter";
            input Real A_ripple = 0.5 "Pass band ripple in [dB]";
            input Boolean normalized=true
                "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";

            output Real cr[mod(order, 2)] "Coefficient of real pole";
            output Real c0[integer(order/2)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[integer(order/2)]
                "Coefficients of s^1 term if conjugate complex pole";
          protected
            Real epsilon;
            Real fac;
            Real alpha=1.0 "Frequency correction factor";
            Real alpha2 "= alpha*alpha";
            Real den1[size(cr,1)]
                "[p] coefficients of denominator first order polynomials (a*p + 1)";
            Real den2[size(c0, 1),2]
                "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
          algorithm
              epsilon := sqrt(10^(A_ripple/10) - 1);
              fac := asinh(1/epsilon)/order;

              den1 := fill(1/sinh(fac),size(den1,1));
              if size(cr,1) == 0 then
                 for i in 1:size(c0, 1) loop
                    den2[i,1] :=1/(cosh(fac)^2 - cos((2*i - 1)*pi/(2*order))^2);
                    den2[i,2] :=2*den2[i, 1]*sinh(fac)*cos((2*i - 1)*pi/(2*order));
                 end for;
              else
                 for i in 1:size(c0, 1) loop
                    den2[i,1] :=1/(cosh(fac)^2 - cos(i*pi/order)^2);
                    den2[i,2] :=2*den2[i, 1]*sinh(fac)*cos(i*pi/order);
                 end for;
              end if;

              /* Transformation of filter transfer function with "new(p) = alpha*p"
       in order that the filter transfer function has an amplitude of
       -3 db at the cutoff frequency
    */
              if normalized then
                alpha :=
                  Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor(
                  den1, den2);
                alpha2 := alpha*alpha;
                for i in 1:size(c0, 1) loop
                  den2[i, 1] := den2[i, 1]*alpha2;
                  den2[i, 2] := den2[i, 2]*alpha;
                end for;
                den1 := den1*alpha;
              end if;

            // Determine polynomials with highest power of s equal to one
              (cr,c0,c1) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(
                den1, den2);
          end ChebyshevI;
          end base;

          package coefficients "Filter coefficients"
              extends Modelica.Icons.InternalPackage;

          function lowPass
              "Return low pass filter coefficients at given cut-off frequency"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles";
            input Real c0_in[:]
                "Coefficients of s^0 term if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            input Modelica.SIunits.Frequency f_cut "Cut-off frequency";

            output Real cr[size(cr_in,1)] "Coefficient of real pole";
            output Real c0[size(c0_in,1)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";

          protected
            Modelica.SIunits.AngularVelocity w_cut=2*pi*f_cut
                "Cut-off angular frequency";
            Real w_cut2=w_cut*w_cut;

          algorithm
            assert(f_cut > 0, "Cut-off frequency f_cut must be positive");

            /* Change filter coefficients according to transformation new(s) = s/w_cut
     s + cr           -> (s/w) + cr              = (s + w*cr)/w
     s^2 + c1*s + c0  -> (s/w)^2 + c1*(s/w) + c0 = (s^2 + (c1*w)*s + (c0*w^2))/w^2
  */
            cr := w_cut*cr_in;
            c1 := w_cut*c1_in;
            c0 := w_cut2*c0_in;

          end lowPass;

          function highPass
              "Return high pass filter coefficients at given cut-off frequency"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles";
            input Real c0_in[:]
                "Coefficients of s^0 term if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            input Modelica.SIunits.Frequency f_cut "Cut-off frequency";

            output Real cr[size(cr_in,1)] "Coefficient of real pole";
            output Real c0[size(c0_in,1)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";

          protected
            Modelica.SIunits.AngularVelocity w_cut=2*pi*f_cut
                "Cut-off angular frequency";
            Real w_cut2=w_cut*w_cut;

          algorithm
            assert(f_cut > 0, "Cut-off frequency f_cut must be positive");

            /* Change filter coefficients according to transformation: new(s) = 1/s
        1/(s + cr)          -> 1/(1/s + cr)                = (1/cr)*s / (s + (1/cr))
        1/(s^2 + c1*s + c0) -> 1/((1/s)^2 + c1*(1/s) + c0) = (1/c0)*s^2 / (s^2 + (c1/c0)*s + 1/c0)

     Check whether transformed roots are also conjugate complex:
        c0 - c1^2/4 > 0  -> (1/c0) - (c1/c0)^2 / 4
                            = (c0 - c1^2/4) / c0^2 > 0
        It is therefore guaranteed that the roots remain conjugate complex

     Change filter coefficients according to transformation new(s) = s/w_cut
        s + 1/cr                -> (s/w) + 1/cr                   = (s + w/cr)/w
        s^2 + (c1/c0)*s + 1/c0  -> (s/w)^2 + (c1/c0)*(s/w) + 1/c0 = (s^2 + (w*c1/c0)*s + (w^2/c0))/w^2
  */
            for i in 1:size(cr_in,1) loop
               cr[i] := w_cut/cr_in[i];
            end for;

            for i in 1:size(c0_in,1) loop
               c0[i] := w_cut2/c0_in[i];
               c1[i] := w_cut*c1_in[i]/c0_in[i];
            end for;

          end highPass;

          function bandPass
              "Return band pass filter coefficients at given cut-off frequency"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles";
            input Real c0_in[:]
                "Coefficients of s^0 term if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            input Modelica.SIunits.Frequency f_min
                "Band of band pass filter is f_min (A=-3db) .. f_max (A=-3db)";
            input Modelica.SIunits.Frequency f_max "Upper band frequency";

            output Real cr[0] "Coefficient of real pole";
            output Real c0[size(cr_in,1) + 2*size(c0_in,1)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[size(cr_in,1) + 2*size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            output Real cn "Numerator coefficient of the PT2 terms";
          protected
            Modelica.SIunits.Frequency f0 = sqrt(f_min*f_max);
            Modelica.SIunits.AngularVelocity w_cut=2*pi*f0
                "Cut-off angular frequency";
            Real w_band = (f_max - f_min) / f0;
            Real w_cut2=w_cut*w_cut;
            Real c;
            Real alpha;
            Integer j;
          algorithm
            assert(f_min > 0 and f_min < f_max, "Band frequencies f_min and f_max are wrong");

              /* The band pass filter is derived from the low pass filter by
       the transformation new(s) = (s + 1/s)/w   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       1/(s + cr)         -> 1/((s/w + 1/s/w) + cr)
                             = w*s / (s^2 + cr*w*s + 1)

       1/(s^2 + c1*s + c0) -> 1/( (s+1/s)^2/w^2 + c1*(s + 1/s)/w + c0 )
                              = 1 /( ( s^2 + 1/s^2 + 2)/w^2 + (s + 1/s)*c1/w + c0 )
                              = w^2*s^2 / (s^4 + 2*s^2 + 1 + (s^3 + s)*c1*w + c0*w^2*s^2)
                              = w^2*s^2 / (s^4 + c1*w*s^3 + (2+c0*w^2)*s^2 + c1*w*s + 1)

                              Assume the following description with PT2:
                              = w^2*s^2 /( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                           (s^2 + s*(c*alpha) + alpha^2) )
                              = w^2*s^2 / ( s^4 + c*(alpha + 1/alpha)*s^3
                                                + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                + c*(alpha + 1/alpha)*s + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = c1*w       -> c = c1*w / (alpha + 1/alpha)
                                                                      = c1*w*alpha/(1+alpha^2)
                                alpha^2 + 1/alpha^2 + c^2 = 2+c0*w^2 -> equation to determine alpha
                                alpha^4 + 1 + c1^2*w^2*alpha^4/(1+alpha^2)^2 = (2+c0*w^2)*alpha^2
                                or z = alpha^2
                                z^2 + c^1^2*w^2*z^2/(1+z)^2 - (2+c0*w^2)*z + 1 = 0

     Check whether roots remain conjugate complex
        c0 - (c1/2)^2 > 0:    1/alpha^2 - (c/alpha)^2/4
                              = 1/alpha^2*(1 - c^2/4)    -> not possible to figure this out

     Afterwards, change filter coefficients according to transformation new(s) = s/w_cut
        w_band*s/(s^2 + c1*s + c0)  -> w_band*(s/w)/((s/w)^2 + c1*(s/w) + c0 =
                                       (w_band/w)*s/(s^2 + (c1*w)*s + (c0*w^2))/w^2) =
                                       (w_band*w)*s/(s^2 + (c1*w)*s + (c0*w^2))
    */
              for i in 1:size(cr_in,1) loop
                 c1[i] := w_cut*cr_in[i]*w_band;
                 c0[i] := w_cut2;
              end for;

              for i in 1:size(c1_in,1) loop
                alpha :=
                  Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha(
                        c1_in[i],
                        c0_in[i],
                        w_band);
                 c       := c1_in[i]*w_band / (alpha + 1/alpha);
                 j       := size(cr_in,1) + 2*i - 1;
                 c1[j]   := w_cut*c/alpha;
                 c1[j+1] := w_cut*c*alpha;
                 c0[j]   := w_cut2/alpha^2;
                 c0[j+1] := w_cut2*alpha^2;
              end for;

              cn :=w_band*w_cut;

          end bandPass;

          function bandStop
              "Return band stop filter coefficients at given cut-off frequency"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles";
            input Real c0_in[:]
                "Coefficients of s^0 term if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            input Modelica.SIunits.Frequency f_min
                "Band of band stop filter is f_min (A=-3db) .. f_max (A=-3db)";
            input Modelica.SIunits.Frequency f_max "Upper band frequency";

            output Real cr[0] "Coefficient of real pole";
            output Real c0[size(cr_in,1) + 2*size(c0_in,1)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[size(cr_in,1) + 2*size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
          protected
            Modelica.SIunits.Frequency f0 = sqrt(f_min*f_max);
            Modelica.SIunits.AngularVelocity w_cut=2*pi*f0
                "Cut-off angular frequency";
            Real w_band = (f_max - f_min) / f0;
            Real w_cut2=w_cut*w_cut;
            Real c;
            Real ww;
            Real alpha;
            Integer j;
          algorithm
            assert(f_min > 0 and f_min < f_max, "Band frequencies f_min and f_max are wrong");

              /* The band pass filter is derived from the low pass filter by
       the transformation new(s) = (s + 1/s)/w   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       1/(s + cr)         -> 1/((s/w + 1/s/w) + cr)
                             = w*s / (s^2 + cr*w*s + 1)

       1/(s^2 + c1*s + c0) -> 1/( (s+1/s)^2/w^2 + c1*(s + 1/s)/w + c0 )
                              = 1 /( ( s^2 + 1/s^2 + 2)/w^2 + (s + 1/s)*c1/w + c0 )
                              = w^2*s^2 / (s^4 + 2*s^2 + 1 + (s^3 + s)*c1*w + c0*w^2*s^2)
                              = w^2*s^2 / (s^4 + c1*w*s^3 + (2+c0*w^2)*s^2 + c1*w*s + 1)

                              Assume the following description with PT2:
                              = w^2*s^2 /( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                           (s^2 + s*(c*alpha) + alpha^2) )
                              = w^2*s^2 / ( s^4 + c*(alpha + 1/alpha)*s^3
                                                + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                + c*(alpha + 1/alpha)*s + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = c1*w       -> c = c1*w / (alpha + 1/alpha)
                                                                      = c1*w*alpha/(1+alpha^2)
                                alpha^2 + 1/alpha^2 + c^2 = 2+c0*w^2 -> equation to determine alpha
                                alpha^4 + 1 + c1^2*w^2*alpha^4/(1+alpha^2)^2 = (2+c0*w^2)*alpha^2
                                or z = alpha^2
                                z^2 + c^1^2*w^2*z^2/(1+z)^2 - (2+c0*w^2)*z + 1 = 0

       The band stop filter is derived from the low pass filter by
       the transformation new(s) = w/( (s + 1/s) )   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       cr/(s + cr)         -> 1/(( w/(s + 1/s) ) + cr)
                              = (s^2 + 1) / (s^2 + (w/cr)*s + 1)

       c0/(s^2 + c1*s + c0) -> c0/( w^2/(s + 1/s)^2 + c1*w/(s + 1/s) + c0 )
                               = c0*(s^2 + 1)^2 / (s^4 + c1*w*s^3/c0 + (2+w^2/b)*s^2 + c1*w*s/c0 + 1)

                               Assume the following description with PT2:
                               = c0*(s^2 + 1)^2 / ( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                                    (s^2 + s*(c*alpha) + alpha^2) )
                               = c0*(s^2 + 1)^2 / (  s^4 + c*(alpha + 1/alpha)*s^3
                                                         + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                         + c*(alpha + 1/alpha)*p + 1 )

                            and therefore:
                              c*(alpha + 1/alpha) = c1*w/b         -> c = c1*w/(c0*(alpha + 1/alpha))
                              alpha^2 + 1/alpha^2 + c^2 = 2+w^2/c0 -> equation to determine alpha
                              alpha^4 + 1 + (c1*w/c0*alpha^2)^2/(1+alpha^2)^2 = (2+w^2/c0)*alpha^2
                              or z = alpha^2
                              z^2 + (c1*w/c0*z)^2/(1+z)^2 - (2+w^2/c0)*z + 1 = 0

                            same as:  ww = w/c0
                              z^2 + (c1*ww*z)^2/(1+z)^2 - (2+c0*ww)*z + 1 = 0  -> same equation as for BandPass

     Afterwards, change filter coefficients according to transformation new(s) = s/w_cut
        c0*(s^2+1)(s^2 + c1*s + c0)  -> c0*((s/w)^2 + 1) / ((s/w)^2 + c1*(s/w) + c0 =
                                        c0/w^2*(s^2 + w^2) / (s^2 + (c1*w)*s + (c0*w^2))/w^2) =
                                        (s^2 + c0*w^2) / (s^2 + (c1*w)*s + (c0*w^2))
    */
              for i in 1:size(cr_in,1) loop
                 c1[i] := w_cut*w_band/cr_in[i];
                 c0[i] := w_cut2;
              end for;

              for i in 1:size(c1_in,1) loop
                 ww      := w_band/c0_in[i];
                alpha :=
                  Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha(
                        c1_in[i],
                        c0_in[i],
                        ww);
                 c       := c1_in[i]*ww / (alpha + 1/alpha);
                 j       := size(cr_in,1) + 2*i - 1;
                 c1[j]   := w_cut*c/alpha;
                 c1[j+1] := w_cut*c*alpha;
                 c0[j]   := w_cut2/alpha^2;
                 c0[j+1] := w_cut2*alpha^2;
              end for;

          end bandStop;
          end coefficients;

          package roots
          "Filter roots and gain as needed for block implementations"
              extends Modelica.Icons.InternalPackage;

          function lowPass
              "Return low pass filter roots as needed for block for given cut-off frequency"
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles of base filter";
            input Real c0_in[:]
                "Coefficients of s^0 term of base filter if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term of base filter if conjugate complex pole";
            input Modelica.SIunits.Frequency f_cut "Cut-off frequency";

            output Real r[size(cr_in,1)] "Real eigenvalues";
            output Real a[size(c0_in,1)]
                "Real parts of complex conjugate eigenvalues";
            output Real b[size(c0_in,1)]
                "Imaginary parts of complex conjugate eigenvalues";
            output Real ku[size(c0_in,1)] "Input gain";
          protected
            Real c0[size(c0_in,1)];
            Real c1[size(c0_in,1)];
            Real cr[size(cr_in,1)];
          algorithm
            // Get coefficients of low pass filter at f_cut
            (cr, c0, c1) :=coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);

            // Transform coefficients in to root
            for i in 1:size(cr_in,1) loop
              r[i] :=-cr[i];
            end for;

            for i in 1:size(c0_in,1) loop
              a [i] :=-c1[i]/2;
              b [i] :=sqrt(c0[i] - a[i]*a[i]);
              ku[i] :=c0[i]/b[i];
            end for;

            annotation (Documentation(info="<html>

<p>
The goal is to implement the filter in the following form:
</p>

<pre>
  // real pole:
   der(x) = r*x - r*u
       y  = x

  // complex conjugate poles:
  der(x1) = a*x1 - b*x2 + ku*u;
  der(x2) = b*x1 + a*x2;
       y  = x2;

            ku = (a^2 + b^2)/b
</pre>
<p>
This representation has the following transfer function:
</p>
<pre>
// real pole:
    s*y = r*y - r*u
  or
    (s-r)*y = -r*u
  or
    y = -r/(s-r)*u

  comparing coefficients with
    y = cr/(s + cr)*u  ->  r = -cr      // r is the real eigenvalue

// complex conjugate poles
    s*x2 =  a*x2 + b*x1
    s*x1 = -b*x2 + a*x1 + ku*u
  or
    (s-a)*x2               = b*x1  ->  x2 = b/(s-a)*x1
    (s + b^2/(s-a) - a)*x1 = ku*u  ->  (s(s-a) + b^2 - a*(s-a))*x1  = ku*(s-a)*u
                                   ->  (s^2 - 2*a*s + a^2 + b^2)*x1 = ku*(s-a)*u
  or
    x1 = ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
    x2 = b/(s-a)*ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
       = b*ku/(s^2 - 2*a*s + a^2 + b^2)*u
    y  = x2

  comparing coefficients with
    y = c0/(s^2 + c1*s + c0)*u  ->  a  = -c1/2
                                    b  = sqrt(c0 - a^2)
                                    ku = c0/b
                                       = (a^2 + b^2)/b

  comparing with eigenvalue representation:
    (s - (a+jb))*(s - (a-jb)) = s^2 -2*a*s + a^2 + b^2
  shows that:
    a: real part of eigenvalue
    b: imaginary part of eigenvalue

  time -> infinity:
    y(s=0) = x2(s=0) = 1
             x1(s=0) = -ku*a/(a^2 + b^2)*u
                     = -(a/b)*u
</pre>

</html>"));
          end lowPass;

          function highPass
              "Return high pass filter roots as needed for block for given cut-off frequency"
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles of base filter";
            input Real c0_in[:]
                "Coefficients of s^0 term of base filter if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term of base filter if conjugate complex pole";
            input Modelica.SIunits.Frequency f_cut "Cut-off frequency";

            output Real r[size(cr_in,1)] "Real eigenvalues";
            output Real a[size(c0_in,1)]
                "Real parts of complex conjugate eigenvalues";
            output Real b[size(c0_in,1)]
                "Imaginary parts of complex conjugate eigenvalues";
            output Real ku[size(c0_in,1)] "Gains of input terms";
            output Real k1[size(c0_in,1)] "Gains of y = k1*x1 + k2*x + u";
            output Real k2[size(c0_in,1)] "Gains of y = k1*x1 + k2*x + u";
          protected
            Real c0[size(c0_in,1)];
            Real c1[size(c0_in,1)];
            Real cr[size(cr_in,1)];
            Real ba2;
          algorithm
            // Get coefficients of high pass filter at f_cut
            (cr, c0, c1) :=coefficients.highPass(cr_in, c0_in, c1_in, f_cut);

            // Transform coefficients in to roots
            for i in 1:size(cr_in,1) loop
              r[i] :=-cr[i];
            end for;

            for i in 1:size(c0_in,1) loop
              a[i]  := -c1[i]/2;
              b[i]  := sqrt(c0[i] - a[i]*a[i]);
              ku[i] := c0[i]/b[i];
              k1[i] := 2*a[i]/ku[i];
              ba2   := (b[i]/a[i])^2;
              k2[i] := (1-ba2)/(1+ba2);
            end for;

            annotation (Documentation(info="<html>

<p>
The goal is to implement the filter in the following form:
</p>

<pre>
  // real pole:
   der(x) = r*x - r*u
       y  = -x + u

  // complex conjugate poles:
  der(x1) = a*x1 - b*x2 + ku*u;
  der(x2) = b*x1 + a*x2;
       y  = k1*x1 + k2*x2 + u;

            ku = (a^2 + b^2)/b
            k1 = 2*a/ku
            k2 = (a^2 - b^2) / (b*ku)
               = (a^2 - b^2) / (a^2 + b^2)
               = (1 - (b/a)^2) / (1 + (b/a)^2)

</pre>
<p>
This representation has the following transfer function:
</p>
<pre>
// real pole:
    s*x = r*x - r*u
  or
    (s-r)*x = -r*u   -> x = -r/(s-r)*u
  or
    y = r/(s-r)*u + (s-r)/(s-r)*u
      = (r+s-r)/(s-r)*u
      = s/(s-r)*u

  comparing coefficients with
    y = s/(s + cr)*u  ->  r = -cr      // r is the real eigenvalue

// complex conjugate poles
    s*x2 =  a*x2 + b*x1
    s*x1 = -b*x2 + a*x1 + ku*u
  or
    (s-a)*x2               = b*x1  ->  x2 = b/(s-a)*x1
    (s + b^2/(s-a) - a)*x1 = ku*u  ->  (s(s-a) + b^2 - a*(s-a))*x1  = ku*(s-a)*u
                                   ->  (s^2 - 2*a*s + a^2 + b^2)*x1 = ku*(s-a)*u
  or
    x1 = ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
    x2 = b/(s-a)*ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
       = b*ku/(s^2 - 2*a*s + a^2 + b^2)*u
    y  = k1*x1 + k2*x2 + u
       = (k1*ku*(s-a) + k2*b*ku +  s^2 - 2*a*s + a^2 + b^2) /
         (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + (k1*ku - 2*a)*s + k2*b*ku - k1*ku*a + a^2 + b^2) /
         (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + (2*a-2*a)*s + a^2 - b^2 - 2*a^2 + a^2 + b^2) /
         (s^2 - 2*a*s + a^2 + b^2)*u
       = s^2 / (s^2 - 2*a*s + a^2 + b^2)*u

  comparing coefficients with
    y = s^2/(s^2 + c1*s + c0)*u  ->  a = -c1/2
                                     b = sqrt(c0 - a^2)

  comparing with eigenvalue representation:
    (s - (a+jb))*(s - (a-jb)) = s^2 -2*a*s + a^2 + b^2
  shows that:
    a: real part of eigenvalue
    b: imaginary part of eigenvalue
</pre>

</html>"));
          end highPass;

          function bandPass
              "Return band pass filter roots as needed for block for given cut-off frequency"
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles of base filter";
            input Real c0_in[:]
                "Coefficients of s^0 term of base filter if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term of base filter if conjugate complex pole";
            input Modelica.SIunits.Frequency f_min
                "Band of band pass filter is f_min (A=-3db) .. f_max (A=-3db)";
            input Modelica.SIunits.Frequency f_max "Upper band frequency";

            output Real a[size(cr_in,1) + 2*size(c0_in,1)]
                "Real parts of complex conjugate eigenvalues";
            output Real b[size(cr_in,1) + 2*size(c0_in,1)]
                "Imaginary parts of complex conjugate eigenvalues";
            output Real ku[size(cr_in,1) + 2*size(c0_in,1)] "Gains of input terms";
            output Real k1[size(cr_in,1) + 2*size(c0_in,1)]
                "Gains of y = k1*x1 + k2*x";
            output Real k2[size(cr_in,1) + 2*size(c0_in,1)]
                "Gains of y = k1*x1 + k2*x";
          protected
            Real cr[0];
            Real c0[size(a,1)];
            Real c1[size(a,1)];
            Real cn;
            Real bb;
          algorithm
            // Get coefficients of band pass filter at f_cut
            (cr, c0, c1, cn) :=coefficients.bandPass(cr_in, c0_in, c1_in, f_min, f_max);

            // Transform coefficients in to roots
            for i in 1:size(a,1) loop
              a[i]  := -c1[i]/2;
              bb    := c0[i] - a[i]*a[i];
              assert(bb >= 0, "\nNot possible to use band pass filter, since transformation results in\n"+
                              "system that does not have conjugate complex poles.\n" +
                              "Try to use another analog filter for the band pass.\n");
              b[i]  := sqrt(bb);
              ku[i] := c0[i]/b[i];
              k1[i] := cn/ku[i];
              k2[i] := cn*a[i]/(b[i]*ku[i]);
            end for;

            annotation (Documentation(info="<html>

<p>
The goal is to implement the filter in the following form:
</p>

<pre>
  // complex conjugate poles:
  der(x1) = a*x1 - b*x2 + ku*u;
  der(x2) = b*x1 + a*x2;
       y  = k1*x1 + k2*x2;

            ku = (a^2 + b^2)/b
            k1 = cn/ku
            k2 = cn*a/(b*ku)
</pre>
<p>
This representation has the following transfer function:
</p>
<pre>
// complex conjugate poles
    s*x2 =  a*x2 + b*x1
    s*x1 = -b*x2 + a*x1 + ku*u
  or
    (s-a)*x2               = b*x1  ->  x2 = b/(s-a)*x1
    (s + b^2/(s-a) - a)*x1 = ku*u  ->  (s(s-a) + b^2 - a*(s-a))*x1  = ku*(s-a)*u
                                   ->  (s^2 - 2*a*s + a^2 + b^2)*x1 = ku*(s-a)*u
  or
    x1 = ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
    x2 = b/(s-a)*ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
       = b*ku/(s^2 - 2*a*s + a^2 + b^2)*u
    y  = k1*x1 + k2*x2
       = (k1*ku*(s-a) + k2*b*ku) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (k1*ku*s + k2*b*ku - k1*ku*a) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (cn*s + cn*a - cn*a) / (s^2 - 2*a*s + a^2 + b^2)*u
       = cn*s / (s^2 - 2*a*s + a^2 + b^2)*u

  comparing coefficients with
    y = cn*s / (s^2 + c1*s + c0)*u  ->  a = -c1/2
                                        b = sqrt(c0 - a^2)

  comparing with eigenvalue representation:
    (s - (a+jb))*(s - (a-jb)) = s^2 -2*a*s + a^2 + b^2
  shows that:
    a: real part of eigenvalue
    b: imaginary part of eigenvalue
</pre>

</html>"));
          end bandPass;

          function bandStop
              "Return band stop filter roots as needed for block for given cut-off frequency"
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles of base filter";
            input Real c0_in[:]
                "Coefficients of s^0 term of base filter if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term of base filter if conjugate complex pole";
            input Modelica.SIunits.Frequency f_min
                "Band of band stop filter is f_min (A=-3db) .. f_max (A=-3db)";
            input Modelica.SIunits.Frequency f_max "Upper band frequency";

            output Real a[size(cr_in,1) + 2*size(c0_in,1)]
                "Real parts of complex conjugate eigenvalues";
            output Real b[size(cr_in,1) + 2*size(c0_in,1)]
                "Imaginary parts of complex conjugate eigenvalues";
            output Real ku[size(cr_in,1) + 2*size(c0_in,1)] "Gains of input terms";
            output Real k1[size(cr_in,1) + 2*size(c0_in,1)]
                "Gains of y = k1*x1 + k2*x";
            output Real k2[size(cr_in,1) + 2*size(c0_in,1)]
                "Gains of y = k1*x1 + k2*x";
          protected
            Real cr[0];
            Real c0[size(a,1)];
            Real c1[size(a,1)];
            Real cn;
            Real bb;
          algorithm
            // Get coefficients of band stop filter at f_cut
            (cr, c0, c1) :=coefficients.bandStop(cr_in, c0_in, c1_in, f_min, f_max);

            // Transform coefficients in to roots
            for i in 1:size(a,1) loop
              a[i]  := -c1[i]/2;
              bb    := c0[i] - a[i]*a[i];
              assert(bb >= 0, "\nNot possible to use band stop filter, since transformation results in\n"+
                              "system that does not have conjugate complex poles.\n" +
                              "Try to use another analog filter for the band stop filter.\n");
              b[i]  := sqrt(bb);
              ku[i] := c0[i]/b[i];
              k1[i] := 2*a[i]/ku[i];
              k2[i] := (c0[i] + a[i]^2 - b[i]^2)/(b[i]*ku[i]);
            end for;

            annotation (Documentation(info="<html>

<p>
The goal is to implement the filter in the following form:
</p>

<pre>
  // complex conjugate poles:
  der(x1) = a*x1 - b*x2 + ku*u;
  der(x2) = b*x1 + a*x2;
       y  = k1*x1 + k2*x2 + u;

            ku = (a^2 + b^2)/b
            k1 = 2*a/ku
            k2 = (c0 + a^2 - b^2)/(b*ku)
</pre>
<p>
This representation has the following transfer function:
</p>
<pre>
// complex conjugate poles
    s*x2 =  a*x2 + b*x1
    s*x1 = -b*x2 + a*x1 + ku*u
  or
    (s-a)*x2               = b*x1  ->  x2 = b/(s-a)*x1
    (s + b^2/(s-a) - a)*x1 = ku*u  ->  (s(s-a) + b^2 - a*(s-a))*x1  = ku*(s-a)*u
                                   ->  (s^2 - 2*a*s + a^2 + b^2)*x1 = ku*(s-a)*u
  or
    x1 = ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
    x2 = b/(s-a)*ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
       = b*ku/(s^2 - 2*a*s + a^2 + b^2)*u
    y  = k1*x1 + k2*x2 + u
       = (k1*ku*(s-a) + k2*b*ku + s^2 - 2*a*s + a^2 + b^2) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + (k1*ku-2*a)*s + k2*b*ku - k1*ku*a + a^2 + b^2) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + c0 + a^2 - b^2 - 2*a^2 + a^2 + b^2) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + c0) / (s^2 - 2*a*s + a^2 + b^2)*u

  comparing coefficients with
    y = (s^2 + c0) / (s^2 + c1*s + c0)*u  ->  a = -c1/2
                                              b = sqrt(c0 - a^2)

  comparing with eigenvalue representation:
    (s - (a+jb))*(s - (a-jb)) = s^2 -2*a*s + a^2 + b^2
  shows that:
    a: real part of eigenvalue
    b: imaginary part of eigenvalue
</pre>

</html>"));
          end bandStop;
          end roots;

          package Utilities "Utility functions for filter computations"
              extends Modelica.Icons.InternalPackage;

            function BesselBaseCoefficients
              "Return coefficients of normalized low pass Bessel filter (= gain at cut-off frequency 1 rad/s is decreased 3dB)"
              extends Modelica.Icons.Function;

              import Modelica.Utilities.Streams;
              input Integer order "Order of filter in the range 1..41";
              output Real c1[mod(order, 2)]
                "[p] coefficients of Bessel denominator polynomials (a*p + 1)";
              output Real c2[integer(order/2),2]
                "[p^2, p] coefficients of Bessel denominator polynomials (b2*p^2 + b1*p + 1)";
              output Real alpha "Normalization factor";
            algorithm
              if order == 1 then
                alpha := 1.002377293007601;
                c1[1] := 0.9976283451109835;
              elseif order == 2 then
                alpha := 0.7356641785819585;
                c2[1, 1] := 0.6159132201783791;
                c2[1, 2] := 1.359315879600889;
              elseif order == 3 then
                alpha := 0.5704770156982642;
                c1[1] := 0.7548574865985343;
                c2[1, 1] := 0.4756958028827457;
                c2[1, 2] := 0.9980615136104388;
              elseif order == 4 then
                alpha := 0.4737978580281427;
                c2[1, 1] := 0.4873729247240677;
                c2[1, 2] := 1.337564170455762;
                c2[2, 1] := 0.3877724315741958;
                c2[2, 2] := 0.7730405590839861;
              elseif order == 5 then
                alpha := 0.4126226974763408;
                c1[1] := 0.6645723262620757;
                c2[1, 1] := 0.4115231900614016;
                c2[1, 2] := 1.138349926728708;
                c2[2, 1] := 0.3234938702877912;
                c2[2, 2] := 0.6205992985771313;
              elseif order == 6 then
                alpha := 0.3705098000736233;
                c2[1, 1] := 0.3874508649098960;
                c2[1, 2] := 1.219740879520741;
                c2[2, 1] := 0.3493298843155746;
                c2[2, 2] := 0.9670265529381365;
                c2[3, 1] := 0.2747419229514599;
                c2[3, 2] := 0.5122165075105700;
              elseif order == 7 then
                alpha := 0.3393452623586350;
                c1[1] := 0.5927147125821412;
                c2[1, 1] := 0.3383379423919174;
                c2[1, 2] := 1.092630816438030;
                c2[2, 1] := 0.3001025788696046;
                c2[2, 2] := 0.8289928256598656;
                c2[3, 1] := 0.2372867471539579;
                c2[3, 2] := 0.4325128641920154;
              elseif order == 8 then
                alpha := 0.3150267393795002;
                c2[1, 1] := 0.3151115975207653;
                c2[1, 2] := 1.109403015460190;
                c2[2, 1] := 0.2969344839572762;
                c2[2, 2] := 0.9737455812222699;
                c2[3, 1] := 0.2612545921889538;
                c2[3, 2] := 0.7190394712068573;
                c2[4, 1] := 0.2080523342974281;
                c2[4, 2] := 0.3721456473047434;
              elseif order == 9 then
                alpha := 0.2953310177184124;
                c1[1] := 0.5377196679501422;
                c2[1, 1] := 0.2824689124281034;
                c2[1, 2] := 1.022646191567475;
                c2[2, 1] := 0.2626824161383468;
                c2[2, 2] := 0.8695626454762596;
                c2[3, 1] := 0.2302781917677917;
                c2[3, 2] := 0.6309047553448520;
                c2[4, 1] := 0.1847991729757028;
                c2[4, 2] := 0.3251978031287202;
              elseif order == 10 then
                alpha := 0.2789426890619463;
                c2[1, 1] := 0.2640769908255582;
                c2[1, 2] := 1.019788132875305;
                c2[2, 1] := 0.2540802639216947;
                c2[2, 2] := 0.9377020417760623;
                c2[3, 1] := 0.2343577229427963;
                c2[3, 2] := 0.7802229808216112;
                c2[4, 1] := 0.2052193139338624;
                c2[4, 2] := 0.5594176813008133;
                c2[5, 1] := 0.1659546953748916;
                c2[5, 2] := 0.2878349616233292;
              elseif order == 11 then
                alpha := 0.2650227766037203;
                c1[1] := 0.4950265498954191;
                c2[1, 1] := 0.2411858478546218;
                c2[1, 2] := 0.9567800996387417;
                c2[2, 1] := 0.2296849355380925;
                c2[2, 2] := 0.8592523717113126;
                c2[3, 1] := 0.2107851705677406;
                c2[3, 2] := 0.7040216048898129;
                c2[4, 1] := 0.1846461385164021;
                c2[4, 2] := 0.5006729207276717;
                c2[5, 1] := 0.1504217970817433;
                c2[5, 2] := 0.2575070491320295;
              elseif order == 12 then
                alpha := 0.2530051198547209;
                c2[1, 1] := 0.2268294941204543;
                c2[1, 2] := 0.9473116570034053;
                c2[2, 1] := 0.2207657387793729;
                c2[2, 2] := 0.8933728946287606;
                c2[3, 1] := 0.2087600700376653;
                c2[3, 2] := 0.7886236252756229;
                c2[4, 1] := 0.1909959101492760;
                c2[4, 2] := 0.6389263649257017;
                c2[5, 1] := 0.1675208146048472;
                c2[5, 2] := 0.4517847275162215;
                c2[6, 1] := 0.1374257286372761;
                c2[6, 2] := 0.2324699157474680;
              elseif order == 13 then
                alpha := 0.2424910397561007;
                c1[1] := 0.4608848369928040;
                c2[1, 1] := 0.2099813050274780;
                c2[1, 2] := 0.8992478823790660;
                c2[2, 1] := 0.2027250423101359;
                c2[2, 2] := 0.8328117484224146;
                c2[3, 1] := 0.1907635894058731;
                c2[3, 2] := 0.7257379204691213;
                c2[4, 1] := 0.1742280397887686;
                c2[4, 2] := 0.5830640944868014;
                c2[5, 1] := 0.1530858190490478;
                c2[5, 2] := 0.4106192089751885;
                c2[6, 1] := 0.1264090712880446;
                c2[6, 2] := 0.2114980230156001;
              elseif order == 14 then
                alpha := 0.2331902368695848;
                c2[1, 1] := 0.1986162311411235;
                c2[1, 2] := 0.8876961808055535;
                c2[2, 1] := 0.1946683341271615;
                c2[2, 2] := 0.8500754229171967;
                c2[3, 1] := 0.1868331332895056;
                c2[3, 2] := 0.7764629313723603;
                c2[4, 1] := 0.1752118757862992;
                c2[4, 2] := 0.6699720402924552;
                c2[5, 1] := 0.1598906457908402;
                c2[5, 2] := 0.5348446712848934;
                c2[6, 1] := 0.1407810153019944;
                c2[6, 2] := 0.3755841316563539;
                c2[7, 1] := 0.1169627966707339;
                c2[7, 2] := 0.1937088226304455;
              elseif order == 15 then
                alpha := 0.2248854870552422;
                c1[1] := 0.4328492272335646;
                c2[1, 1] := 0.1857292591004588;
                c2[1, 2] := 0.8496337061962563;
                c2[2, 1] := 0.1808644178280136;
                c2[2, 2] := 0.8020517898136011;
                c2[3, 1] := 0.1728264404199081;
                c2[3, 2] := 0.7247449729331105;
                c2[4, 1] := 0.1616970125901954;
                c2[4, 2] := 0.6205369315943097;
                c2[5, 1] := 0.1475257264578426;
                c2[5, 2] := 0.4929612162355906;
                c2[6, 1] := 0.1301861023357119;
                c2[6, 2] := 0.3454770708040735;
                c2[7, 1] := 0.1087810777120188;
                c2[7, 2] := 0.1784526655428406;
              elseif order == 16 then
                alpha := 0.2174105053474761;
                c2[1, 1] := 0.1765637967473151;
                c2[1, 2] := 0.8377453068635511;
                c2[2, 1] := 0.1738525357503125;
                c2[2, 2] := 0.8102988957433199;
                c2[3, 1] := 0.1684627004613343;
                c2[3, 2] := 0.7563265923413258;
                c2[4, 1] := 0.1604519074815815;
                c2[4, 2] := 0.6776082294687619;
                c2[5, 1] := 0.1498828607802206;
                c2[5, 2] := 0.5766417034027680;
                c2[6, 1] := 0.1367764717792823;
                c2[6, 2] := 0.4563528264410489;
                c2[7, 1] := 0.1209810465419295;
                c2[7, 2] := 0.3193782657322374;
                c2[8, 1] := 0.1016312648007554;
                c2[8, 2] := 0.1652419227369036;
              elseif order == 17 then
                alpha := 0.2106355148193306;
                c1[1] := 0.4093223608497299;
                c2[1, 1] := 0.1664014345826274;
                c2[1, 2] := 0.8067173752345952;
                c2[2, 1] := 0.1629839591538256;
                c2[2, 2] := 0.7712924931447541;
                c2[3, 1] := 0.1573277802512491;
                c2[3, 2] := 0.7134213666303411;
                c2[4, 1] := 0.1494828185148637;
                c2[4, 2] := 0.6347841731714884;
                c2[5, 1] := 0.1394948812681826;
                c2[5, 2] := 0.5375594414619047;
                c2[6, 1] := 0.1273627583380806;
                c2[6, 2] := 0.4241608926375478;
                c2[7, 1] := 0.1129187258461290;
                c2[7, 2] := 0.2965752009703245;
                c2[8, 1] := 0.9533357359908857e-1;
                c2[8, 2] := 0.1537041700889585;
              elseif order == 18 then
                alpha := 0.2044575288651841;
                c2[1, 1] := 0.1588768571976356;
                c2[1, 2] := 0.7951914263212913;
                c2[2, 1] := 0.1569357024981854;
                c2[2, 2] := 0.7744529690772538;
                c2[3, 1] := 0.1530722206358810;
                c2[3, 2] := 0.7335304425992080;
                c2[4, 1] := 0.1473206710524167;
                c2[4, 2] := 0.6735038935387268;
                c2[5, 1] := 0.1397225420331520;
                c2[5, 2] := 0.5959151542621590;
                c2[6, 1] := 0.1303092459809849;
                c2[6, 2] := 0.5026483447894845;
                c2[7, 1] := 0.1190627367060072;
                c2[7, 2] := 0.3956893824587150;
                c2[8, 1] := 0.1058058030798994;
                c2[8, 2] := 0.2765091830730650;
                c2[9, 1] := 0.8974708108800873e-1;
                c2[9, 2] := 0.1435505288284833;
              elseif order == 19 then
                alpha := 0.1987936248083529;
                c1[1] := 0.3892259966869526;
                c2[1, 1] := 0.1506640012172225;
                c2[1, 2] := 0.7693121733774260;
                c2[2, 1] := 0.1481728062796673;
                c2[2, 2] := 0.7421133586741549;
                c2[3, 1] := 0.1440444668388838;
                c2[3, 2] := 0.6975075386214800;
                c2[4, 1] := 0.1383101628540374;
                c2[4, 2] := 0.6365464378910025;
                c2[5, 1] := 0.1310032283190998;
                c2[5, 2] := 0.5606211948462122;
                c2[6, 1] := 0.1221431166405330;
                c2[6, 2] := 0.4713530424221445;
                c2[7, 1] := 0.1116991161103884;
                c2[7, 2] := 0.3703717538617073;
                c2[8, 1] := 0.9948917351196349e-1;
                c2[8, 2] := 0.2587371155559744;
                c2[9, 1] := 0.8475989238107367e-1;
                c2[9, 2] := 0.1345537894555993;
              elseif order == 20 then
                alpha := 0.1935761760416219;
                c2[1, 1] := 0.1443871348337404;
                c2[1, 2] := 0.7584165598446141;
                c2[2, 1] := 0.1429501891353184;
                c2[2, 2] := 0.7423000962318863;
                c2[3, 1] := 0.1400877384920004;
                c2[3, 2] := 0.7104185332215555;
                c2[4, 1] := 0.1358210369491446;
                c2[4, 2] := 0.6634599783272630;
                c2[5, 1] := 0.1301773703034290;
                c2[5, 2] := 0.6024175491895959;
                c2[6, 1] := 0.1231826501439148;
                c2[6, 2] := 0.5285332736326852;
                c2[7, 1] := 0.1148465498575254;
                c2[7, 2] := 0.4431977385498628;
                c2[8, 1] := 0.1051289462376788;
                c2[8, 2] := 0.3477444062821162;
                c2[9, 1] := 0.9384622797485121e-1;
                c2[9, 2] := 0.2429038300327729;
                c2[10, 1] := 0.8028211612831444e-1;
                c2[10, 2] := 0.1265329974009533;
              elseif order == 21 then
                alpha := 0.1887494014766075;
                c1[1] := 0.3718070668941645;
                c2[1, 1] := 0.1376151928386445;
                c2[1, 2] := 0.7364290859445481;
                c2[2, 1] := 0.1357438914390695;
                c2[2, 2] := 0.7150167318935022;
                c2[3, 1] := 0.1326398453462415;
                c2[3, 2] := 0.6798001808470175;
                c2[4, 1] := 0.1283231214897678;
                c2[4, 2] := 0.6314663440439816;
                c2[5, 1] := 0.1228169159777534;
                c2[5, 2] := 0.5709353626166905;
                c2[6, 1] := 0.1161406100773184;
                c2[6, 2] := 0.4993087153571335;
                c2[7, 1] := 0.1082959649233524;
                c2[7, 2] := 0.4177766148584385;
                c2[8, 1] := 0.9923596957485723e-1;
                c2[8, 2] := 0.3274257287232124;
                c2[9, 1] := 0.8877776108724853e-1;
                c2[9, 2] := 0.2287218166767916;
                c2[10, 1] := 0.7624076527736326e-1;
                c2[10, 2] := 0.1193423971506988;
              elseif order == 22 then
                alpha := 0.1842668221199706;
                c2[1, 1] := 0.1323053462701543;
                c2[1, 2] := 0.7262446126765204;
                c2[2, 1] := 0.1312121721769772;
                c2[2, 2] := 0.7134286088450949;
                c2[3, 1] := 0.1290330911166814;
                c2[3, 2] := 0.6880287870435514;
                c2[4, 1] := 0.1257817990372067;
                c2[4, 2] := 0.6505015800059301;
                c2[5, 1] := 0.1214765261983008;
                c2[5, 2] := 0.6015107185211451;
                c2[6, 1] := 0.1161365140967959;
                c2[6, 2] := 0.5418983553698413;
                c2[7, 1] := 0.1097755171533100;
                c2[7, 2] := 0.4726370779831614;
                c2[8, 1] := 0.1023889478519956;
                c2[8, 2] := 0.3947439506537486;
                c2[9, 1] := 0.9392485861253800e-1;
                c2[9, 2] := 0.3090996703083202;
                c2[10, 1] := 0.8420273775456455e-1;
                c2[10, 2] := 0.2159561978556017;
                c2[11, 1] := 0.7257600023938262e-1;
                c2[11, 2] := 0.1128633732721116;
              elseif order == 23 then
                alpha := 0.1800893554453722;
                c1[1] := 0.3565232673929280;
                c2[1, 1] := 0.1266275171652706;
                c2[1, 2] := 0.7072778066734162;
                c2[2, 1] := 0.1251865227648538;
                c2[2, 2] := 0.6900676345785905;
                c2[3, 1] := 0.1227944815236645;
                c2[3, 2] := 0.6617011100576023;
                c2[4, 1] := 0.1194647013077667;
                c2[4, 2] := 0.6226432315773119;
                c2[5, 1] := 0.1152132989252356;
                c2[5, 2] := 0.5735222810625359;
                c2[6, 1] := 0.1100558598478487;
                c2[6, 2] := 0.5151027978024605;
                c2[7, 1] := 0.1040013558214886;
                c2[7, 2] := 0.4482410942032739;
                c2[8, 1] := 0.9704014176512626e-1;
                c2[8, 2] := 0.3738049984631116;
                c2[9, 1] := 0.8911683905758054e-1;
                c2[9, 2] := 0.2925028692588410;
                c2[10, 1] := 0.8005438265072295e-1;
                c2[10, 2] := 0.2044134600278901;
                c2[11, 1] := 0.6923832296800832e-1;
                c2[11, 2] := 0.1069984887283394;
              elseif order == 24 then
                alpha := 0.1761838665838427;
                c2[1, 1] := 0.1220804912720132;
                c2[1, 2] := 0.6978026874156063;
                c2[2, 1] := 0.1212296762358897;
                c2[2, 2] := 0.6874139794926736;
                c2[3, 1] := 0.1195328372961027;
                c2[3, 2] := 0.6667954259551859;
                c2[4, 1] := 0.1169990987333593;
                c2[4, 2] := 0.6362602049901176;
                c2[5, 1] := 0.1136409040480130;
                c2[5, 2] := 0.5962662188435553;
                c2[6, 1] := 0.1094722001757955;
                c2[6, 2] := 0.5474001634109253;
                c2[7, 1] := 0.1045052832229087;
                c2[7, 2] := 0.4903523180249535;
                c2[8, 1] := 0.9874509806025907e-1;
                c2[8, 2] := 0.4258751523524645;
                c2[9, 1] := 0.9217799943472177e-1;
                c2[9, 2] := 0.3547079765396403;
                c2[10, 1] := 0.8474633796250476e-1;
                c2[10, 2] := 0.2774145482392767;
                c2[11, 1] := 0.7627722381240495e-1;
                c2[11, 2] := 0.1939329108084139;
                c2[12, 1] := 0.6618645465422745e-1;
                c2[12, 2] := 0.1016670147947242;
              elseif order == 25 then
                alpha := 0.1725220521949266;
                c1[1] := 0.3429735385896000;
                c2[1, 1] := 0.1172525033170618;
                c2[1, 2] := 0.6812327932576614;
                c2[2, 1] := 0.1161194585333535;
                c2[2, 2] := 0.6671566071153211;
                c2[3, 1] := 0.1142375145794466;
                c2[3, 2] := 0.6439167855053158;
                c2[4, 1] := 0.1116157454252308;
                c2[4, 2] := 0.6118378416180135;
                c2[5, 1] := 0.1082654809459177;
                c2[5, 2] := 0.5713609763370088;
                c2[6, 1] := 0.1041985674230918;
                c2[6, 2] := 0.5230289949762722;
                c2[7, 1] := 0.9942439308123559e-1;
                c2[7, 2] := 0.4674627926041906;
                c2[8, 1] := 0.9394453593830893e-1;
                c2[8, 2] := 0.4053226688298811;
                c2[9, 1] := 0.8774221237222533e-1;
                c2[9, 2] := 0.3372372276379071;
                c2[10, 1] := 0.8075839512216483e-1;
                c2[10, 2] := 0.2636485508005428;
                c2[11, 1] := 0.7282483286646764e-1;
                c2[11, 2] := 0.1843801345273085;
                c2[12, 1] := 0.6338571166846652e-1;
                c2[12, 2] := 0.9680153764737715e-1;
              elseif order == 26 then
                alpha := 0.1690795702796737;
                c2[1, 1] := 0.1133168695796030;
                c2[1, 2] := 0.6724297955493932;
                c2[2, 1] := 0.1126417845769961;
                c2[2, 2] := 0.6638709519790540;
                c2[3, 1] := 0.1112948749545606;
                c2[3, 2] := 0.6468652038763624;
                c2[4, 1] := 0.1092823986944244;
                c2[4, 2] := 0.6216337070799265;
                c2[5, 1] := 0.1066130386697976;
                c2[5, 2] := 0.5885011413992190;
                c2[6, 1] := 0.1032969057045413;
                c2[6, 2] := 0.5478864278297548;
                c2[7, 1] := 0.9934388184210715e-1;
                c2[7, 2] := 0.5002885306054287;
                c2[8, 1] := 0.9476081523436283e-1;
                c2[8, 2] := 0.4462644847551711;
                c2[9, 1] := 0.8954648464575577e-1;
                c2[9, 2] := 0.3863930785049522;
                c2[10, 1] := 0.8368166847159917e-1;
                c2[10, 2] := 0.3212074592527143;
                c2[11, 1] := 0.7710664731701103e-1;
                c2[11, 2] := 0.2510470347119383;
                c2[12, 1] := 0.6965807988411425e-1;
                c2[12, 2] := 0.1756419294111342;
                c2[13, 1] := 0.6080674930548766e-1;
                c2[13, 2] := 0.9234535279274277e-1;
              elseif order == 27 then
                alpha := 0.1658353543067995;
                c1[1] := 0.3308543720638957;
                c2[1, 1] := 0.1091618578712746;
                c2[1, 2] := 0.6577977071169651;
                c2[2, 1] := 0.1082549561495043;
                c2[2, 2] := 0.6461121666520275;
                c2[3, 1] := 0.1067479247890451;
                c2[3, 2] := 0.6267937760991321;
                c2[4, 1] := 0.1046471079537577;
                c2[4, 2] := 0.6000750116745808;
                c2[5, 1] := 0.1019605976654259;
                c2[5, 2] := 0.5662734183049320;
                c2[6, 1] := 0.9869726954433709e-1;
                c2[6, 2] := 0.5257827234948534;
                c2[7, 1] := 0.9486520934132483e-1;
                c2[7, 2] := 0.4790595019077763;
                c2[8, 1] := 0.9046906518775348e-1;
                c2[8, 2] := 0.4266025862147336;
                c2[9, 1] := 0.8550529998276152e-1;
                c2[9, 2] := 0.3689188223512328;
                c2[10, 1] := 0.7995282239306020e-1;
                c2[10, 2] := 0.3064589322702932;
                c2[11, 1] := 0.7375174596252882e-1;
                c2[11, 2] := 0.2394754504667310;
                c2[12, 1] := 0.6674377263329041e-1;
                c2[12, 2] := 0.1676223546666024;
                c2[13, 1] := 0.5842458027529246e-1;
                c2[13, 2] := 0.8825044329219431e-1;
              elseif order == 28 then
                alpha := 0.1627710671942929;
                c2[1, 1] := 0.1057232656113488;
                c2[1, 2] := 0.6496161226860832;
                c2[2, 1] := 0.1051786825724864;
                c2[2, 2] := 0.6424661279909941;
                c2[3, 1] := 0.1040917964935006;
                c2[3, 2] := 0.6282470268918791;
                c2[4, 1] := 0.1024670101953951;
                c2[4, 2] := 0.6071189030701136;
                c2[5, 1] := 0.1003105109519892;
                c2[5, 2] := 0.5793175191747016;
                c2[6, 1] := 0.9762969425430802e-1;
                c2[6, 2] := 0.5451486608855443;
                c2[7, 1] := 0.9443223803058400e-1;
                c2[7, 2] := 0.5049796971628137;
                c2[8, 1] := 0.9072460982036488e-1;
                c2[8, 2] := 0.4592270546572523;
                c2[9, 1] := 0.8650956423253280e-1;
                c2[9, 2] := 0.4083368605952977;
                c2[10, 1] := 0.8178165740374893e-1;
                c2[10, 2] := 0.3527525188880655;
                c2[11, 1] := 0.7651838885868020e-1;
                c2[11, 2] := 0.2928534570013572;
                c2[12, 1] := 0.7066010532447490e-1;
                c2[12, 2] := 0.2288185204390681;
                c2[13, 1] := 0.6405358596145789e-1;
                c2[13, 2] := 0.1602396172588190;
                c2[14, 1] := 0.5621780070227172e-1;
                c2[14, 2] := 0.8447589564915071e-1;
              elseif order == 29 then
                alpha := 0.1598706626277596;
                c1[1] := 0.3199314513011623;
                c2[1, 1] := 0.1021101032532951;
                c2[1, 2] := 0.6365758882240111;
                c2[2, 1] := 0.1013729819392774;
                c2[2, 2] := 0.6267495975736321;
                c2[3, 1] := 0.1001476175660628;
                c2[3, 2] := 0.6104876178266819;
                c2[4, 1] := 0.9843854640428316e-1;
                c2[4, 2] := 0.5879603139195113;
                c2[5, 1] := 0.9625164534591696e-1;
                c2[5, 2] := 0.5594012291050210;
                c2[6, 1] := 0.9359356960417668e-1;
                c2[6, 2] := 0.5251016150410664;
                c2[7, 1] := 0.9047086748649986e-1;
                c2[7, 2] := 0.4854024475590397;
                c2[8, 1] := 0.8688856407189167e-1;
                c2[8, 2] := 0.4406826457109709;
                c2[9, 1] := 0.8284779224069856e-1;
                c2[9, 2] := 0.3913408089298914;
                c2[10, 1] := 0.7834154620997181e-1;
                c2[10, 2] := 0.3377643999400627;
                c2[11, 1] := 0.7334628941928766e-1;
                c2[11, 2] := 0.2802710651919946;
                c2[12, 1] := 0.6780290487362146e-1;
                c2[12, 2] := 0.2189770008083379;
                c2[13, 1] := 0.6156321231528423e-1;
                c2[13, 2] := 0.1534235999306070;
                c2[14, 1] := 0.5416797446761512e-1;
                c2[14, 2] := 0.8098664736760292e-1;
              elseif order == 30 then
                alpha := 0.1571200296252450;
                c2[1, 1] := 0.9908074847842124e-1;
                c2[1, 2] := 0.6289618807831557;
                c2[2, 1] := 0.9863509708328196e-1;
                c2[2, 2] := 0.6229164525571278;
                c2[3, 1] := 0.9774542692037148e-1;
                c2[3, 2] := 0.6108853364240036;
                c2[4, 1] := 0.9641490581986484e-1;
                c2[4, 2] := 0.5929869253412513;
                c2[5, 1] := 0.9464802912225441e-1;
                c2[5, 2] := 0.5693960175547550;
                c2[6, 1] := 0.9245027206218041e-1;
                c2[6, 2] := 0.5403402396359503;
                c2[7, 1] := 0.8982754584112941e-1;
                c2[7, 2] := 0.5060948065875106;
                c2[8, 1] := 0.8678535291732599e-1;
                c2[8, 2] := 0.4669749797983789;
                c2[9, 1] := 0.8332744242052199e-1;
                c2[9, 2] := 0.4233249626334694;
                c2[10, 1] := 0.7945356393775309e-1;
                c2[10, 2] := 0.3755006094498054;
                c2[11, 1] := 0.7515543969833788e-1;
                c2[11, 2] := 0.3238400339292700;
                c2[12, 1] := 0.7040879901685638e-1;
                c2[12, 2] := 0.2686072427439079;
                c2[13, 1] := 0.6515528854010540e-1;
                c2[13, 2] := 0.2098650589782619;
                c2[14, 1] := 0.5925168237177876e-1;
                c2[14, 2] := 0.1471138832654873;
                c2[15, 1] := 0.5225913954211672e-1;
                c2[15, 2] := 0.7775248839507864e-1;
              elseif order == 31 then
                alpha := 0.1545067022920929;
                c1[1] := 0.3100206996451866;
                c2[1, 1] := 0.9591020358831668e-1;
                c2[1, 2] := 0.6172474793293396;
                c2[2, 1] := 0.9530301275601203e-1;
                c2[2, 2] := 0.6088916323460413;
                c2[3, 1] := 0.9429332655402368e-1;
                c2[3, 2] := 0.5950511595503025;
                c2[4, 1] := 0.9288445429894548e-1;
                c2[4, 2] := 0.5758534119053522;
                c2[5, 1] := 0.9108073420087422e-1;
                c2[5, 2] := 0.5514734636081183;
                c2[6, 1] := 0.8888719137536870e-1;
                c2[6, 2] := 0.5221306199481831;
                c2[7, 1] := 0.8630901440239650e-1;
                c2[7, 2] := 0.4880834248148061;
                c2[8, 1] := 0.8335074993373294e-1;
                c2[8, 2] := 0.4496225358496770;
                c2[9, 1] := 0.8001502494376102e-1;
                c2[9, 2] := 0.4070602306679052;
                c2[10, 1] := 0.7630041338037624e-1;
                c2[10, 2] := 0.3607139804818122;
                c2[11, 1] := 0.7219760885744920e-1;
                c2[11, 2] := 0.3108783301229550;
                c2[12, 1] := 0.6768185077153345e-1;
                c2[12, 2] := 0.2577706252514497;
                c2[13, 1] := 0.6269571766328638e-1;
                c2[13, 2] := 0.2014081375889921;
                c2[14, 1] := 0.5710081766945065e-1;
                c2[14, 2] := 0.1412581515841926;
                c2[15, 1] := 0.5047740914807019e-1;
                c2[15, 2] := 0.7474725873250158e-1;
              elseif order == 32 then
                alpha := 0.1520196210848210;
                c2[1, 1] := 0.9322163554339406e-1;
                c2[1, 2] := 0.6101488690506050;
                c2[2, 1] := 0.9285233997694042e-1;
                c2[2, 2] := 0.6049832320721264;
                c2[3, 1] := 0.9211494244473163e-1;
                c2[3, 2] := 0.5946969295569034;
                c2[4, 1] := 0.9101176786042449e-1;
                c2[4, 2] := 0.5793791854364477;
                c2[5, 1] := 0.8954614071360517e-1;
                c2[5, 2] := 0.5591619969234026;
                c2[6, 1] := 0.8772216763680164e-1;
                c2[6, 2] := 0.5342177994699602;
                c2[7, 1] := 0.8554440426912734e-1;
                c2[7, 2] := 0.5047560942986598;
                c2[8, 1] := 0.8301735302045588e-1;
                c2[8, 2] := 0.4710187048140929;
                c2[9, 1] := 0.8014469519188161e-1;
                c2[9, 2] := 0.4332730387207936;
                c2[10, 1] := 0.7692807528893225e-1;
                c2[10, 2] := 0.3918021436411035;
                c2[11, 1] := 0.7336507157284898e-1;
                c2[11, 2] := 0.3468890521471250;
                c2[12, 1] := 0.6944555312763458e-1;
                c2[12, 2] := 0.2987898029050460;
                c2[13, 1] := 0.6514446669420571e-1;
                c2[13, 2] := 0.2476810747407199;
                c2[14, 1] := 0.6040544477732702e-1;
                c2[14, 2] := 0.1935412053397663;
                c2[15, 1] := 0.5509478650672775e-1;
                c2[15, 2] := 0.1358108994174911;
                c2[16, 1] := 0.4881064725720192e-1;
                c2[16, 2] := 0.7194819894416505e-1;
              elseif order == 33 then
                alpha := 0.1496489351138032;
                c1[1] := 0.3009752799176432;
                c2[1, 1] := 0.9041725460994505e-1;
                c2[1, 2] := 0.5995521047364046;
                c2[2, 1] := 0.8991117804113002e-1;
                c2[2, 2] := 0.5923764112099496;
                c2[3, 1] := 0.8906941547422532e-1;
                c2[3, 2] := 0.5804822013853129;
                c2[4, 1] := 0.8789442491445575e-1;
                c2[4, 2] := 0.5639663528946501;
                c2[5, 1] := 0.8638945831033775e-1;
                c2[5, 2] := 0.5429623519607796;
                c2[6, 1] := 0.8455834602616358e-1;
                c2[6, 2] := 0.5176379938389326;
                c2[7, 1] := 0.8240517431382334e-1;
                c2[7, 2] := 0.4881921474066189;
                c2[8, 1] := 0.7993380417355076e-1;
                c2[8, 2] := 0.4548502528082586;
                c2[9, 1] := 0.7714713890732801e-1;
                c2[9, 2] := 0.4178579388038483;
                c2[10, 1] := 0.7404596598181127e-1;
                c2[10, 2] := 0.3774715722484659;
                c2[11, 1] := 0.7062702339160462e-1;
                c2[11, 2] := 0.3339432938810453;
                c2[12, 1] := 0.6687952672391507e-1;
                c2[12, 2] := 0.2874950693388235;
                c2[13, 1] := 0.6277828912909767e-1;
                c2[13, 2] := 0.2382680702894708;
                c2[14, 1] := 0.5826808305383988e-1;
                c2[14, 2] := 0.1862073169968455;
                c2[15, 1] := 0.5321974125363517e-1;
                c2[15, 2] := 0.1307323751236313;
                c2[16, 1] := 0.4724820282032780e-1;
                c2[16, 2] := 0.6933542082177094e-1;
              elseif order == 34 then
                alpha := 0.1473858373968463;
                c2[1, 1] := 0.8801537152275983e-1;
                c2[1, 2] := 0.5929204288972172;
                c2[2, 1] := 0.8770594341007476e-1;
                c2[2, 2] := 0.5884653382247518;
                c2[3, 1] := 0.8708797598072095e-1;
                c2[3, 2] := 0.5795895850253119;
                c2[4, 1] := 0.8616320590689187e-1;
                c2[4, 2] := 0.5663615383647170;
                c2[5, 1] := 0.8493413175570858e-1;
                c2[5, 2] := 0.5488825092350877;
                c2[6, 1] := 0.8340387368687513e-1;
                c2[6, 2] := 0.5272851839324592;
                c2[7, 1] := 0.8157596213131521e-1;
                c2[7, 2] := 0.5017313864372913;
                c2[8, 1] := 0.7945402670834270e-1;
                c2[8, 2] := 0.4724089864574216;
                c2[9, 1] := 0.7704133559556429e-1;
                c2[9, 2] := 0.4395276256463053;
                c2[10, 1] := 0.7434009635219704e-1;
                c2[10, 2] := 0.4033126590648964;
                c2[11, 1] := 0.7135035113853376e-1;
                c2[11, 2] := 0.3639961488919042;
                c2[12, 1] := 0.6806813160738834e-1;
                c2[12, 2] := 0.3218025212900124;
                c2[13, 1] := 0.6448214312000864e-1;
                c2[13, 2] := 0.2769235521088158;
                c2[14, 1] := 0.6056719318430530e-1;
                c2[14, 2] := 0.2294693573271038;
                c2[15, 1] := 0.5626925196925040e-1;
                c2[15, 2] := 0.1793564218840015;
                c2[16, 1] := 0.5146352031547277e-1;
                c2[16, 2] := 0.1259877129326412;
                c2[17, 1] := 0.4578069074410591e-1;
                c2[17, 2] := 0.6689147319568768e-1;
              elseif order == 35 then
                alpha := 0.1452224267615486;
                c1[1] := 0.2926764667564367;
                c2[1, 1] := 0.8551731299267280e-1;
                c2[1, 2] := 0.5832758214629523;
                c2[2, 1] := 0.8509109732853060e-1;
                c2[2, 2] := 0.5770596582643844;
                c2[3, 1] := 0.8438201446671953e-1;
                c2[3, 2] := 0.5667497616665494;
                c2[4, 1] := 0.8339191981579831e-1;
                c2[4, 2] := 0.5524209816238369;
                c2[5, 1] := 0.8212328610083385e-1;
                c2[5, 2] := 0.5341766459916322;
                c2[6, 1] := 0.8057906332198853e-1;
                c2[6, 2] := 0.5121470053512750;
                c2[7, 1] := 0.7876247299954955e-1;
                c2[7, 2] := 0.4864870722254752;
                c2[8, 1] := 0.7667670879950268e-1;
                c2[8, 2] := 0.4573736721705665;
                c2[9, 1] := 0.7432449556218945e-1;
                c2[9, 2] := 0.4250013835198991;
                c2[10, 1] := 0.7170742126011575e-1;
                c2[10, 2] := 0.3895767735915445;
                c2[11, 1] := 0.6882488171701314e-1;
                c2[11, 2] := 0.3513097926737368;
                c2[12, 1] := 0.6567231746957568e-1;
                c2[12, 2] := 0.3103999917596611;
                c2[13, 1] := 0.6223804362223595e-1;
                c2[13, 2] := 0.2670123611280899;
                c2[14, 1] := 0.5849696460782910e-1;
                c2[14, 2] := 0.2212298104867592;
                c2[15, 1] := 0.5439628409499822e-1;
                c2[15, 2] := 0.1729443731341637;
                c2[16, 1] := 0.4981540179136920e-1;
                c2[16, 2] := 0.1215462157134930;
                c2[17, 1] := 0.4439981033536435e-1;
                c2[17, 2] := 0.6460098363520967e-1;
              elseif order == 36 then
                alpha := 0.1431515914458580;
                c2[1, 1] := 0.8335881847130301e-1;
                c2[1, 2] := 0.5770670512160201;
                c2[2, 1] := 0.8309698922852212e-1;
                c2[2, 2] := 0.5731929100172432;
                c2[3, 1] := 0.8257400347039723e-1;
                c2[3, 2] := 0.5654713811993058;
                c2[4, 1] := 0.8179117911600136e-1;
                c2[4, 2] := 0.5539556343603020;
                c2[5, 1] := 0.8075042173126963e-1;
                c2[5, 2] := 0.5387245649546684;
                c2[6, 1] := 0.7945413151258206e-1;
                c2[6, 2] := 0.5198817177723069;
                c2[7, 1] := 0.7790506514288866e-1;
                c2[7, 2] := 0.4975537629595409;
                c2[8, 1] := 0.7610613635339480e-1;
                c2[8, 2] := 0.4718884193866789;
                c2[9, 1] := 0.7406012816626425e-1;
                c2[9, 2] := 0.4430516443136726;
                c2[10, 1] := 0.7176927060205631e-1;
                c2[10, 2] := 0.4112237708115829;
                c2[11, 1] := 0.6923460172504251e-1;
                c2[11, 2] := 0.3765940116389730;
                c2[12, 1] := 0.6645495833489556e-1;
                c2[12, 2] := 0.3393522147815403;
                c2[13, 1] := 0.6342528888937094e-1;
                c2[13, 2] := 0.2996755899575573;
                c2[14, 1] := 0.6013361864949449e-1;
                c2[14, 2] := 0.2577053294053830;
                c2[15, 1] := 0.5655503081322404e-1;
                c2[15, 2] := 0.2135004731531631;
                c2[16, 1] := 0.5263798119559069e-1;
                c2[16, 2] := 0.1669320999865636;
                c2[17, 1] := 0.4826589873626196e-1;
                c2[17, 2] := 0.1173807590715484;
                c2[18, 1] := 0.4309819397289806e-1;
                c2[18, 2] := 0.6245036108880222e-1;
              elseif order == 37 then
                alpha := 0.1411669104782917;
                c1[1] := 0.2850271036215707;
                c2[1, 1] := 0.8111958235023328e-1;
                c2[1, 2] := 0.5682412610563970;
                c2[2, 1] := 0.8075727567979578e-1;
                c2[2, 2] := 0.5628142923227016;
                c2[3, 1] := 0.8015440554413301e-1;
                c2[3, 2] := 0.5538087696879930;
                c2[4, 1] := 0.7931239302677386e-1;
                c2[4, 2] := 0.5412833323304460;
                c2[5, 1] := 0.7823314328639347e-1;
                c2[5, 2] := 0.5253190555393968;
                c2[6, 1] := 0.7691895211595101e-1;
                c2[6, 2] := 0.5060183741977191;
                c2[7, 1] := 0.7537237072011853e-1;
                c2[7, 2] := 0.4835036020049034;
                c2[8, 1] := 0.7359601294804538e-1;
                c2[8, 2] := 0.4579149413954837;
                c2[9, 1] := 0.7159227884849299e-1;
                c2[9, 2] := 0.4294078049978829;
                c2[10, 1] := 0.6936295002846032e-1;
                c2[10, 2] := 0.3981491350382047;
                c2[11, 1] := 0.6690857785828917e-1;
                c2[11, 2] := 0.3643121502867948;
                c2[12, 1] := 0.6422751692085542e-1;
                c2[12, 2] := 0.3280684291406284;
                c2[13, 1] := 0.6131430866206096e-1;
                c2[13, 2] := 0.2895750997170303;
                c2[14, 1] := 0.5815677249570920e-1;
                c2[14, 2] := 0.2489521814805720;
                c2[15, 1] := 0.5473023527947980e-1;
                c2[15, 2] := 0.2062377435955363;
                c2[16, 1] := 0.5098441033167034e-1;
                c2[16, 2] := 0.1612849131645336;
                c2[17, 1] := 0.4680658811093562e-1;
                c2[17, 2] := 0.1134672937045305;
                c2[18, 1] := 0.4186928031694695e-1;
                c2[18, 2] := 0.6042754777339966e-1;
              elseif order == 38 then
                alpha := 0.1392625697140030;
                c2[1, 1] := 0.7916943373658329e-1;
                c2[1, 2] := 0.5624158631591745;
                c2[2, 1] := 0.7894592250257840e-1;
                c2[2, 2] := 0.5590219398777304;
                c2[3, 1] := 0.7849941672384930e-1;
                c2[3, 2] := 0.5522551628416841;
                c2[4, 1] := 0.7783093084875645e-1;
                c2[4, 2] := 0.5421574325808380;
                c2[5, 1] := 0.7694193770482690e-1;
                c2[5, 2] := 0.5287909941093643;
                c2[6, 1] := 0.7583430534712885e-1;
                c2[6, 2] := 0.5122376814029880;
                c2[7, 1] := 0.7451020436122948e-1;
                c2[7, 2] := 0.4925978555548549;
                c2[8, 1] := 0.7297197617673508e-1;
                c2[8, 2] := 0.4699889739625235;
                c2[9, 1] := 0.7122194706992953e-1;
                c2[9, 2] := 0.4445436860615774;
                c2[10, 1] := 0.6926216260386816e-1;
                c2[10, 2] := 0.4164072786327193;
                c2[11, 1] := 0.6709399961255503e-1;
                c2[11, 2] := 0.3857341621868851;
                c2[12, 1] := 0.6471757977022456e-1;
                c2[12, 2] := 0.3526828388476838;
                c2[13, 1] := 0.6213084287116965e-1;
                c2[13, 2] := 0.3174082831364342;
                c2[14, 1] := 0.5932799638550641e-1;
                c2[14, 2] := 0.2800495563550299;
                c2[15, 1] := 0.5629672408524944e-1;
                c2[15, 2] := 0.2407078154782509;
                c2[16, 1] := 0.5301264751544952e-1;
                c2[16, 2] := 0.1994026830553859;
                c2[17, 1] := 0.4942673259817896e-1;
                c2[17, 2] := 0.1559719194038917;
                c2[18, 1] := 0.4542996716979947e-1;
                c2[18, 2] := 0.1097844277878470;
                c2[19, 1] := 0.4070720755433961e-1;
                c2[19, 2] := 0.5852181110523043e-1;
              elseif order == 39 then
                alpha := 0.1374332900196804;
                c1[1] := 0.2779468246419593;
                c2[1, 1] := 0.7715084161825772e-1;
                c2[1, 2] := 0.5543001331300056;
                c2[2, 1] := 0.7684028301163326e-1;
                c2[2, 2] := 0.5495289890712267;
                c2[3, 1] := 0.7632343924866024e-1;
                c2[3, 2] := 0.5416083298429741;
                c2[4, 1] := 0.7560141319808483e-1;
                c2[4, 2] := 0.5305846713929198;
                c2[5, 1] := 0.7467569064745969e-1;
                c2[5, 2] := 0.5165224112570647;
                c2[6, 1] := 0.7354807648551346e-1;
                c2[6, 2] := 0.4995030679271456;
                c2[7, 1] := 0.7222060351121389e-1;
                c2[7, 2] := 0.4796242430956156;
                c2[8, 1] := 0.7069540462458585e-1;
                c2[8, 2] := 0.4569982440368368;
                c2[9, 1] := 0.6897453353492381e-1;
                c2[9, 2] := 0.4317502624832354;
                c2[10, 1] := 0.6705970959388781e-1;
                c2[10, 2] := 0.4040159353969854;
                c2[11, 1] := 0.6495194541066725e-1;
                c2[11, 2] := 0.3739379843169939;
                c2[12, 1] := 0.6265098412417610e-1;
                c2[12, 2] := 0.3416613843816217;
                c2[13, 1] := 0.6015440984955930e-1;
                c2[13, 2] := 0.3073260166338746;
                c2[14, 1] := 0.5745615876877304e-1;
                c2[14, 2] := 0.2710546723961181;
                c2[15, 1] := 0.5454383762391338e-1;
                c2[15, 2] := 0.2329316824061170;
                c2[16, 1] := 0.5139340231935751e-1;
                c2[16, 2] := 0.1929604256043231;
                c2[17, 1] := 0.4795705862458131e-1;
                c2[17, 2] := 0.1509655259246037;
                c2[18, 1] := 0.4412933231935506e-1;
                c2[18, 2] := 0.1063130748962878;
                c2[19, 1] := 0.3960672309405603e-1;
                c2[19, 2] := 0.5672356837211527e-1;
              elseif order == 40 then
                alpha := 0.1356742655825434;
                c2[1, 1] := 0.7538038374294594e-1;
                c2[1, 2] := 0.5488228264329617;
                c2[2, 1] := 0.7518806529402738e-1;
                c2[2, 2] := 0.5458297722483311;
                c2[3, 1] := 0.7480383050347119e-1;
                c2[3, 2] := 0.5398604576730540;
                c2[4, 1] := 0.7422847031965465e-1;
                c2[4, 2] := 0.5309482987446206;
                c2[5, 1] := 0.7346313704205006e-1;
                c2[5, 2] := 0.5191429845322307;
                c2[6, 1] := 0.7250930053201402e-1;
                c2[6, 2] := 0.5045099368431007;
                c2[7, 1] := 0.7136868456879621e-1;
                c2[7, 2] := 0.4871295553902607;
                c2[8, 1] := 0.7004317764946634e-1;
                c2[8, 2] := 0.4670962098860498;
                c2[9, 1] := 0.6853470921527828e-1;
                c2[9, 2] := 0.4445169164956202;
                c2[10, 1] := 0.6684507689945471e-1;
                c2[10, 2] := 0.4195095960479698;
                c2[11, 1] := 0.6497570123412630e-1;
                c2[11, 2] := 0.3922007419030645;
                c2[12, 1] := 0.6292726794917847e-1;
                c2[12, 2] := 0.3627221993494397;
                c2[13, 1] := 0.6069918741663154e-1;
                c2[13, 2] := 0.3312065181294388;
                c2[14, 1] := 0.5828873983769410e-1;
                c2[14, 2] := 0.2977798532686911;
                c2[15, 1] := 0.5568964389813015e-1;
                c2[15, 2] := 0.2625503293999835;
                c2[16, 1] := 0.5288947816690705e-1;
                c2[16, 2] := 0.2255872486520188;
                c2[17, 1] := 0.4986456327645859e-1;
                c2[17, 2] := 0.1868796731919594;
                c2[18, 1] := 0.4656832613054458e-1;
                c2[18, 2] := 0.1462410193532463;
                c2[19, 1] := 0.4289867647614935e-1;
                c2[19, 2] := 0.1030361558710747;
                c2[20, 1] := 0.3856310684054106e-1;
                c2[20, 2] := 0.5502423832293889e-1;
              elseif order == 41 then
                alpha := 0.1339811106984253;
                c1[1] := 0.2713685065531391;
                c2[1, 1] := 0.7355140275160984e-1;
                c2[1, 2] := 0.5413274778282860;
                c2[2, 1] := 0.7328319082267173e-1;
                c2[2, 2] := 0.5371064088294270;
                c2[3, 1] := 0.7283676160772547e-1;
                c2[3, 2] := 0.5300963437270770;
                c2[4, 1] := 0.7221298133014343e-1;
                c2[4, 2] := 0.5203345998371490;
                c2[5, 1] := 0.7141302173623395e-1;
                c2[5, 2] := 0.5078728971879841;
                c2[6, 1] := 0.7043831559982149e-1;
                c2[6, 2] := 0.4927768111819803;
                c2[7, 1] := 0.6929049381827268e-1;
                c2[7, 2] := 0.4751250308594139;
                c2[8, 1] := 0.6797129849758392e-1;
                c2[8, 2] := 0.4550083840638406;
                c2[9, 1] := 0.6648246325101609e-1;
                c2[9, 2] := 0.4325285673076087;
                c2[10, 1] := 0.6482554675958526e-1;
                c2[10, 2] := 0.4077964789091151;
                c2[11, 1] := 0.6300169683004558e-1;
                c2[11, 2] := 0.3809299858742483;
                c2[12, 1] := 0.6101130648543355e-1;
                c2[12, 2] := 0.3520508315700898;
                c2[13, 1] := 0.5885349417435808e-1;
                c2[13, 2] := 0.3212801560701271;
                c2[14, 1] := 0.5652528148656809e-1;
                c2[14, 2] := 0.2887316252774887;
                c2[15, 1] := 0.5402021575818373e-1;
                c2[15, 2] := 0.2545001287790888;
                c2[16, 1] := 0.5132588802608274e-1;
                c2[16, 2] := 0.2186415296842951;
                c2[17, 1] := 0.4841900639702602e-1;
                c2[17, 2] := 0.1811322622296060;
                c2[18, 1] := 0.4525419574485134e-1;
                c2[18, 2] := 0.1417762065404688;
                c2[19, 1] := 0.4173260173087802e-1;
                c2[19, 2] := 0.9993834530966510e-1;
                c2[20, 1] := 0.3757210572966463e-1;
                c2[20, 2] := 0.5341611499960143e-1;
              else
                Streams.error("Input argument order (= " + String(order) +
                  ") of Bessel filter is not in the range 1..41");
              end if;

              annotation (Documentation(info="<html><p>The transfer function H(p) of a <em>n</em> 'th order Bessel filter is given by</p>
<blockquote><pre>
        Bn(0)
H(p) = -------
        Bn(p)
 </pre>
</blockquote>
<p>with the denominator polynomial</p>
<blockquote><pre>
         n             n  (2n - k)!       p^k
Bn(p) = sum c_k*p^k = sum ----------- * -------   (1)
        k=0           k=0 (n - k)!k!    2^(n-k)
</pre></blockquote>
<p>and the numerator</p>
<blockquote><pre>
               (2n)!     1
Bn(0) = c_0 = ------- * ---- .                    (2)
                n!      2^n
 </pre></blockquote>
<p>Although the coefficients c_k are integer numbers, it is not advisable to use the
polynomials in an unfactorized form because the coefficients are fast growing with order
n (c_0 is approximately 0.3e24 and 0.8e59 for order n=20 and order n=40
respectively).</p>

<p>Therefore, the polynomial Bn(p) is factorized to first and second order polynomials with
real coefficients corresponding to zeros and poles representation that is used in this library.</p>

<p>The function returns the coefficients which resulted from factorization of the normalized transfer function</p>
<blockquote><pre>
H'(p') = H(p),  p' = p/w0
</pre></blockquote>
<p>as well as</p>
<blockquote><pre>
alpha = 1/w0
</pre></blockquote>
<p>the reciprocal of the cut of frequency w0 where the gain of the transfer function is
decreased 3dB.</p>

<p>Both, coefficients and cut off frequency were calculated symbolically and were eventually evaluated
with high precision calculation. The results were stored in this function as real
numbers.</p>

<h4>Calculation of normalized Bessel filter coefficients</h4>
<p>Equation</p>
<blockquote><pre>
abs(H(j*w0)) = abs(Bn(0)/Bn(j*w0)) = 10^(-3/20)
</pre></blockquote>
<p>which must be fulfilled for cut off frequency w = w0 leads to</p>
<blockquote><pre>
[Re(Bn(j*w0))]^2 + [Im(Bn(j*w0))]^2 - (Bn(0)^2)*10^(3/10) = 0
</pre></blockquote>
<p>which has exactly one real solution w0 for each order n. This solutions of w0 are
calculated symbolically first and evaluated by using high precise values of the
coefficients c_k calculated by following (1) and (2).</p>

<p>With w0, the coefficients of the factorized polynomial can be computed by calculating the
zeros of the denominator polynomial</p>
<blockquote><pre>
        n
Bn(p) = sum w0^k*c_k*(p/w0)^k
        k=0
</pre></blockquote>
<p>of the normalized transfer function H'(p'). There exist n/2 of conjugate complex
pairs of zeros (beta +-j*gamma) if n is even and one additional real zero (alpha) if n is
odd. Finally, the coefficients a, b1_k, b2_k of the polynomials</p>
<blockquote><pre> a*p + 1,  n is odd </pre></blockquote>
<p>and</p>
<blockquote><pre>
b2_k*p^2 + b1_k*p + 1,   k = 1,... div(n,2)
</pre></blockquote>
<p>results from</p>
<blockquote><pre>
a = -1/alpha
</pre></blockquote>
<p>and</p>
<blockquote><pre>
b2_k = 1/(beta_k^2 + gamma_k^2) b1_k = -2*beta_k/(beta_k^2 + gamma_k^2)
</pre></blockquote>
</html>"));
            end BesselBaseCoefficients;

            function toHighestPowerOne
              "Transform filter to form with highest power of s equal 1"
              extends Modelica.Icons.Function;

              input Real den1[:] "[s] coefficients of polynomials (den1[i]*s + 1)";
              input Real den2[:,2]
                "[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)";
              output Real cr[size(den1, 1)]
                "[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])";
              output Real c0[size(den2, 1)]
                "[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
              output Real c1[size(den2, 1)]
                "[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
            algorithm
              for i in 1:size(den1, 1) loop
                cr[i] := 1/den1[i];
              end for;

              for i in 1:size(den2, 1) loop
                c1[i] := den2[i, 2]/den2[i, 1];
                c0[i] := 1/den2[i, 1];
              end for;
            end toHighestPowerOne;

            function normalizationFactor
              "Compute correction factor of low pass filter such that amplitude at cut-off frequency is -3db (=10^(-3/20) = 0.70794...)"
              extends Modelica.Icons.Function;

              import Modelica.Utilities.Streams;

              input Real c1[:]
                "[p] coefficients of denominator polynomials (c1[i}*p + 1)";
              input Real c2[:,2]
                "[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
              output Real alpha "Correction factor (replace p by alpha*p)";
          protected
              Real alpha_min;
              Real alpha_max;

              function normalizationResidue
                "Residue of correction factor computation"
                extends Modelica.Icons.Function;
                input Real c1[:]
                  "[p] coefficients of denominator polynomials (c1[i]*p + 1)";
                input Real c2[:,2]
                  "[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
                input Real alpha;
                output Real residue;
            protected
                constant Real beta= 10^(-3/20)
                  "Amplitude of -3db required, i.e., -3db = 20*log(beta)";
                Real cc1;
                Real cc2;
                Real p;
                Real alpha2=alpha*alpha;
                Real alpha4=alpha2*alpha2;
                Real A2=1.0;
              algorithm
                assert(size(c1,1) <= 1, "Internal error 2 (should not occur)");
                if size(c1, 1) == 1 then
                  cc1 := c1[1]*c1[1];
                  p := 1 + cc1*alpha2;
                  A2 := A2*p;
                end if;
                for i in 1:size(c2, 1) loop
                  cc1 := c2[i, 2]*c2[i, 2] - 2*c2[i, 1];
                  cc2 := c2[i, 1]*c2[i, 1];
                  p := 1 + cc1*alpha2 + cc2*alpha4;
                  A2 := A2*p;
                end for;
                residue := 1/sqrt(A2) - beta;
              end normalizationResidue;

              function findInterval "Find interval for the root"
                extends Modelica.Icons.Function;
                input Real c1[:]
                  "[p] coefficients of denominator polynomials (a*p + 1)";
                input Real c2[:,2]
                  "[p^2, p] coefficients of denominator polynomials (b*p^2 + a*p + 1)";
                output Real alpha_min;
                output Real alpha_max;
            protected
                Real alpha = 1.0;
                Real residue;
              algorithm
                alpha_min :=0;
                residue := normalizationResidue(c1, c2, alpha);
                if residue < 0 then
                   alpha_max :=alpha;
                else
                   while residue >= 0 loop
                      alpha := 1.1*alpha;
                      residue := normalizationResidue(c1, c2, alpha);
                   end while;
                   alpha_max :=alpha;
                end if;
              end findInterval;

            function solveOneNonlinearEquation
                "Solve f(u) = 0; f(u_min) and f(u_max) must have different signs"
                extends Modelica.Icons.Function;
                import Modelica.Utilities.Streams.error;

              input Real c1[:]
                  "[p] coefficients of denominator polynomials (c1[i]*p + 1)";
              input Real c2[:,2]
                  "[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
              input Real u_min "Lower bound of search interval";
              input Real u_max "Upper bound of search interval";
              input Real tolerance=100*Modelica.Constants.eps
                  "Relative tolerance of solution u";
              output Real u "Value of independent variable so that f(u) = 0";

            protected
              constant Real eps=Modelica.Constants.eps "machine epsilon";
              Real a=u_min "Current best minimum interval value";
              Real b=u_max "Current best maximum interval value";
              Real c "Intermediate point a <= c <= b";
              Real d;
              Real e "b - a";
              Real m;
              Real s;
              Real p;
              Real q;
              Real r;
              Real tol;
              Real fa "= f(a)";
              Real fb "= f(b)";
              Real fc;
              Boolean found=false;
            algorithm
              // Check that f(u_min) and f(u_max) have different sign
              fa := normalizationResidue(c1,c2,u_min);
              fb := normalizationResidue(c1,c2,u_max);
              fc := fb;
              if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
                error(
                  "The arguments u_min and u_max to solveOneNonlinearEquation(..)\n" +
                  "do not bracket the root of the single non-linear equation:\n" +
                  "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max)
                   + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" +
                  "  fb = f(u_max) = " + String(fb) + "\n" +
                  "fa and fb must have opposite sign which is not the case");
              end if;

              // Initialize variables
              c := a;
              fc := fa;
              e := b - a;
              d := e;

              // Search loop
              while not found loop
                if abs(fc) < abs(fb) then
                  a := b;
                  b := c;
                  c := a;
                  fa := fb;
                  fb := fc;
                  fc := fa;
                end if;

                tol := 2*eps*abs(b) + tolerance;
                m := (c - b)/2;

                if abs(m) <= tol or fb == 0.0 then
                  // root found (interval is small enough)
                  found := true;
                  u := b;
                else
                  // Determine if a bisection is needed
                  if abs(e) < tol or abs(fa) <= abs(fb) then
                    e := m;
                    d := e;
                  else
                    s := fb/fa;
                    if a == c then
                      // linear interpolation
                      p := 2*m*s;
                      q := 1 - s;
                    else
                      // inverse quadratic interpolation
                      q := fa/fc;
                      r := fb/fc;
                      p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                      q := (q - 1)*(r - 1)*(s - 1);
                    end if;

                    if p > 0 then
                      q := -q;
                    else
                      p := -p;
                    end if;

                    s := e;
                    e := d;
                    if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                      // interpolation successful
                      d := p/q;
                    else
                      // use bi-section
                      e := m;
                      d := e;
                    end if;
                  end if;

                  // Best guess value is defined as "a"
                  a := b;
                  fa := fb;
                  b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
                  fb := normalizationResidue(c1,c2,b);

                  if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
                    // initialize variables
                    c := a;
                    fc := fa;
                    e := b - a;
                    d := e;
                  end if;
                end if;
              end while;

              annotation (Documentation(info="<html>

<p>
This function determines the solution of <strong>one non-linear algebraic equation</strong> \"y=f(u)\"
in <strong>one unknown</strong> \"u\" in a reliable way. It is one of the best numerical
algorithms for this purpose. As input, the nonlinear function f(u)
has to be given, as well as an interval u_min, u_max that
contains the solution, i.e., \"f(u_min)\" and \"f(u_max)\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <strong>Algorithms for Minimization without derivatives</strong>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>

</html>"));
            end solveOneNonlinearEquation;

            algorithm
               // Find interval for alpha
               (alpha_min, alpha_max) :=findInterval(c1, c2);

               // Compute alpha, so that abs(G(p)) = -3db
               alpha :=solveOneNonlinearEquation(
                c1,
                c2,
                alpha_min,
                alpha_max);
            end normalizationFactor;

            encapsulated function bandPassAlpha "Return alpha for band pass"
              extends Modelica.Icons.Function;

              import Modelica;
               input Real a "Coefficient of s^1";
               input Real b "Coefficient of s^0";
               input Modelica.SIunits.AngularVelocity w
                "Bandwidth angular frequency";
               output Real alpha "Alpha factor to build up band pass";

          protected
              Real alpha_min;
              Real alpha_max;
              Real z_min;
              Real z_max;
              Real z;

              function residue "Residue of non-linear equation"
                extends Modelica.Icons.Function;
                input Real a;
                input Real b;
                input Real w;
                input Real z;
                output Real res;
              algorithm
                res := z^2 + (a*w*z/(1+z))^2 - (2+b*w^2)*z + 1;
              end residue;

            function solveOneNonlinearEquation
                "Solve f(u) = 0; f(u_min) and f(u_max) must have different signs"
                extends Modelica.Icons.Function;
                import Modelica.Utilities.Streams.error;

              input Real aa;
              input Real bb;
              input Real ww;
              input Real u_min "Lower bound of search interval";
              input Real u_max "Upper bound of search interval";
              input Real tolerance=100*Modelica.Constants.eps
                  "Relative tolerance of solution u";
              output Real u "Value of independent variable so that f(u) = 0";

            protected
              constant Real eps=Modelica.Constants.eps "machine epsilon";
              Real a=u_min "Current best minimum interval value";
              Real b=u_max "Current best maximum interval value";
              Real c "Intermediate point a <= c <= b";
              Real d;
              Real e "b - a";
              Real m;
              Real s;
              Real p;
              Real q;
              Real r;
              Real tol;
              Real fa "= f(a)";
              Real fb "= f(b)";
              Real fc;
              Boolean found=false;
            algorithm
              // Check that f(u_min) and f(u_max) have different sign
              fa := residue(aa,bb,ww,u_min);
              fb := residue(aa,bb,ww,u_max);
              fc := fb;
              if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
                error(
                  "The arguments u_min and u_max to solveOneNonlinearEquation(..)\n" +
                  "do not bracket the root of the single non-linear equation:\n" +
                  "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max)
                   + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" +
                  "  fb = f(u_max) = " + String(fb) + "\n" +
                  "fa and fb must have opposite sign which is not the case");
              end if;

              // Initialize variables
              c := a;
              fc := fa;
              e := b - a;
              d := e;

              // Search loop
              while not found loop
                if abs(fc) < abs(fb) then
                  a := b;
                  b := c;
                  c := a;
                  fa := fb;
                  fb := fc;
                  fc := fa;
                end if;

                tol := 2*eps*abs(b) + tolerance;
                m := (c - b)/2;

                if abs(m) <= tol or fb == 0.0 then
                  // root found (interval is small enough)
                  found := true;
                  u := b;
                else
                  // Determine if a bisection is needed
                  if abs(e) < tol or abs(fa) <= abs(fb) then
                    e := m;
                    d := e;
                  else
                    s := fb/fa;
                    if a == c then
                      // linear interpolation
                      p := 2*m*s;
                      q := 1 - s;
                    else
                      // inverse quadratic interpolation
                      q := fa/fc;
                      r := fb/fc;
                      p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                      q := (q - 1)*(r - 1)*(s - 1);
                    end if;

                    if p > 0 then
                      q := -q;
                    else
                      p := -p;
                    end if;

                    s := e;
                    e := d;
                    if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                      // interpolation successful
                      d := p/q;
                    else
                      // use bi-section
                      e := m;
                      d := e;
                    end if;
                  end if;

                  // Best guess value is defined as "a"
                  a := b;
                  fa := fb;
                  b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
                  fb := residue(aa,bb,ww,b);

                  if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
                    // initialize variables
                    c := a;
                    fc := fa;
                    e := b - a;
                    d := e;
                  end if;
                end if;
              end while;

              annotation (Documentation(info="<html>

<p>
This function determines the solution of <strong>one non-linear algebraic equation</strong> \"y=f(u)\"
in <strong>one unknown</strong> \"u\" in a reliable way. It is one of the best numerical
algorithms for this purpose. As input, the nonlinear function f(u)
has to be given, as well as an interval u_min, u_max that
contains the solution, i.e., \"f(u_min)\" and \"f(u_max)\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <strong>Algorithms for Minimization without derivatives</strong>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>

</html>"));
            end solveOneNonlinearEquation;

            algorithm
              assert( a^2/4 - b <= 0,  "Band pass transformation cannot be computed");
              z :=solveOneNonlinearEquation(a, b, w, 0, 1);
              alpha := sqrt(z);

              annotation (Documentation(info="<html>
<p>
A band pass with bandwidth \"w\" is determined from a low pass
</p>

<pre>
  1/(p^2 + a*p + b)
</pre>

<p>
with the transformation
</p>

<pre>
  new(p) = (p + 1/p)/w
</pre>

<p>
This results in the following derivation:
</p>

<pre>
  1/(p^2 + a*p + b) -> 1/( (p+1/p)^2/w^2 + a*(p + 1/p)/w + b )
                     = 1 /( ( p^2 + 1/p^2 + 2)/w^2 + (p + 1/p)*a/w + b )
                     = w^2*p^2 / (p^4 + 2*p^2 + 1 + (p^3 + p)a*w + b*w^2*p^2)
                     = w^2*p^2 / (p^4 + a*w*p^3 + (2+b*w^2)*p^2 + a*w*p + 1)
</pre>

<p>
This 4th order transfer function shall be split in to two transfer functions of order 2 each
for numerical reasons. With the following formulation, the fourth order
polynomial can be represented (with the unknowns \"c\" and \"alpha\"):
</p>

<pre>
  g(p) = w^2*p^2 / ( (p*alpha)^2 + c*(p*alpha) + 1) * ( (p/alpha)^2 + c*(p/alpha) + 1)
       = w^2*p^2 / ( p^4 + c*(alpha + 1/alpha)*p^3 + (alpha^2 + 1/alpha^2 + c^2)*p^2
                                                   + c*(alpha + 1/alpha)*p + 1 )
</pre>

<p>
Comparison of coefficients:
</p>

<pre>
  c*(alpha + 1/alpha) = a*w           -> c = a*w / (alpha + 1/alpha)
  alpha^2 + 1/alpha^2 + c^2 = 2+b*w^2 -> equation to determine alpha

  alpha^4 + 1 + a^2*w^2*alpha^4/(1+alpha^2)^2 = (2+b*w^2)*alpha^2
    or z = alpha^2
  z^2 + a^2*w^2*z^2/(1+z)^2 - (2+b*w^2)*z + 1 = 0
</pre>

<p>
Therefore the last equation has to be solved for \"z\" (basically, this means to compute
a real zero of a fourth order polynomial):
</p>

<pre>
   solve: 0 = f(z)  = z^2 + a^2*w^2*z^2/(1+z)^2 - (2+b*w^2)*z + 1  for \"z\"
              f(0)  = 1  &gt; 0
              f(1)  = 1 + a^2*w^2/4 - (2+b*w^2) + 1
                    = (a^2/4 - b)*w^2  &lt; 0
                    // since b - a^2/4 > 0 requirement for complex conjugate poles
   -> 0 &lt; z &lt; 1
</pre>

<p>
This function computes the solution of this equation and returns \"alpha = sqrt(z)\";
</p>

</html>"));
            end bandPassAlpha;
          end Utilities;
        end Filter;
      end Internal;
      annotation (
        Documentation(info="<html>
<p>
This package contains basic <strong>continuous</strong> input/output blocks
described by differential equations.
</p>

<p>
All blocks of this package can be initialized in different
ways controlled by parameter <strong>initType</strong>. The possible
values of initType are defined in
<a href=\"modelica://Modelica.Blocks.Types.Init\">Modelica.Blocks.Types.Init</a>:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Name</strong></td>
      <td><strong>Description</strong></td></tr>

  <tr><td><strong>Init.NoInit</strong></td>
      <td>no initialization (start values are used as guess values with fixed=false)</td></tr>

  <tr><td><strong>Init.SteadyState</strong></td>
      <td>steady state initialization (derivatives of states are zero)</td></tr>

  <tr><td><strong>Init.InitialState</strong></td>
      <td>Initialization with initial states</td></tr>

  <tr><td><strong>Init.InitialOutput</strong></td>
      <td>Initialization with initial outputs (and steady state of the states if possible)</td></tr>
</table>

<p>
For backward compatibility reasons the default of all blocks is
<strong>Init.NoInit</strong>, with the exception of Integrator and LimIntegrator
where the default is <strong>Init.InitialState</strong> (this was the initialization
defined in version 2.2 of the Modelica standard library).
</p>

<p>
In many cases, the most useful initial condition is
<strong>Init.SteadyState</strong> because initial transients are then no longer
present. The drawback is that in combination with a non-linear
plant, non-linear algebraic equations occur that might be
difficult to solve if appropriate guess values for the
iteration variables are not provided (i.e., start values with fixed=false).
However, it is often already useful to just initialize
the linear blocks from the Continuous blocks library in SteadyState.
This is uncritical, because only linear algebraic equations occur.
If Init.NoInit is set, then the start values for the states are
interpreted as <strong>guess</strong> values and are propagated to the
states with fixed=<strong>false</strong>.
</p>

<p>
Note, initialization with Init.SteadyState is usually difficult
for a block that contains an integrator
(Integrator, LimIntegrator, PI, PID, LimPID).
This is due to the basic equation of an integrator:
</p>

<pre>
  <strong>initial equation</strong>
     <strong>der</strong>(y) = 0;   // Init.SteadyState
  <strong>equation</strong>
     <strong>der</strong>(y) = k*u;
</pre>

<p>
The steady state equation leads to the condition that the input to the
integrator is zero. If the input u is already (directly or indirectly) defined
by another initial condition, then the initialization problem is <strong>singular</strong>
(has none or infinitely many solutions). This situation occurs often
for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
since speed is both a state and a derivative, it is always defined by
Init.InitialState or Init.SteadyState initialization.
</p>

<p>
In such a case, <strong>Init.NoInit</strong> has to be selected for the integrator
and an additional initial equation has to be added to the system
to which the integrator is connected. E.g., useful initial conditions
for a 1-dim. rotational inertia controlled by a PI controller are that
<strong>angle</strong>, <strong>speed</strong>, and <strong>acceleration</strong> of the inertia are zero.
</p>

</html>"),     Icon(graphics={Line(
              origin={0.061,4.184},
              points={{81.939,36.056},{65.362,36.056},{14.39,-26.199},{-29.966,
                  113.485},{-65.374,-61.217},{-78.061,-78.184}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Continuous;

    package Interfaces
    "Library of connectors and partial models for input/output blocks"
      import Modelica.SIunits;
      extends Modelica.Icons.InterfacesPackage;

      connector RealInput = input Real "'input Real' as connector" annotation (
        defaultComponentName="u",
        Icon(graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})},
          coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{0.0,50.0},{100.0,0.0},{0.0,-50.0},{0.0,50.0}}),
          Text(
            lineColor={0,0,127},
            extent={{-10.0,60.0},{-10.0,85.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>"));

      connector RealOutput = output Real "'output Real' as connector" annotation (
        defaultComponentName="y",
        Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})}),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,50.0},{0.0,0.0},{-100.0,-50.0}}),
          Text(
            lineColor={0,0,127},
            extent={{30.0,60.0},{30.0,110.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>"));

      connector BooleanInput = input Boolean "'input Boolean' as connector"
        annotation (
        defaultComponentName="u",
        Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>"));

      connector BooleanOutput = output Boolean "'output Boolean' as connector"
        annotation (
        defaultComponentName="y",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              lineColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>"));

      connector IntegerInput = input Integer "'input Integer' as connector"
        annotation (
        defaultComponentName="u",
        Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Integer.
</p>
</html>"));

      connector IntegerOutput = output Integer "'output Integer' as connector"
        annotation (
        defaultComponentName="y",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              lineColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Integer.
</p>
</html>"));

      connector BooleanVectorInput = input Boolean
        "Boolean input connector used for vector of connectors" annotation (
        defaultComponentName="u",
        Icon(graphics={Ellipse(
              extent={{-100,-100},{100,100}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=false,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,0,255},
              textString="%name"), Ellipse(
              extent={{-50,50},{50,-50}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Boolean input connector that is used for a vector of connectors,
for example <a href=\"modelica://Modelica.Blocks.Interfaces.PartialBooleanMISO\">PartialBooleanMISO</a>,
and has therefore a different icon as BooleanInput connector.
</p>
</html>"));

      partial block SO "Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real output signal.
</p>
</html>"));

      end SO;

      partial block SISO "Single Input Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real input and one continuous Real output signal.
</p>
</html>"));
      end SISO;

      partial block SI2SO
        "2 Single Input / 1 Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u1 "Connector of Real input signal 1" annotation (Placement(
              transformation(extent={{-140,40},{-100,80}})));
        RealInput u2 "Connector of Real input signal 2" annotation (Placement(
              transformation(extent={{-140,-80},{-100,-40}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p>
Block has two continuous Real input signals u1 and u2 and one
continuous Real output signal y.
</p>
</html>"));

      end SI2SO;

      partial block SIMO "Single Input Multiple Output continuous control block"
        extends Modelica.Blocks.Icons.Block;
        parameter Integer nout=1 "Number of outputs";
        RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y[nout] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p> Block has one continuous Real input signal and a
    vector of continuous Real output signals.</p>

</html>"));
      end SIMO;

      partial block MISO "Multiple Input Single Output continuous control block"

        extends Modelica.Blocks.Icons.Block;
        parameter Integer nin=1 "Number of inputs";
        RealInput u[nin] "Connector of Real input signals" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has a vector of continuous Real input signals and
one continuous Real output signal.
</p>
</html>"));
      end MISO;

      partial block MIMOs
        "Multiple Input Multiple Output continuous control block with same number of inputs and outputs"

        extends Modelica.Blocks.Icons.Block;
        parameter Integer n=1 "Number of inputs (= number of outputs)";
        RealInput u[n] "Connector of Real input signals" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y[n] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has a continuous Real input and a continuous Real output signal vector
where the signal sizes of the input and output vector are identical.
</p>
</html>"));
      end MIMOs;

      partial block SVcontrol "Single-Variable continuous controller"
        extends Modelica.Blocks.Icons.Block;

        RealInput u_s "Connector of setpoint input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealInput u_m "Connector of measurement input signal" annotation (Placement(
              transformation(
              origin={0,-120},
              extent={{20,-20},{-20,20}},
              rotation=270)));
        RealOutput y "Connector of actuator output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Text(
                  extent={{-102,34},{-142,24}},
                  textString="(setpoint)",
                  lineColor={0,0,255}),Text(
                  extent={{100,24},{140,14}},
                  textString="(actuator)",
                  lineColor={0,0,255}),Text(
                  extent={{-83,-112},{-33,-102}},
                  textString=" (measurement)",
                  lineColor={0,0,255})}), Documentation(info="<html>
<p>
Block has two continuous Real input signals and one
continuous Real output signal. The block is designed
to be used as base class for a corresponding controller.
</p>
</html>"));
      end SVcontrol;

      partial block partialBooleanSI "Partial block with 1 input Boolean signal"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;

        Blocks.Interfaces.BooleanInput u "Connector of Boolean input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Ellipse(
                extent={{-71,7},{-85,-7}},
                lineColor=DynamicSelect({235,235,235}, if u > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if u > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
Block has one continuous Boolean input signal
with a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanSI;

      partial block partialBooleanThresholdComparison
        "Partial block to compare the Real input u with a threshold and provide the result as 1 Boolean output signal"

        parameter Real threshold=0 "Comparison with respect to threshold";

        Blocks.Interfaces.RealInput u "Connector of Real input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-150,-140},{150,-110}},
                textString="%threshold"),
              Ellipse(
                extent={{71,7},{85,-7}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid),      Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),           Documentation(info="<html>
<p>
Block has one continuous Real input and one continuous Boolean output signal
as well as a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanThresholdComparison;

      partial block PartialBooleanSISO_small
        "Partial block with a BooleanInput and a BooleanOutput signal and a small block icon"

        Modelica.Blocks.Interfaces.BooleanInput u "Boolean input signal"
          annotation (Placement(transformation(extent={{-180,-40},{-100,40}})));
        Modelica.Blocks.Interfaces.BooleanOutput y "Boolean output signal"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));
        annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.04), graphics={
              Text(
                extent={{-300,200},{300,120}},
                textString="%name",
                lineColor={0,0,255}),
              Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Ellipse(
                extent={{60,10},{80,-10}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}));
      end PartialBooleanSISO_small;

      partial block PartialBooleanMISO
        "Partial block with a BooleanVectorInput and a BooleanOutput signal"

        parameter Integer nu(min=0) = 0 "Number of input connections"
          annotation (Dialog(connectorSizing=true), HideResult=true);
        Modelica.Blocks.Interfaces.BooleanVectorInput u[nu]
          "Vector of Boolean input signals"
          annotation (Placement(transformation(extent={{-120,70},{-80,-70}})));
        Modelica.Blocks.Interfaces.BooleanOutput y "Boolean output signal"
          annotation (Placement(transformation(extent={{100,-15},{130,15}})));
        annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.06), graphics={
              Text(
                extent={{-250,170},{250,110}},
                textString="%name",
                lineColor={0,0,255}),
              Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Ellipse(
                extent={{60,10},{80,-10}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}));
      end PartialBooleanMISO;

      partial block PartialConversionBlock
        "Partial block defining the interface for conversion blocks"

        RealInput u "Connector of Real input signal to be converted" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y
          "Connector of Real output signal containing input signal u in another unit"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        annotation (
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Rectangle(
              lineColor={0,0,127},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-100.0},{100.0,100.0}}),
            Line(
              points={{-90.0,0.0},{30.0,0.0}},
              color={191,0,0}),
            Polygon(
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid,
              points={{90.0,0.0},{30.0,20.0},{30.0,-20.0},{90.0,0.0}}),
            Text(
              lineColor={0,0,255},
              extent={{-150,110},{150,150}},
              textString="%name")}), Documentation(info="<html>
<p>
This block defines the interface of a conversion block that
converts from one unit into another one.
</p>

</html>"));

      end PartialConversionBlock;

      partial block BlockIcon
        "This icon will be removed in future Modelica versions, use Modelica.Blocks.Icons.Block instead."
        extends Modelica.Icons.ObsoleteModel;

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
This icon will be removed in future versions of the Modelica Standard Library.
Instead the icon <a href=\"modelica://Modelica.Blocks.Icons.Block\">Modelica.Blocks.Icons.Block</a> shall be used.
</p>
</html>"),
        obsolete = "Obsolete block - use Modelica.Blocks.Icons.Block instead");
      end BlockIcon;
      annotation (Documentation(info="<html>
<p>
This package contains interface definitions for
<strong>continuous</strong> input/output blocks with Real,
Integer and Boolean signals. Furthermore, it contains
partial models for continuous and discrete blocks.
</p>

</html>",     revisions="<html>
<ul>
<li><em>Oct. 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Added several new interfaces.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       RealInputSignal renamed to RealInput. RealOutputSignal renamed to
       output RealOutput. GraphBlock renamed to BlockIcon. SISOreal renamed to
       SISO. SOreal renamed to SO. I2SOreal renamed to M2SO.
       SignalGenerator renamed to SignalSource. Introduced the following
       new models: MIMO, MIMOs, SVcontrol, MVcontrol, DiscreteBlockIcon,
       DiscreteBlock, DiscreteSISO, DiscreteMIMO, DiscreteMIMOs,
       BooleanBlockIcon, BooleanSISO, BooleanSignalSource, MI2BooleanMOs.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Interfaces;

    package Logical
    "Library of components with Boolean input and output signals"
      extends Modelica.Icons.Package;

      block GreaterThreshold
        "Output y is true, if input u is greater than threshold"
        extends Blocks.Interfaces.partialBooleanThresholdComparison;
      equation
        y = u > threshold;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(
                points={{-54,20},{-8,0},{-54,-20}},
                thickness=0.5)}), Documentation(info="<html>
<p>
The output is <strong>true</strong> if the Real input is greater than
parameter <strong>threshold</strong>, otherwise
the output is <strong>false</strong>.
</p>
</html>"));
      end GreaterThreshold;

      block Switch "Switch between two Real signals"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        Blocks.Interfaces.RealInput u1 "Connector of first Real input signal"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Blocks.Interfaces.BooleanInput u2 "Connector of Boolean input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Blocks.Interfaces.RealInput u3 "Connector of second Real input signal"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Blocks.Interfaces.RealOutput y "Connector of Real output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = if u2 then u1 else u3;
        annotation (
          defaultComponentName="switch1",
          Documentation(info="<html>
<p>The Logical.Switch switches, depending on the
logical connector u2 (the middle connector)
between the two possible input signals
u1 (upper connector) and u3 (lower connector).</p>
<p>If u2 is <strong>true</strong>, the output signal y is set equal to
u1, else it is set equal to u3.</p>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{12,0},{100,0}},
                color={0,0,127}),
              Line(points={{-100,0},{-40,0}},
                color={255,0,255}),
              Line(points={{-100,-80},{-40,-80},{-40,-80}},
                color={0,0,127}),
              Line(points={{-40,12},{-40,-12}},
                color={255,0,255}),
              Line(points={{-100,80},{-38,80}},
                color={0,0,127}),
              Line(points=DynamicSelect({{-38,80},{6,2}}, if u2 then {{-38,80},{6,2}} else {{-38,-80},{6,2}}),
                color={0,0,127},
                thickness=1),
              Ellipse(lineColor={0,0,255},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{2,-8},{18,8}})}));
      end Switch;

      block Hysteresis "Transform Real to Boolean signal with Hysteresis"

        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        parameter Real uLow(start=0) "if y=true and u<=uLow, switch to y=false";
        parameter Real uHigh(start=1) "if y=false and u>=uHigh, switch to y=true";
        parameter Boolean pre_y_start=false "Value of pre(y) at initial time";

        Blocks.Interfaces.RealInput u annotation (Placement(transformation(extent={
                  {-140,-20},{-100,20}})));
        Blocks.Interfaces.BooleanOutput y annotation (Placement(transformation(
                extent={{100,-10},{120,10}})));

      initial equation
        pre(y) = pre_y_start;
      equation
        assert(uHigh > uLow,"Hysteresis limits wrong (uHigh <= uLow)");
        y = not pre(y) and u > uHigh or pre(y) and u >= uLow;
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Polygon(
                  points={{-65,89},{-73,67},{-57,67},{-65,89}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),Line(points={{-65,67},{-65,-81}},
                color={192,192,192}),Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
                Polygon(
                  points={{90,-70},{68,-62},{68,-78},{90,-70}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{70,-80},{94,-100}},
                  lineColor={160,160,164},
                  textString="u"),Text(
                  extent={{-65,93},{-12,75}},
                  lineColor={160,160,164},
                  textString="y"),Line(
                  points={{-80,-70},{30,-70}},
                  thickness=0.5),Line(
                  points={{-50,10},{80,10}},
                  thickness=0.5),Line(
                  points={{-50,10},{-50,-70}},
                  thickness=0.5),Line(
                  points={{30,10},{30,-70}},
                  thickness=0.5),Line(
                  points={{-10,-65},{0,-70},{-10,-75}},
                  thickness=0.5),Line(
                  points={{-10,15},{-20,10},{-10,5}},
                  thickness=0.5),Line(
                  points={{-55,-20},{-50,-30},{-44,-20}},
                  thickness=0.5),Line(
                  points={{25,-30},{30,-19},{35,-30}},
                  thickness=0.5),Text(
                  extent={{-99,2},{-70,18}},
                  lineColor={160,160,164},
                  textString="true"),Text(
                  extent={{-98,-87},{-66,-73}},
                  lineColor={160,160,164},
                  textString="false"),Text(
                  extent={{19,-87},{44,-70}},
                  textString="uHigh"),Text(
                  extent={{-63,-88},{-38,-71}},
                  textString="uLow"),Line(points={{-69,10},{-60,10}}, color={160,
                160,164})}),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-29}}, color={192,192,192}),
              Polygon(
                points={{92,-29},{70,-21},{70,-37},{92,-29}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-79,-29},{84,-29}}, color={192,192,192}),
              Line(points={{-79,-29},{41,-29}}),
              Line(points={{-15,-21},{1,-29},{-15,-36}}),
              Line(points={{41,51},{41,-29}}),
              Line(points={{33,3},{41,22},{50,3}}),
              Line(points={{-49,51},{81,51}}),
              Line(points={{-4,59},{-19,51},{-4,43}}),
              Line(points={{-59,29},{-49,11},{-39,29}}),
              Line(points={{-49,51},{-49,-29}}),
              Text(
                extent={{-92,-49},{-9,-92}},
                lineColor={192,192,192},
                textString="%uLow"),
              Text(
                extent={{2,-49},{91,-92}},
                lineColor={192,192,192},
                textString="%uHigh"),
              Rectangle(extent={{-91,-49},{-8,-92}}, lineColor={192,192,192}),
              Line(points={{-49,-29},{-49,-49}}, color={192,192,192}),
              Rectangle(extent={{2,-49},{91,-92}}, lineColor={192,192,192}),
              Line(points={{41,-29},{41,-49}}, color={192,192,192})}),
          Documentation(info="<html>
<p>
This block transforms a <strong>Real</strong> input signal into a <strong>Boolean</strong>
output signal:
</p>
<ul>
<li> When the output was <strong>false</strong> and the input becomes
     <strong>greater</strong> than parameter <strong>uHigh</strong>, the output
     switches to <strong>true</strong>.</li>
<li> When the output was <strong>true</strong> and the input becomes
     <strong>less</strong> than parameter <strong>uLow</strong>, the output
     switches to <strong>false</strong>.</li>
</ul>
<p>
The start value of the output is defined via parameter
<strong>pre_y_start</strong> (= value of pre(y) at initial time).
The default value of this parameter is <strong>false</strong>.
</p>
</html>"));
      end Hysteresis;

      block OnOffController "On-off controller"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        Blocks.Interfaces.RealInput reference
          "Connector of Real input signal used as reference signal" annotation (
            Placement(transformation(extent={{-140,80},{-100,40}})));
        Blocks.Interfaces.RealInput u
          "Connector of Real input signal used as measurement signal" annotation (
            Placement(transformation(extent={{-140,-40},{-100,-80}})));
        Blocks.Interfaces.BooleanOutput y
          "Connector of Real output signal used as actuator signal" annotation (
            Placement(transformation(extent={{100,-10},{120,10}})));

        parameter Real bandwidth(start=0.1) "Bandwidth around reference signal";
        parameter Boolean pre_y_start=false "Value of pre(y) at initial time";

      initial equation
        pre(y) = pre_y_start;
      equation
        y = pre(y) and (u < reference + bandwidth/2) or (u < reference - bandwidth/
          2);
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Text(
                extent={{-92,74},{44,44}},
                textString="reference"),
              Text(
                extent={{-94,-52},{-34,-74}},
                textString="u"),
              Line(points={{-76,-32},{-68,-6},{-50,26},{-24,40},{-2,42},{16,36},{32,28},{48,12},{58,-6},{68,-28}},
                color={0,0,127}),
              Line(points={{-78,-2},{-6,18},{82,-12}},
                color={255,0,0}),
              Line(points={{-78,12},{-6,30},{82,0}}),
              Line(points={{-78,-16},{-6,4},{82,-26}}),
              Line(points={{-82,-18},{-56,-18},{-56,-40},{64,-40},{64,-20},{90,-20}},
                color={255,0,255})}), Documentation(info="<html>
<p>The block OnOffController sets the output signal <strong>y</strong> to <strong>true</strong> when
the input signal <strong>u</strong> falls below the <strong>reference</strong> signal minus half of
the bandwidth and sets the output signal <strong>y</strong> to <strong>false</strong> when the input
signal <strong>u</strong> exceeds the <strong>reference</strong> signal plus half of the bandwidth.</p>
</html>"));
      end OnOffController;
      annotation (Documentation(info="<html>
<p>
This package provides blocks with Boolean input and output signals
to describe logical networks. A typical example for a logical
network built with package Logical is shown in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/LogicalNetwork1.png\"
     alt=\"LogicalNetwork1.png\">
</p>

<p>
The actual value of Boolean input and/or output signals is displayed
in the respective block icon as \"circle\", where \"white\" color means
value <strong>false</strong> and \"green\" color means value <strong>true</strong>. These
values are visualized in a diagram animation.
</p>
</html>"),     Icon(graphics={Line(
              points={{-86,-22},{-50,-22},{-50,22},{48,22},{48,-22},{88,-24}},
              color={255,0,255})}));
    end Logical;

    package Math
    "Library of Real mathematical functions as input/output blocks"
      import Modelica.SIunits;
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

      encapsulated package UnitConversions
      "Conversion blocks to convert between SI and non-SI unit signals"
        import Modelica;
        import SI = Modelica.SIunits;
        import NonSI = Modelica.SIunits.Conversions.NonSIunits;
        extends Modelica.Icons.Package;

        block From_degC "Convert from degCelsius to Kelvin"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="degC"),
              y(unit="K"));
        equation
          y = SI.Conversions.from_degC(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                      extent={{-20,100},{-100,20}},
                      textString="degC"),Text(
                      extent={{100,-20},{20,-100}},
                      textString="K")}), Documentation(info="<html>
<p>
This block converts the input signal from degCelsius to Kelvin and returns
the result as output signal.
</p>
</html>"));
        end From_degC;

        block From_deg "Convert from degree to radian"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="deg"),
              y(unit="rad"));
        equation
          y = SI.Conversions.from_deg(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                      extent={{-20,100},{-100,20}},
                      textString="deg"),Text(
                      extent={{100,-20},{20,-100}},
                      textString="rad")}), Documentation(info="<html>
<p>
This block converts the input signal from degree to radian and returns
the result as output signal.
</p>
</html>"));
        end From_deg;
        annotation (Documentation(info="<html>
<p>
This package consists of blocks that convert an input signal
with a specific unit to an output signal in another unit
(e.g., conversion of an angle signal from \"deg\" to \"rad\").
</p>

</html>"));
      end UnitConversions;

      block Gain "Output the product of a gain value with the input signal"

        parameter Real k(start=1, unit="1")
          "Gain value multiplied with input signal";
    public
        Interfaces.RealInput u "Input signal connector" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealOutput y "Output signal connector" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

      equation
        y = k*u;
        annotation (
          Documentation(info="<html>
<p>
This block computes output <em>y</em> as
<em>product</em> of gain <em>k</em> with the
input <em>u</em>:
</p>
<pre>
    y = k * u;
</pre>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,-140},{150,-100}},
                textString="k=%k"),
              Text(
                extent={{-150,140},{150,100}},
                textString="%name",
                lineColor={0,0,255})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Polygon(
                  points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{-76,38},{0,-34}},
                  textString="k",
                  lineColor={0,0,255})}));
      end Gain;

      block Sum "Output the sum of the elements of the input vector"
        extends Interfaces.MISO;
        parameter Real k[nin]=ones(nin) "Optional: sum coefficients";
      equation
        y = k*u;
        annotation (
          defaultComponentName="sum1",
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as
<em>sum</em> of the elements of the input signal vector
<strong>u</strong>:
</p>
<pre>
    <strong>y</strong> = <strong>u</strong>[1] + <strong>u</strong>[2] + ...;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   nin = 3;

  results in the following equations:

     y = u[1] + u[2] + u[3];
</pre>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Line(
                points={{26,42},{-34,42},{6,2},{-34,-38},{26,-38}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(
                  points={{26,42},{-34,42},{6,2},{-34,-38},{26,-38}})}));
      end Sum;

      block Add "Output the sum of the two inputs"
        extends Interfaces.SI2SO;

        parameter Real k1=+1 "Gain of input signal 1";
        parameter Real k2=+1 "Gain of input signal 2";

      equation
        y = k1*u1 + k2*u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>sum</em> of the
two input signals <strong>u1</strong> and <strong>u2</strong>:
</p>
<pre>
    <strong>y</strong> = k1*<strong>u1</strong> + k2*<strong>u2</strong>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   k1= +2, k2= -3

  results in the following equations:

     y = 2 * u1 - 3 * u2
</pre>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,60},{-74,24},{-44,24}}, color={0,0,127}),
              Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={0,0,127}),
              Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Text(extent={{-38,-34},{38,34}}, textString="+"),
              Text(extent={{-100,52},{5,92}}, textString="%k1"),
              Text(extent={{-100,-92},{5,-52}}, textString="%k2")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(points={{50,0},{100,0}},
                color={0,0,255}),Line(points={{-100,60},{-74,24},{-44,24}}, color={
                0,0,127}),Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={0,0,127}),
                Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,127}),Line(
                points={{50,0},{100,0}}, color={0,0,127}),Text(
                  extent={{-36,38},{40,-30}},
                  textString="+"),Text(
                  extent={{-100,52},{5,92}},
                  textString="k1"),Text(
                  extent={{-100,-52},{5,-92}},
                  textString="k2")}));
      end Add;

      block Add3 "Output the sum of the three inputs"
        extends Modelica.Blocks.Icons.Block;

        parameter Real k1=+1 "Gain of input signal 1";
        parameter Real k2=+1 "Gain of input signal 2";
        parameter Real k3=+1 "Gain of input signal 3";
        Interfaces.RealInput u1 "Connector of Real input signal 1" annotation (
            Placement(transformation(extent={{-140,60},{-100,100}})));
        Interfaces.RealInput u2 "Connector of Real input signal 2" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealInput u3 "Connector of Real input signal 3" annotation (
            Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Interfaces.RealOutput y "Connector of Real output signal" annotation (
            Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = k1*u1 + k2*u2 + k3*u3;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>sum</em> of the
three input signals <strong>u1</strong>, <strong>u2</strong> and <strong>u3</strong>:
</p>
<pre>
    <strong>y</strong> = k1*<strong>u1</strong> + k2*<strong>u2</strong> + k3*<strong>u3</strong>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   k1= +2, k2= -3, k3=1;

  results in the following equations:

     y = 2 * u1 - 3 * u2 + u3;
</pre>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-100,50},{5,90}},
                textString="%k1"),
              Text(
                extent={{-100,-20},{5,20}},
                textString="%k2"),
              Text(
                extent={{-100,-50},{5,-90}},
                textString="%k3"),
              Text(
                extent={{2,36},{100,-44}},
                textString="+")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{-100,50},{5,90}},
                  textString="k1"),Text(
                  extent={{-100,-20},{5,20}},
                  textString="k2"),Text(
                  extent={{-100,-50},{5,-90}},
                  textString="k3"),Text(
                  extent={{2,46},{100,-34}},
                  textString="+")}));
      end Add3;

      block Product "Output product of the two inputs"
        extends Interfaces.SI2SO;

      equation
        y = u1*u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes the output <strong>y</strong>
as <em>product</em> of the two inputs <strong>u1</strong> and <strong>u2</strong>:
</p>
<pre>
    y = u1 * u2;
</pre>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,127}),
              Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,127}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Line(points={{-30,0},{30,0}}),
              Line(points={{-15,25.99},{15,-25.99}}),
              Line(points={{-15,-25.99},{15,25.99}}),
              Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(points={{-100,60},{-40,60},{-30,
                40}}, color={0,0,255}),Line(points={{-100,-60},{-40,-60},{-30,-40}},
                color={0,0,255}),Line(points={{50,0},{100,0}}, color={0,0,255}),
                Line(points={{-30,0},{30,0}}),Line(points={{-15,
                25.99},{15,-25.99}}),Line(points={{-15,-25.99},{15,
                25.99}}),Ellipse(extent={{-50,50},{50,-50}},
                lineColor={0,0,255})}));
      end Product;

      block IntegerToReal "Convert Integer to Real signals"
        extends Modelica.Blocks.Icons.Block;
        Interfaces.IntegerInput u "Connector of Integer input signal" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealOutput y "Connector of Real output signal" annotation (
            Placement(transformation(extent={{100,-10},{120,10}})));
      equation
        y = u;
        annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
              Text(
                lineColor={255,127,0},
                extent={{-120.0,-40.0},{-20.0,40.0}},
                textString="I"),
              Text(
                lineColor={0,0,127},
                extent={{0.0,-40.0},{100.0,40.0}},
                textString="R"),
              Polygon(
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                points={{10.0,0.0},{-10.0,20.0},{-10.0,10.0},{-40.0,10.0},{-40.0,-10.0},
                    {-10.0,-10.0},{-10.0,-20.0},{10.0,0.0}})}), Documentation(info="<html>
<p>
This block computes the output <strong>y</strong>
as <em>Real equivalent</em> of the Integer input <strong>u</strong>:
</p>
<pre>    y = u;
</pre>
<p>where <strong>u</strong> is of Integer and <strong>y</strong> of Real type.</p>
</html>"));
      end IntegerToReal;

      block BooleanToReal "Convert Boolean to Real signal"
        extends Interfaces.partialBooleanSI;
        parameter Real realTrue=1.0 "Output signal for true Boolean input";
        parameter Real realFalse=0.0 "Output signal for false Boolean input";

        Blocks.Interfaces.RealOutput y "Connector of Real output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = if u then realTrue else realFalse;
        annotation (Documentation(info="<html>
<p>
This block computes the output <strong>y</strong>
as <em>Real equivalent</em> of the Boolean input <strong>u</strong>:
</p>
<pre>    y = <strong>if</strong> u <strong>then</strong> realTrue <strong>else</strong> realFalse;
</pre>
<p>where <strong>u</strong> is of Boolean and <strong>y</strong> of Real type,
and <strong>realTrue</strong> and <strong>realFalse</strong> are parameters.
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Text(
                extent={{-86,92},{-6,10}},
                lineColor={255,0,255},
                textString="B"),
              Polygon(
                points={{-12,-46},{-32,-26},{-32,-36},{-64,-36},{-64,-56},{-32,-56},
                    {-32,-66},{-12,-46}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Text(
                extent={{8,-4},{92,-94}},
                textString="R",
                lineColor={0,0,127})}));
      end BooleanToReal;

      block BooleanToInteger "Convert Boolean to Integer signal"
        extends Interfaces.partialBooleanSI;
        parameter Integer integerTrue=1 "Output signal for true Boolean input";
        parameter Integer integerFalse=0 "Output signal for false Boolean input";

        Blocks.Interfaces.IntegerOutput y "Connector of Integer output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = if u then integerTrue else integerFalse;
        annotation (Documentation(info="<html>
<p>
This block computes the output <strong>y</strong>
as <em>Integer equivalent</em> of the Boolean input <strong>u</strong>:
</p>
<pre>    y = <strong>if</strong> u <strong>then</strong> integerTrue <strong>else</strong> integerFalse;
</pre>
<p>where <strong>u</strong> is of Boolean and <strong>y</strong> of Integer type,
and <strong>integerTrue</strong> and <strong>integerFalse</strong> are parameters.
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Text(
                extent={{-86,92},{-6,10}},
                lineColor={255,0,255},
                textString="B"),
              Polygon(
                points={{-12,-46},{-32,-26},{-32,-36},{-64,-36},{-64,-56},{-32,-56},
                    {-32,-66},{-12,-46}},
                lineColor={255,170,85},
                fillColor={255,170,85},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{8,-4},{92,-94}},
                lineColor={255,170,85},
                textString="I")}));
      end BooleanToInteger;
      annotation (Documentation(info="<html>
<p>
This package contains basic <strong>mathematical operations</strong>,
such as summation and multiplication, and basic <strong>mathematical
functions</strong>, such as <strong>sqrt</strong> and <strong>sin</strong>, as
input/output blocks. All blocks of this library can be either
connected with continuous blocks or with sampled-data blocks.
</p>
</html>",     revisions="<html>
<ul>
<li><em>August 24, 2016</em>
       by Christian Kral: added WrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New blocks added: RealToInteger, IntegerToReal, Max, Min, Edge, BooleanChange, IntegerChange.</li>
<li><em>August 7, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized (partly based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist).
</li>
</ul>
</html>"),     Icon(graphics={Line(
              points={{-80,-2},{-68.7,32.2},{-61.5,51.1},{-55.1,64.4},{-49.4,72.6},
                  {-43.8,77.1},{-38.2,77.8},{-32.6,74.6},{-26.9,67.7},{-21.3,57.4},
                  {-14.9,42.1},{-6.83,19.2},{10.1,-32.8},{17.3,-52.2},{23.7,-66.2},
                  {29.3,-75.1},{35,-80.4},{40.6,-82},{46.2,-79.6},{51.9,-73.5},{
                  57.5,-63.9},{63.9,-49.2},{72,-26.8},{80,-2}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Math;

    package MathBoolean
    "Library of Boolean mathematical functions as input/output blocks"
      extends Modelica.Icons.Package;

      block And "Logical 'and': y = u[1] and u[2] and ... and u[nu]"
        extends Modelica.Blocks.Interfaces.PartialBooleanMISO;

      equation
        y = Modelica.Math.BooleanVectors.allTrue(
                                  u);
        annotation (defaultComponentName="and1", Icon(graphics={Text(
                  extent={{-76,40},{60,-40}},
                  textString="and")}),
          Documentation(info="<html>
<p>
The output is <strong>true</strong> if all inputs are <strong>true</strong>, otherwise
the output is <strong>false</strong>.
</p>

<p>
The input connector is a vector of Boolean input signals.
When a connection line is drawn, the dimension of the input
vector is enlarged by one and the connection is automatically
connected to this new free index (thanks to the
connectorSizing annotation).
</p>

<p>
The usage is demonstrated, e.g., in example
<a href=\"modelica://Modelica.Blocks.Examples.BooleanNetwork1\">Modelica.Blocks.Examples.BooleanNetwork1</a>.
</p>

<p>
If no connection to the input connector \"u\" is present,
the output is set to <strong>false</strong>: y=false.
</p>
</html>"));
      end And;

      block Not "Logical 'not': y = not u"
        extends Modelica.Blocks.Interfaces.PartialBooleanSISO_small;

      equation
        y = not u;
        annotation (defaultComponentName="not1", Icon(graphics={Text(
                  extent={{-98,40},{42,-40}},
                  textString="not")}),
          Documentation(info="<html>
<p>
The output is <strong>false</strong> if at least one input is <strong>true</strong>, otherwise
the output is <strong>true</strong>.
</p>

<p>
The input connector is a vector of Boolean input signals.
When a connection line is drawn, the dimension of the input
vector is enlarged by one and the connection is automatically
connected to this new free index (thanks to the
connectorSizing annotation).
</p>

<p>
The usage is demonstrated, e.g., in example
<a href=\"modelica://Modelica.Blocks.Examples.BooleanNetwork1\">Modelica.Blocks.Examples.BooleanNetwork1</a>.
</p>
</html>"));
      end Not;
      annotation (Documentation(info="<html>
<p>
This package contains basic <strong>mathematical operations</strong>
on <strong>Boolean</strong> signals.
</p>

<p>
The new features are:
</p>

<ul>
<li> If useful, blocks may have an arbitrary number of inputs (e.g., \"And\" block with 2,3,4,...
     Boolean inputs). This is based on the \"connectorSizing\" annotation which
     allows a tool to conveniently handle vectors of connectors.</li>

<li> The blocks are smaller in size, so that the diagram area is better
     utilized for trivial blocks such as \"And\" or \"Or\".</li>

</ul>

</html>"),     Icon(graphics={Line(points={{-80,-16},{-4,-16},{-4,28},{38,28},{38,
                  -16},{66,-16}}, color={255,0,255})}));
    end MathBoolean;

    package Nonlinear
    "Library of discontinuous or non-differentiable algebraic control blocks"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

          block Limiter "Limit the range of a signal"
            parameter Real uMax(start=1) "Upper limits of input signals";
            parameter Real uMin= -uMax "Lower limits of input signals";
            parameter Boolean strict=false "= true, if strict limits with noEvent(..)"
              annotation (Evaluate=true, choices(checkBox=true), Dialog(tab="Advanced"));
            parameter Types.LimiterHomotopy homotopyType = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization"
              annotation (Evaluate=true, Dialog(group="Initialization"));
            parameter Boolean limitsAtInit=true
              "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)"
              annotation (Dialog(tab="Dummy"),Evaluate=true, choices(checkBox=true));
            extends Interfaces.SISO;
    protected
            Real simplifiedExpr "Simplified expression for homotopy-based initialization";

          equation
            assert(uMax >= uMin, "Limiter: Limits must be consistent. However, uMax (=" + String(uMax) +
                                 ") < uMin (=" + String(uMin) + ")");
            simplifiedExpr = (if homotopyType == Types.LimiterHomotopy.Linear then u
                              else if homotopyType == Types.LimiterHomotopy.UpperLimit then uMax
                              else if homotopyType == Types.LimiterHomotopy.LowerLimit then uMin
                              else 0);
            if strict then
              if homotopyType == Types.LimiterHomotopy.NoHomotopy then
                y = smooth(0, noEvent(if u > uMax then uMax else if u < uMin then uMin else u));
              else
                y = homotopy(actual = smooth(0, noEvent(if u > uMax then uMax else if u < uMin then uMin else u)),
                             simplified=simplifiedExpr);
              end if;
            else
              if homotopyType == Types.LimiterHomotopy.NoHomotopy then
                y = smooth(0,if u > uMax then uMax else if u < uMin then uMin else u);
              else
                y = homotopy(actual = smooth(0,if u > uMax then uMax else if u < uMin then uMin else u),
                             simplified=simplifiedExpr);
              end if;
            end if;
            annotation (
              Documentation(info="<html>
<p>
The Limiter block passes its input signal as output signal
as long as the input is within the specified upper and lower
limits. If this is not the case, the corresponding limits are passed
as output.
</p>
<p>
The parameter <code>homotopyType</code> in the Advanced tab specifies the
simplified behaviour if homotopy-based initialization is used:
</p>
<ul>
<li><code>NoHomotopy</code>: the actual expression with limits is used</li>
<li><code>Linear</code>: a linear behaviour y = u is assumed (default option)</li>
<li><code>UpperLimit</code>: it is assumed that the output is stuck at the upper limit u = uMax</li>
<li><code>LowerLimit</code>: it is assumed that the output is stuck at the lower limit u = uMin</li>
</ul>
<p>
If it is known a priori in which region the input signal will be located, this option can help
a lot by removing one strong nonlinearity from the initialization problem.
</p>
</html>"),     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{0,-90},{0,68}}, color={192,192,192}),
              Polygon(
                points={{0,90},{-8,68},{8,68},{0,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{68,0}}, color={192,192,192}),
              Polygon(
                points={{90,0},{68,-8},{68,8},{90,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-70},{-50,-70},{50,70},{80,70}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="uMax=%uMax"),
              Line(
                visible=strict,
                points={{50,70},{80,70}},
                color={255,0,0}),
              Line(
                visible=strict,
                points={{-80,-70},{-50,-70}},
                color={255,0,0})}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{0,-60},{0,50}}, color={192,192,192}),
              Polygon(
                points={{0,60},{-5,50},{5,50},{0,60}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-60,0},{50,0}}, color={192,192,192}),
              Polygon(
                points={{60,0},{50,-5},{50,5},{60,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-50,-40},{-30,-40},{30,40},{50,40}}),
              Text(
                extent={{46,-6},{68,-18}},
                lineColor={128,128,128},
                textString="u"),
              Text(
                extent={{-30,70},{-5,50}},
                lineColor={128,128,128},
                textString="y"),
              Text(
                extent={{-58,-54},{-28,-42}},
                lineColor={128,128,128},
                textString="uMin"),
              Text(
                extent={{26,40},{66,56}},
                lineColor={128,128,128},
                textString="uMax")}));
          end Limiter;
          annotation (
            Documentation(info="<html>
<p>
This package contains <strong>discontinuous</strong> and
<strong>non-differentiable, algebraic</strong> input/output blocks.
</p>
</html>",     revisions="<html>
<ul>
<li><em>October 21, 2002</em>
       by Christian Schweiger:<br>
       New block VariableLimiter added.</li>
<li><em>August 22, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.
</li>
</ul>
</html>"),     Icon(graphics={Line(points={{-80,-66},{-26,-66},{28,52},{88,52}},
                color={95,95,95})}));
    end Nonlinear;

    package Routing "Library of blocks to combine and extract signals"
      extends Modelica.Icons.Package;

      block Replicator "Signal replicator"
        extends Modelica.Blocks.Interfaces.SIMO;
      equation
        y = fill(u, nout);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,0},{-6,0}}, color={0,0,127}),
              Line(points={{100,0},{10,0}}, color={0,0,127}),
              Line(points={{0,0},{100,10}}, color={0,0,127}),
              Line(points={{0,0},{100,-10}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
This block replicates the input signal to an array of <code>nout</code> identical output signals.
</p>
</html>"));
      end Replicator;

      block Multiplex3 "Multiplexer block for three input connectors"
        extends Modelica.Blocks.Icons.Block;
        parameter Integer n1=1 "Dimension of input signal connector 1";
        parameter Integer n2=1 "Dimension of input signal connector 2";
        parameter Integer n3=1 "Dimension of input signal connector 3";
        Modelica.Blocks.Interfaces.RealInput u1[n1]
          "Connector of Real input signals 1" annotation (Placement(transformation(
                extent={{-140,50},{-100,90}})));
        Modelica.Blocks.Interfaces.RealInput u2[n2]
          "Connector of Real input signals 2" annotation (Placement(transformation(
                extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealInput u3[n3]
          "Connector of Real input signals 3" annotation (Placement(transformation(
                extent={{-140,-90},{-100,-50}})));
        Modelica.Blocks.Interfaces.RealOutput y[n1 + n2 + n3]
          "Connector of Real output signals" annotation (Placement(transformation(
                extent={{100,-10},{120,10}})));

      equation
        [y] = [u1; u2; u3];
        annotation (
          Documentation(info="<html>
<p>
The output connector is the <strong>concatenation</strong> of the three input connectors.
Note, that the dimensions of the input connector signals have to be
explicitly defined via parameters n1, n2 and n3.</p>
</html>"),     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{8,0},{102,0}}, color={0,0,127}),
              Line(points={{-100,70},{-60,70},{0,0}}, color={0,0,127}),
              Line(points={{-100,0},{-12,0}}, color={0,0,127}),
              Line(points={{-100,-70},{-60,-70},{0,0}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,70},{-60,70},{0,0}}, color={0,0,127}),
              Line(points={{-100,-70},{-60,-70},{0,0}}, color={0,0,127}),
              Line(points={{8,0},{102,0}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Line(points={{-100,0},{-12,0}}, color={0,0,127})}));
      end Multiplex3;

      model RealPassThrough "Pass a Real signal through without modification"
        extends Modelica.Blocks.Interfaces.SISO;
      equation
        y = u;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Line(points={{-100,0},{100,0}},
                  color={0,0,127})}),
                          Documentation(info="<html>
<p>
Passes a Real signal through without modification.  Enables signals to be read out of one bus, have their name changed and be sent back to a bus.
</p>
</html>"));
      end RealPassThrough;
      annotation (Documentation(info="<html>
<p>
This package contains blocks to combine and extract signals.
</p>
</html>"),     Icon(graphics={
            Line(points={{-90,0},{4,0}}, color={95,95,95}),
            Line(points={{88,65},{48,65},{-8,0}}, color={95,95,95}),
            Line(points={{-8,0},{93,0}}, color={95,95,95}),
            Line(points={{87,-65},{48,-65},{-8,0}}, color={95,95,95})}));
    end Routing;

    package Sources
    "Library of signal source blocks generating Real, Integer and Boolean signals"
      import Modelica.Blocks.Interfaces;
      import Modelica.SIunits;
      extends Modelica.Icons.SourcesPackage;

      block RealExpression "Set output signal to a time varying Real expression"

        Modelica.Blocks.Interfaces.RealOutput y=0.0 "Value of Real output"
          annotation (Dialog(group="Time varying output signal"), Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                textString="%y"),
              Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
The (time varying) Real output signal of this block can be defined in its
parameter menu via variable <strong>y</strong>. The purpose is to support the
easy definition of Real expressions in a block diagram. For example,
in the y-menu the definition \"if time &lt; 1 then 0 else 1\" can be given in order
to define that the output signal is one, if time &ge; 1 and otherwise
it is zero. Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
variable <strong>y</strong> is both a variable and a connector.
</p>
</html>"));

      end RealExpression;

      block BooleanExpression
        "Set output signal to a time varying Boolean expression"

        Modelica.Blocks.Interfaces.BooleanOutput y=false "Value of Boolean output"
          annotation (Dialog(group="Time varying output signal"), Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                textString="%y"),
              Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                lineColor={0,0,255}),
              Polygon(
                points={{100,10},{120,0},{100,-10},{100,10}},
                lineColor=DynamicSelect({255,0,255}, if y > 0.5 then {0,255,0}
                     else {255,0,255}),
                fillColor=DynamicSelect({255,255,255}, if y > 0.5 then {0,255,0}
                     else {255,255,255}),
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
The (time varying) Boolean output signal of this block can be defined in its
parameter menu via variable <strong>y</strong>. The purpose is to support the
easy definition of Boolean expressions in a block diagram. For example,
in the y-menu the definition \"time &gt;= 1 and time &lt;= 2\" can be given in order
to define that the output signal is <strong>true</strong> in the time interval
1 &le; time &le; 2 and otherwise it is <strong>false</strong>.
Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
variable <strong>y</strong> is both a variable and a connector.
</p>
</html>"));

      end BooleanExpression;

      block Constant "Generate constant signal of type Real"
        parameter Real k(start=1) "Constant output value"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png"));
        extends Interfaces.SO;

      equation
        y = k;
        annotation (
          defaultComponentName="const",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{80,0}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="k=%k")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Polygon(
                points={{-80,90},{-86,68},{-74,68},{-80,90}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-80}}, color={95,95,95}),
              Line(
                points={{-80,0},{80,0}},
                color={0,0,255},
                thickness=0.5),
              Line(points={{-90,-70},{82,-70}}, color={95,95,95}),
              Polygon(
                points={{90,-70},{68,-64},{68,-76},{90,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-83,92},{-30,74}},
                textString="y"),
              Text(
                extent={{70,-80},{94,-100}},
                textString="time"),
              Text(
                extent={{-101,8},{-81,-12}},
                textString="k")}),
          Documentation(info="<html>
<p>
The Real output y is a constant signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png\"
     alt=\"Constant.png\">
</p>
</html>"));
      end Constant;
      annotation (Documentation(info="<html>
<p>
This package contains <strong>source</strong> components, i.e., blocks which
have only output signals. These blocks are used as signal generators
for Real, Integer and Boolean signals.
</p>

<p>
All Real source signals (with the exception of the Constant source)
have at least the following two parameters:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>offset</strong></td>
      <td>Value which is added to the signal</td>
  </tr>
  <tr><td><strong>startTime</strong></td>
      <td>Start time of signal. For time &lt; startTime,
                the output y is set to offset.</td>
  </tr>
</table>

<p>
The <strong>offset</strong> parameter is especially useful in order to shift
the corresponding source, such that at initial time the system
is stationary. To determine the corresponding value of offset,
usually requires a trimming calculation.
</p>
</html>",     revisions="<html>
<ul>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Integer sources added. Step, TimeTable and BooleanStep slightly changed.</li>
<li><em>Nov. 8, 1999</em>
       by <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       New sources: Exponentials, TimeTable. Trapezoid slightly enhanced
       (nperiod=-1 is an infinite number of periods).</li>
<li><em>Oct. 31, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       All sources vectorized. New sources: ExpSine, Trapezoid,
       BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.
       Improved documentation, especially detailed description of
       signals in diagram layer.</li>
<li><em>June 29, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Sources;

    package Tables
    "Library of blocks to interpolate in one and two-dimensional tables"
      extends Modelica.Icons.Package;

      block CombiTable1D
        "Table look-up in one dimension (matrix/file) with n inputs and n outputs"
        extends Modelica.Blocks.Interfaces.MIMOs(final n=size(columns, 1));
        parameter Boolean tableOnFile=false
          "= true, if table is defined on file or in function usertab"
          annotation (Dialog(group="Table data definition"));
        parameter Real table[:, :] = fill(0.0, 0, 2)
          "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])"
          annotation (Dialog(group="Table data definition",enable=not tableOnFile));
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see docu)"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
          annotation (Dialog(
            group="Table data definition",
            enable=tableOnFile,
            loadSelector(filter="Text files (*.txt);;MATLAB MAT-files (*.mat)",
                caption="Open file in which table is present")));
        parameter Boolean verboseRead=true
          "= true, if info message that file is loading is to be printed"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter Integer columns[:]=2:size(table, 2)
          "Columns of table to be interpolated"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
          "Smoothness of table interpolation"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
          "Extrapolation of data outside the definition range"
          annotation (Dialog(group="Table data interpretation"));
        parameter Boolean verboseExtrapolation=false
          "= true, if warning messages are to be printed if table input is outside the definition range"
          annotation (Dialog(group="Table data interpretation", enable=extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint));
        final parameter Real u_min=Internal.getTable1DAbscissaUmin(tableID)
          "Minimum abscissa value defined in table";
        final parameter Real u_max=Internal.getTable1DAbscissaUmax(tableID)
          "Maximum abscissa value defined in table";
    protected
        parameter Modelica.Blocks.Types.ExternalCombiTable1D tableID=
            Modelica.Blocks.Types.ExternalCombiTable1D(
              if tableOnFile then tableName else "NoName",
              if tableOnFile and fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(fileName) then fileName else "NoName",
              table,
              columns,
              smoothness,
              extrapolation,
              if tableOnFile then verboseRead else false) "External table object";
        function readTableData =
          Modelica.Blocks.Tables.Internal.readTable1DData "Read table data from text or MATLAB MAT-file";
                                 // No longer used, but kept for backward compatibility
      equation
        if tableOnFile then
          assert(tableName <> "NoName",
            "tableOnFile = true and no table name given");
        else
          assert(size(table, 1) > 0 and size(table, 2) > 0,
            "tableOnFile = false and parameter table is an empty matrix");
        end if;

        if verboseExtrapolation and (
          extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or
          extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint) then
          for i in 1:n loop
            assert(noEvent(u[i] >= u_min), "
Extrapolation warning: The value u["     + String(i) +"] (=" + String(u[i]) + ") must be greater or equal
than the minimum abscissa value u_min (="     + String(u_min) + ") defined in the table.
",     level=AssertionLevel.warning);
            assert(noEvent(u[i] <= u_max), "
Extrapolation warning: The value u["     + String(i) +"] (=" + String(u[i]) + ") must be less or equal
than the maximum abscissa value u_max (="     + String(u_max) + ") defined in the table.
",     level=AssertionLevel.warning);
          end for;
        end if;

        if smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then
          for i in 1:n loop
            y[i] = Internal.getTable1DValueNoDer(tableID, i, u[i]);
          end for;
        else
          for i in 1:n loop
            y[i] = Internal.getTable1DValue(tableID, i, u[i]);
          end for;
        end if;
        annotation (
          Documentation(info="<html>
<p>
<strong>Univariate constant</strong>, <strong>linear</strong> or <strong>cubic Hermite
spline interpolation</strong> in <strong>one</strong> dimension of a
<strong>table</strong>.
Via parameter <strong>columns</strong> it can be defined how many columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that 2 input
and 2 output signals are present and that the first output interpolates
the first input via column 2 and the second output interpolates the
second input via column 4 of the table matrix.
</p>
<p>
The grid points and function values are stored in a matrix \"table[i,j]\",
where the first column \"table[:,1]\" contains the grid points and the
other columns contain the data to be interpolated. Example:
</p>
<pre>
   table = [0,  0;
            1,  1;
            2,  4;
            4, 16]
   If, e.g., the input u = 1.0, the output y =  1.0,
       e.g., the input u = 1.5, the output y =  2.5,
       e.g., the input u = 2.0, the output y =  4.0,
       e.g., the input u =-1.0, the output y = -1.0 (i.e., extrapolation).
</pre>
<ul>
<li>The interpolation interval is found by a binary search where the interval used in the
    last call is used as start interval.</li>
<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:
<pre>
  smoothness = 1: Linear interpolation
             = 2: Akima interpolation: Smooth interpolation by cubic Hermite
                  splines such that der(y) is continuous, also if extrapolated.
             = 3: Constant segments
             = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic
                  Hermite splines such that y preserves the monotonicity and
                  der(y) is continuous, also if extrapolated.
             = 5: Steffen interpolation: Smooth interpolation by cubic Hermite
                  splines such that y preserves the monotonicity and der(y)
                  is continuous, also if extrapolated.
</pre></li>
<li>Values <strong>outside</strong> of the table range, are computed by
    extrapolation according to the setting of parameter <strong>extrapolation</strong>:
<pre>
  extrapolation = 1: Hold the first or last value of the table,
                     if outside of the table scope.
                = 2: Extrapolate by using the derivative at the first/last table
                     points if outside of the table scope.
                     (If smoothness is LinearSegments or ConstantSegments
                     this means to extrapolate linearly through the first/last
                     two table points.).
                = 3: Periodically repeat the table data (periodical function).
                = 4: No extrapolation, i.e. extrapolation triggers an error
</pre></li>
<li>If the table has only <strong>one row</strong>, the table value is returned,
    independent of the value of the input signal.</li>
<li>The grid values (first column) have to be strictly increasing.</li>
</ul>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li>Explicitly supplied as <strong>parameter matrix</strong> \"table\",
    and the other parameters have the following values:
<pre>
   tableName is \"NoName\" or has only blanks,
   fileName  is \"NoName\" or has only blanks.
</pre></li>
<li><strong>Read</strong> from a <strong>file</strong> \"fileName\" where the matrix is stored as
    \"tableName\". Both text and MATLAB MAT-file format is possible.
    (The text format is described below).
    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.
    The library supports at least v4, v6 and v7 whereas v7.3 is optional.
    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;
    by command
<pre>
   save tables.mat tab1 tab2 tab3
</pre>
    or Scilab by command
<pre>
   savematfile tables.mat tab1 tab2 tab3
</pre>
    when the three tables tab1, tab2, tab3 should be used from the model.<br>
    Note, a fileName can be defined as URI by using the helper function
    <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.</li>
<li>Statically stored in function \"usertab\" in file \"usertab.c\".
    The matrix is identified by \"tableName\". Parameter
    fileName = \"NoName\" or has only blanks. Row-wise storage is always to be
    preferred as otherwise the table is reallocated and transposed.
    See the <a href=\"modelica://Modelica.Blocks.Tables\">Tables</a> package
    documentation for more details.</li>
</ol>
<p>
When the constant \"NO_FILE_SYSTEM\" is defined, all file I/O related parts of the
source code are removed by the C-preprocessor, such that no access to files takes place.
</p>
<p>
If tables are read from a text file, the file needs to have the
following structure (\"-----\" is not part of the file content):
</p>
<pre>
-----------------------------------------------------
#1
double tab1(5,2)   # comment line
  0   0
  1   1
  2   4
  3   9
  4  16
double tab2(5,2)   # another comment line
  0   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre>
<p>
Note, that the first two characters in the file need to be
\"#1\" (a line comment defining the version number of the file format).
Afterwards, the corresponding matrix has to be declared
with type (= \"double\" or \"float\"), name and actual dimensions.
Finally, in successive rows of the file, the elements of the matrix
have to be given. The elements have to be provided as a sequence of
numbers in row-wise order (therefore a matrix row can span several
lines in the file and need not start at the beginning of a line).
Numbers have to be given according to C syntax (such as 2.3, -2, +2.e4).
Number separators are spaces, tab (\\t), comma (,), or semicolon (;).
Several matrices may be defined one after another. Line comments start
with the hash symbol (#) and can appear everywhere.
Text files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.
Other characters, like trailing non comments, are not allowed in the file.
</p>
<p>
MATLAB is a registered trademark of The MathWorks, Inc.
</p>
</html>"),Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-60.0,40.0},{-60.0,-40.0},{60.0,-40.0},{60.0,40.0},{30.0,40.0},{30.0,-40.0},{-30.0,-40.0},{-30.0,40.0},{-60.0,40.0},{-60.0,20.0},{60.0,20.0},{60.0,0.0},{-60.0,0.0},{-60.0,-20.0},{60.0,-20.0},{60.0,-40.0},{-60.0,-40.0},{-60.0,40.0},{60.0,40.0},{60.0,-40.0}}),
          Line(points={{0.0,40.0},{0.0,-40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,20.0},{-30.0,40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,0.0},{-30.0,20.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-20.0},{-30.0,0.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-40.0},{-30.0,-20.0}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-60,60},{60,-60}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{-100,0},{-58,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{-100,100},{100,64}},
                textString="Univariate constant, linear or cubic Hermite spline table interpolation",
                lineColor={0,0,255}),
              Line(points={{-54,40},{-54,-40},{54,-40},{54,40},{28,40},{28,-40},{-28,
                    -40},{-28,40},{-54,40},{-54,20},{54,20},{54,0},{-54,0},{-54,-20},
                    {54,-20},{54,-40},{-54,-40},{-54,40},{54,40},{54,-40}}, color={
                    0,0,0}),
              Line(points={{0,40},{0,-40}}),
              Rectangle(
                extent={{-54,40},{-28,20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,20},{-28,0}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,0},{-28,-20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,-20},{-28,-40}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-50,54},{-32,42}},
                textString="u[1]/[2]",
                lineColor={0,0,255}),
              Text(
                extent={{-24,54},{0,42}},
                textString="y[1]",
                lineColor={0,0,255}),
              Text(
                extent={{-2,-40},{30,-54}},
                textString="columns",
                lineColor={0,0,255}),
              Text(
                extent={{2,54},{26,42}},
                textString="y[2]",
                lineColor={0,0,255})}));
      end CombiTable1D;

      block CombiTable1Ds
        "Table look-up in one dimension (matrix/file) with one input and n outputs"
        extends Modelica.Blocks.Interfaces.SIMO(final nout=size(columns, 1));
        parameter Boolean tableOnFile=false
          "= true, if table is defined on file or in function usertab"
          annotation (Dialog(group="Table data definition"));
        parameter Real table[:, :] = fill(0.0, 0, 2)
          "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])"
          annotation (Dialog(group="Table data definition",enable=not tableOnFile));
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see docu)"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
          annotation (Dialog(
            group="Table data definition",
            enable=tableOnFile,
            loadSelector(filter="Text files (*.txt);;MATLAB MAT-files (*.mat)",
                caption="Open file in which table is present")));
        parameter Boolean verboseRead=true
          "= true, if info message that file is loading is to be printed"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter Integer columns[:]=2:size(table, 2)
          "Columns of table to be interpolated"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
          "Smoothness of table interpolation"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
          "Extrapolation of data outside the definition range"
          annotation (Dialog(group="Table data interpretation"));
        parameter Boolean verboseExtrapolation=false
          "= true, if warning messages are to be printed if table input is outside the definition range"
          annotation (Dialog(group="Table data interpretation", enable=extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint));
        final parameter Real u_min=Internal.getTable1DAbscissaUmin(tableID)
          "Minimum abscissa value defined in table";
        final parameter Real u_max=Internal.getTable1DAbscissaUmax(tableID)
          "Maximum abscissa value defined in table";
    protected
        parameter Modelica.Blocks.Types.ExternalCombiTable1D tableID=
            Modelica.Blocks.Types.ExternalCombiTable1D(
              if tableOnFile then tableName else "NoName",
              if tableOnFile and fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(fileName) then fileName else "NoName",
              table,
              columns,
              smoothness,
              extrapolation,
              if tableOnFile then verboseRead else false) "External table object";
        function readTableData =
          Modelica.Blocks.Tables.Internal.readTable1DData "Read table data from text or MATLAB MAT-file";
                                 // No longer used, but kept for backward compatibility
      equation
        if tableOnFile then
          assert(tableName <> "NoName",
            "tableOnFile = true and no table name given");
        else
          assert(size(table, 1) > 0 and size(table, 2) > 0,
            "tableOnFile = false and parameter table is an empty matrix");
        end if;

        if verboseExtrapolation and (
          extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or
          extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint) then
          assert(noEvent(u >= u_min), "
Extrapolation warning: The value u (="     + String(u) + ") must be greater or equal
than the minimum abscissa value u_min (="     + String(u_min) + ") defined in the table.
",     level=AssertionLevel.warning);
          assert(noEvent(u <= u_max), "
Extrapolation warning: The value u (="     + String(u) + ") must be less or equal
than the maximum abscissa value u_max (="     + String(u_max) + ") defined in the table.
",     level=AssertionLevel.warning);
        end if;

        if smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then
          for i in 1:nout loop
            y[i] = Internal.getTable1DValueNoDer(tableID, i, u);
          end for;
        else
          for i in 1:nout loop
            y[i] = Internal.getTable1DValue(tableID, i, u);
          end for;
        end if;
        annotation (
          Documentation(info="<html>
<p>
<strong>Univariate constant</strong>, <strong>linear</strong> or <strong>cubic Hermite
spline interpolation</strong> in <strong>one</strong> dimension of a
<strong>table</strong>.
Via parameter <strong>columns</strong> it can be defined how many columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that
2 output signals are present and that the first output interpolates
via column 2 and the second output interpolates via column 4 of the
table matrix.
</p>
<p>
The grid points and function values are stored in a matrix \"table[i,j]\",
where the first column \"table[:,1]\" contains the grid points and the
other columns contain the data to be interpolated. Example:
</p>
<pre>
   table = [0,  0;
            1,  1;
            2,  4;
            4, 16]
   If, e.g., the input u = 1.0, the output y =  1.0,
       e.g., the input u = 1.5, the output y =  2.5,
       e.g., the input u = 2.0, the output y =  4.0,
       e.g., the input u =-1.0, the output y = -1.0 (i.e., extrapolation).
</pre>
<ul>
<li>The interpolation interval is found by a binary search where the interval used in the
    last call is used as start interval.</li>
<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:
<pre>
  smoothness = 1: Linear interpolation
             = 2: Akima interpolation: Smooth interpolation by cubic Hermite
                  splines such that der(y) is continuous, also if extrapolated.
             = 3: Constant segments
             = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic
                  Hermite splines such that y preserves the monotonicity and
                  der(y) is continuous, also if extrapolated.
             = 5: Steffen interpolation: Smooth interpolation by cubic Hermite
                  splines such that y preserves the monotonicity and der(y)
                  is continuous, also if extrapolated.
</pre></li>
<li>Values <strong>outside</strong> of the table range, are computed by
    extrapolation according to the setting of parameter <strong>extrapolation</strong>:
<pre>
  extrapolation = 1: Hold the first or last value of the table,
                     if outside of the table scope.
                = 2: Extrapolate by using the derivative at the first/last table
                     points if outside of the table scope.
                     (If smoothness is LinearSegments or ConstantSegments
                     this means to extrapolate linearly through the first/last
                     two table points.).
                = 3: Periodically repeat the table data (periodical function).
                = 4: No extrapolation, i.e. extrapolation triggers an error
</pre></li>
<li>If the table has only <strong>one row</strong>, the table value is returned,
    independent of the value of the input signal.</li>
<li>The grid values (first column) have to be strictly increasing.</li>
</ul>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li>Explicitly supplied as <strong>parameter matrix</strong> \"table\",
    and the other parameters have the following values:
<pre>
   tableName is \"NoName\" or has only blanks,
   fileName  is \"NoName\" or has only blanks.
</pre></li>
<li><strong>Read</strong> from a <strong>file</strong> \"fileName\" where the matrix is stored as
    \"tableName\". Both text and MATLAB MAT-file format is possible.
    (The text format is described below).
    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.
    The library supports at least v4, v6 and v7 whereas v7.3 is optional.
    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;
    by command
<pre>
   save tables.mat tab1 tab2 tab3
</pre>
    or Scilab by command
<pre>
   savematfile tables.mat tab1 tab2 tab3
</pre>
    when the three tables tab1, tab2, tab3 should be used from the model.<br>
    Note, a fileName can be defined as URI by using the helper function
    <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.</li>
<li>Statically stored in function \"usertab\" in file \"usertab.c\".
    The matrix is identified by \"tableName\". Parameter
    fileName = \"NoName\" or has only blanks. Row-wise storage is always to be
    preferred as otherwise the table is reallocated and transposed.
    See the <a href=\"modelica://Modelica.Blocks.Tables\">Tables</a> package
    documentation for more details.</li>
</ol>
<p>
When the constant \"NO_FILE_SYSTEM\" is defined, all file I/O related parts of the
source code are removed by the C-preprocessor, such that no access to files takes place.
</p>
<p>
If tables are read from a text file, the file needs to have the
following structure (\"-----\" is not part of the file content):
</p>
<pre>
-----------------------------------------------------
#1
double tab1(5,2)   # comment line
  0   0
  1   1
  2   4
  3   9
  4  16
double tab2(5,2)   # another comment line
  0   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre>
<p>
Note, that the first two characters in the file need to be
\"#1\" (a line comment defining the version number of the file format).
Afterwards, the corresponding matrix has to be declared
with type (= \"double\" or \"float\"), name and actual dimensions.
Finally, in successive rows of the file, the elements of the matrix
have to be given. The elements have to be provided as a sequence of
numbers in row-wise order (therefore a matrix row can span several
lines in the file and need not start at the beginning of a line).
Numbers have to be given according to C syntax (such as 2.3, -2, +2.e4).
Number separators are spaces, tab (\\t), comma (,), or semicolon (;).
Several matrices may be defined one after another. Line comments start
with the hash symbol (#) and can appear everywhere.
Text files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.
Other characters, like trailing non comments, are not allowed in the file.
</p>
<p>
MATLAB is a registered trademark of The MathWorks, Inc.
</p>
</html>"),Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-60.0,40.0},{-60.0,-40.0},{60.0,-40.0},{60.0,40.0},{30.0,40.0},{30.0,-40.0},{-30.0,-40.0},{-30.0,40.0},{-60.0,40.0},{-60.0,20.0},{60.0,20.0},{60.0,0.0},{-60.0,0.0},{-60.0,-20.0},{60.0,-20.0},{60.0,-40.0},{-60.0,-40.0},{-60.0,40.0},{60.0,40.0},{60.0,-40.0}}),
          Line(points={{0.0,40.0},{0.0,-40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,20.0},{-30.0,40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,0.0},{-30.0,20.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-20.0},{-30.0,0.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-40.0},{-30.0,-20.0}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-60,60},{60,-60}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{-100,0},{-58,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{-100,100},{100,64}},
                textString="Univariate constant, linear or cubic Hermite spline table interpolation",
                lineColor={0,0,255}),
              Line(points={{-54,40},{-54,-40},{54,-40},{54,40},{28,40},{28,-40},{-28,
                    -40},{-28,40},{-54,40},{-54,20},{54,20},{54,0},{-54,0},{-54,-20},
                    {54,-20},{54,-40},{-54,-40},{-54,40},{54,40},{54,-40}}, color={
                    0,0,0}),
              Line(points={{0,40},{0,-40}}),
              Rectangle(
                extent={{-54,40},{-28,20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,20},{-28,0}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,0},{-28,-20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,-20},{-28,-40}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-52,56},{-34,44}},
                textString="u",
                lineColor={0,0,255}),
              Text(
                extent={{-22,54},{2,42}},
                textString="y[1]",
                lineColor={0,0,255}),
              Text(
                extent={{4,54},{28,42}},
                textString="y[2]",
                lineColor={0,0,255}),
              Text(
                extent={{0,-40},{32,-54}},
                textString="columns",
                lineColor={0,0,255})}));
      end CombiTable1Ds;

      package Internal
      "Internal external object definitions for table functions that should not be directly utilized by the user"
        extends Modelica.Icons.InternalPackage;

        function readTable1DData "Read table data from text or MATLAB MAT-file"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Boolean forceRead = false
            "= true: Force reading of table data; = false: Only read, if not yet read.";
          input Boolean verboseRead = true
            "= true: Print info message; = false: No info message";
          output Real readSuccess "Table read success";
          external"C" readSuccess = ModelicaStandardTables_CombiTable1D_read(tableID, forceRead, verboseRead)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation(__ModelicaAssociation_Impure=true);
        end readTable1DData;

        function getTable1DValue "Interpolate 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Integer icol;
          input Real u;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation (derivative = getDerTable1DValue);
        end getTable1DValue;

        function getTable1DValueNoDer
          "Interpolate 1-dim. table defined by matrix (but do not provide a derivative function)"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Integer icol;
          input Real u;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DValueNoDer;

        function getDerTable1DValue
          "Derivative of interpolated 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Integer icol;
          input Real u;
          input Real der_u;
          output Real der_y;
          external"C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getDerTable1DValue;

        function getTable1DAbscissaUmin
          "Return minimum abscissa value of 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          output Real uMin "Minimum abscissa value in table";
          external"C" uMin = ModelicaStandardTables_CombiTable1D_minimumAbscissa(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DAbscissaUmin;

        function getTable1DAbscissaUmax
          "Return maximum abscissa value of 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          output Real uMax "Maximum abscissa value in table";
          external"C" uMax = ModelicaStandardTables_CombiTable1D_maximumAbscissa(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DAbscissaUmax;
      end Internal;
      annotation (Documentation(info="<html>
<p>This package contains blocks for one- and two-dimensional interpolation in tables.</p>
<h4>Special interest topic: Statically stored tables for real-time simulation targets</h4>
<p>Especially for use on real-time platform targets (e.g., HIL-simulators) with <strong>no file system</strong>, it is possible to statically
store tables using a function &quot;usertab&quot; in a file conventionally named &quot;usertab.c&quot;. This can be more efficient than providing the tables as Modelica parameter arrays.</p>
<p>This is achieved by providing the tables in a specific structure as C-code and compiling that C-code together with the rest of the simulation model into a binary
that can be executed on the target platform. The &quot;Resources/Data/Tables/&quot; subdirectory of the MSL installation directory contains the files
<a href=\"modelica://Modelica/Resources/Data/Tables/usertab.c\">&quot;usertab.c&quot;</a> and <a href=\"modelica://Modelica/Resources/Data/Tables/usertab.h\">&quot;usertab.h&quot;</a>
that can be used as a template for own developments. While &quot;usertab.c&quot; would be typically used unmodified, the
&quot;usertab.h&quot; needs to adapted for the own needs.</p>
<p>In order to work it is necessary that the compiler pulls in the &quot;usertab.c&quot; file. Different Modelica tools might provide different mechanisms to do so.
Please consult the respective documentation/support for your Modelica tool.</p>
<p>A possible (though a bit &quot;hackish&quot;) Modelica standard conformant approach is to pull in the required files by utilizing a &quot;dummy&quot;-function that uses the Modelica external function
interface to pull in the required &quot;usertab.c&quot;. An example how this can be done is given below.</p>
<pre>
model Test25_usertab \"Test utilizing the usertab.c interface\"
  extends Modelica.Icons.Example;
public
  Modelica.Blocks.Sources.RealExpression realExpression(y=getUsertab(t_new.y))
    annotation (Placement(transformation(extent={{-40,-34},{-10,-14}})));
  Modelica.Blocks.Tables.CombiTable1D t_new(tableOnFile=true, tableName=\"TestTable_1D_a\")
    annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
  Modelica.Blocks.Sources.Clock clock
    annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
protected
  encapsulated function getUsertab
    input Real dummy_u[:];
    output Real dummy_y;
    external \"C\" dummy_y=  mydummyfunc(dummy_u);
    annotation(IncludeDirectory=\"modelica://Modelica/Resources/Data/Tables\",
           Include = \"#include \"usertab.c\"
double mydummyfunc(double* dummy_in) {
   return 0;
}
\");
  end getUsertab;
equation
  connect(clock.y,t_new. u[1]) annotation (Line(
      points={{-59,10},{-42,10}}, color={0,0,127}));
  annotation (experiment(StartTime=0, StopTime=5), uses(Modelica(version=\"3.2.2\")));
end Test25_usertab;
</pre>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={
            Rectangle(
              extent={{-76,-26},{80,-76}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-76,24},{80,-26}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-76,74},{80,24}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-28,74},{-28,-76}},
              color={95,95,95}),
            Line(
              points={{24,74},{24,-76}},
              color={95,95,95})}));
    end Tables;

    package Types
    "Library of constants, external objects and types with choices, especially to build menus"
      extends Modelica.Icons.TypesPackage;

      type Smoothness = enumeration(
        LinearSegments   "Table points are linearly interpolated",
        ContinuousDerivative
            "Table points are interpolated (by Akima splines) such that the first derivative is continuous",
        ConstantSegments
            "Table points are not interpolated, but the value from the previous abscissa point is returned",
        MonotoneContinuousDerivative1
            "Table points are interpolated (by Fritsch-Butland splines) such that the monotonicity is preserved and the first derivative is continuous",
        MonotoneContinuousDerivative2
            "Table points are interpolated (by Steffen splines) such that the monotonicity is preserved and the first derivative is continuous")
        "Enumeration defining the smoothness of table interpolation";

        type Extrapolation = enumeration(
        HoldLastPoint
            "Hold the first/last table point outside of the table scope",
        LastTwoPoints
            "Extrapolate by using the derivative at the first/last table points outside of the table scope",
        Periodic   "Repeat the table scope periodically",
        NoExtrapolation   "Extrapolation triggers an error")
        "Enumeration defining the extrapolation of table interpolation";

        type Init = enumeration(
        NoInit
            "No initialization (start values are used as guess values with fixed=false)",
        SteadyState
            "Steady state initialization (derivatives of states are zero)",
        InitialState   "Initialization with initial states",
        InitialOutput
            "Initialization with initial outputs (and steady state of the states if possible)")
        "Enumeration defining initialization of a block" annotation (Evaluate=true,
        Documentation(info="<html>
  <p>The following initialization alternatives are available:</p>
  <dl>
    <dt><code><strong>NoInit</strong></code></dt>
      <dd>No initialization (start values are used as guess values with <code>fixed=false</code>)</dd>
    <dt><code><strong>SteadyState</strong></code></dt>
      <dd>Steady state initialization (derivatives of states are zero)</dd>
    <dt><code><strong>InitialState</strong></code></dt>
      <dd>Initialization with initial states</dd>
    <dt><code><strong>InitialOutput</strong></code></dt>
      <dd>Initialization with initial outputs (and steady state of the states if possible)</dd>
  </dl>
</html>"));

        type InitPID = enumeration(
        NoInit
            "No initialization (start values are used as guess values with fixed=false)",
        SteadyState
            "Steady state initialization (derivatives of states are zero)",
        InitialState   "Initialization with initial states",
        InitialOutput
            "Initialization with initial outputs (and steady state of the states if possible)",
        DoNotUse_InitialIntegratorState
            "Do not use, only for backward compatibility (initialize only integrator state)")
        "Enumeration defining initialization of PID and LimPID blocks" annotation (
          Evaluate=true, Documentation(info="<html>
<p>
This initialization type is identical to <a href=\"modelica://Modelica.Blocks.Types.Init\">Types.Init</a> and has just one
additional option <strong><code>DoNotUse_InitialIntegratorState</code></strong>. This option
is introduced in order that the default initialization for the
<code>Continuous.PID</code> and <code>Continuous.LimPID</code> blocks are backward
compatible. In Modelica 2.2, the integrators have been initialized
with their given states where as the D-part has not been initialized.
The option <strong><code>DoNotUse_InitialIntegratorState</code></strong> leads to this
initialization definition.
</p>

 <p>The following initialization alternatives are available:</p>
  <dl>
    <dt><code><strong>NoInit</strong></code></dt>
      <dd>No initialization (start values are used as guess values with <code>fixed=false</code>)</dd>
    <dt><code><strong>SteadyState</strong></code></dt>
      <dd>Steady state initialization (derivatives of states are zero)</dd>
    <dt><code><strong>InitialState</strong></code></dt>
      <dd>Initialization with initial states</dd>
    <dt><code><strong>InitialOutput</strong></code></dt>
      <dd>Initialization with initial outputs (and steady state of the states if possible)</dd>
    <dt><code><strong>DoNotUse_InitialIntegratorState</strong></code></dt>
      <dd>Do not use, only for backward compatibility (initialize only integrator state)</dd>
  </dl>
</html>"));

       type SimpleController = enumeration(
        P   "P controller",
        PI   "PI controller",
        PD   "PD controller",
        PID   "PID controller")
        "Enumeration defining P, PI, PD, or PID simple controller type" annotation (
         Evaluate=true);

      type AnalogFilter = enumeration(
        CriticalDamping   "Filter with critical damping",
        Bessel   "Bessel filter",
        Butterworth   "Butterworth filter",
        ChebyshevI   "Chebyshev I filter")
        "Enumeration defining the method of filtering" annotation (Evaluate=true);

      type FilterType = enumeration(
        LowPass   "Low pass filter",
        HighPass   "High pass filter",
        BandPass   "Band pass filter",
        BandStop   "Band stop / notch filter")
        "Enumeration of analog filter types (low, high, band pass or band stop filter)"
        annotation (Evaluate=true);

      type LimiterHomotopy = enumeration(
        NoHomotopy   "Homotopy is not used",
        Linear   "Simplified model without limits",
        UpperLimit   "Simplified model fixed at upper limit",
        LowerLimit   "Simplified model fixed at lower limit")
        "Enumeration defining use of homotopy in limiter components" annotation (Evaluate=true);

      class ExternalCombiTable1D
        "External object of 1-dim. table defined by matrix"
        extends ExternalObject;

        function constructor "Initialize 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input String tableName "Table name";
          input String fileName "File name";
          input Real table[:, :];
          input Integer columns[:];
          input Modelica.Blocks.Types.Smoothness smoothness;
          input Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints;
          input Boolean verboseRead=true "= true: Print info message; = false: No info message";
          output ExternalCombiTable1D externalCombiTable1D;
        external"C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init2(
                fileName,
                tableName,
                table,
                size(table, 1),
                size(table, 2),
                columns,
                size(columns, 1),
                smoothness,
                extrapolation,
                verboseRead) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end constructor;

        function destructor "Terminate 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input ExternalCombiTable1D externalCombiTable1D;
        external"C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end destructor;

      end ExternalCombiTable1D;
      annotation (Documentation(info="<html>
<p>
In this package <strong>types</strong>, <strong>constants</strong> and <strong>external objects</strong> are defined that are used
in library Modelica.Blocks. The types have additional annotation choices
definitions that define the menus to be built up in the graphical
user interface when the type is used as parameter in a declaration.
</p>
</html>"));
    end Types;

    package Icons "Icons for Blocks"
        extends Modelica.Icons.IconsPackage;

        partial block Block "Basic graphical layout of input/output block"

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output
block (no declarations, no equations). Most blocks
of package Modelica.Blocks inherit directly or indirectly
from this block.
</p>
</html>"));

        end Block;

        partial block DiscreteBlock
        "Graphical layout of discrete block component icon"

          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
                               Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
discrete block (no declarations, no equations), e.g.,
from Blocks.Discrete.
</p>
</html>"));
        end DiscreteBlock;

      partial block PartialBooleanBlock "Basic graphical layout of logical block"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Boolean block (no declarations, no equations) used especially
in the Blocks.Logical library.
</p>
</html>"));
      end PartialBooleanBlock;
    end Icons;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}), Documentation(info="<html>
<p>
This library contains input/output blocks to build up block diagrams.
</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a><br></dd>
</dl>
<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>June 23, 2004</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Introduced new block connectors and adapted all blocks to the new connectors.
       Included subpackages Continuous, Discrete, Logical, Nonlinear from
       package ModelicaAdditions.Blocks.
       Included subpackage ModelicaAdditions.Table in Modelica.Blocks.Sources
       and in the new package Modelica.Blocks.Tables.
       Added new blocks to Blocks.Sources and Blocks.Logical.
       </li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New subpackage Examples, additional components.
       </li>
<li><em>June 20, 2000</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
       Michael Tiller:<br>
       Introduced a replaceable signal type into
       Blocks.Interfaces.RealInput/RealOutput:
<pre>
   replaceable type SignalType = Real
</pre>
       in order that the type of the signal of an input/output block
       can be changed to a physical type, for example:
<pre>
   Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
</pre>
      </li>
<li><em>Sept. 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Renamed to Blocks. New subpackages Math, Nonlinear.
       Additional components in subpackages Interfaces, Continuous
       and Sources.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
  end Blocks;

  package Mechanics
  "Library of 1-dim. and 3-dim. mechanical components (multi-body, rotational, translational)"
  extends Modelica.Icons.Package;

    package MultiBody "Library to model 3-dimensional mechanical systems"
      extends Modelica.Icons.Package;
    import SI = Modelica.SIunits;
    import Cv = Modelica.SIunits.Conversions;
    import C = Modelica.Constants;

      package Frames "Functions to transform rotational frame quantities"
        extends Modelica.Icons.Package;

        record Orientation
          "Orientation object defining rotation from a frame 1 into a frame 2"

          extends Modelica.Icons.Record;
          Real T[3, 3] "Transformation matrix from world frame to local frame";
          SI.AngularVelocity w[3]
            "Absolute angular velocity of local frame, resolved in local frame";

          encapsulated function equalityConstraint
            "Return the constraint residues to express that two frames have the same orientation"

            import Modelica;
            import Modelica.Mechanics.MultiBody.Frames;
            extends Modelica.Icons.Function;
            input Frames.Orientation R1
              "Orientation object to rotate frame 0 into frame 1";
            input Frames.Orientation R2
              "Orientation object to rotate frame 0 into frame 2";
            output Real residue[3]
              "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)";
          algorithm
            residue := {
               Modelica.Math.atan2(cross(R1.T[1, :], R1.T[2, :])*R2.T[2, :],R1.T[1,:]*R2.T[1,:]),
               Modelica.Math.atan2(-cross(R1.T[1, :],R1.T[2, :])*R2.T[1, :],R1.T[2,:]*R2.T[2,:]),
               Modelica.Math.atan2(R1.T[2, :]*R2.T[1, :],R1.T[3,:]*R2.T[3,:])};
            annotation(Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
residue = Orientation.<strong>equalityConstraint</strong>(R1, R2);
</pre></blockquote>

<h4>Description</h4>
<p>
The function call <code>Orientation.<strong>equalityConstrain</strong>(R1,R2)</code> returns the Real residue vector
with 3 elements. This vector has zero elements if orientation objects R1 and R2 are identical
(= describe the same orientation). The residue vector is determined by computing the relative
orientation object between R1 and R2 and using the outer-diagonal elements of this matrix to
formulate the residue in such a way that only identical orientation objects lead to a zero residue vector.
</p>
</html>"));
          end equalityConstraint;

          annotation (Documentation(info="<html>
<p>
This object describes the <strong>rotation</strong> from a <strong>frame&nbsp;1</strong> into a <strong>frame&nbsp;2</strong>.
An instance of this type should never be directly accessed but
only with the access functions provided
in package Modelica.Mechanics.MultiBody.Frames. As a consequence, it is not necessary to know
the internal representation of this object as described in the next paragraphs.
</p>
<p>
\"Orientation\" is defined to be a record consisting of two
elements: \"Real T[3,3]\", the transformation matrix to rotate frame&nbsp;1
into frame&nbsp;2 and \"Real w[3]\", the angular velocity of frame&nbsp;2 with
respect to frame&nbsp;1, resolved in frame&nbsp;2. Element \"T\"
has the following interpretation:
</p>

<blockquote><pre>
Orientation R;
<strong>R.T</strong> = [<strong>e</strong><sub>x</sub>, <strong>e</strong><sub>y</sub>, <strong>e</strong><sub>z</sub>];
    e.g., <strong>R.T</strong> = [1,0,0; 0,1,0; 0,0,1]
</pre></blockquote>

<p>
where <strong>e</strong><sub>x</sub>,<strong>e</strong><sub>y</sub>,<strong>e</strong><sub>z</sub>
are unit vectors in the direction of the x-axis, y-axis, and z-axis
of frame&nbsp;1, resolved in frame&nbsp;2, respectively. Therefore, if <strong>v</strong><sub>1</sub>
is vector <strong>v</strong> resolved in frame&nbsp;1 and <strong>v</strong><sub>2</sub> is
vector <strong>v</strong> resolved in frame&nbsp;2, the following relationship holds:
</p>

<blockquote><pre>
<strong>v</strong><sub>2</sub> = <strong>R.T</strong> * <strong>v</strong><sub>1</sub>
</pre></blockquote>

<p>
The <strong>inverse</strong> orientation
<strong>R_inv.T</strong> = <strong>R.T</strong><sup>T</sup> describes the rotation
from frame&nbsp;2 into frame&nbsp;1.
</p>
<p>
Since the orientation is described by 9 variables, there are
6 constraints between these variables. These constraints
are defined in function <strong>Frames.orientationConstraint</strong>.
</p>
<p>
R.w is the angular velocity of frame&nbsp;2 with respect to frame&nbsp;1, resolved
in frame&nbsp;2. Formally, R.w is defined as:<br>
<strong>skew</strong>(R.w) = R.T*<strong>der</strong>(transpose(R.T))
with
</p>
<blockquote><pre>
          |   0   -w[3]  w[2] |
<strong>skew</strong>(w) = |  w[3]   0   -w[1] |
          | -w[2]  w[1]     0 |
</pre></blockquote>
</html>"));
        end Orientation;

        function nullRotation
          "Return orientation object that does not rotate a frame"
          extends Modelica.Icons.Function;
          output Orientation R
            "Orientation object such that frame 1 and frame 2 are identical";
        algorithm
          R := Orientation(T=identity(3),w= zeros(3));
          annotation(Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
R = Frames.<strong>nullRotation</strong>();
</pre></blockquote>

<h4>Description</h4>
<p>
The function call <code>Frames.<strong>nullRotation</strong>()</code> returns an orientation matrix&nbsp;R
describing the orientation object to rotate frame&nbsp;1 into frame&nbsp;2, if frame&nbsp;1 and frame&nbsp;2 are identical.
(= transformation matrix is identity matrix and angular velocity is zero).
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.nullRotation\">TransformationMatrices.nullRotation</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation\">Quaternions.nullRotation</a>.
</p>
</html>"));
        end nullRotation;
        annotation (Documentation(info="<html>
<p>
Package <strong>Frames</strong> contains type definitions and
functions to transform rotational frame quantities. The basic idea is to
hide the actual definition of an <strong>orientation</strong> in this package
by providing essentially type <strong>Orientation</strong> together with
<strong>functions</strong> operating on instances of this type.
</p>
<h4>Content</h4>
<p>In the table below an example is given for every function definition.
The used variables have the following declaration:
</p>
<pre>
   Frames.Orientation R, R1, R2, R_rel, R_inv;
   Real[3,3]   T, T_inv;
   Real[3]     v1, v2, w1, w2, n_x, n_y, n_z, e, e_x, res_ori, phi;
   Real[6]     res_equal;
   Real        L, angle;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><strong>Orientation R;</strong></td>
      <td>New type defining an orientation object that describes<br>
          the rotation of frame 1 into frame 2.
      </td>
  </tr>
  <tr><td>res_ori = <strong>orientationConstraint</strong>(R);</td>
      <td>Return the constraints between the variables of an orientation object<br>
      (shall be zero).</td>
  </tr>
  <tr><td>w1 = <strong>angularVelocity1</strong>(R);</td>
      <td>Return angular velocity resolved in frame 1 from
          orientation object R.
     </td>
  </tr>
  <tr><td>w2 = <strong>angularVelocity2</strong>(R);</td>
      <td>Return angular velocity resolved in frame 2 from
          orientation object R.
     </td>
  </tr>
  <tr><td>v1 = <strong>resolve1</strong>(R,v2);</td>
      <td>Transform vector v2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td>v2 = <strong>resolve2</strong>(R,v1);</td>
      <td>Transform vector v1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td>v2 = <strong>resolveRelative</strong>(v1,R1,R2);</td>
      <td>Transform vector v1 from frame 1 to frame 2
          using absolute orientation objects R1 of frame 1 and R2 of frame 2.
      </td>
  </tr>
  <tr><td>D1 = <strong>resolveDyade1</strong>(R,D2);</td>
      <td>Transform second order tensor D2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td>D2 = <strong>resolveDyade2</strong>(R,D1);</td>
      <td>Transform second order tensor D1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td>R = <strong>nullRotation</strong>()</td>
      <td>Return orientation object R that does not rotate a frame.
     </td>
  </tr>
  <tr><td>R_inv = <strong>inverseRotation</strong>(R);</td>
      <td>Return inverse orientation object.
      </td>
  </tr>
  <tr><td>R_rel = <strong>relativeRotation</strong>(R1,R2);</td>
      <td>Return relative orientation object from two absolute
          orientation objects.
      </td>
  </tr>
  <tr><td>R2 = <strong>absoluteRotation</strong>(R1,R_rel);</td>
      <td>Return absolute orientation object from another
          absolute<br> and a relative orientation object.
      </td>
  </tr>
  <tr><td>R = <strong>planarRotation</strong>(e, angle, der_angle);</td>
      <td>Return orientation object of a planar rotation.
      </td>
  </tr>
  <tr><td>angle = <strong>planarRotationAngle</strong>(e, v1, v2);</td>
      <td>Return angle of a planar rotation, given the rotation axis<br>
        and the representations of a vector in frame 1 and frame 2.
      </td>
  </tr>
  <tr><td>R = <strong>axisRotation</strong>(axis, angle, der_angle);</td>
      <td>Return orientation object R to rotate around angle along axis of frame 1.
      </td>
  </tr>
  <tr><td>R = <strong>axesRotations</strong>(sequence, angles, der_angles);</td>
      <td>Return rotation object to rotate in sequence around 3 axes. Example:<br>
          R = axesRotations({1,2,3},{pi/2,pi/4,-pi}, zeros(3));
      </td>
  </tr>
  <tr><td>angles = <strong>axesRotationsAngles</strong>(R, sequence);</td>
      <td>Return the 3 angles to rotate in sequence around 3 axes to<br>
          construct the given orientation object.
      </td>
  </tr>
  <tr><td>phi = <strong>smallRotation</strong>(R);</td>
      <td>Return rotation angles phi valid for a small rotation R.
      </td>
  </tr>
  <tr><td>R = <strong>from_nxy</strong>(n_x, n_y);</td>
      <td>Return orientation object from n_x and n_y vectors.
      </td>
  </tr>
  <tr><td>R = <strong>from_nxz</strong>(n_x, n_z);</td>
      <td>Return orientation object from n_x and n_z vectors.
      </td>
  </tr>
  <tr><td>R = <strong>from_T</strong>(T,w);</td>
      <td>Return orientation object R from transformation matrix T and
          its angular velocity w.
      </td>
  </tr>
  <tr><td>R = <strong>from_T2</strong>(T,der(T));</td>
      <td>Return orientation object R from transformation matrix T and
          its derivative der(T).
      </td>
  </tr>
  <tr><td>R = <strong>from_T_inv</strong>(T_inv,w);</td>
      <td>Return orientation object R from inverse transformation matrix T_inv and
          its angular velocity w.
      </td>
  </tr>
  <tr><td>R = <strong>from_Q</strong>(Q,w);</td>
      <td>Return orientation object R from quaternion orientation object Q
          and its angular velocity w.
      </td>
  </tr>
  <tr><td>T = <strong>to_T</strong>(R);</td>
      <td>Return transformation matrix T from orientation object R.
      </td>
  </tr>
  <tr><td>T_inv = <strong>to_T_inv</strong>(R);</td>
      <td>Return inverse transformation matrix T_inv from orientation object R.
      </td>
  </tr>
  <tr><td>Q = <strong>to_Q</strong>(R);</td>
      <td>Return quaternion orientation object Q from orientation object R.
      </td>
  </tr>
  <tr><td>exy = <strong>to_exy</strong>(R);</td>
      <td>Return [e_x, e_y] matrix of an orientation object R,<br>
          with e_x and e_y vectors of frame 2, resolved in frame 1.
      </td>
  </tr>
  <tr><td>L = <strong>length</strong>(n_x);</td>
      <td>Return length L of a vector n_x.
      </td>
  </tr>
  <tr><td>e_x = <strong>normalize</strong>(n_x);</td>
      <td>Return normalized vector e_x of n_x such that length of e_x is one.
      </td>
  </tr>
  <tr><td>e = <strong>axis</strong>(i);</td>
      <td>Return unit vector e directed along axis i
      </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.Quaternions\">Quaternions</a></td>
      <td><strong>Package</strong> with functions to transform rotational frame quantities based
          on quaternions (also called Euler parameters).
      </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.TransformationMatrices\">TransformationMatrices</a></td>
      <td><strong>Package</strong> with functions to transform rotational frame quantities based
          on transformation matrices.
      </td>
  </tr>
</table>
</html>"),       Icon(graphics={
              Line(points={{-2,-18},{80,-60}}, color={95,95,95}),
              Line(points={{-2,-18},{-2,80}}, color={95,95,95}),
              Line(points={{-78,-56},{-2,-18}}, color={95,95,95})}));
      end Frames;

      package Interfaces
      "Connectors and partial models for 3-dim. mechanical components"
        extends Modelica.Icons.InterfacesPackage;

        partial function partialSurfaceCharacteristic "Interface for a function returning surface characteristics"
          extends Modelica.Icons.Function;
           input Integer nu "Number of points in u-Dimension";
           input Integer nv "Number of points in v-Dimension";
           input Boolean multiColoredSurface=false
            "= true: Color is defined for each surface point";
           output Modelica.SIunits.Position X[nu,nv]
            "[nu,nv] positions of points in x-Direction resolved in surface frame";
           output Modelica.SIunits.Position Y[nu,nv]
            "[nu,nv] positions of points in y-Direction resolved in surface frame";
           output Modelica.SIunits.Position Z[nu,nv]
            "[nu,nv] positions of points in z-Direction resolved in surface frame";
           output Real C[if multiColoredSurface then nu else 0,
                         if multiColoredSurface then nv else 0,3]
            "[nu,nv,3] Color array, defining the color for each surface point";
          annotation (Documentation(info="<html>
<p>This partial function defines the interface of a function that returns
surface characteristics for an object visualization, see e.g.
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.SurfaceCharacteristics.torus\">Visualizers.Advanced.SurfaceCharacteristics.torus</a>.
</p>
</html>"));
        end partialSurfaceCharacteristic;
        annotation (Documentation(info="<html>
<p>
This package contains connectors and partial models (i.e., models
that are only used to build other models) of the MultiBody library.
</p>
</html>"));
      end Interfaces;

      package Types
      "Constants and types with choices, especially to build menus"
        extends Modelica.Icons.TypesPackage;

        type SpecularCoefficient = Modelica.Icons.TypeReal(min=0)
          "Reflection of ambient light (= 0: light is completely absorbed)"
             annotation (choices(
               choice=0 "0.0 \"dull\"",
               choice=0.7 "0.7 \"medium\"",
               choice=1 "1.0 \"glossy\""),
          Documentation(info="<html>
<p>
Type <strong>SpecularCoefficient</strong> defines the reflection of
ambient light on shape surfaces. If value = 0, the light
is completely absorbed. Often, 0.7 is a reasonable value.
It might be that from some viewing directions, a body is no
longer visible, if the SpecularCoefficient value is too high.
In the following image, the different values of SpecularCoefficient
are shown for a cylinder:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/SpecularCoefficient.png\"/>
</p>
</html>"));

        type ShapeType = Modelica.Icons.TypeString
          "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring, <external shape>)"
           annotation ( choices(
            choice="box" "\"box\"",
            choice="sphere" "\"sphere\"",
            choice="cylinder" "\"cylinder\"",
            choice="pipecylinder" "\"pipecylinder\"",
            choice="cone" "\"cone\"",
            choice="pipe" "\"pipe\"",
            choice="beam" "\"beam\"",
            choice="gearwheel" "\"gearwheel\"",
            choice="spring" "\"spring\"",
            choice="modelica://PackageName/PathName.dxf"),
          Documentation(info="<html>
<p>
Type <strong>ShapeType</strong> is used to define the shape of the
visual object as parameter String. Usually, \"shapeType\" is used
as instance name. The following
values for shapeType are possible, e.g., shapeType=\"box\":
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Shape.png\" alt=\"model Visualizers.FixedShape\">
</p>

<p>
The dark blue arrows in the figure above are directed along
variable <strong>lengthDirection</strong>. The light blue arrows are directed
along variable <strong>widthDirection</strong>. The <strong>coordinate systems</strong>
in the figure represent frame_a of the Shape component.
</p>

<p>
Additionally, external shapes can be specified as (not all options might be supported by all tools):
</p>

<ul>
<li> <strong>\"1\", \"2\", ...</strong><br>
     define external shapes specified in DXF format in files \"1.dxf\", \"2.dxf\", ...
     The DXF-files must be found either in the current directory or in the directory where
     the Shape instance is stored that references the DXF file.
     This (very limited) option should not be used for new models. Example:<br>
    shapeType=\"1\".<br></li>

<li> \"<strong>modelica:</strong>//&lt;Modelica-name&gt;/&lt;relative-path-file-name&gt;\"<br>
     characterizes the file that is stored under the location of the
     &lt;Modelica-name&gt; library path with the given relative file name.
     Example:<br> shapeType = \"modelica://Modelica/Resources/Data/Shapes/Engine/piston.dxf\".<br></li>

<li> \"<strong>file:</strong>//&lt;absolute-file-name&gt;\"<br>
     characterizes an absolute file name in the file system. Example:<br>
     shapeType=\"file://C:/users/myname/shapes/piston.dxf\".</li>
</ul>

<p>
The supported file formats are tool dependent. Most tools support
at least DXF-files (a tool might support 3-dim. Face of the DXF format only),
but may support other format as well (such as stl, obj, 3ds).
Since visualization files contain color and other data, the corresponding
information in the model is usually ignored.
</p>
</html>"));

        type ShapeExtra = Modelica.Icons.TypeReal
          "Type of the additional data that can be defined for an elementary ShapeType"
             annotation (
          Documentation(info="<html>
<p>
This type is used in shapes of visual objects to define
extra data depending on the shape type. Usually, input
variable <strong>extra</strong> is used as instance name:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><strong>shapeType</strong></th><th>Meaning of parameter <strong>extra</strong></th></tr>
<tr>
  <td>\"cylinder\"</td>
  <td>if extra&nbsp;&gt;&nbsp;0, a black line is included in the
      cylinder to show the rotation of it.</td>
</tr>
<tr>
  <td>\"cone\"</td>
  <td>extra = diameter-left-side / diameter-right-side, i.e.,<br>
      extra = 1: cylinder<br>
      extra = 0: \"real\" cone.</td>
</tr>
<tr>
  <td>\"pipe\"</td>
  <td>extra = outer-diameter / inner-diameter, i.e,<br>
      extra = 1: cylinder that is completely hollow<br>
      extra = 0: cylinder without a hole.</td>
</tr>
<tr>
  <td>\"gearwheel\"</td>
  <td>extra is the number of teeth of the (external) gear.
If extra&nbsp;&lt;&nbsp;0, an internal gear is visualized with |extra| teeth.
The axis of the gearwheel is along \"lengthDirection\", and usually:
width = height = 2*radiusOfGearWheel.</td>
</tr>
<tr>
  <td>\"spring\"</td>
  <td>extra is the number of windings of the spring.
      Additionally, \"height\" is <strong>not</strong> the \"height\" but
      2*coil-width.</td>
</tr>
<tr>
  <td>external shape</td>
  <td>extra = 0: Visualization from file is not scaled.<br>
                     extra = 1: Visualization from file is scaled with \"length\", \"width\" and \"height\"
                                of the shape</td>
</tr>
</table>
</html>"));
        annotation (Documentation(info="<html>
<p>
In this package <strong>types</strong> and <strong>constants</strong> are defined that are used in the
MultiBody library. The types have additional annotation choices
definitions that define the menus to be built up in the graphical
user interface when the type is used as parameter in a declaration.
</p>
</html>"));
      end Types;
    annotation (
      Documentation(info="<html>
<p>
Library <strong>MultiBody</strong> is a <strong>free</strong> Modelica package providing
3-dimensional mechanical components to model in a convenient way
<strong>mechanical systems</strong>, such as robots, mechanisms, vehicles.
Typical animations generated with this library are shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/MultiBody.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide\">MultiBody.UsersGuide</a>
     discusses the most important aspects how to use this library.</li>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.Examples\">MultiBody.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={
            Polygon(
              points={{-58,76},{6,76},{-26,50},{-58,76}},
              lineColor={95,95,95},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-26,50},{28,-50}}),
            Ellipse(
              extent={{-4,-14},{60,-78}},
              lineColor={135,135,135},
              fillPattern=FillPattern.Sphere,
              fillColor={255,255,255})}));
    end MultiBody;
  annotation (
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={8.6,63.3333},
          lineColor={64,64,64},
          fillColor={192,192,192},
          fillPattern=FillPattern.HorizontalCylinder,
          extent={{-4.6,-93.3333},{41.4,-53.3333}}),
        Ellipse(
          origin={9.0,46.0},
          extent={{-90.0,-60.0},{-80.0,-50.0}}),
        Line(
          origin={9.0,46.0},
          points={{-85.0,-55.0},{-60.0,-21.0}},
          thickness=0.5),
        Ellipse(
          origin={9.0,46.0},
          extent={{-65.0,-26.0},{-55.0,-16.0}}),
        Line(
          origin={9.0,46.0},
          points={{-60.0,-21.0},{9.0,-55.0}},
          thickness=0.5),
        Ellipse(
          origin={9.0,46.0},
          fillPattern=FillPattern.Solid,
          extent={{4.0,-60.0},{14.0,-50.0}}),
        Line(
          origin={9.0,46.0},
          points={{-10.0,-26.0},{72.0,-26.0},{72.0,-86.0},{-10.0,-86.0}})}),
    Documentation(info="<html>
<p>
This package contains components to model the movement
of 1-dim. rotational, 1-dim. translational, and
3-dim. <strong>mechanical systems</strong>.
</p>

<p>
Note, all <strong>dissipative</strong> components of the Modelica.Mechanics library have
an optional <strong>heatPort</strong> connector to which the
dissipated energy is transported in form of heat. This connector is enabled
via parameter \"useHeatPort\". If the heatPort connector is enabled,
it must be connected, and if it is not enabled, it must not be connected.
Independently, whether the heatPort is enabled or not,
the dissipated power is available from variable \"<strong>lossPower</strong>\" (which is
positive if heat is flowing out of the heatPort).
</p>
</html>"));
  end Mechanics;

  package Fluid
  "Library of 1-dim. thermo-fluid flow models using the Modelica.Media media description"
    extends Modelica.Icons.Package;
  import SI = Modelica.SIunits;
  import Cv = Modelica.SIunits.Conversions;

    package Vessels "Devices for storing fluid"
        extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Base classes used in the Vessels package (only of interest to build new component models)"
        extends Modelica.Icons.BasesPackage;

        connector VesselFluidPorts_b
          "Fluid connector with outlined, large icon to be used for horizontally aligned vectors of FluidPorts (vector dimensions must be added after dragging)"
          extends Interfaces.FluidPort;
          annotation (defaultComponentName="ports_b",
                      Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                initialScale=0.2), graphics={
                Text(extent={{-75,130},{75,100}}, textString="%name"),
                Rectangle(
                  extent={{-25,100},{25,-100}}),
                Ellipse(
                  extent={{-22,100},{-10,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-20,-69},{-12,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,100},{6,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{10,100},{22,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-4,-69},{4,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{12,-69},{20,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
               Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                initialScale=0.2), graphics={
                Rectangle(
                  extent={{-50,200},{50,-200}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-44,200},{-20,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-12,200},{12,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{20,200},{44,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-39,-118.5},{-25,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-7,-118.5},{7,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{25,-117.5},{39,114}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end VesselFluidPorts_b;
      end BaseClasses;
      annotation (Documentation(info="<html>

</html>"));
    end Vessels;

    package Pipes "Devices for conveying fluid"
        extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Base classes used in the Pipes package (only of interest to build new component models)"
        extends Modelica.Icons.BasesPackage;

        package WallFriction
        "Different variants for pressure drops due to pipe wall friction"
          extends Modelica.Icons.Package;

          partial package PartialWallFriction
            "Partial wall friction characteristic (base package of all wall friction characteristics)"
            extends Modelica.Icons.Package;
            import Modelica.Constants.pi;

          // Constants to be set in subpackages
            constant Boolean use_mu = true
              "= true, if mu_a/mu_b are used in function, otherwise value is not used";
            constant Boolean use_roughness = true
              "= true, if roughness is used in function, otherwise value is not used";
            constant Boolean use_dp_small = true
              "= true, if dp_small is used in function, otherwise value is not used";
            constant Boolean use_m_flow_small = true
              "= true, if m_flow_small is used in function, otherwise value is not used";
            constant Boolean dp_is_zero = false
              "= true, if no wall friction is present, i.e., dp = 0 (function massFlowRate_dp() cannot be used)";
            constant Boolean use_Re_turbulent = true
              "= true, if Re_turbulent input is used in function, otherwise value is not used";

          // pressure loss characteristic functions
            replaceable partial function massFlowRate_dp
              "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"
              extends Modelica.Icons.Function;

              input SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.Area crossArea = pi*diameter^2/4 "Inner cross section area";
              input SI.Length roughness(min=0) = 2.5e-5
                "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
              input SI.AbsolutePressure dp_small = 1
                "Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)";
              input SI.ReynoldsNumber Re_turbulent = 4000
                "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

              output SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
            annotation (Documentation(info="<html>

</html>"));
            end massFlowRate_dp;

            replaceable partial function massFlowRate_dp_staticHead
              "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"
              extends Modelica.Icons.Function;

              input SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input Real g_times_height_ab
                "Gravity times (Height(port_b) - Height(port_a))";
              input SI.Area crossArea = pi*diameter^2/4 "Inner cross section area";
              input SI.Length roughness(min=0) = 2.5e-5
                "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
              input SI.AbsolutePressure dp_small=1
                "Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)";
              input SI.ReynoldsNumber Re_turbulent = 4000
                "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

              output SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              annotation (Documentation(info="<html>

</html>"));
            end massFlowRate_dp_staticHead;

            replaceable partial function pressureLoss_m_flow
              "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"
              extends Modelica.Icons.Function;

              input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.Area crossArea = pi*diameter^2/4 "Inner cross section area";
              input SI.Length roughness(min=0) = 2.5e-5
                "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
              input SI.MassFlowRate m_flow_small = 0.01
                "Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)";
              input SI.ReynoldsNumber Re_turbulent = 4000
                "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

              output SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";

            annotation (Documentation(info="<html>

</html>"));
            end pressureLoss_m_flow;

            replaceable partial function pressureLoss_m_flow_staticHead
              "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"
                      extends Modelica.Icons.Function;

              input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input Real g_times_height_ab
                "Gravity times (Height(port_b) - Height(port_a))";
              input SI.Area crossArea = pi*diameter^2/4 "Inner cross section area";
              input SI.Length roughness(min=0) = 2.5e-5
                "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
              input SI.MassFlowRate m_flow_small = 0.01
                "Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)";
              input SI.ReynoldsNumber Re_turbulent = 4000
                "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

              output SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";

            annotation (Documentation(info="<html>

</html>"));
            end pressureLoss_m_flow_staticHead;
            annotation (Documentation(info="<html>

</html>"));
          end PartialWallFriction;

          package Detailed
          "Pipe wall friction for laminar and turbulent flow (detailed characteristic)"
            extends PartialWallFriction(
                      final use_mu = true,
                      final use_roughness = true,
                      final use_dp_small = true,
                      final use_m_flow_small = true,
                      final use_Re_turbulent = true);
            import ln = Modelica.Math.log "Logarithm, base e";
            import Modelica.Math.log10 "Logarithm, base 10";
            import Modelica.Math.exp "Exponential function";

            redeclare function extends massFlowRate_dp
              "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"
              import Modelica.Math;
          protected
              Real Delta = roughness/diameter "Relative roughness";
              SI.ReynoldsNumber Re1 = min((745*Math.exp(if Delta <= 0.0065 then 1 else 0.0065/Delta))^0.97, Re_turbulent)
                "Re leaving laminar curve";
              SI.ReynoldsNumber Re2 = Re_turbulent "Re entering turbulent curve";
              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              SI.ReynoldsNumber Re "Reynolds number";
              Real lambda2 "Modified friction coefficient (= lambda*Re^2)";

              function interpolateInRegion2
                 input Real Re_turbulent;
                 input SI.ReynoldsNumber Re1;
                 input SI.ReynoldsNumber Re2;
                 input Real Delta;
                 input Real lambda2;
                 output SI.ReynoldsNumber Re;
                // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
                Real x1=Math.log10(64*Re1);
                Real y1=Math.log10(Re1);
                Real yd1=1;

                // Point lg(lambda2(Re2)) with derivative at lg(Re2)
                Real aux1=(0.5/Math.log(10))*5.74*0.9;
                Real aux2=Delta/3.7 + 5.74/Re2^0.9;
                Real aux3=Math.log10(aux2);
                Real L2=0.25*(Re2/aux3)^2;
                Real aux4=2.51/sqrt(L2) + 0.27*Delta;
                Real aux5=-2*sqrt(L2)*Math.log10(aux4);
                Real x2=Math.log10(L2);
                Real y2=Math.log10(aux5);
                Real yd2=0.5 + (2.51/Math.log(10))/(aux5*aux4);

                // Constants: Cubic polynomial between lg(Re1) and lg(Re2)
                Real diff_x=x2 - x1;
                Real m=(y2 - y1)/diff_x;
                Real c2=(3*m - 2*yd1 - yd2)/diff_x;
                Real c3=(yd1 + yd2 - 2*m)/(diff_x*diff_x);
                Real lambda2_1=64*Re1;
                Real dx;
              algorithm
                 dx := Math.log10(lambda2/lambda2_1);
                 Re := Re1*(lambda2/lambda2_1)^(1 + dx*(c2 + dx*c3));
                 annotation(smoothOrder=1);
              end interpolateInRegion2;

            algorithm
              // Determine upstream density, upstream viscosity, and lambda2
              rho     := if dp >= 0 then rho_a else rho_b;
              mu      := if dp >= 0 then mu_a else mu_b;
              lambda2 := abs(dp)*2*diameter^3*rho/(length*mu*mu);

              // Determine Re under the assumption of laminar flow
              Re := lambda2/64;

              // Modify Re, if turbulent flow
              if Re > Re1 then
                 Re :=-2*sqrt(lambda2)*Math.log10(2.51/sqrt(lambda2) + 0.27*Delta);
                 if Re < Re2 then
                    Re := interpolateInRegion2(Re, Re1, Re2, Delta, lambda2);
                 end if;
              end if;

              // Determine mass flow rate
              m_flow := crossArea/diameter*mu*(if dp >= 0 then Re else -Re);
                      annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
            end massFlowRate_dp;

            redeclare function extends pressureLoss_m_flow
              "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"
              import Modelica.Math;
              import Modelica.Constants.pi;
          protected
              Real Delta = roughness/diameter "Relative roughness";
              SI.ReynoldsNumber Re1 = min(745*Math.exp(if Delta <= 0.0065 then 1 else 0.0065/Delta), Re_turbulent)
                "Re leaving laminar curve";
              SI.ReynoldsNumber Re2 = Re_turbulent "Re entering turbulent curve";
              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              SI.ReynoldsNumber Re "Reynolds number";
              Real lambda2 "Modified friction coefficient (= lambda*Re^2)";

              function interpolateInRegion2
                 input SI.ReynoldsNumber Re;
                 input SI.ReynoldsNumber Re1;
                 input SI.ReynoldsNumber Re2;
                 input Real Delta;
                 output Real lambda2;
                // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
                Real x1 = Math.log10(Re1);
                Real y1 = Math.log10(64*Re1);
                Real yd1=1;

                // Point lg(lambda2(Re2)) with derivative at lg(Re2)
                Real aux1=(0.5/Math.log(10))*5.74*0.9;
                Real aux2=Delta/3.7 + 5.74/Re2^0.9;
                Real aux3=Math.log10(aux2);
                Real L2=0.25*(Re2/aux3)^2;
                Real aux4=2.51/sqrt(L2) + 0.27*Delta;
                Real aux5=-2*sqrt(L2)*Math.log10(aux4);
                Real x2 =  Math.log10(Re2);
                Real y2 =  Math.log10(L2);
                Real yd2 = 2 + 4*aux1/(aux2*aux3*(Re2)^0.9);

                // Constants: Cubic polynomial between lg(Re1) and lg(Re2)
                Real diff_x=x2 - x1;
                Real m=(y2 - y1)/diff_x;
                Real c2=(3*m - 2*yd1 - yd2)/diff_x;
                Real c3=(yd1 + yd2 - 2*m)/(diff_x*diff_x);
                Real dx;
              algorithm
                 dx := Math.log10(Re/Re1);
                 lambda2 := 64*Re1*(Re/Re1)^(1 + dx*(c2 + dx*c3));
                 annotation(smoothOrder=1);
              end interpolateInRegion2;
            algorithm
              // Determine upstream density and upstream viscosity
              rho     :=if m_flow >= 0 then rho_a else rho_b;
              mu      :=if m_flow >= 0 then mu_a else mu_b;

              // Determine Re, lambda2 and pressure drop
              Re := diameter*abs(m_flow)/(crossArea*mu);
              lambda2 := if Re <= Re1 then 64*Re else
                        (if Re >= Re2 then 0.25*(Re/Math.log10(Delta/3.7 + 5.74/Re^0.9))^2 else
                         interpolateInRegion2(Re, Re1, Re2, Delta));
              dp :=length*mu*mu/(2*rho*diameter*diameter*diameter)*
                   (if m_flow >= 0 then lambda2 else -lambda2);
                      annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
            end pressureLoss_m_flow;

            redeclare function extends massFlowRate_dp_staticHead
              "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"

          protected
              Real Delta = roughness/diameter "Relative roughness";
              SI.ReynoldsNumber Re "Reynolds number";
              SI.ReynoldsNumber Re1 = min((745*exp(if Delta <= 0.0065 then 1 else 0.0065/Delta))^0.97, Re_turbulent)
                "Boundary between laminar regime and transition";
              SI.ReynoldsNumber Re2 = Re_turbulent
                "Boundary between transition and turbulent regime";
              SI.Pressure dp_a
                "Upper end of regularization domain of the m_flow(dp) relation";
              SI.Pressure dp_b
                "Lower end of regularization domain of the m_flow(dp) relation";
              SI.MassFlowRate m_flow_a
                "Value at upper end of regularization domain";
              SI.MassFlowRate m_flow_b
                "Value at lower end of regularization domain";

              SI.MassFlowRate dm_flow_ddp_fric_a
                "Derivative at upper end of regularization domain";
              SI.MassFlowRate dm_flow_ddp_fric_b
                "Derivative at lower end of regularization domain";

              SI.Pressure dp_grav_a = g_times_height_ab*rho_a
                "Static head if mass flows in design direction (a to b)";
              SI.Pressure dp_grav_b = g_times_height_ab*rho_b
                "Static head if mass flows against design direction (b to a)";

              // Properly define zero mass flow conditions
              SI.MassFlowRate m_flow_zero = 0;
              SI.Pressure dp_zero = (dp_grav_a + dp_grav_b)/2;
              Real dm_flow_ddp_fric_zero;

            algorithm
              dp_a := max(dp_grav_a, dp_grav_b)+dp_small;
              dp_b := min(dp_grav_a, dp_grav_b)-dp_small;

              if dp>=dp_a then
                // Positive flow outside regularization
                m_flow := Internal.m_flow_of_dp_fric(dp-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
              elseif dp<=dp_b then
                // Negative flow outside regularization
                m_flow := Internal.m_flow_of_dp_fric(dp-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
              else
                // Regularization parameters
                (m_flow_a, dm_flow_ddp_fric_a) := Internal.m_flow_of_dp_fric(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
                (m_flow_b, dm_flow_ddp_fric_b) := Internal.m_flow_of_dp_fric(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
                // Include a properly defined zero mass flow point
                // Obtain a suitable slope from the linear section slope c (value of m_flow is overwritten later)
                (m_flow, dm_flow_ddp_fric_zero) := Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
                // Do regularization
                if dp>dp_zero then
                  m_flow := Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a);
                else
                  m_flow := Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero);
                end if;
              end if;
              annotation (smoothOrder=1);
            end massFlowRate_dp_staticHead;

            redeclare function extends pressureLoss_m_flow_staticHead
              "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"

          protected
              Real Delta = roughness/diameter "Relative roughness";
              SI.ReynoldsNumber Re1 = min(745*exp(if Delta <= 0.0065 then 1 else 0.0065/Delta), Re_turbulent)
                "Boundary between laminar regime and transition";
              SI.ReynoldsNumber Re2 = Re_turbulent
                "Boundary between transition and turbulent regime";

              SI.MassFlowRate m_flow_a
                "Upper end of regularization domain of the dp(m_flow) relation";
              SI.MassFlowRate m_flow_b
                "Lower end of regularization domain of the dp(m_flow) relation";

              SI.Pressure dp_a "Value at upper end of regularization domain";
              SI.Pressure dp_b "Value at lower end of regularization domain";

              SI.Pressure dp_grav_a = g_times_height_ab*rho_a
                "Static head if mass flows in design direction (a to b)";
              SI.Pressure dp_grav_b = g_times_height_ab*rho_b
                "Static head if mass flows against design direction (b to a)";

              Real ddp_dm_flow_a
                "Derivative of pressure drop with mass flow rate at m_flow_a";
              Real ddp_dm_flow_b
                "Derivative of pressure drop with mass flow rate at m_flow_b";

              // Properly define zero mass flow conditions
              SI.MassFlowRate m_flow_zero = 0;
              SI.Pressure dp_zero = (dp_grav_a + dp_grav_b)/2;
              Real ddp_dm_flow_zero;

            algorithm
              m_flow_a := if dp_grav_a<dp_grav_b then
                Internal.m_flow_of_dp_fric(dp_grav_b - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)+m_flow_small else
                m_flow_small;
              m_flow_b := if dp_grav_a<dp_grav_b then
                Internal.m_flow_of_dp_fric(dp_grav_a - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)-m_flow_small else
                -m_flow_small;

              if m_flow>=m_flow_a then
                // Positive flow outside regularization
                dp := Internal.dp_fric_of_m_flow(m_flow, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta) + dp_grav_a;
              elseif m_flow<=m_flow_b then
                // Negative flow outside regularization
                dp := Internal.dp_fric_of_m_flow(m_flow, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta) + dp_grav_b;
              else
                // Regularization parameters
                (dp_a, ddp_dm_flow_a) := Internal.dp_fric_of_m_flow(m_flow_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
                dp_a := dp_a + dp_grav_a "Adding dp_grav to dp_fric to get dp";
                (dp_b, ddp_dm_flow_b) := Internal.dp_fric_of_m_flow(m_flow_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
                dp_b := dp_b + dp_grav_b "Adding dp_grav to dp_fric to get dp";
                // Include a properly defined zero mass flow point
                // Obtain a suitable slope from the linear section slope c (value of dp is overwritten later)
                (dp, ddp_dm_flow_zero) := Utilities.regFun3(m_flow_zero, m_flow_b, m_flow_a, dp_b, dp_a, ddp_dm_flow_b, ddp_dm_flow_a);
                // Do regularization
                if m_flow>m_flow_zero then
                  dp := Utilities.regFun3(m_flow, m_flow_zero, m_flow_a, dp_zero, dp_a, ddp_dm_flow_zero, ddp_dm_flow_a);
                else
                  dp := Utilities.regFun3(m_flow, m_flow_b, m_flow_zero, dp_b, dp_zero, ddp_dm_flow_b, ddp_dm_flow_zero);
                end if;
              end if;
              annotation (smoothOrder=1);
            end pressureLoss_m_flow_staticHead;

          package Internal
            "Functions to calculate mass flow rate from friction pressure drop and vice versa"
            extends Modelica.Icons.InternalPackage;

            function m_flow_of_dp_fric
                "Calculate mass flow rate as function of pressure drop due to friction"
              extends Modelica.Icons.Function;

              input SI.Pressure dp_fric
                  "Pressure loss due to friction (dp = port_a.p - port_b.p)";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                  "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                  "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.Area crossArea "Inner cross section area";
              input SI.ReynoldsNumber Re1
                  "Boundary between laminar regime and transition";
              input SI.ReynoldsNumber Re2
                  "Boundary between transition and turbulent regime";
              input Real Delta "Relative roughness";
              output SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              output Real dm_flow_ddp_fric
                  "Derivative of mass flow rate with dp_fric";

          protected
              function interpolateInRegion2_withDerivative
                  "Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(lambda2), y=log10(Re)"
                extends Modelica.Icons.Function;

                input Real lambda2 "Known independent variable";
                input SI.ReynoldsNumber Re1
                    "Boundary between laminar regime and transition";
                input SI.ReynoldsNumber Re2
                    "Boundary between transition and turbulent regime";
                input Real Delta "Relative roughness";
                input SI.Pressure dp_fric
                    "Pressure loss due to friction (dp = port_a.p - port_b.p)";
                output SI.ReynoldsNumber Re "Unknown return variable";
                output Real dRe_ddp "Derivative of return value";
                // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
                Real x1=log10(64*Re1);
                Real y1=log10(Re1);
                Real y1d=1;

                // Point lg(lambda2(Re2)) with derivative at lg(Re2)
                Real aux2=Delta/3.7 + 5.74/Re2^0.9;
                Real aux3=log10(aux2);
                Real L2=0.25*(Re2/aux3)^2;
                Real aux4=2.51/sqrt(L2) + 0.27*Delta;
                Real aux5=-2*sqrt(L2)*log10(aux4);
                Real x2=log10(L2);
                Real y2=log10(aux5);
                Real y2d=0.5 + (2.51/log(10))/(aux5*aux4);

                // Point of interest in transformed space
                Real x=log10(lambda2);
                Real y;
                Real dy_dx "Derivative in transformed space";
              algorithm
                // Interpolation
                (y, dy_dx) := Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);

                // Return value
                Re := 10^y;

                // Derivative of return value
                dRe_ddp := Re/abs(dp_fric)*dy_dx;
                annotation (smoothOrder=1);
              end interpolateInRegion2_withDerivative;

              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
              SI.ReynoldsNumber Re "Reynolds number";
              Real dRe_ddp "dRe/ddp";
              Real aux1;
              Real aux2;

            algorithm
              // Determine upstream density and upstream viscosity
              if dp_fric >= 0 then
                rho := rho_a;
                mu  := mu_a;
              else
                rho := rho_b;
                mu  := mu_b;
              end if;

              // Positive mass flow rate
              lambda2 := abs(dp_fric)*2*diameter^3*rho/(length*mu*mu)
                  "Known as lambda2=f(dp)";

              aux1:=(2*diameter^3*rho)/(length*mu^2);

              // Determine Re and dRe/ddp under the assumption of laminar flow
              Re := lambda2/64 "Hagen-Poiseuille";
              dRe_ddp := aux1/64 "Hagen-Poiseuille";

              // Modify Re, if turbulent flow
              if Re > Re1 then
                Re :=-2*sqrt(lambda2)*log10(2.51/sqrt(lambda2) + 0.27*Delta)
                    "Colebrook-White";
                aux2 := sqrt(aux1*abs(dp_fric));
                dRe_ddp := 1/log(10)*(-2*log(2.51/aux2+0.27*Delta)*aux1/(2*aux2)+2*2.51/(2*abs(dp_fric)*(2.51/aux2+0.27*Delta)));
                if Re < Re2 then
                  (Re, dRe_ddp) := interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
                end if;
              end if;

              // Determine mass flow rate
              m_flow := crossArea/diameter*mu*(if dp_fric >= 0 then Re else -Re);
              // Determine derivative of mass flow rate with dp_fric
              dm_flow_ddp_fric := crossArea/diameter*mu*dRe_ddp;
              annotation(smoothOrder=1);
            end m_flow_of_dp_fric;

            function dp_fric_of_m_flow
                "Calculate pressure drop due to friction as function of mass flow rate"
              extends Modelica.Icons.Function;

              input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                  "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                  "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.Area crossArea "Inner cross section area";
              input SI.ReynoldsNumber Re1
                  "Boundary between laminar regime and transition";
              input SI.ReynoldsNumber Re2
                  "Boundary between transition and turbulent regime";
              input Real Delta "Relative roughness";
              output SI.Pressure dp_fric
                  "Pressure loss due to friction (dp_fric = port_a.p - port_b.p - dp_grav)";
              output Real ddp_fric_dm_flow
                  "Derivative of pressure drop with mass flow rate";

          protected
              function interpolateInRegion2
                  "Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(Re), y=log10(lambda2)"
                extends Modelica.Icons.Function;

                input SI.ReynoldsNumber Re "Known independent variable";
                input SI.ReynoldsNumber Re1
                    "Boundary between laminar regime and transition";
                input SI.ReynoldsNumber Re2
                    "Boundary between transition and turbulent regime";
                input Real Delta "Relative roughness";
                input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
                output Real lambda2 "Unknown return value";
                output Real dlambda2_dm_flow "Derivative of return value";
                // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
                Real x1 = log10(Re1);
                Real y1 = log10(64*Re1);
                Real y1d = 1;

                // Point lg(lambda2(Re2)) with derivative at lg(Re2)
                Real aux2 = Delta/3.7 + 5.74/Re2^0.9;
                Real aux3 = log10(aux2);
                Real L2 = 0.25*(Re2/aux3)^2;
                Real x2 = log10(Re2);
                Real y2 = log10(L2);
                Real y2d = 2+(2*5.74*0.9)/(log(aux2)*Re2^0.9*aux2);

                // Point of interest in transformed space
                Real x=log10(Re);
                Real y;
                Real dy_dx "Derivative in transformed space";
              algorithm
                // Interpolation
                (y, dy_dx) := Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);

                // Return value
                lambda2 := 10^y;

                // Derivative of return value
                dlambda2_dm_flow := lambda2/abs(m_flow)*dy_dx;
                annotation(smoothOrder=1);
              end interpolateInRegion2;

              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              SI.ReynoldsNumber Re "Reynolds number";
              Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
              Real dlambda2_dm_flow "dlambda2/dm_flow";
              Real aux1;
              Real aux2;

            algorithm
              // Determine upstream density and upstream viscosity
              if m_flow >= 0 then
                rho := rho_a;
                mu  := mu_a;
              else
                rho := rho_b;
                mu  := mu_b;
              end if;

              // Determine Reynolds number
              Re := abs(m_flow)*diameter/(crossArea*mu);

              aux1 := diameter/(crossArea*mu);

              // Use correlation for lambda2 depending on actual conditions
              if Re <= Re1 then
                lambda2 := 64*Re "Hagen-Poiseuille";
                dlambda2_dm_flow := 64*aux1 "Hagen-Poiseuille";
              elseif Re >= Re2 then
                lambda2 := 0.25*(Re/log10(Delta/3.7 + 5.74/Re^0.9))^2 "Swamee-Jain";
                aux2 := Delta/3.7+5.74/((aux1*abs(m_flow))^0.9);
                dlambda2_dm_flow := 0.5*aux1*Re*log(10)^2*(1/(log(aux2)^2)+(5.74*0.9)/(log(aux2)^3*Re^0.9*aux2))
                    "Swamee-Jain";
              else
                (lambda2, dlambda2_dm_flow) := interpolateInRegion2(Re, Re1, Re2, Delta, m_flow);
              end if;

              // Compute pressure drop from lambda2
              dp_fric :=length*mu*mu/(2*rho*diameter*diameter*diameter)*
                   (if m_flow >= 0 then lambda2 else -lambda2);

              // Compute derivative from dlambda2/dm_flow
              ddp_fric_dm_flow := (length*mu^2)/(2*diameter^3*rho)*dlambda2_dm_flow;
              annotation(smoothOrder=1);
            end dp_fric_of_m_flow;
          end Internal;
            annotation (Documentation(info="<html>
<p>
This component defines the complete regime of wall friction.
The details are described in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a>.
The functional relationship of the friction loss factor &lambda; is
displayed in the next figure. Function massFlowRate_dp() defines the \"red curve\"
(\"Swamee and Jain\"), where as function pressureLoss_m_flow() defines the
\"blue curve\" (\"Colebrook-White\"). The two functions are inverses from
each other and give slightly different results in the transition region
between Re = 1500 .. 4000, in order to get explicit equations without
solving a non-linear equation.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction1.png\"
     alt=\"PipeFriction1.png\">
</p>

<p>
Additionally to wall friction, this component properly implements static
head. With respect to the latter, two cases can be distinguished. In the case
shown next, the change of elevation with the path from a to b has the opposite
sign of the change of density.</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFrictionStaticHead_case-a.png\"
     alt=\"PipeFrictionStaticHead_case-a.png\">
</p>

<p>
In the case illustrated second, the change of elevation with the path from a to
b has the same sign of the change of density.</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFrictionStaticHead_case-b.png\"
     alt=\"PipeFrictionStaticHead_case-b.png\">
</p>

</html>"));
          end Detailed;
          annotation (Documentation(info="<html>
<p>
This package provides functions to compute
pressure losses due to <strong>wall friction</strong> in a pipe.
Every correlation is defined by a package that is derived
by inheritance from the package WallFriction.PartialWallFriction.
The details of the underlying pipe wall friction model are described in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a>.
Basically, different variants of the equation
</p>

<pre>
   dp = &lambda;(Re,<font face=\"Symbol\">D</font>)*(L/D)*&rho;*v*|v|/2
</pre>

<p>
are used, where the friction loss factor &lambda; is shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction1.png\"
     alt=\"PipeFriction1.png\">
</p>

</html>"));
        end WallFriction;
      end BaseClasses;
      annotation (Documentation(info="<html>

</html>"));
    end Pipes;

    package Interfaces
    "Interfaces for steady state and unsteady, mixed-phase, multi-substance, incompressible and compressible flow"
      extends Modelica.Icons.InterfacesPackage;

      connector FluidPort
        "Interface for quasi one-dimensional fluid flow in a piping network (incompressible or compressible, one or more phases, one or more substances)"

        replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
          "Medium model" annotation (choicesAllMatching=true);

        flow Medium.MassFlowRate m_flow
          "Mass flow rate from the connection point into the component";
        Medium.AbsolutePressure p "Thermodynamic pressure in the connection point";
        stream Medium.SpecificEnthalpy h_outflow
          "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        stream Medium.MassFraction Xi_outflow[Medium.nXi]
          "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        stream Medium.ExtraProperty C_outflow[Medium.nC]
          "Properties c_i/m close to the connection point if m_flow < 0";
      end FluidPort;

      connector FluidPort_a "Generic fluid connector at design inlet"
        extends FluidPort;
        annotation (defaultComponentName="port_a",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Ellipse(
                extent={{-40,40},{40,-40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Text(extent={{-150,110},{150,50}},
                  textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{-100,100},{100,-100}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_a;

      connector FluidPort_b "Generic fluid connector at design outlet"
        extends FluidPort;
        annotation (defaultComponentName="port_b",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Ellipse(
                extent={{-40,40},{40,-40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(extent={{-150,110},{150,50}}, textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={
              Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-100,100},{100,-100}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-80,80},{80,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_b;

      connector FluidPorts_a
        "Fluid connector with filled, large icon to be used for vectors of FluidPorts (vector dimensions must be added after dragging)"
        extends FluidPort;
        annotation (defaultComponentName="ports_a",
                    Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Text(extent={{-75,130},{75,100}}, textString="%name"),
              Rectangle(
                extent={{25,-100},{-25,100}},
                lineColor={0,127,255}),
              Ellipse(
                extent={{-25,90},{25,40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,25},{25,-25}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,-40},{25,-90}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}),
             Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{50,-200},{-50,200}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,180},{50,80}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,50},{50,-50}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,-80},{50,-180}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPorts_a;

      connector FluidPorts_b
        "Fluid connector with outlined, large icon to be used for vectors of FluidPorts (vector dimensions must be added after dragging)"
        extends FluidPort;
        annotation (defaultComponentName="ports_b",
                    Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Text(extent={{-75,130},{75,100}}, textString="%name"),
              Rectangle(
                extent={{-25,100},{25,-100}}),
              Ellipse(
                extent={{-25,90},{25,40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,25},{25,-25}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,-40},{25,-90}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,-50},{15,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,15},{15,-15}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,50},{15,80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
             Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{-50,200},{50,-200}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,180},{50,80}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,50},{50,-50}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,-80},{50,-180}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,100},{30,160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,-100},{30,-160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPorts_b;
      annotation (Documentation(info="<html>

</html>",     revisions="<html>
<ul>
<li><em>June 9th, 2008</em>
       by Michael Sielemann: Introduced stream keyword after decision at 57th Design Meeting (Lund).</li>
<li><em>May 30, 2007</em>
       by Christoph Richter: moved everything back to its original position in Modelica.Fluid.</li>
<li><em>Apr. 20, 2007</em>
       by Christoph Richter: moved parts of the original package from Modelica.Fluid
       to the development branch of Modelica 2.2.2.</li>
<li><em>Nov. 2, 2005</em>
       by Francesco Casella: restructured after 45th Design Meeting.</li>
<li><em>Nov. 20-21, 2002</em>
       by Hilding Elmqvist, Mike Tiller, Allan Watson, John Batteh, Chuck Newman,
       Jonas Eborn: Improved at the 32nd Modelica Design Meeting.
<li><em>Nov. 11, 2002</em>
       by Hilding Elmqvist, Martin Otter: improved version.</li>
<li><em>Nov. 6, 2002</em>
       by Hilding Elmqvist: first version.</li>
<li><em>Aug. 11, 2002</em>
       by Martin Otter: Improved according to discussion with Hilding
       Elmqvist and Hubertus Tummescheit.<br>
       The PortVicinity model is manually
       expanded in the base models.<br>
       The Volume used for components is renamed
       PartialComponentVolume.<br>
       A new volume model \"Fluid.Components.PortVolume\"
       introduced that has the medium properties of the port to which it is
       connected.<br>
       Fluid.Interfaces.PartialTwoPortTransport is a component
       for elementary two port transport elements, whereas PartialTwoPort
       is a component for a container component.</li>
</ul>
</html>"));
    end Interfaces;

    package Types "Common types for fluid models"
      extends Modelica.Icons.TypesPackage;

      type Dynamics = enumeration(
        DynamicFreeInitial
            "DynamicFreeInitial -- Dynamic balance, Initial guess value",
        FixedInitial   "FixedInitial -- Dynamic balance, Initial value fixed",
        SteadyStateInitial
            "SteadyStateInitial -- Dynamic balance, Steady state initial with guess value",
        SteadyState   "SteadyState -- Steady state balance, Initial guess value")
        "Enumeration to define definition of balance equations"
      annotation (Documentation(info="<html>
<p>
Enumeration to define the formulation of balance equations
(to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><strong>Dynamics.</strong></th><th><strong>Meaning</strong></th></tr>
<tr><td>DynamicFreeInitial</td><td>Dynamic balance, Initial guess value</td></tr>

<tr><td>FixedInitial</td><td>Dynamic balance, Initial value fixed</td></tr>

<tr><td>SteadyStateInitial</td><td>Dynamic balance, Steady state initial with guess value</td></tr>

<tr><td>SteadyState</td><td>Steady state balance, Initial guess value</td></tr>
</table>

<p>
The enumeration \"Dynamics\" is used for the mass, energy and momentum balance equations
respectively. The exact meaning for the three balance equations is stated in the following
tables:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><strong>Mass balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> <strong>if</strong> Medium.singleState <strong>then</strong><br>
         &nbsp;&nbsp;no initial condition<br>
         <strong>else</strong> p=p_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>if</strong> Medium.singleState <strong>then</strong><br>
         &nbsp;&nbsp;no initial condition<br>
         <strong>else</strong> <strong>der</strong>(p)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(m)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><strong>Energy balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> T=T_start or h=h_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>der</strong>(T)=0 or <strong>der</strong>(h)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(U)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><strong>Momentum balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> m_flow = m_flow_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>der</strong>(m_flow)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(m_flow)=0 </td>
    <td> no initial conditions </td></tr>
</table>

<p>
In the tables above, the equations are given for one-substance fluids. For multiple-substance
fluids and for trace substances, equivalent equations hold.
</p>

<p>
Medium.singleState is a medium property and defines whether the medium is only
described by one state (+ the mass fractions in case of a multi-substance fluid). In such
a case one initial condition less must be provided. For example, incompressible
media have Medium.singleState = <strong>true</strong>.
</p>

</html>"));

      type PortFlowDirection = enumeration(
        Entering   "Fluid flow is only entering",
        Leaving   "Fluid flow is only leaving",
        Bidirectional   "No restrictions on fluid flow (flow reversal possible)")
        "Enumeration to define whether flow reversal is allowed" annotation (
          Documentation(info="<html>

<p>
Enumeration to define the assumptions on the model for the
direction of fluid flow at a port (to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><strong>PortFlowDirection.</strong></th>
    <th><strong>Meaning</strong></th></tr>

<tr><td>Entering</td>
    <td>Fluid flow is only entering the port from the outside</td></tr>

<tr><td>Leaving</td>
    <td>Fluid flow is only leaving the port to the outside</td></tr>

<tr><td>Bidirectional</td>
    <td>No restrictions on fluid flow (flow reversal possible)</td></tr>
</table>

<p>
The default is \"PortFlowDirection.Bidirectional\". If you are completely sure that
the flow is only in one direction, then the other settings may
make the simulation of your model faster.
</p>

</html>"));
      annotation (preferredView="info",
                  Documentation(info="<html>

</html>"));
    end Types;

    package Utilities
    "Utility models to construct fluid components (should not be used directly)"
      extends Modelica.Icons.UtilitiesPackage;

      function checkBoundary "Check whether boundary definition is correct"
        extends Modelica.Icons.Function;
        input String mediumName;
        input String substanceNames[:] "Names of substances";
        input Boolean singleState;
        input Boolean define_p;
        input Real X_boundary[:];
        input String modelName = "??? boundary ???";
    protected
        Integer nX = size(X_boundary,1);
        String X_str;
      algorithm
        assert(not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""     + modelName + "\":
The selected medium \""     + mediumName + "\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");

        for i in 1:nX loop
          assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""
      + mediumName + "\" in model \"" + modelName + "\":
The boundary value X_boundary("   + String(i) + ") = " + String(
            X_boundary[i]) + "
is negative. It must be positive.
");     end for;

        if nX > 0 and abs(sum(X_boundary) - 1.0) > 1e-10 then
           X_str :="";
           for i in 1:nX loop
              X_str :=X_str + "   X_boundary[" + String(i) + "] = " + String(X_boundary[
              i]) + " \"" + substanceNames[i] + "\"\n";
           end for;
           Modelica.Utilities.Streams.error(
              "The boundary mass fractions in medium \"" + mediumName + "\" in model \"" + modelName + "\"\n" +
              "do not sum up to 1. Instead, sum(X_boundary) = " + String(sum(X_boundary)) + ":\n"
              + X_str);
        end if;
      end checkBoundary;

      function regStep
        "Approximation of a general step, such that the characteristic is continuous and differentiable"
        extends Modelica.Icons.Function;
        input Real x "Abscissa value";
        input Real y1 "Ordinate value for x > 0";
        input Real y2 "Ordinate value for x < 0";
        input Real x_small(min=0) = 1e-5
          "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
        output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
      algorithm
        y := smooth(1, if x >  x_small then y1 else
                       if x < -x_small then y2 else
                       if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);
        annotation(Documentation(revisions="<html>
<ul>
<li><em>April 29, 2008</em>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><em>August 12, 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",       info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <strong>if</strong> x &gt; 0 <strong>then</strong> y1 <strong>else</strong> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> y1 <strong>else</strong>
                 <strong>if</strong> x &lt; -x_small <strong>then</strong> y2 <strong>else</strong> f(y1, y2));
</pre>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>
</html>"));
      end regStep;

      function regFun3 "Co-monotonic and C1 smooth regularization function"
        extends Modelica.Icons.Function;

        input Real x "Abscissa value";
        input Real x0 "Lower abscissa value";
        input Real x1 "Upper abscissa value";
        input Real y0 "Ordinate value at lower abscissa value";
        input Real y1 "Ordinate value at upper abscissa value";
        input Real y0d "Derivative at lower abscissa value";
        input Real y1d "Derivative at upper abscissa value";

        output Real y "Ordinate value";
        output Real c
          "Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used";

    protected
        Real h0 "Width of interval i=0";
        Real Delta0 "Slope of secant on interval i=0";
        Real xstar "Inflection point of cubic polynomial S0";
        Real mu "Distance of inflection point and left limit x0";
        Real eta "Distance of right limit x1 and inflection point";
        Real omega "Slope of cubic polynomial S0 at inflection point";
        Real rho "Weighting factor of eta and eta_tilde, mu and mu_tilde";
        Real theta0 "Slope metric";
        Real mu_tilde "Distance of start of linear section and left limit x0";
        Real eta_tilde "Distance of right limit x1 and end of linear section";
        Real xi1 "Start of linear section";
        Real xi2 "End of linear section";
        Real a1 "Leading coefficient of cubic on the left";
        Real a2 "Leading coefficient of cubic on the right";
        Real const12 "Integration constant of left cubic, linear section";
        Real const3 "Integration constant of right cubic";
        Real aux01;
        Real aux02;
        Boolean useSingleCubicPolynomial=false
          "Indicate to override further logic and use single cubic";
      algorithm
        // Check arguments: Data point position
        assert(x0 < x1, "regFun3(): Data points not sorted appropriately (x0 = " +
          String(x0) + " > x1 = " + String(x1) + "). Please flip arguments.");
        // Check arguments: Data point derivatives
        if y0d*y1d >= 0 then
          // Derivatives at data points allow co-monotone interpolation, nothing to do
        else
          // Strictly speaking, derivatives at data points do not allow co-monotone interpolation, however, they may be numerically zero so assert this
          assert(abs(y0d)<Modelica.Constants.eps or abs(y1d)<Modelica.Constants.eps, "regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = " +
          String(y0d) + ", y1d = " + String(y1d) + "). Please correct arguments.");
        end if;

        h0 := x1 - x0;
        Delta0 := (y1 - y0)/h0;

        if abs(Delta0) <= 0 then
          // Points (x0,y0) and (x1,y1) on horizontal line
          // Degenerate case as we cannot fulfill the C1 goal an comonotone behaviour at the same time
          y := y0 + Delta0*(x-x0);     // y == y0 == y1 with additional term to assist automatic differentiation
          c := 0;
        elseif abs(y1d + y0d - 2*Delta0) < 100*Modelica.Constants.eps then
          // Inflection point at +/- infinity, thus S0 is co-monotone and can be returned directly
          y := y0 + (x-x0)*(y0d + (x-x0)/h0*( (-2*y0d-y1d+3*Delta0) + (x-x0)*(y0d+y1d-2*Delta0)/h0));
          // Provide a "dummy linear section slope" as the slope of the cubic at x:=(x0+x1)/2
          aux01 := (x0 + x1)/2;
          c := 3*(y0d + y1d - 2*Delta0)*(aux01 - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*Delta0)*(aux01 - x0)/h0
             + y0d;
        else
          // Points (x0,y0) and (x1,y1) not on horizontal line and inflection point of S0 not at +/- infinity
          // Do actual interpolation
          xstar := 1/3*(-3*x0*y0d - 3*x0*y1d + 6*x0*Delta0 - 2*h0*y0d - h0*y1d + 3*h0*
            Delta0)/(-y0d - y1d + 2*Delta0);
          mu := xstar - x0;
          eta := x1 - xstar;
          omega := 3*(y0d + y1d - 2*Delta0)*(xstar - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*
            Delta0)*(xstar - x0)/h0 + y0d;

          aux01 := 0.25*sign(Delta0)*min(abs(omega), abs(Delta0))
            "Slope c if not using plain cubic S0";
          if abs(y0d - y1d) <= 100*Modelica.Constants.eps then
            // y0 == y1 (value and sign equal) -> resolve indefinite 0/0
            aux02 := y0d;
            if y1 > y0 + y0d*(x1 - x0) then
              // If y1 is above the linear extension through (x0/y0)
              // with slope y0d (when slopes are identical)
              //  -> then always used single cubic polynomial
              useSingleCubicPolynomial := true;
            end if;
          elseif abs(y1d + y0d - 2*Delta0) < 100*Modelica.Constants.eps then
            // (y1d+y0d-2*Delta0) approximately 0 -> avoid division by 0
            aux02 := (6*Delta0*(y1d + y0d - 3/2*Delta0) - y1d*y0d - y1d^2 - y0d^2)*(
              if (y1d + y0d - 2*Delta0) >= 0 then 1 else -1)*Modelica.Constants.inf;
          else
            // Okay, no guarding necessary
            aux02 := (6*Delta0*(y1d + y0d - 3/2*Delta0) - y1d*y0d - y1d^2 - y0d^2)/(3*
              (y1d + y0d - 2*Delta0));
          end if;

          //aux02 := -1/3*(y0d^2+y0d*y1d-6*y0d*Delta0+y1d^2-6*y1d*Delta0+9*Delta0^2)/(y0d+y1d-2*Delta0);
          //aux02 := -1/3*(6*y1d*y0*x1+y0d*y1d*x1^2-6*y0d*x0*y0+y0d^2*x0^2+y0d^2*x1^2+y1d^2*x1^2+y1d^2*x0^2-2*y0d*x0*y1d*x1-2*x0*y0d^2*x1+y0d*y1d*x0^2+6*y0d*x0*y1-6*y0d*y1*x1+6*y0d*y0*x1-2*x0*y1d^2*x1-6*y1d*y1*x1+6*y1d*x0*y1-6*y1d*x0*y0-18*y1*y0+9*y1^2+9*y0^2)/(y0d*x1^2-2*x0*y0d*x1+y1d*x1^2-2*x0*y1d*x1-2*y1*x1+2*y0*x1+y0d*x0^2+y1d*x0^2+2*x0*y1-2*x0*y0);

          // Test criteria (also used to avoid saddle points that lead to integrator contraction):
          //
          //  1. Cubic is not monotonic (from Gasparo Morandi)
          //       ((mu > 0) and (eta < h0) and (Delta0*omega <= 0))
          //
          //  2. Cubic may be monotonic but the linear section slope c is either too close
          //     to zero or the end point of the linear section is left of the start point
          //     Note however, that the suggested slope has to have the same sign as Delta0.
          //       (abs(aux01)<abs(aux02) and aux02*Delta0>=0)
          //
          //  3. Cubic may be monotonic but the resulting slope in the linear section
          //     is too close to zero (less than 1/10 of Delta0).
          //       (c < Delta0 / 10)
          //
          if (((mu > 0) and (eta < h0) and (Delta0*omega <= 0)) or (abs(aux01) < abs(
              aux02) and aux02*Delta0 >= 0) or (abs(aux01) < abs(0.1*Delta0))) and
              not useSingleCubicPolynomial then
            // NOT monotonic using plain cubic S0, use piecewise function S0 tilde instead
            c := aux01;
            // Avoid saddle points that are co-monotonic but lead to integrator contraction
            if abs(c) < abs(aux02) and aux02*Delta0 >= 0 then
              c := aux02;
            end if;
            if abs(c) < abs(0.1*Delta0) then
              c := 0.1*Delta0;
            end if;
            theta0 := (y0d*mu + y1d*eta)/h0;
            if abs(theta0 - c) < 1e-6 then
              // Slightly reduce c in order to avoid ill-posed problem
              c := (1 - 1e-6)*theta0;
            end if;
            rho := 3*(Delta0 - c)/(theta0 - c);
            mu_tilde := rho*mu;
            eta_tilde := rho*eta;
            xi1 := x0 + mu_tilde;
            xi2 := x1 - eta_tilde;
            a1 := (y0d - c)/max(mu_tilde^2, 100*Modelica.Constants.eps);
            a2 := (y1d - c)/max(eta_tilde^2, 100*Modelica.Constants.eps);
            const12 := y0 - a1/3*(x0 - xi1)^3 - c*x0;
            const3 := y1 - a2/3*(x1 - xi2)^3 - c*x1;
            // Do actual interpolation
            if (x < xi1) then
              y := a1/3*(x - xi1)^3 + c*x + const12;
            elseif (x < xi2) then
              y := c*x + const12;
            else
              y := a2/3*(x - xi2)^3 + c*x + const3;
            end if;
          else
            // Cubic S0 is monotonic, use it as is
            y := y0 + (x-x0)*(y0d + (x-x0)/h0*( (-2*y0d-y1d+3*Delta0) + (x-x0)*(y0d+y1d-2*Delta0)/h0));
            // Provide a "dummy linear section slope" as the slope of the cubic at x:=(x0+x1)/2
            aux01 := (x0 + x1)/2;
            c := 3*(y0d + y1d - 2*Delta0)*(aux01 - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*Delta0)*(aux01 - x0)/h0
               + y0d;
          end if;
        end if;

        annotation (smoothOrder=1, Documentation(revisions="<html>
<ul>
<li><em>May 2008</em> by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>Designed and implemented.</li>
<li><em>February 2011</em> by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>If the inflection point of the cubic S0 was at +/- infinity, the test criteria of <em>[Gasparo and Morandi, 1991]</em> result in division by zero. This case is handled properly now.</li>
<li><em>March 2013</em> by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>If the arguments prescribed a degenerate case with points <code>(x0,y0)</code> and <code>(x1,y1)</code> on horizontal line, then return value <code>c</code> was undefined. This was corrected. Furthermore, an additional term was included for the computation of <code>y</code> in this case to assist automatic differentiation.</li>
</ul>
</html>",       info="<html>
<p>
Approximates a function in a region between <code>x0</code> and <code>x1</code>
such that
</p>
<ul>
<li> The overall function is continuous with a
     continuous first derivative everywhere.</li>
<li> The function is co-monotone with the given
     data points.</li>
</ul>
<p>
In this region, a continuation is constructed from the given points
<code>(x0, y0)</code>, <code>(x1, y1)</code> and the respective
derivatives. For this purpose, a single polynomial of third order or two
cubic polynomials with a linear section in between are used <em>[Gasparo
and Morandi, 1991]</em>. This algorithm was extended with two additional
conditions to avoid saddle points with zero/infinite derivative that lead to
integrator step size reduction to zero.
</p>
<p>
This function was developed for pressure loss correlations properly
addressing the static head on top of the established requirements
for monotonicity and smoothness. In this case, the present function
allows to implement the exact solution in the limit of
<code>x1-x0 -> 0</code> or <code>y1-y0 -> 0</code>.
</p>
<p>
Typical screenshots for two different configurations
are shown below. The first one illustrates five different settings of <code>xi</code> and <code>yid</code>:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regFun3_a.png\"
      alt=\"regFun3_a.png\">
</p>
<p>
The second graph shows the continuous derivative of this regularization function:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regFun3_b.png\"
     alt=\"regFun3_a.png\">
</p>

<p>
<strong>Literature</strong>
</p>

<dl>
<dt> Gasparo M. G. and Morandi R. (1991):</dt>
<dd> <strong>Piecewise cubic monotone interpolation with assigned slopes</strong>.
     Computing, Vol. 46, Issue 4, December 1991, pp. 355 - 365.</dd>
</dl>
</html>"));
      end regFun3;

      function cubicHermite "Evaluate a cubic Hermite spline"
        extends Modelica.Icons.Function;

        input Real x "Abscissa value";
        input Real x1 "Lower abscissa value";
        input Real x2 "Upper abscissa value";
        input Real y1 "Lower ordinate value";
        input Real y2 "Upper ordinate value";
        input Real y1d "Lower gradient";
        input Real y2d "Upper gradient";
        output Real y "Interpolated ordinate value";
    protected
        Real h "Distance between x1 and x2";
        Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
        Real h00 "Basis function 00 of cubic Hermite spline";
        Real h10 "Basis function 10 of cubic Hermite spline";
        Real h01 "Basis function 01 of cubic Hermite spline";
        Real h11 "Basis function 11 of cubic Hermite spline";
        Real aux3 "t cube";
        Real aux2 "t square";
      algorithm
        h := x2 - x1;
        if abs(h)>0 then
          // Regular case
          t := (x - x1)/h;

          aux3 :=t^3;
          aux2 :=t^2;

          h00 := 2*aux3 - 3*aux2 + 1;
          h10 := aux3 - 2*aux2 + t;
          h01 := -2*aux3 + 3*aux2;
          h11 := aux3 - aux2;
          y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
        else
          // Degenerate case, x1 and x2 are identical, return step function
          y := (y1 + y2)/2;
        end if;
        annotation(smoothOrder=3, Documentation(revisions="<html>
<ul>
<li><em>May 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
      end cubicHermite;

      function cubicHermite_withDerivative
        "Evaluate a cubic Hermite spline, return value and derivative"
        extends Modelica.Icons.Function;

        input Real x "Abscissa value";
        input Real x1 "Lower abscissa value";
        input Real x2 "Upper abscissa value";
        input Real y1 "Lower ordinate value";
        input Real y2 "Upper ordinate value";
        input Real y1d "Lower gradient";
        input Real y2d "Upper gradient";
        output Real y "Interpolated ordinate value";
        output Real dy_dx "Derivative dy/dx at abscissa value x";
    protected
        Real h "Distance between x1 and x2";
        Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
        Real h00 "Basis function 00 of cubic Hermite spline";
        Real h10 "Basis function 10 of cubic Hermite spline";
        Real h01 "Basis function 01 of cubic Hermite spline";
        Real h11 "Basis function 11 of cubic Hermite spline";

        Real h00d "d/dt h00";
        Real h10d "d/dt h10";
        Real h01d "d/dt h01";
        Real h11d "d/dt h11";

        Real aux3 "t cube";
        Real aux2 "t square";
      algorithm
        h := x2 - x1;
        if abs(h)>0 then
          // Regular case
          t := (x - x1)/h;

          aux3 :=t^3;
          aux2 :=t^2;

          h00 := 2*aux3 - 3*aux2 + 1;
          h10 := aux3 - 2*aux2 + t;
          h01 := -2*aux3 + 3*aux2;
          h11 := aux3 - aux2;

          h00d := 6*(aux2 - t);
          h10d := 3*aux2 - 4*t + 1;
          h01d := 6*(t - aux2);
          h11d := 3*aux2 - 2*t;

          y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
          dy_dx := y1*h00d/h + y1d*h10d + y2*h01d/h + y2d*h11d;
        else
          // Degenerate case, x1 and x2 are identical, return step function
          y := (y1 + y2)/2;
          dy_dx := sign(y2 - y1)*Modelica.Constants.inf;
        end if;
        annotation(smoothOrder=3, Documentation(revisions="<html>
<ul>
<li><em>May 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
      end cubicHermite_withDerivative;
      annotation (Documentation(info="<html>

</html>"));
    end Utilities;
  annotation (Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}}),
          Line(points={{2,42},{2,-10}}),
          Rectangle(
            extent={{-18,50},{22,42}},
            fillPattern=FillPattern.Solid)}), preferredView="info",
    Documentation(info="<html>
<p>
Library <strong>Modelica.Fluid</strong> is a <strong>free</strong> Modelica package providing components for
<strong>1-dimensional thermo-fluid flow</strong> in networks of vessels, pipes, fluid machines, valves and fittings.
A unique feature is that the component equations and the media models
as well as pressure loss and heat transfer correlations are decoupled from each other.
All components are implemented such that they can be used for
media from the Modelica.Media library. This means especially that an
incompressible or compressible medium, a single or a multiple
substance medium with one or more phases might be used.
</p>

<p>
In the next figure, several features of the library are demonstrated with
a simple heating system with a closed flow cycle. By just changing one configuration parameter in the system object the equations are changed between steady-state and dynamic simulation with fixed or steady-state initial conditions.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/HeatingSystem.png\" border=\"1\"
     alt=\"HeatingSystem.png\">
</p>

<p>
With respect to previous versions, the design
of the connectors has been changed in a non-backward compatible way,
using the recently developed concept
of stream connectors that results in much more reliable simulations
(see also <a href=\"modelica://Modelica/Resources/Documentation/Fluid/Stream-Connectors-Overview-Rationale.pdf\">Stream-Connectors-Overview-Rationale.pdf</a>).
This extension was included in Modelica 3.1.
</p>

<p>
The following parts are useful, when newly starting with this library:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide\">Modelica.Fluid.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide.ReleaseNotes\">Modelica.Fluid.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Fluid.Examples\">Modelica.Fluid.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
Copyright &copy; 2002-2019, Modelica Association and contributors
</p>
</html>"));
  end Fluid;

  package Media "Library of media property models"
  extends Modelica.Icons.Package;
  import SI = Modelica.SIunits;
  import Cv = Modelica.SIunits.Conversions;

  package Interfaces "Interfaces for media models"
    extends Modelica.Icons.InterfacesPackage;

    partial package PartialMedium
      "Partial medium properties (base package of all media packages)"
      extends Modelica.Media.Interfaces.Types;
      extends Modelica.Icons.MaterialPropertiesPackage;

      // Constants to be set in Medium
      constant Modelica.Media.Interfaces.Choices.IndependentVariables
        ThermoStates "Enumeration type for independent variables";
      constant String mediumName="unusablePartialMedium" "Name of the medium";
      constant String substanceNames[:]={mediumName}
        "Names of the mixture substances. Set substanceNames={mediumName} if only one substance.";
      constant String extraPropertiesNames[:]=fill("", 0)
        "Names of the additional (extra) transported properties. Set extraPropertiesNames=fill(\"\",0) if unused";
      constant Boolean singleState
        "= true, if u and d are not a function of pressure";
      constant Boolean reducedX=true
        "= true if medium contains the equation sum(X) = 1.0; set reducedX=true if only one substance (see docu for details)";
      constant Boolean fixedX=false
        "= true if medium contains the equation X = reference_X";
      constant AbsolutePressure reference_p=101325
        "Reference pressure of Medium: default 1 atmosphere";
      constant Temperature reference_T=298.15
        "Reference temperature of Medium: default 25 deg Celsius";
      constant MassFraction reference_X[nX]=fill(1/nX, nX)
        "Default mass fractions of medium";
      constant AbsolutePressure p_default=101325
        "Default value for pressure of medium (for initialization)";
      constant Temperature T_default=Modelica.SIunits.Conversions.from_degC(20)
        "Default value for temperature of medium (for initialization)";
      constant SpecificEnthalpy h_default=specificEnthalpy_pTX(
              p_default,
              T_default,
              X_default)
        "Default value for specific enthalpy of medium (for initialization)";
      constant MassFraction X_default[nX]=reference_X
        "Default value for mass fractions of medium (for initialization)";
      constant ExtraProperty C_default[nC]=fill(0, nC)
        "Default value for trace substances of medium (for initialization)";

      final constant Integer nS=size(substanceNames, 1) "Number of substances";
      constant Integer nX=nS "Number of mass fractions";
      constant Integer nXi=if fixedX then 0 else if reducedX then nS - 1 else nS
        "Number of structurally independent mass fractions (see docu for details)";

      final constant Integer nC=size(extraPropertiesNames, 1)
        "Number of extra (outside of standard mass-balance) transported properties";
      constant Real C_nominal[nC](min=fill(Modelica.Constants.eps, nC)) = 1.0e-6*
        ones(nC) "Default for the nominal values for the extra properties";
      replaceable record FluidConstants =
          Modelica.Media.Interfaces.Types.Basic.FluidConstants
        "Critical, triple, molecular and other standard data of fluid";

      replaceable record ThermodynamicState
        "Minimal variable set that is available as input argument to every medium function"
        extends Modelica.Icons.Record;
      end ThermodynamicState;

      replaceable partial model BaseProperties
        "Base properties (p, d, T, h, u, R, MM and, if applicable, X and Xi) of a medium"
        InputAbsolutePressure p "Absolute pressure of medium";
        InputMassFraction[nXi] Xi(start=reference_X[1:nXi])
          "Structurally independent mass fractions";
        InputSpecificEnthalpy h "Specific enthalpy of medium";
        Density d "Density of medium";
        Temperature T "Temperature of medium";
        MassFraction[nX] X(start=reference_X)
          "Mass fractions (= (component mass)/total mass  m_i/m)";
        SpecificInternalEnergy u "Specific internal energy of medium";
        SpecificHeatCapacity R "Gas constant (of mixture if applicable)";
        MolarMass MM "Molar mass (of mixture or single fluid)";
        ThermodynamicState state
          "Thermodynamic state record for optional functions";
        parameter Boolean preferredMediumStates=false
          "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean standardOrderComponents=true
          "If true, and reducedX = true, the last element of X will be computed from the other ones";
        SI.Conversions.NonSIunits.Temperature_degC T_degC=
            Modelica.SIunits.Conversions.to_degC(T)
          "Temperature of medium in [degC]";
        SI.Conversions.NonSIunits.Pressure_bar p_bar=
            Modelica.SIunits.Conversions.to_bar(p)
          "Absolute pressure of medium in [bar]";

        // Local connector definition, used for equation balancing check
        connector InputAbsolutePressure = input SI.AbsolutePressure
          "Pressure as input signal connector";
        connector InputSpecificEnthalpy = input SI.SpecificEnthalpy
          "Specific enthalpy as input signal connector";
        connector InputMassFraction = input SI.MassFraction
          "Mass fraction as input signal connector";

      equation
        if standardOrderComponents then
          Xi = X[1:nXi];

          if fixedX then
            X = reference_X;
          end if;
          if reducedX and not fixedX then
            X[nX] = 1 - sum(Xi);
          end if;
          for i in 1:nX loop
            assert(X[i] >= -1.e-5 and X[i] <= 1 + 1.e-5, "Mass fraction X[" +
              String(i) + "] = " + String(X[i]) + "of substance " +
              substanceNames[i] + "\nof medium " + mediumName +
              " is not in the range 0..1");
          end for;

        end if;

        assert(p >= 0.0, "Pressure (= " + String(p) + " Pa) of medium \"" +
          mediumName + "\" is negative\n(Temperature = " + String(T) + " K)");
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}), Text(
                extent={{-152,164},{152,102}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
Model <strong>BaseProperties</strong> is a model within package <strong>PartialMedium</strong>
and contains the <strong>declarations</strong> of the minimum number of
variables that every medium model is supposed to support.
A specific medium inherits from model <strong>BaseProperties</strong> and provides
the equations for the basic properties.</p>
<p>
The BaseProperties model contains the following <strong>7+nXi variables</strong>
(nXi is the number of independent mass fractions defined in package
PartialMedium):
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>independent mass fractions m_i/m</td></tr>
  <tr><td>R</td>
      <td>J/kg.K</td>
      <td>gas constant</td></tr>
  <tr><td>M</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
<p>
In order to implement an actual medium model, one can extend from this
base model and add <strong>5 equations</strong> that provide relations among
these variables. Equations will also have to be added in order to
set all the variables within the ThermodynamicState record state.</p>
<p>
If standardOrderComponents=true, the full composition vector X[nX]
is determined by the equations contained in this base class, depending
on the independent mass fraction vector Xi[nXi].</p>
<p>Additional <strong>2 + nXi</strong> equations will have to be provided
when using the BaseProperties model, in order to fully specify the
thermodynamic conditions. The input connector qualifier applied to
p, h, and nXi indirectly declares the number of missing equations,
permitting advanced equation balance checking by Modelica tools.
Please note that this doesn't mean that the additional equations
should be connection equations, nor that exactly those variables
should be supplied, in order to complete the model.
For further information, see the Modelica.Media User's guide, and
Section 4.7 (Balanced Models) of the Modelica 3.0 specification.</p>
</html>"));
      end BaseProperties;

      replaceable partial function setState_pTX
        "Return thermodynamic state as function of p, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_pTX;

      replaceable partial function setState_phX
        "Return thermodynamic state as function of p, h and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_phX;

      replaceable partial function setState_psX
        "Return thermodynamic state as function of p, s and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_psX;

      replaceable partial function setState_dTX
        "Return thermodynamic state as function of d, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_dTX;

      replaceable partial function setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
        extends Modelica.Icons.Function;
        input Real x "m_flow or dp";
        input ThermodynamicState state_a "Thermodynamic state if x > 0";
        input ThermodynamicState state_b "Thermodynamic state if x < 0";
        input Real x_small(min=0)
          "Smooth transition in the region -x_small < x < x_small";
        output ThermodynamicState state
          "Smooth thermodynamic state for all x (continuous and differentiable)";
        annotation (Documentation(info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    state = <strong>if</strong> x &gt; 0 <strong>then</strong> state_a <strong>else</strong> state_b;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   state := <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> state_a <strong>else</strong>
                      <strong>if</strong> x &lt; -x_small <strong>then</strong> state_b <strong>else</strong> f(state_a, state_b));
</pre>

<p>
This is performed by applying function <strong>Media.Common.smoothStep</strong>(..)
on every element of the thermodynamic state record.
</p>

<p>
If <strong>mass fractions</strong> X[:] are approximated with this function then this can be performed
for all <strong>nX</strong> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(state.X) = 1, provided sum(state_a.X) = sum(state_b.X) = 1.
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise state.X is either state_a.X or state_b.X):
</p>

<pre>
    X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
    X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
       ...
    X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre>

<p>
or
</p>

<pre>
    X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
    X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
       ...
    X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
    c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre>

<p>
Summing all mass fractions together results in
</p>

<pre>
    sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
           = c*(1 - 1) + (1 + 1)/2
           = 1
</pre>

</html>"));
      end setSmoothState;

      replaceable partial function dynamicViscosity "Return dynamic viscosity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DynamicViscosity eta "Dynamic viscosity";
      end dynamicViscosity;

      replaceable partial function thermalConductivity
        "Return thermal conductivity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output ThermalConductivity lambda "Thermal conductivity";
      end thermalConductivity;

      replaceable function prandtlNumber "Return the Prandtl number"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output PrandtlNumber Pr "Prandtl number";
      algorithm
        Pr := dynamicViscosity(state)*specificHeatCapacityCp(state)/
          thermalConductivity(state);
      end prandtlNumber;

      replaceable partial function pressure "Return pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output AbsolutePressure p "Pressure";
      end pressure;

      replaceable partial function temperature "Return temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Temperature T "Temperature";
      end temperature;

      replaceable partial function density "Return density"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Density d "Density";
      end density;

      replaceable partial function specificEnthalpy "Return specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnthalpy h "Specific enthalpy";
      end specificEnthalpy;

      replaceable partial function specificInternalEnergy
        "Return specific internal energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy u "Specific internal energy";
      end specificInternalEnergy;

      replaceable partial function specificEntropy "Return specific entropy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEntropy s "Specific entropy";
      end specificEntropy;

      replaceable partial function specificGibbsEnergy
        "Return specific Gibbs energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy g "Specific Gibbs energy";
      end specificGibbsEnergy;

      replaceable partial function specificHelmholtzEnergy
        "Return specific Helmholtz energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy f "Specific Helmholtz energy";
      end specificHelmholtzEnergy;

      replaceable partial function specificHeatCapacityCp
        "Return specific heat capacity at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificHeatCapacity cp
          "Specific heat capacity at constant pressure";
      end specificHeatCapacityCp;

      function heatCapacity_cp = specificHeatCapacityCp
        "Alias for deprecated name";

      replaceable partial function specificHeatCapacityCv
        "Return specific heat capacity at constant volume"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificHeatCapacity cv
          "Specific heat capacity at constant volume";
      end specificHeatCapacityCv;

      function heatCapacity_cv = specificHeatCapacityCv
        "Alias for deprecated name";

      replaceable partial function isentropicExponent
        "Return isentropic exponent"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output IsentropicExponent gamma "Isentropic exponent";
      end isentropicExponent;

      replaceable partial function isentropicEnthalpy
        "Return isentropic enthalpy"
        extends Modelica.Icons.Function;
        input AbsolutePressure p_downstream "Downstream pressure";
        input ThermodynamicState refState "Reference state for entropy";
        output SpecificEnthalpy h_is "Isentropic enthalpy";
        annotation (Documentation(info="<html>
<p>
This function computes an isentropic state transformation:
</p>
<ol>
<li> A medium is in a particular state, refState.</li>
<li> The enthalpy at another state (h_is) shall be computed
     under the assumption that the state transformation from refState to h_is
     is performed with a change of specific entropy ds = 0 and the pressure of state h_is
     is p_downstream and the composition X upstream and downstream is assumed to be the same.</li>
</ol>

</html>"));
      end isentropicEnthalpy;

      replaceable partial function velocityOfSound "Return velocity of sound"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output VelocityOfSound a "Velocity of sound";
      end velocityOfSound;

      replaceable partial function isobaricExpansionCoefficient
        "Return overall the isobaric expansion coefficient beta"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output IsobaricExpansionCoefficient beta "Isobaric expansion coefficient";
        annotation (Documentation(info="<html>
<pre>
beta is defined as  1/v * der(v,T), with v = 1/d, at constant pressure p.
</pre>
</html>"));
      end isobaricExpansionCoefficient;

      function beta = isobaricExpansionCoefficient
        "Alias for isobaricExpansionCoefficient for user convenience";

      replaceable partial function isothermalCompressibility
        "Return overall the isothermal compressibility factor"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SI.IsothermalCompressibility kappa "Isothermal compressibility";
        annotation (Documentation(info="<html>
<pre>

kappa is defined as - 1/v * der(v,p), with v = 1/d at constant temperature T.

</pre>
</html>"));
      end isothermalCompressibility;

      function kappa = isothermalCompressibility
        "Alias of isothermalCompressibility for user convenience";

      // explicit derivative functions for finite element models
      replaceable partial function density_derp_h
        "Return density derivative w.r.t. pressure at const specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByPressure ddph "Density derivative w.r.t. pressure";
      end density_derp_h;

      replaceable partial function density_derh_p
        "Return density derivative w.r.t. specific enthalpy at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByEnthalpy ddhp
          "Density derivative w.r.t. specific enthalpy";
      end density_derh_p;

      replaceable partial function density_derp_T
        "Return density derivative w.r.t. pressure at const temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByPressure ddpT "Density derivative w.r.t. pressure";
      end density_derp_T;

      replaceable partial function density_derT_p
        "Return density derivative w.r.t. temperature at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByTemperature ddTp
          "Density derivative w.r.t. temperature";
      end density_derT_p;

      replaceable partial function density_derX
        "Return density derivative w.r.t. mass fraction"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Density[nX] dddX "Derivative of density w.r.t. mass fraction";
      end density_derX;

      replaceable partial function molarMass
        "Return the molar mass of the medium"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output MolarMass MM "Mixture molar mass";
      end molarMass;

      replaceable function specificEnthalpy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_pTX(
                p,
                T,
                X));
        annotation (inverse(T=temperature_phX(
                      p,
                      h,
                      X)));
      end specificEnthalpy_pTX;

      replaceable function specificEntropy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEntropy s "Specific entropy";
      algorithm
        s := specificEntropy(setState_pTX(
                p,
                T,
                X));

        annotation (inverse(T=temperature_psX(
                      p,
                      s,
                      X)));
      end specificEntropy_pTX;

      replaceable function density_pTX "Return density from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:] "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(
                p,
                T,
                X));
      end density_pTX;

      replaceable function temperature_phX
        "Return temperature from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_phX(
                p,
                h,
                X));
      end temperature_phX;

      replaceable function density_phX "Return density from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_phX(
                p,
                h,
                X));
      end density_phX;

      replaceable function temperature_psX
        "Return temperature from p,s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_psX(
                p,
                s,
                X));
        annotation (inverse(s=specificEntropy_pTX(
                      p,
                      T,
                      X)));
      end temperature_psX;

      replaceable function density_psX "Return density from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_psX(
                p,
                s,
                X));
      end density_psX;

      replaceable function specificEnthalpy_psX
        "Return specific enthalpy from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_psX(
                p,
                s,
                X));
      end specificEnthalpy_psX;

      type MassFlowRate = SI.MassFlowRate (
          quantity="MassFlowRate." + mediumName,
          min=-1.0e5,
          max=1.e5) "Type for mass flow rate with medium specific attributes";

      // Only for backwards compatibility to version 3.2 (
      // (do not use these definitions in new models, but use Modelica.Media.Interfaces.Choices instead)
      package Choices = Modelica.Media.Interfaces.Choices annotation (obsolete=
            "Use Modelica.Media.Interfaces.Choices");

      annotation (Documentation(info="<html>
<p>
<strong>PartialMedium</strong> is a package and contains all <strong>declarations</strong> for
a medium. This means that constants, models, and functions
are defined that every medium is supposed to support
(some of them are optional). A medium package
inherits from <strong>PartialMedium</strong> and provides the
equations for the medium. The details of this package
are described in
<a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.
</p>
</html>",   revisions="<html>

</html>"));
    end PartialMedium;

    partial package PartialPureSubstance
      "Base class for pure substances of one chemical substance"
      extends PartialMedium(final reducedX=true, final fixedX=true);

      replaceable function setState_pT "Return thermodynamic state from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_pTX(
                p,
                T,
                fill(0, 0));
      end setState_pT;

      replaceable function setState_ph "Return thermodynamic state from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_phX(
                p,
                h,
                fill(0, 0));
      end setState_ph;

      replaceable function setState_ps "Return thermodynamic state from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_psX(
                p,
                s,
                fill(0, 0));
      end setState_ps;

      replaceable function setState_dT "Return thermodynamic state from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_dTX(
                d,
                T,
                fill(0, 0));
      end setState_dT;

      replaceable function density_ph "Return density from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Density d "Density";
      algorithm
        d := density_phX(
                p,
                h,
                fill(0, 0));
      end density_ph;

      replaceable function temperature_ph "Return temperature from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_phX(
                p,
                h,
                fill(0, 0));
      end temperature_ph;

      replaceable function pressure_dT "Return pressure from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output AbsolutePressure p "Pressure";
      algorithm
        p := pressure(setState_dTX(
                d,
                T,
                fill(0, 0)));
      end pressure_dT;

      replaceable function specificEnthalpy_dT
        "Return specific enthalpy from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_dTX(
                d,
                T,
                fill(0, 0)));
      end specificEnthalpy_dT;

      replaceable function specificEnthalpy_ps
        "Return specific enthalpy from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy_psX(
                p,
                s,
                fill(0, 0));
      end specificEnthalpy_ps;

      replaceable function temperature_ps "Return temperature from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_psX(
                p,
                s,
                fill(0, 0));
      end temperature_ps;

      replaceable function density_ps "Return density from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Density d "Density";
      algorithm
        d := density_psX(
                p,
                s,
                fill(0, 0));
      end density_ps;

      replaceable function specificEnthalpy_pT
        "Return specific enthalpy from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy_pTX(
                p,
                T,
                fill(0, 0));
      end specificEnthalpy_pT;

      replaceable function density_pT "Return density from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(
                p,
                T,
                fill(0, 0)));
      end density_pT;

      redeclare replaceable partial model extends BaseProperties(final
          standardOrderComponents=true)
      end BaseProperties;
    end PartialPureSubstance;

    partial package PartialMixtureMedium
      "Base class for pure substances of several chemical substances"
      extends PartialMedium(redeclare replaceable record FluidConstants =
            Modelica.Media.Interfaces.Types.IdealGas.FluidConstants);

      redeclare replaceable record extends ThermodynamicState
        "Thermodynamic state variables"
        AbsolutePressure p "Absolute pressure of medium";
        Temperature T "Temperature of medium";
        MassFraction[nX] X(start=reference_X)
          "Mass fractions (= (component mass)/total mass  m_i/m)";
      end ThermodynamicState;

      constant FluidConstants[nS] fluidConstants "Constant data for the fluid";

      replaceable function gasConstant
        "Return the gas constant of the mixture (also for liquids)"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        output SI.SpecificHeatCapacity R "Mixture gas constant";
      end gasConstant;

      function moleToMassFractions "Return mass fractions X from mole fractions"
        extends Modelica.Icons.Function;
        input SI.MoleFraction moleFractions[:] "Mole fractions of mixture";
        input MolarMass[:] MMX "Molar masses of components";
        output SI.MassFraction X[size(moleFractions, 1)]
          "Mass fractions of gas mixture";
    protected
        MolarMass Mmix=moleFractions*MMX "Molar mass of mixture";
      algorithm
        for i in 1:size(moleFractions, 1) loop
          X[i] := moleFractions[i]*MMX[i]/Mmix;
        end for;
        annotation (smoothOrder=5);
      end moleToMassFractions;

      function massToMoleFractions "Return mole fractions from mass fractions X"
        extends Modelica.Icons.Function;
        input SI.MassFraction X[:] "Mass fractions of mixture";
        input SI.MolarMass[:] MMX "Molar masses of components";
        output SI.MoleFraction moleFractions[size(X, 1)]
          "Mole fractions of gas mixture";
    protected
        Real invMMX[size(X, 1)] "Inverses of molar weights";
        SI.MolarMass Mmix "Molar mass of mixture";
      algorithm
        for i in 1:size(X, 1) loop
          invMMX[i] := 1/MMX[i];
        end for;
        Mmix := 1/(X*invMMX);
        for i in 1:size(X, 1) loop
          moleFractions[i] := Mmix*X[i]/MMX[i];
        end for;
        annotation (smoothOrder=5);
      end massToMoleFractions;

    end PartialMixtureMedium;

    partial package PartialCondensingGases
      "Base class for mixtures of condensing and non-condensing gases"
      extends PartialMixtureMedium(ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pTX);

      replaceable partial function saturationPressure
        "Return saturation pressure of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature Tsat "Saturation temperature";
        output AbsolutePressure psat "Saturation pressure";
      end saturationPressure;

      replaceable partial function enthalpyOfVaporization
        "Return vaporization enthalpy of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy r0 "Vaporization enthalpy";
      end enthalpyOfVaporization;

      replaceable partial function enthalpyOfLiquid
        "Return liquid enthalpy of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Liquid enthalpy";
      end enthalpyOfLiquid;

      replaceable partial function enthalpyOfGas
        "Return enthalpy of non-condensing gas mixture"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        input MassFraction[:] X "Vector of mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfGas;

      replaceable partial function enthalpyOfCondensingGas
        "Return enthalpy of condensing gas (most often steam)"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfCondensingGas;

      replaceable partial function enthalpyOfNonCondensingGas
        "Return enthalpy of the non-condensing species"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfNonCondensingGas;
    end PartialCondensingGases;

    partial package PartialSimpleMedium
      "Medium model with linear dependency of u, h from temperature. All other quantities, especially density, are constant."

      extends Interfaces.PartialPureSubstance(final ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pT,
          final singleState=true);

      constant SpecificHeatCapacity cp_const
        "Constant specific heat capacity at constant pressure";
      constant SpecificHeatCapacity cv_const
        "Constant specific heat capacity at constant volume";
      constant Density d_const "Constant density";
      constant DynamicViscosity eta_const "Constant dynamic viscosity";
      constant ThermalConductivity lambda_const "Constant thermal conductivity";
      constant VelocityOfSound a_const "Constant velocity of sound";
      constant Temperature T_min "Minimum temperature valid for medium model";
      constant Temperature T_max "Maximum temperature valid for medium model";
      constant Temperature T0=reference_T "Zero enthalpy temperature";
      constant MolarMass MM_const "Molar mass";

      constant FluidConstants[nS] fluidConstants "Fluid constants";

      redeclare record extends ThermodynamicState "Thermodynamic state"
        AbsolutePressure p "Absolute pressure of medium";
        Temperature T "Temperature of medium";
      end ThermodynamicState;

      redeclare replaceable model extends BaseProperties(T(stateSelect=if
              preferredMediumStates then StateSelect.prefer else StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else
              StateSelect.default)) "Base properties"
      equation
        assert(T >= T_min and T <= T_max, "
Temperature T (= "   + String(T) + " K) is not
in the allowed range ("   + String(T_min) + " K <= T <= " + String(T_max) + " K)
required from medium model \""   + mediumName + "\".
");

        // h = cp_const*(T-T0);
        h = specificEnthalpy_pTX(
                p,
                T,
                X);
        u = cv_const*(T - T0);
        d = d_const;
        R = 0;
        MM = MM_const;
        state.T = T;
        state.p = p;
        annotation (Documentation(info="<html>
<p>
This is the most simple incompressible medium model, where
specific enthalpy h and specific internal energy u are only
a function of temperature T and all other provided medium
quantities are assumed to be constant.
Note that the (small) influence of the pressure term p/d is neglected.
</p>
</html>"));
      end BaseProperties;

      redeclare function setState_pTX
        "Return thermodynamic state from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=T);
      end setState_pTX;

      redeclare function setState_phX
        "Return thermodynamic state from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=T0 + h/cp_const);
      end setState_phX;

      redeclare replaceable function setState_psX
        "Return thermodynamic state from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=Modelica.Math.exp(s/cp_const +
          Modelica.Math.log(reference_T)))
          "Here the incompressible limit is used, with cp as heat capacity";
      end setState_psX;

      redeclare function setState_dTX
        "Return thermodynamic state from d, T, and X or Xi"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        assert(false,
          "Pressure can not be computed from temperature and density for an incompressible fluid!");
      end setState_dTX;

      redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
      algorithm
        state := ThermodynamicState(p=Media.Common.smoothStep(
                x,
                state_a.p,
                state_b.p,
                x_small), T=Media.Common.smoothStep(
                x,
                state_a.T,
                state_b.T,
                x_small));
      end setSmoothState;

      redeclare function extends dynamicViscosity "Return dynamic viscosity"

      algorithm
        eta := eta_const;
      end dynamicViscosity;

      redeclare function extends thermalConductivity
        "Return thermal conductivity"

      algorithm
        lambda := lambda_const;
      end thermalConductivity;

      redeclare function extends pressure "Return pressure"

      algorithm
        p := state.p;
      end pressure;

      redeclare function extends temperature "Return temperature"

      algorithm
        T := state.T;
      end temperature;

      redeclare function extends density "Return density"

      algorithm
        d := d_const;
      end density;

      redeclare function extends specificEnthalpy "Return specific enthalpy"

      algorithm
        h := cp_const*(state.T - T0);
      end specificEnthalpy;

      redeclare function extends specificHeatCapacityCp
        "Return specific heat capacity at constant pressure"

      algorithm
        cp := cp_const;
      end specificHeatCapacityCp;

      redeclare function extends specificHeatCapacityCv
        "Return specific heat capacity at constant volume"

      algorithm
        cv := cv_const;
      end specificHeatCapacityCv;

      redeclare function extends isentropicExponent "Return isentropic exponent"

      algorithm
        gamma := cp_const/cv_const;
      end isentropicExponent;

      redeclare function extends velocityOfSound "Return velocity of sound"

      algorithm
        a := a_const;
      end velocityOfSound;

      redeclare function specificEnthalpy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[nX] "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := cp_const*(T - T0);
        annotation (Documentation(info="<html>
<p>
This function computes the specific enthalpy of the fluid, but neglects the (small) influence of the pressure term p/d.
</p>
</html>"));
      end specificEnthalpy_pTX;

      redeclare function temperature_phX
        "Return temperature from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[nX] "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := T0 + h/cp_const;
      end temperature_phX;

      redeclare function density_phX "Return density from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[nX] "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_phX(
                p,
                h,
                X));
      end density_phX;

      redeclare function extends specificInternalEnergy
        "Return specific internal energy"
        extends Modelica.Icons.Function;
      algorithm
        //  u := cv_const*(state.T - T0) - reference_p/d_const;
        u := cv_const*(state.T - T0);
        annotation (Documentation(info="<html>
<p>
This function computes the specific internal energy of the fluid, but neglects the (small) influence of the pressure term p/d.
</p>
</html>"));
      end specificInternalEnergy;

      redeclare function extends specificEntropy "Return specific entropy"
        extends Modelica.Icons.Function;
      algorithm
        s := cv_const*Modelica.Math.log(state.T/T0);
      end specificEntropy;

      redeclare function extends specificGibbsEnergy
        "Return specific Gibbs energy"
        extends Modelica.Icons.Function;
      algorithm
        g := specificEnthalpy(state) - state.T*specificEntropy(state);
      end specificGibbsEnergy;

      redeclare function extends specificHelmholtzEnergy
        "Return specific Helmholtz energy"
        extends Modelica.Icons.Function;
      algorithm
        f := specificInternalEnergy(state) - state.T*specificEntropy(state);
      end specificHelmholtzEnergy;

      redeclare function extends isentropicEnthalpy "Return isentropic enthalpy"
      algorithm
        h_is := cp_const*(temperature(refState) - T0);
      end isentropicEnthalpy;

      redeclare function extends isobaricExpansionCoefficient
        "Returns overall the isobaric expansion coefficient beta"
      algorithm
        beta := 0.0;
      end isobaricExpansionCoefficient;

      redeclare function extends isothermalCompressibility
        "Returns overall the isothermal compressibility factor"
      algorithm
        kappa := 0;
      end isothermalCompressibility;

      redeclare function extends density_derp_T
        "Returns the partial derivative of density with respect to pressure at constant temperature"
      algorithm
        ddpT := 0;
      end density_derp_T;

      redeclare function extends density_derT_p
        "Returns the partial derivative of density with respect to temperature at constant pressure"
      algorithm
        ddTp := 0;
      end density_derT_p;

      redeclare function extends density_derX
        "Returns the partial derivative of density with respect to mass fractions at constant pressure and temperature"
      algorithm
        dddX := fill(0, nX);
      end density_derX;

      redeclare function extends molarMass "Return the molar mass of the medium"
      algorithm
        MM := MM_const;
      end molarMass;
    end PartialSimpleMedium;

    package Choices "Types, constants to define menu choices"
      extends Modelica.Icons.Package;

      type IndependentVariables = enumeration(
        T   "Temperature",
        pT   "Pressure, Temperature",
        ph   "Pressure, Specific Enthalpy",
        phX   "Pressure, Specific Enthalpy, Mass Fraction",
        pTX   "Pressure, Temperature, Mass Fractions",
        dTX   "Density, Temperature, Mass Fractions")
        "Enumeration defining the independent variables of a medium";

      type ReferenceEnthalpy = enumeration(
        ZeroAt0K
            "The enthalpy is 0 at 0 K (default), if the enthalpy of formation is excluded",
        ZeroAt25C
            "The enthalpy is 0 at 25 degC, if the enthalpy of formation is excluded",
        UserDefined
            "The user-defined reference enthalpy is used at 293.15 K (25 degC)")
        "Enumeration defining the reference enthalpy of a medium" annotation (
          Evaluate=true);
      annotation (Documentation(info="<html>
<p>
Enumerations and data types for all types of fluids
</p>

<p>
Note: Reference enthalpy might have to be extended with enthalpy of formation.
</p>
</html>"));
    end Choices;

    package Types "Types to be used in fluid models"
      extends Modelica.Icons.Package;

      type AbsolutePressure = SI.AbsolutePressure (
          min=0,
          max=1.e8,
          nominal=1.e5,
          start=1.e5)
        "Type for absolute pressure with medium specific attributes";

      type Density = SI.Density (
          min=0,
          max=1.e5,
          nominal=1,
          start=1) "Type for density with medium specific attributes";

      type DynamicViscosity = SI.DynamicViscosity (
          min=0,
          max=1.e8,
          nominal=1.e-3,
          start=1.e-3)
        "Type for dynamic viscosity with medium specific attributes";

      type EnthalpyFlowRate = SI.EnthalpyFlowRate (
          nominal=1000.0,
          min=-1.0e8,
          max=1.e8) "Type for enthalpy flow rate with medium specific attributes";

      type MassFraction = Real (
          quantity="MassFraction",
          final unit="kg/kg",
          min=0,
          max=1,
          nominal=0.1) "Type for mass fraction with medium specific attributes";

      type MoleFraction = Real (
          quantity="MoleFraction",
          final unit="mol/mol",
          min=0,
          max=1,
          nominal=0.1) "Type for mole fraction with medium specific attributes";

      type MolarMass = SI.MolarMass (
          min=0.001,
          max=0.25,
          nominal=0.032) "Type for molar mass with medium specific attributes";

      type MolarVolume = SI.MolarVolume (
          min=1e-6,
          max=1.0e6,
          nominal=1.0) "Type for molar volume with medium specific attributes";

      type IsentropicExponent = SI.RatioOfSpecificHeatCapacities (
          min=1,
          max=500000,
          nominal=1.2,
          start=1.2)
        "Type for isentropic exponent with medium specific attributes";

      type SpecificEnergy = SI.SpecificEnergy (
          min=-1.0e8,
          max=1.e8,
          nominal=1.e6)
        "Type for specific energy with medium specific attributes";

      type SpecificInternalEnergy = SpecificEnergy
        "Type for specific internal energy with medium specific attributes";

      type SpecificEnthalpy = SI.SpecificEnthalpy (
          min=-1.0e10,
          max=1.e10,
          nominal=1.e6)
        "Type for specific enthalpy with medium specific attributes";

      type SpecificEntropy = SI.SpecificEntropy (
          min=-1.e7,
          max=1.e7,
          nominal=1.e3)
        "Type for specific entropy with medium specific attributes";

      type SpecificHeatCapacity = SI.SpecificHeatCapacity (
          min=0,
          max=1.e7,
          nominal=1.e3,
          start=1.e3)
        "Type for specific heat capacity with medium specific attributes";

      type Temperature = SI.Temperature (
          min=1,
          max=1.e4,
          nominal=300,
          start=288.15) "Type for temperature with medium specific attributes";

      type ThermalConductivity = SI.ThermalConductivity (
          min=0,
          max=500,
          nominal=1,
          start=1)
        "Type for thermal conductivity with medium specific attributes";

      type PrandtlNumber = SI.PrandtlNumber (
          min=1e-3,
          max=1e5,
          nominal=1.0) "Type for Prandtl number with medium specific attributes";

      type VelocityOfSound = SI.Velocity (
          min=0,
          max=1.e5,
          nominal=1000,
          start=1000)
        "Type for velocity of sound with medium specific attributes";

      type ExtraProperty = Real (min=0.0, start=1.0)
        "Type for unspecified, mass-specific property transported by flow";

      type ExtraPropertyFlowRate = Real (unit="kg/s")
        "Type for flow rate of unspecified, mass-specific property";

      type IsobaricExpansionCoefficient = Real (
          min=0,
          max=1.0e8,
          unit="1/K")
        "Type for isobaric expansion coefficient with medium specific attributes";

      type DipoleMoment = Real (
          min=0.0,
          max=2.0,
          unit="debye",
          quantity="ElectricDipoleMoment")
        "Type for dipole moment with medium specific attributes";

      type DerDensityByPressure = SI.DerDensityByPressure
        "Type for partial derivative of density with respect to pressure with medium specific attributes";

      type DerDensityByEnthalpy = SI.DerDensityByEnthalpy
        "Type for partial derivative of density with respect to enthalpy with medium specific attributes";

      type DerDensityByTemperature = SI.DerDensityByTemperature
        "Type for partial derivative of density with respect to temperature with medium specific attributes";

      package Basic
      "The most basic version of a record used in several degrees of detail"
        extends Icons.Package;

        record FluidConstants
          "Critical, triple, molecular and other standard data of fluid"
          extends Modelica.Icons.Record;
          String iupacName
            "Complete IUPAC name (or common name, if non-existent)";
          String casRegistryNumber
            "Chemical abstracts sequencing number (if it exists)";
          String chemicalFormula
            "Chemical formula, (brutto, nomenclature according to Hill";
          String structureFormula "Chemical structure formula";
          MolarMass molarMass "Molar mass";
        end FluidConstants;
      end Basic;

      package IdealGas
      "The ideal gas version of a record used in several degrees of detail"
        extends Icons.Package;

        record FluidConstants "Extended fluid constants"
          extends Modelica.Media.Interfaces.Types.Basic.FluidConstants;
          Temperature criticalTemperature "Critical temperature";
          AbsolutePressure criticalPressure "Critical pressure";
          MolarVolume criticalMolarVolume "Critical molar Volume";
          Real acentricFactor "Pitzer acentric factor";
          //   Temperature triplePointTemperature "Triple point temperature";
          //   AbsolutePressure triplePointPressure "Triple point pressure";
          Temperature meltingPoint "Melting point at 101325 Pa";
          Temperature normalBoilingPoint "Normal boiling point (at 101325 Pa)";
          DipoleMoment dipoleMoment
            "Dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
          Boolean hasIdealGasHeatCapacity=false
            "True if ideal gas heat capacity is available";
          Boolean hasCriticalData=false "True if critical data are known";
          Boolean hasDipoleMoment=false "True if a dipole moment known";
          Boolean hasFundamentalEquation=false "True if a fundamental equation";
          Boolean hasLiquidHeatCapacity=false
            "True if liquid heat capacity is available";
          Boolean hasSolidHeatCapacity=false
            "True if solid heat capacity is available";
          Boolean hasAccurateViscosityData=false
            "True if accurate data for a viscosity function is available";
          Boolean hasAccurateConductivityData=false
            "True if accurate data for thermal conductivity is available";
          Boolean hasVapourPressureCurve=false
            "True if vapour pressure data, e.g., Antoine coefficients are known";
          Boolean hasAcentricFactor=false
            "True if Pitzer acentric factor is known";
          SpecificEnthalpy HCRIT0=0.0
            "Critical specific enthalpy of the fundamental equation";
          SpecificEntropy SCRIT0=0.0
            "Critical specific entropy of the fundamental equation";
          SpecificEnthalpy deltah=0.0
            "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
          SpecificEntropy deltas=0.0
            "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";
        end FluidConstants;
      end IdealGas;
    end Types;
    annotation (Documentation(info="<html>
<p>
This package provides basic interfaces definitions of media models for different
kind of media.
</p>
</html>"));
  end Interfaces;

  package Common
    "Data structures and fundamental functions for fluid properties"
    extends Modelica.Icons.Package;

    function smoothStep
      "Approximation of a general step, such that the characteristic is continuous and differentiable"
      extends Modelica.Icons.Function;
      input Real x "Abscissa value";
      input Real y1 "Ordinate value for x > 0";
      input Real y2 "Ordinate value for x < 0";
      input Real x_small(min=0) = 1e-5
        "Approximation of step for -x_small <= x <= x_small; x_small > 0 required";
      output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
    algorithm
      y := smooth(1, if x > x_small then y1 else if x < -x_small then y2 else if
        abs(x_small) > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2 - y1)/4 + (y1
         + y2)/2 else (y1 + y2)/2);

      annotation (
        Inline=true,
        smoothOrder=1,
        Documentation(revisions="<html>
<ul>
<li><em>April 29, 2008</em>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><em>August 12, 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",   info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <strong>if</strong> x &gt; 0 <strong>then</strong> y1 <strong>else</strong> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> y1 <strong>else</strong>
                 <strong>if</strong> x &lt; -x_small <strong>then</strong> y2 <strong>else</strong> f(y1, y2));
</pre>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>

<p>
If <strong>mass fractions</strong> X[:] are approximated with this function then this can be performed
for all <strong>nX</strong> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(X) = 1, provided sum(X_a) = sum(X_b) = 1
(and y1=X_a[i], y2=X_b[i]).
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise X is either X_a or X_b):
</p>

<pre>
    X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
    X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
       ...
    X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre>

<p>
or
</p>

<pre>
    X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
    X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
       ...
    X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
    c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre>

<p>
Summing all mass fractions together results in
</p>

<pre>
    sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
           = c*(1 - 1) + (1 + 1)/2
           = 1
</pre>
</html>"));
    end smoothStep;

    package OneNonLinearEquation
      "Determine solution of a non-linear algebraic equation in one unknown without derivatives in a reliable and efficient way"
      extends Modelica.Icons.Package;

      replaceable record f_nonlinear_Data
        "Data specific for function f_nonlinear"
        extends Modelica.Icons.Record;
      end f_nonlinear_Data;

      replaceable partial function f_nonlinear
        "Nonlinear algebraic equation in one unknown: y = f_nonlinear(x,p,X)"
        extends Modelica.Icons.Function;
        input Real x "Independent variable of function";
        input Real p=0.0 "Disregarded variables (here always used for pressure)";
        input Real[:] X=fill(0, 0)
          "Disregarded variables (her always used for composition)";
        input f_nonlinear_Data f_nonlinear_data
          "Additional data for the function";
        output Real y "= f_nonlinear(x)";
        // annotation(derivative(zeroDerivative=y)); // this must hold for all replaced functions
      end f_nonlinear;

      replaceable function solve
        "Solve f_nonlinear(x_zero)=y_zero; f_nonlinear(x_min) - y_zero and f_nonlinear(x_max)-y_zero must have different sign"
        import Modelica.Utilities.Streams.error;
        extends Modelica.Icons.Function;
        input Real y_zero
          "Determine x_zero, such that f_nonlinear(x_zero) = y_zero";
        input Real x_min "Minimum value of x";
        input Real x_max "Maximum value of x";
        input Real pressure=0.0
          "Disregarded variables (here always used for pressure)";
        input Real[:] X=fill(0, 0)
          "Disregarded variables (here always used for composition)";
        input f_nonlinear_Data f_nonlinear_data
          "Additional data for function f_nonlinear";
        input Real x_tol=100*Modelica.Constants.eps
          "Relative tolerance of the result";
        output Real x_zero "f_nonlinear(x_zero) = y_zero";
    protected
        constant Real eps=Modelica.Constants.eps "Machine epsilon";
        constant Real x_eps=1e-10
          "Slight modification of x_min, x_max, since x_min, x_max are usually exactly at the borders T_min/h_min and then small numeric noise may make the interval invalid";
        Real x_min2=x_min - x_eps;
        Real x_max2=x_max + x_eps;
        Real a=x_min2 "Current best minimum interval value";
        Real b=x_max2 "Current best maximum interval value";
        Real c "Intermediate point a <= c <= b";
        Real d;
        Real e "b - a";
        Real m;
        Real s;
        Real p;
        Real q;
        Real r;
        Real tol;
        Real fa "= f_nonlinear(a) - y_zero";
        Real fb "= f_nonlinear(b) - y_zero";
        Real fc;
        Boolean found=false;
      algorithm
        // Check that f(x_min) and f(x_max) have different sign
        fa := f_nonlinear(
                x_min2,
                pressure,
                X,
                f_nonlinear_data) - y_zero;
        fb := f_nonlinear(
                x_max2,
                pressure,
                X,
                f_nonlinear_data) - y_zero;
        fc := fb;
        if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
          error(
            "The arguments x_min and x_max to OneNonLinearEquation.solve(..)\n"
             + "do not bracket the root of the single non-linear equation:\n" +
            "  x_min  = " + String(x_min2) + "\n" + "  x_max  = " + String(x_max2)
             + "\n" + "  y_zero = " + String(y_zero) + "\n" +
            "  fa = f(x_min) - y_zero = " + String(fa) + "\n" +
            "  fb = f(x_max) - y_zero = " + String(fb) + "\n" +
            "fa and fb must have opposite sign which is not the case");
        end if;

        // Initialize variables
        c := a;
        fc := fa;
        e := b - a;
        d := e;

        // Search loop
        while not found loop
          if abs(fc) < abs(fb) then
            a := b;
            b := c;
            c := a;
            fa := fb;
            fb := fc;
            fc := fa;
          end if;

          tol := 2*eps*abs(b) + x_tol;
          m := (c - b)/2;

          if abs(m) <= tol or fb == 0.0 then
            // root found (interval is small enough)
            found := true;
            x_zero := b;
          else
            // Determine if a bisection is needed
            if abs(e) < tol or abs(fa) <= abs(fb) then
              e := m;
              d := e;
            else
              s := fb/fa;
              if a == c then
                // linear interpolation
                p := 2*m*s;
                q := 1 - s;
              else
                // inverse quadratic interpolation
                q := fa/fc;
                r := fb/fc;
                p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                q := (q - 1)*(r - 1)*(s - 1);
              end if;

              if p > 0 then
                q := -q;
              else
                p := -p;
              end if;

              s := e;
              e := d;
              if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                // interpolation successful
                d := p/q;
              else
                // use bi-section
                e := m;
                d := e;
              end if;
            end if;

            // Best guess value is defined as "a"
            a := b;
            fa := fb;
            b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
            fb := f_nonlinear(
                    b,
                    pressure,
                    X,
                    f_nonlinear_data) - y_zero;

            if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
              // initialize variables
              c := a;
              fc := fa;
              e := b - a;
              d := e;
            end if;
          end if;
        end while;
      end solve;

      annotation (Documentation(info="<html>
<p>
This function should currently only be used in Modelica.Media,
since it might be replaced in the future by another strategy,
where the tool is responsible for the solution of the non-linear
equation.
</p>

<p>
This library determines the solution of one non-linear algebraic equation \"y=f(x)\"
in one unknown \"x\" in a reliable way. As input, the desired value y of the
non-linear function has to be given, as well as an interval x_min, x_max that
contains the solution, i.e., \"f(x_min) - y\" and \"f(x_max) - y\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <strong>Algorithms for Minimization without derivatives</strong>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>

<p>
Due to current limitations of the
Modelica language (not possible to pass a function reference to a function),
the construction to use this solver on a user-defined function is a bit
complicated (this method is from Hans Olsson, Dassault Syst&egrave;mes AB). A user has to
provide a package in the following way:
</p>

<pre>
  <strong>package</strong> MyNonLinearSolver
    <strong>extends</strong> OneNonLinearEquation;

    <strong>redeclare record extends</strong> Data
      // Define data to be passed to user function
      ...
    <strong>end</strong> Data;

    <strong>redeclare function extends</strong> f_nonlinear
    <strong>algorithm</strong>
       // Compute the non-linear equation: y = f(x, Data)
    <strong>end</strong> f_nonlinear;

    // Dummy definition that has to be present for current Dymola
    <strong>redeclare function extends</strong> solve
    <strong>end</strong> solve;
  <strong>end</strong> MyNonLinearSolver;

  x_zero = MyNonLinearSolver.solve(y_zero, x_min, x_max, data=data);
</pre>
</html>"));
    end OneNonLinearEquation;
    annotation (Documentation(info="<html><h4>Package description</h4>
      <p>Package Modelica.Media.Common provides records and functions shared by many of the property sub-packages.
      High accuracy fluid property models share a lot of common structure, even if the actual models are different.
      Common data structures and computations shared by these property models are collected in this library.
   </p>

</html>",   revisions="<html>
      <ul>
      <li>First implemented: <em>July, 2000</em>
      by Hubertus Tummescheit
      for the ThermoFluid Library with help from Jonas Eborn and Falko Jens Wagner
      </li>
      <li>Code reorganization, enhanced documentation, additional functions: <em>December, 2002</em>
      by Hubertus Tummescheit and move to Modelica
                            properties library.</li>
      <li>Inclusion into Modelica.Media: September 2003</li>
      </ul>

      <address>Author: Hubertus Tummescheit,<br>
      Lund University<br>
      Department of Automatic Control<br>
      Box 118, 22100 Lund, Sweden<br>
      email: hubertus@control.lth.se
      </address>
</html>"));
  end Common;

    package Air "Medium models for air"
        extends Modelica.Icons.VariantsPackage;

      package MoistAir "Air: Moist air model (190 ... 647 K)"
        extends Interfaces.PartialCondensingGases(
          mediumName="Moist air",
          substanceNames={"water","air"},
          final reducedX=true,
          final singleState=false,
          reference_X={0.01,0.99},
          fluidConstants={IdealGases.Common.FluidData.H2O,IdealGases.Common.FluidData.N2},
          Temperature(min=190, max=647));
        import Modelica.Media.IdealGases.Common.Functions;

        constant Integer Water=1
          "Index of water (in substanceNames, massFractions X, etc.)";

        constant Integer Air=2
          "Index of air (in substanceNames, massFractions X, etc.)";

        constant Real k_mair=steam.MM/dryair.MM "Ratio of molar weights";

        constant IdealGases.Common.DataRecord dryair=IdealGases.Common.SingleGasesData.Air;

        constant IdealGases.Common.DataRecord steam=IdealGases.Common.SingleGasesData.H2O;

        constant SI.MolarMass[2] MMX={steam.MM,dryair.MM}
          "Molar masses of components";
        import Modelica.Media.Interfaces;
        import Modelica.Math;
        import Modelica.Constants;
        import Modelica.Media.IdealGases.Common.SingleGasNasa;
        import Modelica.Media.Interfaces.Choices.ReferenceEnthalpy;

        redeclare record extends ThermodynamicState
          "ThermodynamicState record for moist air"
        end ThermodynamicState;

        redeclare replaceable model extends BaseProperties(
          T(stateSelect=if preferredMediumStates then StateSelect.prefer else
                StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else
                StateSelect.default),
          Xi(each stateSelect=if preferredMediumStates then StateSelect.prefer
                 else StateSelect.default),
          final standardOrderComponents=true) "Moist air base properties record"

          /* p, T, X = X[Water] are used as preferred states, since only then all
     other quantities can be computed in a recursive sequence.
     If other variables are selected as states, static state selection
     is no longer possible and non-linear algebraic equations occur.
      */
          MassFraction x_water "Mass of total water/mass of dry air";
          Real phi "Relative humidity";

      protected
          MassFraction X_liquid "Mass fraction of liquid or solid water";
          MassFraction X_steam "Mass fraction of steam water";
          MassFraction X_air "Mass fraction of air";
          MassFraction X_sat
            "Steam water mass fraction of saturation boundary in kg_water/kg_moistair";
          MassFraction x_sat
            "Steam water mass content of saturation boundary in kg_water/kg_dryair";
          AbsolutePressure p_steam_sat "partial saturation pressure of steam";
        equation
          assert(T >= 190 and T <= 647, "
Temperature T is not in the allowed range
190.0 K <= (T ="     + String(T) + " K) <= 647.0 K
required from medium model \""     + mediumName + "\".");
          MM = 1/(Xi[Water]/MMX[Water] + (1.0 - Xi[Water])/MMX[Air]);

          p_steam_sat = min(saturationPressure(T), 0.999*p);
          X_sat = min(p_steam_sat*k_mair/max(100*Constants.eps, p - p_steam_sat)*(1
             - Xi[Water]), 1.0)
            "Water content at saturation with respect to actual water content";
          X_liquid = max(Xi[Water] - X_sat, 0.0);
          X_steam = Xi[Water] - X_liquid;
          X_air = 1 - Xi[Water];

          h = specificEnthalpy_pTX(
                p,
                T,
                Xi);
          R = dryair.R*(X_air/(1 - X_liquid)) + steam.R*X_steam/(1 - X_liquid);
          //
          u = h - R*T;
          d = p/(R*T);
          /* Note, u and d are computed under the assumption that the volume of the liquid
         water is negligible with respect to the volume of air and of steam
      */
          state.p = p;
          state.T = T;
          state.X = X;

          // these x are per unit mass of DRY air!
          x_sat = k_mair*p_steam_sat/max(100*Constants.eps, p - p_steam_sat);
          x_water = Xi[Water]/max(X_air, 100*Constants.eps);
          phi = p/p_steam_sat*Xi[Water]/(Xi[Water] + k_mair*X_air);
          annotation (Documentation(info="<html>
<p>This model computes thermodynamic properties of moist air from three independent (thermodynamic or/and numerical) state variables. Preferred numerical states are temperature T, pressure p and the reduced composition vector Xi, which contains the water mass fraction only. As an EOS the <strong>ideal gas law</strong> is used and associated restrictions apply. The model can also be used in the <strong>fog region</strong>, when moisture is present in its liquid state. However, it is assumed that the liquid water volume is negligible compared to that of the gas phase. Computation of thermal properties is based on property data of <a href=\"modelica://Modelica.Media.Air.DryAirNasa\"> dry air</a> and water (source: VDI-W&auml;rmeatlas), respectively. Besides the standard thermodynamic variables <strong>absolute and relative humidity</strong>, x_water and phi, respectively, are given by the model. Upper case X denotes absolute humidity with respect to mass of moist air while absolute humidity with respect to mass of dry air only is denoted by a lower case x throughout the model. See <a href=\"modelica://Modelica.Media.Air.MoistAir\">package description</a> for further information.</p>
</html>"));
        end BaseProperties;

        redeclare function setState_pTX
          "Return thermodynamic state as function of pressure p, temperature T and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input Temperature T "Temperature";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";
        algorithm
          state := if size(X, 1) == nX then ThermodynamicState(
                p=p,
                T=T,
                X=X) else ThermodynamicState(
                p=p,
                T=T,
                X=cat(
                  1,
                  X,
                  {1 - sum(X)}));
          annotation (smoothOrder=2, Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from pressure p, temperature T and composition X.
</html>"));
        end setState_pTX;

        redeclare function setState_phX
          "Return thermodynamic state as function of pressure p, specific enthalpy h and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";
        algorithm
          state := if size(X, 1) == nX then ThermodynamicState(
                p=p,
                T=T_phX(
                  p,
                  h,
                  X),
                X=X) else ThermodynamicState(
                p=p,
                T=T_phX(
                  p,
                  h,
                  X),
                X=cat(
                  1,
                  X,
                  {1 - sum(X)}));
          annotation (smoothOrder=2, Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>"));
        end setState_phX;

        redeclare function setState_dTX
          "Return thermodynamic state as function of density d, temperature T and composition X"
          extends Modelica.Icons.Function;
          input Density d "Density";
          input Temperature T "Temperature";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";
        algorithm
          state := if size(X, 1) == nX then ThermodynamicState(
                p=d*({steam.R,dryair.R}*X)*T,
                T=T,
                X=X) else ThermodynamicState(
                p=d*({steam.R,dryair.R}*cat(
                  1,
                  X,
                  {1 - sum(X)}))*T,
                T=T,
                X=cat(
                  1,
                  X,
                  {1 - sum(X)}));
          annotation (smoothOrder=2, Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from density d, temperature T and composition X.
</html>"));
        end setState_dTX;

        redeclare function extends setSmoothState
          "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
        algorithm
          state := ThermodynamicState(
                p=Media.Common.smoothStep(
                  x,
                  state_a.p,
                  state_b.p,
                  x_small),
                T=Media.Common.smoothStep(
                  x,
                  state_a.T,
                  state_b.T,
                  x_small),
                X=Media.Common.smoothStep(
                  x,
                  state_a.X,
                  state_b.X,
                  x_small));
        end setSmoothState;

        redeclare function extends gasConstant
          "Return ideal gas constant as a function from thermodynamic state, only valid for phi<1"

        algorithm
          R := dryair.R*(1 - state.X[Water]) + steam.R*state.X[Water];
          annotation (smoothOrder=2, Documentation(info="<html>
The ideal gas constant for moist air is computed from <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state</a> assuming that all water is in the gas phase.
</html>"));
        end gasConstant;

        function saturationPressureLiquid
          "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 647.096 K"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Saturation temperature";
          output SI.AbsolutePressure psat "Saturation pressure";
      protected
          SI.Temperature Tcritical=647.096 "Critical temperature";
          SI.AbsolutePressure pcritical=22.064e6 "Critical pressure";
          Real r1=(1 - Tsat/Tcritical) "Common subexpression";
          Real a[:]={-7.85951783,1.84408259,-11.7866497,22.6807411,-15.9618719,
              1.80122502} "Coefficients a[:]";
          Real n[:]={1.0,1.5,3.0,3.5,4.0,7.5} "Coefficients n[:]";
        algorithm
          psat := exp(((a[1]*r1^n[1] + a[2]*r1^n[2] + a[3]*r1^n[3] + a[4]*r1^n[4]
             + a[5]*r1^n[5] + a[6]*r1^n[6])*Tcritical)/Tsat)*pcritical;
          annotation (
            derivative=saturationPressureLiquid_der,
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
<p>Saturation pressure of water above the triple point temperature is computed from temperature.</p>
<p>Source: A Saul, W Wagner: &quot;International equations for the saturation properties of ordinary water substance&quot;, equation 2.1</p>
</html>"));
        end saturationPressureLiquid;

        function saturationPressureLiquid_der
          "Derivative function for 'saturationPressureLiquid'"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Saturation temperature";
          input Real dTsat(unit="K/s") "Saturation temperature derivative";
          output Real psat_der(unit="Pa/s") "Saturation pressure derivative";
      protected
          SI.Temperature Tcritical=647.096 "Critical temperature";
          SI.AbsolutePressure pcritical=22.064e6 "Critical pressure";
          Real r1=(1 - Tsat/Tcritical) "Common subexpression 1";
          Real r1_der=-1/Tcritical*dTsat "Derivative of common subexpression 1";
          Real a[:]={-7.85951783,1.84408259,-11.7866497,22.6807411,-15.9618719,
              1.80122502} "Coefficients a[:]";
          Real n[:]={1.0,1.5,3.0,3.5,4.0,7.5} "Coefficients n[:]";
          Real r2=(a[1]*r1^n[1] + a[2]*r1^n[2] + a[3]*r1^n[3] + a[4]*r1^n[4] + a[5]
              *r1^n[5] + a[6]*r1^n[6]) "Common subexpression 2";
        algorithm
          // Approach used here is based on Baehr: "Thermodynamik", 12th edition p.204ff, "Method of Wagner"
          //psat := exp(((a[1]*r1^n[1] + a[2]*r1^n[2] + a[3]*r1^n[3] + a[4]*r1^n[4] + a[5]*r1^n[5] + a[6]*r1^n[6])*Tcritical)/Tsat) * pcritical;
          psat_der := exp((r2*Tcritical)/Tsat)*pcritical*((a[1]*(r1^(n[1] - 1)*n[1]
            *r1_der) + a[2]*(r1^(n[2] - 1)*n[2]*r1_der) + a[3]*(r1^(n[3] - 1)*n[3]*
            r1_der) + a[4]*(r1^(n[4] - 1)*n[4]*r1_der) + a[5]*(r1^(n[5] - 1)*n[5]*
            r1_der) + a[6]*(r1^(n[6] - 1)*n[6]*r1_der))*Tcritical/Tsat - r2*
            Tcritical*dTsat/Tsat^2);
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
<p>Saturation pressure of water above the triple point temperature is computed from temperature.</p>
<p>Source: A Saul, W Wagner: &quot;International equations for the saturation properties of ordinary water substance&quot;, equation 2.1</p>
</html>"));
        end saturationPressureLiquid_der;

        function sublimationPressureIce
          "Return sublimation pressure of water as a function of temperature T between 190 and 273.16 K"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Sublimation temperature";
          output SI.AbsolutePressure psat "Sublimation pressure";
      protected
          SI.Temperature Ttriple=273.16 "Triple point temperature";
          SI.AbsolutePressure ptriple=611.657 "Triple point pressure";
          Real r1=Tsat/Ttriple "Common subexpression";
          Real a[:]={-13.9281690,34.7078238} "Coefficients a[:]";
          Real n[:]={-1.5,-1.25} "Coefficients n[:]";
        algorithm
          psat := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*ptriple;
          annotation (
            Inline=false,
            smoothOrder=5,
            derivative=sublimationPressureIce_der,
            Documentation(info="<html>
<p>Sublimation pressure of water below the triple point temperature is computed from temperature.</p>
<p>Source: W Wagner, A Saul, A Pruss: &quot;International equations for the pressure along the melting and along the sublimation curve of ordinary water substance&quot;, equation 3.5</p>
</html>"));
        end sublimationPressureIce;

        function sublimationPressureIce_der
          "Derivative function for 'sublimationPressureIce'"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Sublimation temperature";
          input Real dTsat(unit="K/s") "Sublimation temperature derivative";
          output Real psat_der(unit="Pa/s") "Sublimation pressure derivative";
      protected
          SI.Temperature Ttriple=273.16 "Triple point temperature";
          SI.AbsolutePressure ptriple=611.657 "Triple point pressure";
          Real r1=Tsat/Ttriple "Common subexpression 1";
          Real r1_der=dTsat/Ttriple "Derivative of common subexpression 1";
          Real a[:]={-13.9281690,34.7078238} "Coefficients a[:]";
          Real n[:]={-1.5,-1.25} "Coefficients n[:]";
        algorithm
          //psat := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2]) * ptriple;
          psat_der := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*ptriple*(-(a[1]
            *(r1^(n[1] - 1)*n[1]*r1_der)) - (a[2]*(r1^(n[2] - 1)*n[2]*r1_der)));
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
<p>Sublimation pressure of water below the triple point temperature is computed from temperature.</p>
<p>Source: W Wagner, A Saul, A Pruss: &quot;International equations for the pressure along the melting and along the sublimation curve of ordinary water substance&quot;, equation 3.5</p>
</html>"));
        end sublimationPressureIce_der;

        redeclare function extends saturationPressure
          "Return saturation pressure of water as a function of temperature T between 190 and 647.096 K"

        algorithm
          psat := Utilities.spliceFunction(
                saturationPressureLiquid(Tsat),
                sublimationPressureIce(Tsat),
                Tsat - 273.16,
                1.0);
          annotation (
            Inline=false,
            smoothOrder=5,
            derivative=saturationPressure_der,
            Documentation(info="<html>
Saturation pressure of water in the liquid and the solid region is computed using correlations. Functions for the
<a href=\"modelica://Modelica.Media.Air.MoistAir.sublimationPressureIce\">solid</a> and the <a href=\"modelica://Modelica.Media.Air.MoistAir.saturationPressureLiquid\"> liquid</a> region, respectively, are combined using the first derivative continuous <a href=\"modelica://Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">spliceFunction</a>. This functions range of validity is from 190 to 647.096 K. For more information on the type of correlation used, see the documentation of the linked functions.
</html>"));
        end saturationPressure;

        function saturationPressure_der
          "Derivative function for 'saturationPressure'"
          extends Modelica.Icons.Function;
          input Temperature Tsat "Saturation temperature";
          input Real dTsat(unit="K/s") "Time derivative of saturation temperature";
          output Real psat_der(unit="Pa/s") "Saturation pressure";

        algorithm
          /*psat := Utilities.spliceFunction(saturationPressureLiquid(Tsat),sublimationPressureIce(Tsat),Tsat-273.16,1.0);*/
          psat_der := Utilities.spliceFunction_der(
                saturationPressureLiquid(Tsat),
                sublimationPressureIce(Tsat),
                Tsat - 273.16,
                1.0,
                saturationPressureLiquid_der(Tsat=Tsat, dTsat=dTsat),
                sublimationPressureIce_der(Tsat=Tsat, dTsat=dTsat),
                dTsat,
                0);
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
Derivative function of <a href=\"modelica://Modelica.Media.Air.MoistAir.saturationPressure\">saturationPressure</a>
</html>"));
        end saturationPressure_der;

        redeclare function extends enthalpyOfVaporization
          "Return enthalpy of vaporization of water as a function of temperature T, 273.16 to 647.096 K"

      protected
          Real Tcritical=647.096 "Critical temperature";
          Real dcritical=322 "Critical density";
          Real pcritical=22.064e6 "Critical pressure";
          Real n[:]={1,1.5,3,3.5,4,7.5} "Powers in equation (1)";
          Real a[:]={-7.85951783,1.84408259,-11.7866497,22.6807411,-15.9618719,
              1.80122502} "Coefficients in equation (1) of [1]";
          Real m[:]={1/3,2/3,5/3,16/3,43/3,110/3} "Powers in equation (2)";
          Real b[:]={1.99274064,1.09965342,-0.510839303,-1.75493479,-45.5170352,-6.74694450e5}
            "Coefficients in equation (2) of [1]";
          Real o[:]={2/6,4/6,8/6,18/6,37/6,71/6} "Powers in equation (3)";
          Real c[:]={-2.03150240,-2.68302940,-5.38626492,-17.2991605,-44.7586581,-63.9201063}
            "Coefficients in equation (3) of [1]";
          Real tau=1 - T/Tcritical "Temperature expression";
          Real r1=(a[1]*Tcritical*tau^n[1])/T + (a[2]*Tcritical*tau^n[2])/T + (a[3]
              *Tcritical*tau^n[3])/T + (a[4]*Tcritical*tau^n[4])/T + (a[5]*
              Tcritical*tau^n[5])/T + (a[6]*Tcritical*tau^n[6])/T "Expression 1";
          Real r2=a[1]*n[1]*tau^n[1] + a[2]*n[2]*tau^n[2] + a[3]*n[3]*tau^n[3] + a[
              4]*n[4]*tau^n[4] + a[5]*n[5]*tau^n[5] + a[6]*n[6]*tau^n[6]
            "Expression 2";
          Real dp=dcritical*(1 + b[1]*tau^m[1] + b[2]*tau^m[2] + b[3]*tau^m[3] + b[
              4]*tau^m[4] + b[5]*tau^m[5] + b[6]*tau^m[6])
            "Density of saturated liquid";
          Real dpp=dcritical*exp(c[1]*tau^o[1] + c[2]*tau^o[2] + c[3]*tau^o[3] + c[
              4]*tau^o[4] + c[5]*tau^o[5] + c[6]*tau^o[6])
            "Density of saturated vapor";
        algorithm
          r0 := -(((dp - dpp)*exp(r1)*pcritical*(r2 + r1*tau))/(dp*dpp*tau))
            "Difference of equations (7) and (6)";
          annotation (
            smoothOrder=2,
            Documentation(info="<html>
<p>Enthalpy of vaporization of water is computed from temperature in the region of 273.16 to 647.096 K.</p>
<p>Source: W Wagner, A Pruss: \"International equations for the saturation properties of ordinary water substance. Revised according to the international temperature scale of 1990\" (1993).</p>
</html>"));
        end enthalpyOfVaporization;

        redeclare function extends enthalpyOfLiquid
          "Return enthalpy of liquid water as a function of temperature T(use enthalpyOfWater instead)"

        algorithm
          h := (T - 273.15)*1e3*(4.2166 - 0.5*(T - 273.15)*(0.0033166 + 0.333333*(T
             - 273.15)*(0.00010295 - 0.25*(T - 273.15)*(1.3819e-6 + 0.2*(T - 273.15)
            *7.3221e-9))));
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
Specific enthalpy of liquid water is computed from temperature using a polynomial approach. Kept for compatibility reasons, better use <a href=\"modelica://Modelica.Media.Air.MoistAir.enthalpyOfWater\">enthalpyOfWater</a> instead.
</html>"));
        end enthalpyOfLiquid;

        redeclare function extends enthalpyOfGas
          "Return specific enthalpy of gas (air and steam) as a function of temperature T and composition X"

        algorithm
          h := Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5)*X[Water] +
            Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684)*(1.0 - X[Water]);
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
Specific enthalpy of moist air is computed from temperature, provided all water is in the gaseous state. The first entry in the composition vector X must be the mass fraction of steam. For a function that also covers the fog region please refer to <a href=\"modelica://Modelica.Media.Air.MoistAir.h_pTX\">h_pTX</a>.
</html>"));
        end enthalpyOfGas;

        redeclare function extends enthalpyOfCondensingGas
          "Return specific enthalpy of steam as a function of temperature T"

        algorithm
          h := Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5);
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
Specific enthalpy of steam is computed from temperature.
</html>"));
        end enthalpyOfCondensingGas;

        redeclare function extends enthalpyOfNonCondensingGas
          "Return specific enthalpy of dry air as a function of temperature T"

        algorithm
          h := Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684);
          annotation (
            Inline=false,
            smoothOrder=1,
            Documentation(info="<html>
Specific enthalpy of dry air is computed from temperature.
</html>"));
        end enthalpyOfNonCondensingGas;

        function enthalpyOfWater
          "Computes specific enthalpy of water (solid/liquid) near atmospheric pressure from temperature T"
          extends Modelica.Icons.Function;
          input SIunits.Temperature T "Temperature";
          output SIunits.SpecificEnthalpy h "Specific enthalpy of water";
        algorithm
          /*simple model assuming constant properties:
  heat capacity of liquid water:4200 J/kg
  heat capacity of solid water: 2050 J/kg
  enthalpy of fusion (liquid=>solid): 333000 J/kg*/

          h := Utilities.spliceFunction(
                4200*(T - 273.15),
                2050*(T - 273.15) - 333000,
                T - 273.16,
                0.1);
          annotation (derivative=enthalpyOfWater_der, Documentation(info="<html>
Specific enthalpy of water (liquid and solid) is computed from temperature using constant properties as follows:<br>
<ul>
<li>  heat capacity of liquid water:4200 J/kg</li>
<li>  heat capacity of solid water: 2050 J/kg</li>
<li>  enthalpy of fusion (liquid=>solid): 333000 J/kg</li>
</ul>
Pressure is assumed to be around 1 bar. This function is usually used to determine the specific enthalpy of the liquid or solid fraction of moist air.
</html>"));
        end enthalpyOfWater;

        function enthalpyOfWater_der "Derivative function of enthalpyOfWater"
          extends Modelica.Icons.Function;
          input SIunits.Temperature T "Temperature";
          input Real dT(unit="K/s") "Time derivative of temperature";
          output Real dh(unit="J/(kg.s)") "Time derivative of specific enthalpy";
        algorithm
          /*simple model assuming constant properties:
  heat capacity of liquid water:4200 J/kg
  heat capacity of solid water: 2050 J/kg
  enthalpy of fusion (liquid=>solid): 333000 J/kg*/

          //h:=Utilities.spliceFunction(4200*(T-273.15),2050*(T-273.15)-333000,T-273.16,0.1);
          dh := Utilities.spliceFunction_der(
                4200*(T - 273.15),
                2050*(T - 273.15) - 333000,
                T - 273.16,
                0.1,
                4200*dT,
                2050*dT,
                dT,
                0);
          annotation (Documentation(info="<html>
Derivative function for <a href=\"modelica://Modelica.Media.Air.MoistAir.enthalpyOfWater\">enthalpyOfWater</a>.

</html>"));
        end enthalpyOfWater_der;

        redeclare function extends pressure
          "Returns pressure of ideal gas as a function of the thermodynamic state record"

        algorithm
          p := state.p;
          annotation (smoothOrder=2, Documentation(info="<html>
Pressure is returned from the thermodynamic state record input as a simple assignment.
</html>"));
        end pressure;

        redeclare function extends temperature
          "Return temperature of ideal gas as a function of the thermodynamic state record"

        algorithm
          T := state.T;
          annotation (smoothOrder=2, Documentation(info="<html>
Temperature is returned from the thermodynamic state record input as a simple assignment.
</html>"));
        end temperature;

        function T_phX
          "Return temperature as a function of pressure p, specific enthalpy h and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          input MassFraction[:] X "Mass fractions of composition";
          output Temperature T "Temperature";

      protected
          package Internal
            "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;
            redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
              extends Modelica.Media.IdealGases.Common.DataRecord;
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear
            algorithm
              y := h_pTX(
                        p,
                        x,
                        X);
            end f_nonlinear;

            // Dummy definition has to be added for current Dymola
            redeclare function extends solve
            end solve;
          end Internal;

        algorithm
          T := Internal.solve(
                h,
                190,
                647,
                p,
                X[1:nXi],
                steam);
          annotation (Documentation(info="<html>
Temperature is computed from pressure, specific enthalpy and composition via numerical inversion of function <a href=\"modelica://Modelica.Media.Air.MoistAir.h_pTX\">h_pTX</a>.
</html>"));
        end T_phX;

        redeclare function extends density
          "Returns density of ideal gas as a function of the thermodynamic state record"

        algorithm
          d := state.p/(gasConstant(state)*state.T);
          annotation (smoothOrder=2, Documentation(info="<html>
Density is computed from pressure, temperature and composition in the thermodynamic state record applying the ideal gas law.
</html>"));
        end density;

        redeclare function extends specificEnthalpy
          "Return specific enthalpy of moist air as a function of the thermodynamic state record"

        algorithm
          h := h_pTX(
                state.p,
                state.T,
                state.X);
          annotation (smoothOrder=2, Documentation(info="<html>
Specific enthalpy of moist air is computed from the thermodynamic state record. The fog region is included for both, ice and liquid fog.
</html>"));
        end specificEnthalpy;

        function h_pTX
          "Return specific enthalpy of moist air as a function of pressure p, temperature T and composition X"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T, X";
      protected
          SI.AbsolutePressure p_steam_sat "partial saturation pressure of steam";
          SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
          SI.MassFraction X_liquid "Mass fraction of liquid water";
          SI.MassFraction X_steam "Mass fraction of steam water";
          SI.MassFraction X_air "Mass fraction of air";
        algorithm
          p_steam_sat := saturationPressure(T);
          //p_steam_sat :=min(saturationPressure(T), 0.999*p);
          X_sat := min(p_steam_sat*k_mair/max(100*Constants.eps, p - p_steam_sat)*(
            1 - X[Water]), 1.0);
          X_liquid := max(X[Water] - X_sat, 0.0);
          X_steam := X[Water] - X_liquid;
          X_air := 1 - X[Water];
          /* h        := {SingleGasNasa.h_Tlow(data=steam,  T=T, refChoice=ReferenceEnthalpy.UserDefined, h_off=46479.819+2501014.5),
               SingleGasNasa.h_Tlow(data=dryair, T=T, refChoice=ReferenceEnthalpy.UserDefined, h_off=25104.684)}*
    {X_steam, X_air} + enthalpyOfLiquid(T)*X_liquid;*/
          h := {Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5),
            Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684)}*{X_steam,X_air} + enthalpyOfWater(T)*X_liquid;
          annotation (
            derivative=h_pTX_der,
            Inline=false,
            Documentation(info="<html>
Specific enthalpy of moist air is computed from pressure, temperature and composition with X[1] as the total water mass fraction. The fog region is included for both, ice and liquid fog.
</html>"));
        end h_pTX;

        function h_pTX_der "Derivative function of h_pTX"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          input Real dp(unit="Pa/s") "Pressure derivative";
          input Real dT(unit="K/s") "Temperature derivative";
          input Real dX[:](each unit="1/s") "Composition derivative";
          output Real h_der(unit="J/(kg.s)") "Time derivative of specific enthalpy";
      protected
          SI.AbsolutePressure p_steam_sat "partial saturation pressure of steam";
          SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
          SI.MassFraction X_liquid "Mass fraction of liquid water";
          SI.MassFraction X_steam "Mass fraction of steam water";
          SI.MassFraction X_air "Mass fraction of air";
          SI.MassFraction x_sat
            "Absolute humidity per unit mass of dry air at saturation";
          Real dX_steam(unit="1/s") "Time derivative of steam mass fraction";
          Real dX_air(unit="1/s") "Time derivative of dry air mass fraction";
          Real dX_liq(unit="1/s")
            "Time derivative of liquid/solid water mass fraction";
          Real dps(unit="Pa/s") "Time derivative of saturation pressure";
          Real dx_sat(unit="1/s")
            "Time derivative of absolute humidity per unit mass of dry air";
        algorithm
          p_steam_sat := saturationPressure(T);
          x_sat := p_steam_sat*k_mair/max(100*Modelica.Constants.eps, p -
            p_steam_sat);
          X_sat := min(x_sat*(1 - X[Water]), 1.0);
          X_liquid := Utilities.smoothMax(
                X[Water] - X_sat,
                0.0,
                1e-5);
          X_steam := X[Water] - X_liquid;
          X_air := 1 - X[Water];

          dX_air := -dX[Water];
          dps := saturationPressure_der(Tsat=T, dTsat=dT);
          dx_sat := k_mair*(dps*(p - p_steam_sat) - p_steam_sat*(dp - dps))/(p -
            p_steam_sat)/(p - p_steam_sat);
          dX_liq := Utilities.smoothMax_der(
                X[Water] - X_sat,
                0.0,
                1e-5,
                (1 + x_sat)*dX[Water] - (1 - X[Water])*dx_sat,
                0,
                0);
          dX_steam := dX[Water] - dX_liq;

          h_der := X_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow_der(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5,
                dT=dT) + dX_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5) + X_air*
            Modelica.Media.IdealGases.Common.Functions.h_Tlow_der(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684,
                dT=dT) + dX_air*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684) + X_liquid*enthalpyOfWater_der(T=T, dT=dT) +
            dX_liq*enthalpyOfWater(T);

          annotation (
            Inline=false,
            smoothOrder=1,
            Documentation(info="<html>
Derivative function for <a href=\"modelica://Modelica.Media.Air.MoistAir.h_pTX\">h_pTX</a>.
</html>"));
        end h_pTX_der;

        redeclare function extends isentropicExponent
          "Return isentropic exponent (only for gas fraction!)"
        algorithm
          gamma := specificHeatCapacityCp(state)/specificHeatCapacityCv(state);
        end isentropicExponent;

        redeclare function extends specificInternalEnergy
          "Return specific internal energy of moist air as a function of the thermodynamic state record"
          extends Modelica.Icons.Function;
          output SI.SpecificInternalEnergy u "Specific internal energy";
        algorithm
          u := specificInternalEnergy_pTX(
                state.p,
                state.T,
                state.X);

          annotation (smoothOrder=2, Documentation(info="<html>
Specific internal energy is determined from the thermodynamic state record, assuming that the liquid or solid water volume is negligible.
</html>"));
        end specificInternalEnergy;

        function specificInternalEnergy_pTX
          "Return specific internal energy of moist air as a function of pressure p, temperature T and composition X"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          output SI.SpecificInternalEnergy u "Specific internal energy";
      protected
          SI.AbsolutePressure p_steam_sat "partial saturation pressure of steam";
          SI.MassFraction X_liquid "Mass fraction of liquid water";
          SI.MassFraction X_steam "Mass fraction of steam water";
          SI.MassFraction X_air "Mass fraction of air";
          SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
          Real R_gas "Ideal gas constant";
        algorithm
          p_steam_sat := saturationPressure(T);
          X_sat := min(p_steam_sat*k_mair/max(100*Constants.eps, p - p_steam_sat)*(
            1 - X[Water]), 1.0);
          X_liquid := max(X[Water] - X_sat, 0.0);
          X_steam := X[Water] - X_liquid;
          X_air := 1 - X[Water];
          R_gas := dryair.R*X_air/(1 - X_liquid) + steam.R*X_steam/(1 - X_liquid);
          u := X_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5) + X_air*
            Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684) + enthalpyOfWater(T)*X_liquid - R_gas*T;

          annotation (derivative=specificInternalEnergy_pTX_der, Documentation(info=
                 "<html>
Specific internal energy is determined from pressure p, temperature T and composition X, assuming that the liquid or solid water volume is negligible.
</html>"));
        end specificInternalEnergy_pTX;

        function specificInternalEnergy_pTX_der
          "Derivative function for specificInternalEnergy_pTX"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          input Real dp(unit="Pa/s") "Pressure derivative";
          input Real dT(unit="K/s") "Temperature derivative";
          input Real dX[:](each unit="1/s") "Mass fraction derivatives";
          output Real u_der(unit="J/(kg.s)") "Specific internal energy derivative";
      protected
          SI.AbsolutePressure p_steam_sat "partial saturation pressure of steam";
          SI.MassFraction X_liquid "Mass fraction of liquid water";
          SI.MassFraction X_steam "Mass fraction of steam water";
          SI.MassFraction X_air "Mass fraction of air";
          SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
          SI.SpecificHeatCapacity R_gas "Ideal gas constant";

          SI.MassFraction x_sat
            "Absolute humidity per unit mass of dry air at saturation";
          Real dX_steam(unit="1/s") "Time derivative of steam mass fraction";
          Real dX_air(unit="1/s") "Time derivative of dry air mass fraction";
          Real dX_liq(unit="1/s")
            "Time derivative of liquid/solid water mass fraction";
          Real dps(unit="Pa/s") "Time derivative of saturation pressure";
          Real dx_sat(unit="1/s")
            "Time derivative of absolute humidity per unit mass of dry air";
          Real dR_gas(unit="J/(kg.K.s)") "Time derivative of ideal gas constant";
        algorithm
          p_steam_sat := saturationPressure(T);
          x_sat := p_steam_sat*k_mair/max(100*Modelica.Constants.eps, p -
            p_steam_sat);
          X_sat := min(x_sat*(1 - X[Water]), 1.0);
          X_liquid := Utilities.spliceFunction(
                X[Water] - X_sat,
                0.0,
                X[Water] - X_sat,
                1e-6);
          X_steam := X[Water] - X_liquid;
          X_air := 1 - X[Water];
          R_gas := steam.R*X_steam/(1 - X_liquid) + dryair.R*X_air/(1 - X_liquid);

          dX_air := -dX[Water];
          dps := saturationPressure_der(Tsat=T, dTsat=dT);
          dx_sat := k_mair*(dps*(p - p_steam_sat) - p_steam_sat*(dp - dps))/(p -
            p_steam_sat)/(p - p_steam_sat);
          dX_liq := Utilities.spliceFunction_der(
                X[Water] - X_sat,
                0.0,
                X[Water] - X_sat,
                1e-6,
                (1 + x_sat)*dX[Water] - (1 - X[Water])*dx_sat,
                0.0,
                (1 + x_sat)*dX[Water] - (1 - X[Water])*dx_sat,
                0.0);
          dX_steam := dX[Water] - dX_liq;
          dR_gas := (steam.R*(dX_steam*(1 - X_liquid) + dX_liq*X_steam) + dryair.R*
            (dX_air*(1 - X_liquid) + dX_liq*X_air))/(1 - X_liquid)/(1 - X_liquid);

          u_der := X_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow_der(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5,
                dT=dT) + dX_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5) + X_air*
            Modelica.Media.IdealGases.Common.Functions.h_Tlow_der(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684,
                dT=dT) + dX_air*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684) + X_liquid*enthalpyOfWater_der(T=T, dT=dT) +
            dX_liq*enthalpyOfWater(T) - dR_gas*T - R_gas*dT;
          annotation (Documentation(info="<html>
Derivative function for <a href=\"modelica://Modelica.Media.Air.MoistAir.specificInternalEnergy_pTX\">specificInternalEnergy_pTX</a>.
</html>"));
        end specificInternalEnergy_pTX_der;

        redeclare function extends specificEntropy
          "Return specific entropy from thermodynamic state record, only valid for phi<1"

        algorithm
          s := s_pTX(
                state.p,
                state.T,
                state.X);
          annotation (
            Inline=false,
            smoothOrder=2,
            Documentation(info="<html>
Specific entropy is calculated from the thermodynamic state record, assuming ideal gas behavior and including entropy of mixing. Liquid or solid water is not taken into account, the entire water content X[1] is assumed to be in the vapor state (relative humidity below 1.0).
</html>"));
        end specificEntropy;

        redeclare function extends specificGibbsEnergy
          "Return specific Gibbs energy as a function of the thermodynamic state record, only valid for phi<1"
          extends Modelica.Icons.Function;
        algorithm
          g := h_pTX(
                state.p,
                state.T,
                state.X) - state.T*specificEntropy(state);
          annotation (smoothOrder=2, Documentation(info="<html>
The Gibbs Energy is computed from the thermodynamic state record for moist air with a water content below saturation.
</html>"));
        end specificGibbsEnergy;

        redeclare function extends specificHelmholtzEnergy
          "Return specific Helmholtz energy as a function of the thermodynamic state record, only valid for phi<1"
          extends Modelica.Icons.Function;
        algorithm
          f := h_pTX(
                state.p,
                state.T,
                state.X) - gasConstant(state)*state.T - state.T*specificEntropy(
            state);
          annotation (smoothOrder=2, Documentation(info="<html>
The Specific Helmholtz Energy is computed from the thermodynamic state record for moist air with a water content below saturation.
</html>"));
        end specificHelmholtzEnergy;

        redeclare function extends specificHeatCapacityCp
          "Return specific heat capacity at constant pressure as a function of the thermodynamic state record"

      protected
          Real dT(unit="s/K") = 1.0;
        algorithm
          cp := h_pTX_der(
                state.p,
                state.T,
                state.X,
                0.0,
                1.0,
                zeros(size(state.X, 1)))*dT "Definition of cp: dh/dT @ constant p";
          //      cp:= SingleGasNasa.cp_Tlow(dryair, state.T)*(1-state.X[Water])
          //        + SingleGasNasa.cp_Tlow(steam, state.T)*state.X[Water];
          annotation (
            Inline=false,
            smoothOrder=2,
            Documentation(info="<html>
The specific heat capacity at constant pressure <strong>cp</strong> is computed from temperature and composition for a mixture of steam (X[1]) and dry air. All water is assumed to be in the vapor state.
</html>"));
        end specificHeatCapacityCp;

        redeclare function extends specificHeatCapacityCv
          "Return specific heat capacity at constant volume as a function of the thermodynamic state record"

        algorithm
          cv := Modelica.Media.IdealGases.Common.Functions.cp_Tlow(dryair, state.T)
            *(1 - state.X[Water]) +
            Modelica.Media.IdealGases.Common.Functions.cp_Tlow(steam, state.T)*
            state.X[Water] - gasConstant(state);
          annotation (
            Inline=false,
            smoothOrder=2,
            Documentation(info="<html>
The specific heat capacity at constant density <strong>cv</strong> is computed from temperature and composition for a mixture of steam (X[1]) and dry air. All water is assumed to be in the vapor state.
</html>"));
        end specificHeatCapacityCv;

      redeclare function extends dynamicViscosity
          "Return dynamic viscosity as a function of the thermodynamic state record, valid from 123.15 K to 1273.15 K"

        import Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
      algorithm
        eta := 1e-6*Polynomials_Temp.evaluateWithRange(
            {9.7391102886305869E-15,-3.1353724870333906E-11,4.3004876595642225E-08,
            -3.8228016291758240E-05,5.0427874367180762E-02,1.7239260139242528E+01},
            Cv.to_degC(123.15),
            Cv.to_degC(1273.15),
            Cv.to_degC(state.T));
        annotation (smoothOrder=2, Documentation(info="<html>
<p>Dynamic viscosity is computed from temperature using a simple polynomial for dry air. Range of validity is from 123.15 K to 1273.15 K. The influence of pressure and moisture is neglected.</p>
<p>Source: VDI Waermeatlas, 8th edition.</p>
</html>"));
      end dynamicViscosity;

      redeclare function extends thermalConductivity
          "Return thermal conductivity as a function of the thermodynamic state record, valid from 123.15 K to 1273.15 K"
        import Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
        import Cv = Modelica.SIunits.Conversions;
      algorithm
        lambda := 1e-3*Polynomials_Temp.evaluateWithRange(
            {6.5691470817717812E-15,-3.4025961923050509E-11,5.3279284846303157E-08,
            -4.5340839289219472E-05,7.6129675309037664E-02,2.4169481088097051E+01},
            Cv.to_degC(123.15),
            Cv.to_degC(1273.15),
            Cv.to_degC(state.T));

        annotation (smoothOrder=2, Documentation(info="<html>
<p>Thermal conductivity is computed from temperature using a simple polynomial for dry air. Range of validity is from 123.15 K to 1273.15 K. The influence of pressure and moisture is neglected.</p>
<p>Source: VDI Waermeatlas, 8th edition.</p>
</html>"));
      end thermalConductivity;

        redeclare function extends velocityOfSound
        algorithm
          a := sqrt(isentropicExponent(state)*gasConstant(state)*temperature(state));
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end velocityOfSound;

        redeclare function extends isobaricExpansionCoefficient

        algorithm
          beta := 1/temperature(state);
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end isobaricExpansionCoefficient;

        redeclare function extends isothermalCompressibility

        algorithm
          kappa := 1/pressure(state);
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end isothermalCompressibility;

        redeclare function extends density_derp_h

        algorithm
          ddph := 1/(gasConstant(state)*temperature(state));

          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derp_h;

        redeclare function extends density_derh_p

        algorithm
          ddhp := -density(state)/(specificHeatCapacityCp(state)*temperature(state));
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derh_p;

        redeclare function extends density_derp_T

        algorithm
          ddpT := 1/(gasConstant(state)*temperature(state));

          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derp_T;

        redeclare function extends density_derT_p

        algorithm
          ddTp := -density(state)/temperature(state);
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derT_p;

        redeclare function extends density_derX

        algorithm
          dddX[Water] := pressure(state)*(steam.R - dryair.R)/((steam.R - dryair.R)
            *state.X[Water]*temperature(state) + dryair.R*temperature(state))^2;
          dddX[Air] := pressure(state)*(dryair.R - steam.R)/((dryair.R - steam.R)*
            state.X[Air]*temperature(state) + steam.R*temperature(state))^2;

          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derX;

        redeclare function extends molarMass
        algorithm
          MM := Modelica.Constants.R/Modelica.Media.Air.MoistAir.gasConstant(state);
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end molarMass;

        function T_psX
          "Return temperature as a function of pressure p, specific entropy s and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEntropy s "Specific entropy";
          input MassFraction[:] X "Mass fractions of composition";
          output Temperature T "Temperature";

      protected
          package Internal "Solve s(data,T) for T with given s"
            extends Modelica.Media.Common.OneNonLinearEquation;
            redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
              extends Modelica.Media.IdealGases.Common.DataRecord;
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear
            algorithm
              y := s_pTX(
                        p,
                        x,
                        X);
            end f_nonlinear;

            // Dummy definition has to be added for current Dymola
            redeclare function extends solve
            end solve;
          end Internal;

        algorithm
          T := Internal.solve(
                s,
                190,
                647,
                p,
                X[1:nX],
                steam);
          annotation (Documentation(info="<html>
Temperature is computed from pressure, specific entropy and composition via numerical inversion of function <a href=\"modelica://Modelica.Media.Air.MoistAir.specificEntropy\">specificEntropy</a>.
</html>",     revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end T_psX;

        redeclare function extends setState_psX
        algorithm
          state := if size(X, 1) == nX then ThermodynamicState(
                p=p,
                T=T_psX(
                  p,
                  s,
                  X),
                X=X) else ThermodynamicState(
                p=p,
                T=T_psX(
                  p,
                  s,
                  X),
                X=cat(
                  1,
                  X,
                  {1 - sum(X)}));
          annotation (smoothOrder=2, Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>",     revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end setState_psX;

        function s_pTX
          "Return specific entropy of moist air as a function of pressure p, temperature T and composition X (only valid for phi<1)"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          output SI.SpecificEntropy s "Specific entropy at p, T, X";
      protected
          MoleFraction[2] Y=massToMoleFractions(X, {steam.MM,dryair.MM})
            "Molar fraction";

        algorithm
          s := Modelica.Media.IdealGases.Common.Functions.s0_Tlow(dryair, T)*(1 - X[
            Water]) + Modelica.Media.IdealGases.Common.Functions.s0_Tlow(steam, T)*
            X[Water] - Modelica.Constants.R*(Utilities.smoothMax(
                X[Water]/MMX[Water]*Modelica.Math.log(max(Y[Water], Modelica.Constants.eps)
              *p/reference_p),
                0.0,
                1e-9) - Utilities.smoothMax(
                (1 - X[Water])/MMX[Air]*Modelica.Math.log(max(Y[Air], Modelica.Constants.eps)
              *p/reference_p),
                0.0,
                1e-9));
          annotation (
            derivative=s_pTX_der,
            Inline=false,
            Documentation(info="<html>
Specific entropy of moist air is computed from pressure, temperature and composition with X[1] as the total water mass fraction.
</html>",     revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"),  Icon(graphics={Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,127,0},
                  textString="f")}));
        end s_pTX;

        function s_pTX_der
          "Return specific entropy of moist air as a function of pressure p, temperature T and composition X (only valid for phi<1)"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          input Real dp(unit="Pa/s") "Derivative of pressure";
          input Real dT(unit="K/s") "Derivative of temperature";
          input Real dX[nX](each unit="1/s") "Derivative of mass fractions";
          output Real ds(unit="J/(kg.K.s)") "Specific entropy at p, T, X";
      protected
          MoleFraction[2] Y=massToMoleFractions(X, {steam.MM,dryair.MM})
            "Molar fraction";

        algorithm
          ds := Modelica.Media.IdealGases.Common.Functions.s0_Tlow_der(
                dryair,
                T,
                dT)*(1 - X[Water]) +
            Modelica.Media.IdealGases.Common.Functions.s0_Tlow_der(
                steam,
                T,
                dT)*X[Water] + Modelica.Media.IdealGases.Common.Functions.s0_Tlow(
            dryair, T)*dX[Air] + Modelica.Media.IdealGases.Common.Functions.s0_Tlow(
            steam, T)*dX[Water] - Modelica.Constants.R*(1/MMX[Water]*
            Utilities.smoothMax_der(
                X[Water]*Modelica.Math.log(max(Y[Water], Modelica.Constants.eps)*p/
              reference_p),
                0.0,
                1e-9,
                (Modelica.Math.log(max(Y[Water], Modelica.Constants.eps)*p/
              reference_p) + (X[Water]/Y[Water]*(X[Air]*MMX[Water]/(X[Air]*MMX[
              Water] + X[Water]*MMX[Air])^2)))*dX[Water] + X[Water]*reference_p/p*
              dp,
                0,
                0) - 1/MMX[Air]*Utilities.smoothMax_der(
                (1 - X[Water])*Modelica.Math.log(max(Y[Air], Modelica.Constants.eps)
              *p/reference_p),
                0.0,
                1e-9,
                (Modelica.Math.log(max(Y[Air], Modelica.Constants.eps)*p/
              reference_p) + (X[Air]/Y[Air]*(X[Water]*MMX[Air]/(X[Air]*MMX[Water]
               + X[Water]*MMX[Air])^2)))*dX[Air] + X[Air]*reference_p/p*dp,
                0,
                0));
          annotation (
            Inline=false,
            smoothOrder=1,
            Documentation(info="<html>
Specific entropy of moist air is computed from pressure, temperature and composition with X[1] as the total water mass fraction.
</html>",     revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"),  Icon(graphics={Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,127,0},
                  textString="f")}));
        end s_pTX_der;

        redeclare function extends isentropicEnthalpy
          "Isentropic enthalpy (only valid for phi<1)"
          extends Modelica.Icons.Function;
        algorithm
          h_is := Modelica.Media.Air.MoistAir.h_pTX(
                p_downstream,
                Modelica.Media.Air.MoistAir.T_psX(
                  p_downstream,
                  Modelica.Media.Air.MoistAir.specificEntropy(refState),
                  refState.X),
                refState.X);

          annotation (Icon(graphics={Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,127,0},
                  textString="f")}), Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end isentropicEnthalpy;

        package Utilities "Utility functions"
          extends Modelica.Icons.UtilitiesPackage;

          function spliceFunction "Spline interpolation of two functions"
            extends Modelica.Icons.Function;
            input Real pos "Returned value for x-deltax >= 0";
            input Real neg "Returned value for x+deltax <= 0";
            input Real x "Function argument";
            input Real deltax=1 "Region around x with spline interpolation";
            output Real out;
        protected
            Real scaledX;
            Real scaledX1;
            Real y;
          algorithm
            scaledX1 := x/deltax;
            scaledX := scaledX1*Modelica.Math.asin(1);
            if scaledX1 <= -0.999999999 then
              y := 0;
            elseif scaledX1 >= 0.999999999 then
              y := 1;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
            end if;
            out := pos*y + (1 - y)*neg;
            annotation (derivative=spliceFunction_der);
          end spliceFunction;

          function spliceFunction_der "Derivative of spliceFunction"
            extends Modelica.Icons.Function;
            input Real pos;
            input Real neg;
            input Real x;
            input Real deltax=1;
            input Real dpos;
            input Real dneg;
            input Real dx;
            input Real ddeltax=0;
            output Real out;
        protected
            Real scaledX;
            Real scaledX1;
            Real dscaledX1;
            Real y;
          algorithm
            scaledX1 := x/deltax;
            scaledX := scaledX1*Modelica.Math.asin(1);
            dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
            if scaledX1 <= -0.99999999999 then
              y := 0;
            elseif scaledX1 >= 0.9999999999 then
              y := 1;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
            end if;
            out := dpos*y + (1 - y)*dneg;
            if (abs(scaledX1) < 1) then
              out := out + (pos - neg)*dscaledX1*Modelica.Math.asin(1)/2/(
                Modelica.Math.cosh(Modelica.Math.tan(scaledX))*Modelica.Math.cos(
                scaledX))^2;
            end if;
          end spliceFunction_der;

          function smoothMax
            extends Modelica.Icons.Function;
            import Modelica.Math;

            input Real x1 "First argument of smooth max operator";
            input Real x2 "Second argument of smooth max operator";
            input Real dx
              "Approximate difference between x1 and x2, below which regularization starts";
            output Real y "Result of smooth max operator";
          algorithm
            y := max(x1, x2) + Math.log((exp((4/dx)*(x1 - max(x1, x2)))) + (exp((4/
              dx)*(x2 - max(x1, x2)))))/(4/dx);
            annotation (smoothOrder=2, Documentation(info="<html>
<p>An implementation of Kreisselmeier Steinhauser smooth maximum</p>
</html>"));
          end smoothMax;

          function smoothMax_der
            extends Modelica.Icons.Function;

            import Modelica.Math.exp;
            import Modelica.Math.log;

            input Real x1 "First argument of smooth max operator";
            input Real x2 "Second argument of smooth max operator";
            input Real dx
              "Approximate difference between x1 and x2, below which regularization starts";
            input Real dx1;
            input Real dx2;
            input Real ddx;
            output Real dy "Derivative of smooth max operator";
          algorithm
            dy := (if x1 > x2 then dx1 else dx2) + 0.25*(((4*(dx1 - (if x1 > x2
               then dx1 else dx2))/dx - 4*(x1 - max(x1, x2))*ddx/dx^2)*exp(4*(x1 -
              max(x1, x2))/dx) + (4*(dx2 - (if x1 > x2 then dx1 else dx2))/dx - 4*(
              x2 - max(x1, x2))*ddx/dx^2)*exp(4*(x2 - max(x1, x2))/dx))*dx/(exp(4*(
              x1 - max(x1, x2))/dx) + exp(4*(x2 - max(x1, x2))/dx)) + log(exp(4*(x1
               - max(x1, x2))/dx) + exp(4*(x2 - max(x1, x2))/dx))*ddx);

            annotation (Documentation(info="<html>
<p>An implementation of Kreisselmeier Steinhauser smooth maximum</p>
</html>"));
          end smoothMax_der;
        end Utilities;
        annotation (Documentation(info="<html>
<h4>Thermodynamic Model</h4>
<p>This package provides a full thermodynamic model of moist air including the fog region and temperatures below zero degC.
The governing assumptions in this model are:</p>
<ul>
<li>the perfect gas law applies</li>
<li>water volume other than that of steam is neglected</li></ul>
<p>All extensive properties are expressed in terms of the total mass in order to comply with other media in this library. However, for moist air it is rather common to express the absolute humidity in terms of mass of dry air only, which has advantages when working with charts. In addition, care must be taken, when working with mass fractions with respect to total mass, that all properties refer to the same water content when being used in mathematical operations (which is always the case if based on dry air only). Therefore two absolute humidities are computed in the <strong>BaseProperties</strong> model: <strong>X</strong> denotes the absolute humidity in terms of the total mass while <strong>x</strong> denotes the absolute humidity per unit mass of dry air. In addition, the relative humidity <strong>phi</strong> is also computed.</p>
<p>At the triple point temperature of water of 0.01 &deg;C or 273.16 K and a relative humidity greater than 1 fog may be present as liquid and as ice resulting in a specific enthalpy somewhere between those of the two isotherms for solid and liquid fog, respectively. For numerical reasons a coexisting mixture of 50% solid and 50% liquid fog is assumed in the fog region at the triple point in this model.</p>

<h4>Range of validity</h4>
<p>From the assumptions mentioned above it follows that the <strong>pressure</strong> should be in the region around <strong>atmospheric</strong> conditions or below (a few bars may still be fine though). Additionally a very high water content at low temperatures would yield incorrect densities, because the volume of the liquid or solid phase would not be negligible anymore. The model does not provide information on limits for water drop size in the fog region or transport information for the actual condensation or evaporation process in combination with surfaces. All excess water which is not in its vapour state is assumed to be still present in the air regarding its energy but not in terms of its spatial extent.<br><br>
The thermodynamic model may be used for <strong>temperatures</strong> ranging from <strong>190 ... 647 K</strong>. This holds for all functions unless otherwise stated in their description. However, although the model works at temperatures above the saturation temperature it is questionable to use the term \"relative humidity\" in this region. Please note, that although several functions compute pure water properties, they are designed to be used within the moist air medium model where properties are dominated by air and steam in their vapor states, and not for pure liquid water applications.</p>

<h4>Transport Properties</h4>
<p>Several additional functions that are not needed to describe the thermodynamic system, but are required to model transport processes, like heat and mass transfer, may be called. They usually neglect the moisture influence unless otherwise stated.</p>

<h4>Application</h4>
<p>The model's main area of application is all processes that involve moist air cooling under near atmospheric pressure with possible moisture condensation. This is the case in all domestic and industrial air conditioning applications. Another large domain of moist air applications covers all processes that deal with dehydration of bulk material using air as a transport medium. Engineering tasks involving moist air are often performed (or at least visualized) by using charts that contain all relevant thermodynamic data for a moist air system. These so called psychrometric charts can be generated from the medium properties in this package. The model <a href=\"modelica://Modelica.Media.Examples.PsychrometricData\">PsychrometricData</a> may be used for this purpose in order to obtain data for figures like those below (the plotting itself is not part of the model though).</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Media/Air/Mollier.png\"><br>
<img src=\"modelica://Modelica/Resources/Images/Media/Air/PsycroChart.png\">
</p>

<p>
<strong>Legend:</strong> blue - constant specific enthalpy, red - constant temperature, black - constant relative humidity</p>

</html>"));
      end MoistAir;
      annotation (Documentation(info="<html>
  <p>This package contains different medium models for air:</p>
<ul>
<li><strong>SimpleAir</strong><br>
    Simple dry air medium in a limited temperature range.</li>
<li><strong>DryAirNasa</strong><br>
    Dry air as an ideal gas from Media.IdealGases.MixtureGases.Air.</li>
<li><strong>MoistAir</strong><br>
    Moist air as an ideal gas mixture of steam and dry air with fog below and above the triple point temperature.</li>
</ul>
</html>"));
    end Air;

    package IdealGases
    "Data and models of ideal gases (single, fixed and dynamic mixtures) from NASA source"
      extends Modelica.Icons.VariantsPackage;

      package Common "Common packages and data for the ideal gas models"
      extends Modelica.Icons.Package;

      record DataRecord
        "Coefficient data record for properties of ideal gases based on NASA source"
        extends Modelica.Icons.Record;
        String name "Name of ideal gas";
        SI.MolarMass MM "Molar mass";
        SI.SpecificEnthalpy Hf "Enthalpy of formation at 298.15K";
        SI.SpecificEnthalpy H0 "H0(298.15K) - H0(0K)";
        SI.Temperature Tlimit "Temperature limit between low and high data sets";
        Real alow[7] "Low temperature coefficients a";
        Real blow[2] "Low temperature constants b";
        Real ahigh[7] "High temperature coefficients a";
        Real bhigh[2] "High temperature constants b";
        SI.SpecificHeatCapacity R "Gas constant";
        annotation (Documentation(info="<html>
<p>
This data record contains the coefficients for the
ideal gas equations according to:
</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>
The equations have the following structure:
</p>
<img src=\"modelica://Modelica/Resources/Images/Media/IdealGases/singleEquations.png\">
<p>
The polynomials for h(T) and s0(T) are derived via integration from the one for cp(T)  and contain the integration constants b1, b2 that define the reference specific enthalpy and entropy. For entropy differences the reference pressure p0 is arbitrary, but not for absolute entropies. It is chosen as 1 standard atmosphere (101325 Pa).
</p>
<p>
For most gases, the region of validity is from 200 K to 6000 K.
The equations are split into two regions that are separated
by Tlimit (usually 1000 K). In both regions the gas is described
by the data above. The two branches are continuous and in most
gases also differentiable at Tlimit.
</p>
</html>"));
      end DataRecord;

        package Functions
        "Basic Functions for ideal gases: cp, h, s, thermal conductivity, viscosity"
          extends Modelica.Icons.FunctionsPackage;

          constant Boolean excludeEnthalpyOfFormation=true
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";

          constant Modelica.Media.Interfaces.Choices.ReferenceEnthalpy referenceChoice=Modelica.Media.Interfaces.Choices.ReferenceEnthalpy.ZeroAt0K
            "Choice of reference enthalpy";

          constant Modelica.Media.Interfaces.Types.SpecificEnthalpy h_offset=0.0
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";

          constant Integer methodForThermalConductivity(min=1,max=2)=1;

          function cp_T
            "Compute specific heat capacity at constant pressure from temperature and gas data"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            output SI.SpecificHeatCapacity cp "Specific heat capacity at temperature T";
          algorithm
            cp := smooth(0,if T < data.Tlimit then data.R*(1/(T*T)*(data.alow[1] + T*(
              data.alow[2] + T*(1.*data.alow[3] + T*(data.alow[4] + T*(data.alow[5] + T
              *(data.alow[6] + data.alow[7]*T))))))) else data.R*(1/(T*T)*(data.ahigh[1]
               + T*(data.ahigh[2] + T*(1.*data.ahigh[3] + T*(data.ahigh[4] + T*(data.
              ahigh[5] + T*(data.ahigh[6] + data.ahigh[7]*T))))))));
            annotation (Inline=true,smoothOrder=2);
          end cp_T;

          function cp_Tlow
            "Compute specific heat capacity at constant pressure, low T region"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            output SI.SpecificHeatCapacity cp "Specific heat capacity at temperature T";
          algorithm
            cp := data.R*(1/(T*T)*(data.alow[1] + T*(
              data.alow[2] + T*(1.*data.alow[3] + T*(data.alow[4] + T*(data.alow[5] + T
              *(data.alow[6] + data.alow[7]*T)))))));
            annotation (Inline=false, derivative(zeroDerivative=data) = cp_Tlow_der);
          end cp_Tlow;

          function cp_Tlow_der
            "Compute specific heat capacity at constant pressure, low T region"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Real dT "Temperature derivative";
            output Real cp_der "Derivative of specific heat capacity";
          algorithm
            cp_der := dT*data.R/(T*T*T)*(-2*data.alow[1] + T*(
              -data.alow[2] + T*T*(data.alow[4] + T*(2.*data.alow[5] + T
              *(3.*data.alow[6] + 4.*data.alow[7]*T)))));
            annotation(smoothOrder=2);
          end cp_Tlow_der;

          function h_T "Compute specific enthalpy from temperature and gas data; reference is decided by the
    refChoice input, or by the referenceChoice package constant by default"
            import Modelica.Media.Interfaces.Choices;
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Boolean exclEnthForm=excludeEnthalpyOfFormation
              "If true, enthalpy of formation Hf is not included in specific enthalpy h";
            input Modelica.Media.Interfaces.Choices.ReferenceEnthalpy
                                            refChoice=referenceChoice
              "Choice of reference enthalpy";
            input SI.SpecificEnthalpy h_off=h_offset
              "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
            output SI.SpecificEnthalpy h "Specific enthalpy at temperature T";

          algorithm
            h := smooth(0,(if T < data.Tlimit then data.R*((-data.alow[1] + T*(data.
              blow[1] + data.alow[2]*Math.log(T) + T*(1.*data.alow[3] + T*(0.5*data.
              alow[4] + T*(1/3*data.alow[5] + T*(0.25*data.alow[6] + 0.2*data.alow[7]*T))))))
              /T) else data.R*((-data.ahigh[1] + T*(data.bhigh[1] + data.ahigh[2]*
              Math.log(T) + T*(1.*data.ahigh[3] + T*(0.5*data.ahigh[4] + T*(1/3*data.
              ahigh[5] + T*(0.25*data.ahigh[6] + 0.2*data.ahigh[7]*T))))))/T)) + (if
              exclEnthForm then -data.Hf else 0.0) + (if (refChoice
               == Choices.ReferenceEnthalpy.ZeroAt0K) then data.H0 else 0.0) + (if
              refChoice == Choices.ReferenceEnthalpy.UserDefined then h_off else
                    0.0));
            annotation (Inline=false,smoothOrder=2);
          end h_T;

          function h_Tlow "Compute specific enthalpy, low T region; reference is decided by the
    refChoice input, or by the referenceChoice package constant by default"
            import Modelica.Media.Interfaces.Choices;
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Boolean exclEnthForm=excludeEnthalpyOfFormation
              "If true, enthalpy of formation Hf is not included in specific enthalpy h";
            input Modelica.Media.Interfaces.Choices.ReferenceEnthalpy
                                            refChoice=referenceChoice
              "Choice of reference enthalpy";
            input SI.SpecificEnthalpy h_off=h_offset
              "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
            output SI.SpecificEnthalpy h "Specific enthalpy at temperature T";

          algorithm
            h := data.R*((-data.alow[1] + T*(data.
              blow[1] + data.alow[2]*Math.log(T) + T*(1.*data.alow[3] + T*(0.5*data.
              alow[4] + T*(1/3*data.alow[5] + T*(0.25*data.alow[6] + 0.2*data.alow[7]*T))))))
              /T) + (if
              exclEnthForm then -data.Hf else 0.0) + (if (refChoice
               == Choices.ReferenceEnthalpy.ZeroAt0K) then data.H0 else 0.0) + (if
              refChoice == Choices.ReferenceEnthalpy.UserDefined then h_off else
                    0.0);
            annotation(Inline=false,smoothOrder=2);
          end h_Tlow;

          function h_Tlow_der "Compute specific enthalpy, low T region; reference is decided by the
    refChoice input, or by the referenceChoice package constant by default"
            import Modelica.Media.Interfaces.Choices;
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Boolean exclEnthForm=excludeEnthalpyOfFormation
              "If true, enthalpy of formation Hf is not included in specific enthalpy h";
            input Modelica.Media.Interfaces.Choices.ReferenceEnthalpy
                                            refChoice=referenceChoice
              "Choice of reference enthalpy";
            input SI.SpecificEnthalpy h_off=h_offset
              "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
            input Real dT(unit="K/s") "Temperature derivative";
            output Real h_der(unit="J/(kg.s)")
              "Derivative of specific enthalpy at temperature T";
          algorithm
            h_der := dT*Modelica.Media.IdealGases.Common.Functions.cp_Tlow(
                                data,T);
            annotation(Inline=true,smoothOrder=2);
          end h_Tlow_der;

          function s0_T "Compute specific entropy from temperature and gas data"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            output SI.SpecificEntropy s "Specific entropy at temperature T";
          algorithm
            s := if T < data.Tlimit then data.R*(data.blow[2] - 0.5*data.alow[
              1]/(T*T) - data.alow[2]/T + data.alow[3]*Math.log(T) + T*(
              data.alow[4] + T*(0.5*data.alow[5] + T*(1/3*data.alow[6] + 0.25*data.alow[
              7]*T)))) else data.R*(data.bhigh[2] - 0.5*data.ahigh[1]/(T*T) - data.
              ahigh[2]/T + data.ahigh[3]*Math.log(T) + T*(data.ahigh[4]
               + T*(0.5*data.ahigh[5] + T*(1/3*data.ahigh[6] + 0.25*data.ahigh[7]*T))));
            annotation (Inline=true, smoothOrder=2);
          end s0_T;

          function s0_Tlow "Compute specific entropy, low T region"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            output SI.SpecificEntropy s "Specific entropy at temperature T";
          algorithm
            s := data.R*(data.blow[2] - 0.5*data.alow[
              1]/(T*T) - data.alow[2]/T + data.alow[3]*Math.log(T) + T*(
              data.alow[4] + T*(0.5*data.alow[5] + T*(1/3*data.alow[6] + 0.25*data.alow[
              7]*T))));
            annotation (Inline=true);
          end s0_Tlow;

          function s0_Tlow_der "Compute derivative of specific entropy, low T region"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Real T_der "Temperature derivative";
            output SI.SpecificEntropy s "Specific entropy at temperature T";
          algorithm
            s := data.R*(data.blow[2] - 0.5*data.alow[
              1]/(T*T) - data.alow[2]/T + data.alow[3]*Math.log(T) + T*(
              data.alow[4] + T*(0.5*data.alow[5] + T*(1/3*data.alow[6] + 0.25*data.alow[
              7]*T))));
            annotation (Inline=true);
          end s0_Tlow_der;

          function dynamicViscosityLowPressure
            "Dynamic viscosity of low pressure gases"
            extends Modelica.Icons.Function;
            input SI.Temp_K T "Gas temperature";
            input SI.Temp_K Tc "Critical temperature of gas";
            input SI.MolarMass M "Molar mass of gas";
            input SI.MolarVolume Vc "Critical molar volume of gas";
            input Real w "Acentric factor of gas";
            input Modelica.Media.Interfaces.Types.DipoleMoment mu
              "Dipole moment of gas molecule";
            input Real k =  0.0 "Special correction for highly polar substances";
            output SI.DynamicViscosity eta "Dynamic viscosity of gas";
        protected
            parameter Real Const1_SI=40.785*10^(-9.5)
              "Constant in formula for eta converted to SI units";
            parameter Real Const2_SI=131.3/1000.0
              "Constant in formula for mur converted to SI units";
            Real mur=Const2_SI*mu/sqrt(Vc*Tc)
              "Dimensionless dipole moment of gas molecule";
            Real Fc=1 - 0.2756*w + 0.059035*mur^4 + k
              "Factor to account for molecular shape and polarities of gas";
            Real Tstar "Dimensionless temperature defined by equation below";
            Real Ov "Viscosity collision integral for the gas";

          algorithm
            Tstar := 1.2593*T/Tc;
            Ov := 1.16145*Tstar^(-0.14874) + 0.52487*Modelica.Math.exp(-0.7732*Tstar) + 2.16178*Modelica.Math.exp(-2.43787
              *Tstar);
            eta := Const1_SI*Fc*sqrt(M*T)/(Vc^(2/3)*Ov);
            annotation (smoothOrder=2,
                        Documentation(info="<html>
<p>
The used formula are based on the method of Chung et al (1984, 1988) referred to in ref [1] chapter 9.
The formula 9-4.10 is the one being used. The Formula is given in non-SI units, the following conversion constants were used to
transform the formula to SI units:
</p>

<ul>
<li> <strong>Const1_SI:</strong> The factor 10^(-9.5) =10^(-2.5)*1e-7 where the
     factor 10^(-2.5) originates from the conversion of g/mol->kg/mol + cm^3/mol->m^3/mol
      and the factor 1e-7 is due to conversion from microPoise->Pa.s.</li>
<li>  <strong>Const2_SI:</strong> The factor 1/3.335641e-27 = 1e-3/3.335641e-30
      where the factor 3.335641e-30 comes from debye->C.m and
      1e-3 is due to conversion from cm^3/mol->m^3/mol</li>
</ul>

<h4>References:</h4>
<p>
[1] Bruce E. Poling, John E. Prausnitz, John P. O'Connell, \"The Properties of Gases and Liquids\" 5th Ed. Mc Graw Hill.
</p>

<h4>Author</h4>
<p>T. Skoglund, Lund, Sweden, 2004-08-31</p>

</html>"));
          end dynamicViscosityLowPressure;

          function thermalConductivityEstimate
            "Thermal conductivity of polyatomic gases (Eucken and Modified Eucken correlation)"
            extends Modelica.Icons.Function;
            input Modelica.Media.Interfaces.Types.SpecificHeatCapacity Cp
              "Constant pressure heat capacity";
            input Modelica.Media.Interfaces.Types.DynamicViscosity eta
              "Dynamic viscosity";
            input Integer method(min=1,max=2)=1
              "1: Eucken Method, 2: Modified Eucken Method";
            input IdealGases.Common.DataRecord data "Ideal gas data";
            output Modelica.Media.Interfaces.Types.ThermalConductivity lambda
              "Thermal conductivity [W/(m.k)]";
          algorithm
            lambda := if method == 1 then eta*(Cp - data.R + (9/4)*data.R)
                                     else eta*(Cp - data.R)*(1.32 + 1.77/((Cp/data.R) - 1.0));
            annotation (smoothOrder=2,
                        Documentation(info="<html>
<p>
This function provides two similar methods for estimating the
thermal conductivity of polyatomic gases.
The Eucken method (input method == 1) gives good results for low temperatures,
but it tends to give an underestimated value of the thermal conductivity
(lambda) at higher temperatures.<br>
The Modified Eucken method (input method == 2) gives good results for
high-temperatures, but it tends to give an overestimated value of the
thermal conductivity (lambda) at low temperatures.
</p>
</html>"));
          end thermalConductivityEstimate;
        end Functions;

      partial package SingleGasNasa
        "Medium model of an ideal gas based on NASA source"

        extends Interfaces.PartialPureSubstance(
           ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pT,
           redeclare final record FluidConstants =
              Modelica.Media.Interfaces.Types.IdealGas.FluidConstants,
           mediumName=data.name,
           substanceNames={data.name},
           singleState=false,
           Temperature(min=200, max=6000, start=500, nominal=500),
           SpecificEnthalpy(start=if Functions.referenceChoice==ReferenceEnthalpy.ZeroAt0K then data.H0 else
              if Functions.referenceChoice==ReferenceEnthalpy.UserDefined then Functions.h_offset else 0, nominal=1.0e5),
           Density(start=10, nominal=10),
           AbsolutePressure(start=10e5, nominal=10e5));

        redeclare record extends ThermodynamicState
          "Thermodynamic state variables for ideal gases"
          AbsolutePressure p "Absolute pressure of medium";
          Temperature T "Temperature of medium";
        end ThermodynamicState;

        import Modelica.Math;
        import Modelica.Media.Interfaces.Choices.ReferenceEnthalpy;

        constant IdealGases.Common.DataRecord data
          "Data record of ideal gas substance";

        constant FluidConstants[nS] fluidConstants "Constant data for the fluid";

        redeclare model extends BaseProperties(
         T(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
         p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default))
          "Base properties of ideal gas medium"
        equation
          assert(T >= 200 and T <= 6000, "
Temperature T (= "       + String(T) + " K) is not in the allowed range
200 K <= T <= 6000 K required from medium model \""       + mediumName + "\".
");       MM = data.MM;
          R = data.R;
          h = Modelica.Media.IdealGases.Common.Functions.h_T(
                  data, T,
                  Modelica.Media.IdealGases.Common.Functions.excludeEnthalpyOfFormation,
                  Modelica.Media.IdealGases.Common.Functions.referenceChoice,
                  Modelica.Media.IdealGases.Common.Functions.h_offset);
          u = h - R*T;

          // Has to be written in the form d=f(p,T) in order that static
          // state selection for p and T is possible
          d = p/(R*T);
          // connect state with BaseProperties
          state.T = T;
          state.p = p;
        end BaseProperties;

          redeclare function setState_pTX
          "Return thermodynamic state as function of p, T and composition X"
            extends Modelica.Icons.Function;
            input AbsolutePressure p "Pressure";
            input Temperature T "Temperature";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=p,T=T);
            annotation(Inline=true,smoothOrder=2);
          end setState_pTX;

          redeclare function setState_phX
          "Return thermodynamic state as function of p, h and composition X"
            extends Modelica.Icons.Function;
            input AbsolutePressure p "Pressure";
            input SpecificEnthalpy h "Specific enthalpy";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=p,T=T_h(h));
            annotation(Inline=true,smoothOrder=2);
          end setState_phX;

          redeclare function setState_psX
          "Return thermodynamic state as function of p, s and composition X"
            extends Modelica.Icons.Function;
            input AbsolutePressure p "Pressure";
            input SpecificEntropy s "Specific entropy";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=p,T=T_ps(p,s));
            annotation(Inline=true,smoothOrder=2);
          end setState_psX;

          redeclare function setState_dTX
          "Return thermodynamic state as function of d, T and composition X"
            extends Modelica.Icons.Function;
            input Density d "Density";
            input Temperature T "Temperature";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=d*data.R*T,T=T);
            annotation(Inline=true,smoothOrder=2);
          end setState_dTX;

            redeclare function extends setSmoothState
          "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
            algorithm
              state := ThermodynamicState(p=Media.Common.smoothStep(x, state_a.p, state_b.p, x_small),
                                          T=Media.Common.smoothStep(x, state_a.T, state_b.T, x_small));
              annotation(Inline=true,smoothOrder=2);
            end setSmoothState;

        redeclare function extends pressure "Return pressure of ideal gas"
        algorithm
          p := state.p;
          annotation(Inline=true,smoothOrder=2);
        end pressure;

        redeclare function extends temperature "Return temperature of ideal gas"
        algorithm
          T := state.T;
          annotation(Inline=true,smoothOrder=2);
        end temperature;

        redeclare function extends density "Return density of ideal gas"
        algorithm
          d := state.p/(data.R*state.T);
          annotation(Inline=true,smoothOrder=2);
        end density;

        redeclare function extends specificEnthalpy "Return specific enthalpy"
          extends Modelica.Icons.Function;
        algorithm
          h := Modelica.Media.IdealGases.Common.Functions.h_T(
                   data,state.T);
          annotation(Inline=true,smoothOrder=2);
        end specificEnthalpy;

        redeclare function extends specificInternalEnergy
          "Return specific internal energy"
          extends Modelica.Icons.Function;
        algorithm
          u := Modelica.Media.IdealGases.Common.Functions.h_T(
                   data,state.T) - data.R*state.T;
          annotation(Inline=true,smoothOrder=2);
        end specificInternalEnergy;

        redeclare function extends specificEntropy "Return specific entropy"
          extends Modelica.Icons.Function;
        algorithm
          s := Modelica.Media.IdealGases.Common.Functions.s0_T(
                    data, state.T) - data.R*Modelica.Math.log(state.p/reference_p);
          annotation(Inline=true,smoothOrder=2);
        end specificEntropy;

        redeclare function extends specificGibbsEnergy "Return specific Gibbs energy"
          extends Modelica.Icons.Function;
        algorithm
          g := Modelica.Media.IdealGases.Common.Functions.h_T(
                   data,state.T) - state.T*specificEntropy(state);
          annotation(Inline=true,smoothOrder=2);
        end specificGibbsEnergy;

        redeclare function extends specificHelmholtzEnergy
          "Return specific Helmholtz energy"
          extends Modelica.Icons.Function;
        algorithm
          f := Modelica.Media.IdealGases.Common.Functions.h_T(
                   data,state.T) - data.R*state.T - state.T*specificEntropy(state);
          annotation(Inline=true,smoothOrder=2);
        end specificHelmholtzEnergy;

        redeclare function extends specificHeatCapacityCp
          "Return specific heat capacity at constant pressure"
        algorithm
          cp := Modelica.Media.IdealGases.Common.Functions.cp_T(
                     data, state.T);
          annotation(Inline=true,smoothOrder=2);
        end specificHeatCapacityCp;

        redeclare function extends specificHeatCapacityCv
          "Compute specific heat capacity at constant volume from temperature and gas data"
        algorithm
          cv := Modelica.Media.IdealGases.Common.Functions.cp_T(
                     data, state.T) - data.R;
          annotation(Inline=true,smoothOrder=2);
        end specificHeatCapacityCv;

        redeclare function extends isentropicExponent "Return isentropic exponent"
        algorithm
          gamma := specificHeatCapacityCp(state)/specificHeatCapacityCv(state);
          annotation(Inline=true,smoothOrder=2);
        end isentropicExponent;

        redeclare function extends velocityOfSound "Return velocity of sound"
          extends Modelica.Icons.Function;
        algorithm
          a := sqrt(max(0,data.R*state.T*Modelica.Media.IdealGases.Common.Functions.cp_T(
                                              data, state.T)/specificHeatCapacityCv(state)));
          annotation(Inline=true,smoothOrder=2);
        end velocityOfSound;

        function isentropicEnthalpyApproximation
          "Approximate method of calculating h_is from upstream properties and downstream pressure"
          extends Modelica.Icons.Function;
          input SI.Pressure p2 "Downstream pressure";
          input ThermodynamicState state "Properties at upstream location";
          input Boolean exclEnthForm=Functions.excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
          input ReferenceEnthalpy refChoice=Functions.referenceChoice
            "Choice of reference enthalpy";
          input SpecificEnthalpy h_off=Functions.h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
          output SI.SpecificEnthalpy h_is "Isentropic enthalpy";
        protected
          IsentropicExponent gamma =  isentropicExponent(state) "Isentropic exponent";
        algorithm
          h_is := Modelica.Media.IdealGases.Common.Functions.h_T(
                      data,state.T,exclEnthForm,refChoice,h_off) +
            gamma/(gamma - 1.0)*state.p/density(state)*((p2/state.p)^((gamma - 1)/gamma) - 1.0);
          annotation(Inline=true,smoothOrder=2);
        end isentropicEnthalpyApproximation;

        redeclare function extends isentropicEnthalpy "Return isentropic enthalpy"
        input Boolean exclEnthForm=Functions.excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
        input ReferenceEnthalpy refChoice=Functions.referenceChoice
            "Choice of reference enthalpy";
        input SpecificEnthalpy h_off=Functions.h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
        algorithm
          h_is := isentropicEnthalpyApproximation(p_downstream,refState,exclEnthForm,refChoice,h_off);
          annotation(Inline=true,smoothOrder=2);
        end isentropicEnthalpy;

        redeclare function extends isobaricExpansionCoefficient
          "Returns overall the isobaric expansion coefficient beta"
        algorithm
          beta := 1/state.T;
          annotation(Inline=true,smoothOrder=2);
        end isobaricExpansionCoefficient;

        redeclare function extends isothermalCompressibility
          "Returns overall the isothermal compressibility factor"
        algorithm
          kappa := 1.0/state.p;
          annotation(Inline=true,smoothOrder=2);
        end isothermalCompressibility;

        redeclare function extends density_derp_T
          "Returns the partial derivative of density with respect to pressure at constant temperature"
        algorithm
          ddpT := 1/(state.T*data.R);
          annotation(Inline=true,smoothOrder=2);
        end density_derp_T;

        redeclare function extends density_derT_p
          "Returns the partial derivative of density with respect to temperature at constant pressure"
        algorithm
          ddTp := -state.p/(state.T*state.T*data.R);
          annotation(Inline=true,smoothOrder=2);
        end density_derT_p;

        redeclare function extends density_derX
          "Returns the partial derivative of density with respect to mass fractions at constant pressure and temperature"
        algorithm
          dddX := fill(0,nX);
          annotation(Inline=true,smoothOrder=2);
        end density_derX;

        redeclare replaceable function extends dynamicViscosity "Dynamic viscosity"
        algorithm
          assert(fluidConstants[1].hasCriticalData,
          "Failed to compute dynamicViscosity: For the species \"" + mediumName + "\" no critical data is available.");
          assert(fluidConstants[1].hasDipoleMoment,
          "Failed to compute dynamicViscosity: For the species \"" + mediumName + "\" no critical data is available.");
          eta := Modelica.Media.IdealGases.Common.Functions.dynamicViscosityLowPressure(
                                             state.T,
                             fluidConstants[1].criticalTemperature,
                             fluidConstants[1].molarMass,
                             fluidConstants[1].criticalMolarVolume,
                             fluidConstants[1].acentricFactor,
                             fluidConstants[1].dipoleMoment);
          annotation (smoothOrder=2);
        end dynamicViscosity;

        redeclare replaceable function extends thermalConductivity
          "Thermal conductivity of gas"
        //  input IdealGases.Common.DataRecord data "Ideal gas data";
          input Integer method=Functions.methodForThermalConductivity
            "1: Eucken Method, 2: Modified Eucken Method";
        algorithm
          assert(fluidConstants[1].hasCriticalData,
          "Failed to compute thermalConductivity: For the species \"" + mediumName + "\" no critical data is available.");
          lambda := Modelica.Media.IdealGases.Common.Functions.thermalConductivityEstimate(
                                                specificHeatCapacityCp(state),
            dynamicViscosity(state), method=method,data=data);
          annotation (smoothOrder=2);
        end thermalConductivity;

        redeclare function extends molarMass "Return the molar mass of the medium"
        algorithm
          MM := data.MM;
          annotation(Inline=true,smoothOrder=2);
        end molarMass;

        function T_h "Compute temperature from specific enthalpy"
          extends Modelica.Icons.Function;
          input SpecificEnthalpy h "Specific enthalpy";
          output Temperature T "Temperature";

        protected
        package Internal
            "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
          extends Modelica.Media.Common.OneNonLinearEquation;
          redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
            extends Modelica.Media.IdealGases.Common.DataRecord;
          end f_nonlinear_Data;

          redeclare function extends f_nonlinear
          algorithm
              y := Modelica.Media.IdealGases.Common.Functions.h_T(
                       f_nonlinear_data,x);
          end f_nonlinear;

          // Dummy definition has to be added for current Dymola
          redeclare function extends solve
          end solve;
        end Internal;

        algorithm
          T := Internal.solve(h, 200, 6000, 1.0e5, {1}, data);
        end T_h;

        function T_ps "Compute temperature from pressure and specific entropy"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEntropy s "Specific entropy";
          output Temperature T "Temperature";

        protected
        package Internal
            "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
          extends Modelica.Media.Common.OneNonLinearEquation;
          redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
            extends Modelica.Media.IdealGases.Common.DataRecord;
          end f_nonlinear_Data;

          redeclare function extends f_nonlinear
          algorithm
              y := Modelica.Media.IdealGases.Common.Functions.s0_T(
                        f_nonlinear_data,x)- data.R*Modelica.Math.log(p/reference_p);
          end f_nonlinear;

          // Dummy definition has to be added for current Dymola
          redeclare function extends solve
          end solve;
        end Internal;

        algorithm
          T := Internal.solve(s, 200, 6000, p, {1}, data);
        end T_ps;

      // the functions below are not strictly necessary, there are just here for compatibility reasons

        function dynamicViscosityLowPressure
          "Dynamic viscosity of low pressure gases"
          extends Modelica.Icons.Function;
          input SI.Temp_K T "Gas temperature";
          input SI.Temp_K Tc "Critical temperature of gas";
          input SI.MolarMass M "Molar mass of gas";
          input SI.MolarVolume Vc "Critical molar volume of gas";
          input Real w "Acentric factor of gas";
          input Modelica.Media.Interfaces.Types.DipoleMoment mu
            "Dipole moment of gas molecule";
          input Real k =  0.0 "Special correction for highly polar substances";
          output Modelica.Media.Interfaces.Types.DynamicViscosity eta
            "Dynamic viscosity of gas";
        protected
          parameter Real Const1_SI=40.785*10^(-9.5)
            "Constant in formula for eta converted to SI units";
          parameter Real Const2_SI=131.3/1000.0
            "Constant in formula for mur converted to SI units";
          Real mur=Const2_SI*mu/sqrt(Vc*Tc)
            "Dimensionless dipole moment of gas molecule";
          Real Fc=1 - 0.2756*w + 0.059035*mur^4 + k
            "Factor to account for molecular shape and polarities of gas";
          Real Tstar "Dimensionless temperature defined by equation below";
          Real Ov "Viscosity collision integral for the gas";

        algorithm
          eta := Functions.dynamicViscosityLowPressure(T,Tc,M,Vc,w,mu,k);
          annotation (smoothOrder=2,
                      Documentation(info="<html>
<p>
The used formula are based on the method of Chung et al (1984, 1988) referred to in ref [1] chapter 9.
The formula 9-4.10 is the one being used. The Formula is given in non-SI units, the following conversion constants were used to
transform the formula to SI units:
</p>

<ul>
<li> <strong>Const1_SI:</strong> The factor 10^(-9.5) =10^(-2.5)*1e-7 where the
     factor 10^(-2.5) originates from the conversion of g/mol->kg/mol + cm^3/mol->m^3/mol
      and the factor 1e-7 is due to conversion from microPoise->Pa.s.</li>
<li>  <strong>Const2_SI:</strong> The factor 1/3.335641e-27 = 1e-3/3.335641e-30
      where the factor 3.335641e-30 comes from debye->C.m and
      1e-3 is due to conversion from cm^3/mol->m^3/mol</li>
</ul>

<h4>References:</h4>
<p>
[1] Bruce E. Poling, John E. Prausnitz, John P. O'Connell, \"The Properties of Gases and Liquids\" 5th Ed. Mc Graw Hill.
</p>

<h4>Author</h4>
<p>T. Skoglund, Lund, Sweden, 2004-08-31</p>

</html>"));
        end dynamicViscosityLowPressure;

        function thermalConductivityEstimate
          "Thermal conductivity of polyatomic gases(Eucken and Modified Eucken correlation)"
          extends Modelica.Icons.Function;
          input Modelica.Media.Interfaces.Types.SpecificHeatCapacity Cp
            "Constant pressure heat capacity";
          input Modelica.Media.Interfaces.Types.DynamicViscosity eta
            "Dynamic viscosity";
          input Integer method(min=1,max=2)=1
            "1: Eucken Method, 2: Modified Eucken Method";
          input IdealGases.Common.DataRecord data "Ideal gas data";
          output Modelica.Media.Interfaces.Types.ThermalConductivity lambda
            "Thermal conductivity [W/(m.k)]";
        algorithm
          lambda := Functions.thermalConductivityEstimate(Cp,eta,method,data);
          annotation (smoothOrder=2,
                      Documentation(info="<html>
<p>
This function provides two similar methods for estimating the
thermal conductivity of polyatomic gases.
The Eucken method (input method == 1) gives good results for low temperatures,
but it tends to give an underestimated value of the thermal conductivity
(lambda) at higher temperatures.<br>
The Modified Eucken method (input method == 2) gives good results for
high-temperatures, but it tends to give an overestimated value of the
thermal conductivity (lambda) at low temperatures.
</p>
</html>"));
        end thermalConductivityEstimate;

        annotation (
          Documentation(info="<html>
<p>
This model calculates medium properties
for an ideal gas of a single substance, or for an ideal
gas consisting of several substances where the
mass fractions are fixed. Independent variables
are temperature <strong>T</strong> and pressure <strong>p</strong>.
Only density is a function of T and p. All other quantities
are solely a function of T. The properties
are valid in the range:
</p>
<pre>
   200 K &le; T &le; 6000 K
</pre>
<p>
The following quantities are always computed:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy h = h(T)</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy u = u(T)</td></tr>
  <tr><td>d</td>
      <td>kg/m^3</td>
      <td>density d = d(p,T)</td></tr>
</table>
<p>
For the other variables, see the functions in
Modelica.Media.IdealGases.Common.SingleGasNasa.
Note, dynamic viscosity and thermal conductivity are only provided
for gases that use a data record from Modelica.Media.IdealGases.FluidData.
Currently these are the following gases:
</p>
<pre>
  Ar
  C2H2_vinylidene
  C2H4
  C2H5OH
  C2H6
  C3H6_propylene
  C3H7OH
  C3H8
  C4H8_1_butene
  C4H9OH
  C4H10_n_butane
  C5H10_1_pentene
  C5H12_n_pentane
  C6H6
  C6H12_1_hexene
  C6H14_n_heptane
  C7H14_1_heptene
  C8H10_ethylbenz
  CH3OH
  CH4
  CL2
  CO
  CO2
  F2
  H2
  H2O
  He
  N2
  N2O
  NH3
  NO
  O2
  SO2
  SO3
</pre>
<p>
<strong>Sources for model and literature:</strong><br>
Original Data: Computer program for calculation of complex chemical
equilibrium compositions and applications. Part 1: Analysis
Document ID: 19950013764 N (95N20180) File Series: NASA Technical Reports
Report Number: NASA-RP-1311  E-8017  NAS 1.61:1311
Authors: Gordon, Sanford (NASA Lewis Research Center)
 Mcbride, Bonnie J. (NASA Lewis Research Center)
Published: Oct 01, 1994.
</p>
<p><strong>Known limits of validity:</strong><br>
The data is valid for
temperatures between 200K and 6000K.  A few of the data sets for
monatomic gases have a discontinuous 1st derivative at 1000K, but
this never caused problems so far.
</p>
<p>
This model has been copied from the ThermoFluid library
and adapted to the Modelica.Media package.
</p>
</html>"));
      end SingleGasNasa;

        package FluidData "Critical data, dipole moments and related data"
          extends Modelica.Icons.Package;
          import Modelica.Media.Interfaces.PartialMixtureMedium;
          import Modelica.Media.IdealGases.Common.SingleGasesData;

          constant Modelica.Media.Interfaces.Types.IdealGas.FluidConstants N2(
                               chemicalFormula =        "N2",
                               iupacName =              "unknown",
                               structureFormula =       "unknown",
                               casRegistryNumber =      "7727-37-9",
                               meltingPoint =            63.15,
                               normalBoilingPoint =      77.35,
                               criticalTemperature =    126.20,
                               criticalPressure =        33.98e5,
                               criticalMolarVolume =     90.10e-6,
                               acentricFactor =           0.037,
                               dipoleMoment =             0.0,
                               molarMass =              SingleGasesData.N2.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);

          constant Modelica.Media.Interfaces.Types.IdealGas.FluidConstants H2O(
                               chemicalFormula =        "H2O",
                               iupacName =              "oxidane",
                               structureFormula =       "H2O",
                               casRegistryNumber =      "7732-18-5",
                               meltingPoint =           273.15,
                               normalBoilingPoint =     373.124,
                               criticalTemperature =    647.096,
                               criticalPressure =       220.64e5,
                               criticalMolarVolume =     55.95e-6,
                               acentricFactor =           0.344,
                               dipoleMoment =             1.8,
                               molarMass =              SingleGasesData.H2O.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);
          annotation (Documentation(info="<html>
<p>
This package contains FluidConstants data records for the following 37 gases
(see also the description in
<a href=\"modelica://Modelica.Media.IdealGases\">Modelica.Media.IdealGases</a>):
</p>
<pre>
Argon             Methane          Methanol       Carbon Monoxide  Carbon Dioxide
Acetylene         Ethylene         Ethanol        Ethane           Propylene
Propane           1-Propanol       1-Butene       N-Butane         1-Pentene
N-Pentane         Benzene          1-Hexene       N-Hexane         1-Heptane
N-Heptane         Ethylbenzene     N-Octane       Chlorine         Fluorine
Hydrogen          Steam            Helium         Ammonia          Nitric Oxide
Nitrogen Dioxide  Nitrogen         Nitrous        Oxide            Neon Oxygen
Sulfur Dioxide    Sulfur Trioxide
</pre>

</html>"));
        end FluidData;

        package SingleGasesData
        "Ideal gas data based on the NASA Glenn coefficients"
          extends Modelica.Icons.Package;

          constant IdealGases.Common.DataRecord Air(
            name="Air",
            MM=0.0289651159,
            Hf=-4333.833858403446,
            H0=298609.6803431054,
            Tlimit=1000,
            alow={10099.5016,-196.827561,5.00915511,-0.00576101373,1.06685993e-005,-7.94029797e-009,
                2.18523191e-012},
            blow={-176.796731,-3.921504225},
            ahigh={241521.443,-1257.8746,5.14455867,-0.000213854179,7.06522784e-008,-1.07148349e-011,
                6.57780015e-016},
            bhigh={6462.26319,-8.147411905},
            R=287.0512249529787);

          constant IdealGases.Common.DataRecord CO2(
            name="CO2",
            MM=0.0440095,
            Hf=-8941478.544405185,
            H0=212805.6215135368,
            Tlimit=1000,
            alow={49436.5054,-626.411601,5.30172524,0.002503813816,-2.127308728e-007,-7.68998878e-010,
                2.849677801e-013},
            blow={-45281.9846,-7.04827944},
            ahigh={117696.2419,-1788.791477,8.29152319,-9.22315678e-005,4.86367688e-009,
                -1.891053312e-012,6.330036589999999e-016},
            bhigh={-39083.5059,-26.52669281},
            R=188.9244822140674);

          constant IdealGases.Common.DataRecord H2O(
            name="H2O",
            MM=0.01801528,
            Hf=-13423382.81725291,
            H0=549760.6476280135,
            Tlimit=1000,
            alow={-39479.6083,575.573102,0.931782653,0.00722271286,-7.34255737e-006,
                4.95504349e-009,-1.336933246e-012},
            blow={-33039.7431,17.24205775},
            ahigh={1034972.096,-2412.698562,4.64611078,0.002291998307,-6.836830479999999e-007,
                9.426468930000001e-011,-4.82238053e-015},
            bhigh={-13842.86509,-7.97814851},
            R=461.5233290850878);

          constant IdealGases.Common.DataRecord N2(
            name="N2",
            MM=0.0280134,
            Hf=0,
            H0=309498.4543111511,
            Tlimit=1000,
            alow={22103.71497,-381.846182,6.08273836,-0.00853091441,1.384646189e-005,-9.62579362e-009,
                2.519705809e-012},
            blow={710.846086,-10.76003744},
            ahigh={587712.406,-2239.249073,6.06694922,-0.00061396855,1.491806679e-007,-1.923105485e-011,
                1.061954386e-015},
            bhigh={12832.10415,-15.86640027},
            R=296.8033869505308);
          annotation (Documentation(info="<html>
<p>This package contains ideal gas models for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>

<pre>
 Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
 Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
 Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
 Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
 Al        Be              C2H5            D2      K+       NbO     Si+
 Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
 Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
 AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
 AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
 AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
 AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
 AlC2      BeF             CCN             F       KF       Ni-     SiC2
 AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
 AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
 AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
 AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
 AlF       BeI             C3              FO      KNO3     O       SiF
 AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
 AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
 AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
 AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
 AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
 AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
 AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
 AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
 AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
 AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
 AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
 AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
 AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
 AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
 AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
 AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
 AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
 AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
 AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
 AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
 AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
 AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
 AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
 AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
 AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
 AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
 AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
 AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
 AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
 AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
 AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
 AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
 AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
 AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
 AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
 AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
 AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
 Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
 Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
 Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
 Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
 AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
 AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
 Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
 Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
 Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
 Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
 Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
 Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
 Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
 Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
 Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
 Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
 Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
 Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
 Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
 Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
 Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
 B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
 B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
 B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
 BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
 BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
 BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
 BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
 BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
 BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
 BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
 BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
 BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
 BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
 BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
 BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
 BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
 BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
 BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
 BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
 BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
 BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
 BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
 BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
 BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
 BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
 BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
 BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
 BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
 BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
 BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
 BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
 BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
 BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
 BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
 BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
 BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
 BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
 BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
 BH4       CH4             Cd              HOF     NH+      RbNa    U
 BI        CH3OH           Cd+             HO2     NHF      RbO     UF
 BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
 BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
 BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
 BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
 BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
 BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
 BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
 BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
 BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
 BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
 BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
 BO2-      COCl            Co              H2O2    NO2-     S       UF5
 B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
 BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
 BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
 B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
 B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
 B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
 B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
 B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
 B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
 B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
 B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
 B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
 B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
 B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
 B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
 B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
 B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
 B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
 B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
 B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
 B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
 B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
 B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
 B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
 B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
 B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
 B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
 B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
 B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
 B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
 B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
 B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
 B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
 B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
 B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
 Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
 Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
 BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
 BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
 BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
 BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
 BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
 BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
 BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
 BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
 BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
 BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
 BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
 BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
 BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
 BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre>
</html>"));
        end SingleGasesData;
      annotation (Documentation(info="<html>

</html>"));
      end Common;
    annotation (Documentation(info="<html>
<p>This package contains data for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>Medium models for some of these gases are available in package
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a>
and some examples for mixtures are available in package <a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a>
</p>
<h4>Using and Adapting Medium Models</h4>
<p>
The data records allow computing the ideal gas specific enthalpy, specific entropy and heat capacity of the substances listed below. From them, even the Gibbs energy and equilibrium constants for reactions can be computed. Critical data that is needed for computing the viscosity and thermal conductivity is not included. In order to add mixtures or single substance medium packages that are
subtypes of
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">Interfaces.PartialMedium</a>
(i.e., can be utilized at all places where PartialMedium is defined),
a few additional steps have to be performed:
</p>
<ol>
<li>
All single gas media need to define a constant instance of record
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium.FluidConstants\">IdealGases.Common.SingleGasNasa.FluidConstants</a>.
For 37 ideal gases such records are provided in package
<a href=\"modelica://Modelica.Media.IdealGases.Common.FluidData\">IdealGases.Common.FluidData</a>.
For the other gases, such a record instance has to be provided by the user, e.g., by getting
the data from a commercial or public data base. A public source of the needed data is for example the <a href=\"http://webbook.nist.gov/chemistry/\"> NIST Chemistry WebBook</a></li>

<li>When the data is available, and a user has an instance of a
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium.FluidConstants\">FluidConstants</a> record filled with data, a medium package has to be written. Note that only the dipole moment, the acentric factor and critical data are necessary for the viscosity and thermal conductivity functions.</li>
<li><ul>
<li>For single components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a> has to be created, pointing both to a data record for cp and to a user-defined fluidConstants record.</li>
<li>For mixtures of several components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a> has to be created, building an array of data records for cp and an array of (partly) user-defined fluidConstants records.</li>
</ul></li>
</ol>
<p>Note that many properties can computed for the full set of 1241 gases listed below, but due to the missing viscosity and thermal conductivity functions, no fully Modelica.Media-compliant media can be defined.</p>
<p>
Data records for heat capacity, specific enthalpy and specific entropy exist for the following substances and ions:
</p>
<pre>
 Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
 Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
 Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
 Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
 Al        Be              C2H5            D2      K+       NbO     Si+
 Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
 Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
 AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
 AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
 AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
 AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
 AlC2      BeF             CCN             F       KF       Ni-     SiC2
 AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
 AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
 AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
 AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
 AlF       BeI             C3              FO      KNO3     O       SiF
 AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
 AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
 AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
 AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
 AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
 AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
 AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
 AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
 AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
 AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
 AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
 AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
 AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
 AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
 AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
 AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
 AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
 AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
 AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
 AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
 AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
 AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
 AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
 AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
 AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
 AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
 AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
 AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
 AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
 AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
 AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
 AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
 AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
 AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
 AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
 AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
 AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
 Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
 Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
 Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
 Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
 AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
 AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
 Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
 Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
 Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
 Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
 Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
 Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
 Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
 Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
 Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
 Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
 Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
 Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
 Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
 Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
 Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
 B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
 B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
 B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
 BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
 BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
 BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
 BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
 BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
 BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
 BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
 BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
 BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
 BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
 BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
 BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
 BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
 BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
 BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
 BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
 BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
 BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
 BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
 BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
 BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
 BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
 BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
 BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
 BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
 BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
 BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
 BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
 BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
 BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
 BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
 BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
 BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
 BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
 BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
 BH4       CH4             Cd              HOF     NH+      RbNa    U
 BI        CH3OH           Cd+             HO2     NHF      RbO     UF
 BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
 BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
 BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
 BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
 BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
 BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
 BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
 BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
 BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
 BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
 BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
 BO2-      COCl            Co              H2O2    NO2-     S       UF5
 B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
 BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
 BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
 B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
 B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
 B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
 B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
 B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
 B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
 B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
 B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
 B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
 B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
 B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
 B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
 B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
 B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
 B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
 B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
 B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
 B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
 B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
 B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
 B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
 B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
 B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
 B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
 B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
 B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
 B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
 B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
 B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
 B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
 B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
 B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
 Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
 Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
 BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
 BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
 BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
 BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
 BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
 BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
 BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
 BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
 BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
 BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
 BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
 BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
 BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
 BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre></html>"));
    end IdealGases;

    package Incompressible
    "Medium model for T-dependent properties, defined by tables or polynomials"
      extends Modelica.Icons.VariantsPackage;
      import Modelica.Constants;
      import Modelica.Math;

      package Common "Common data structures"
        extends Modelica.Icons.Package;

        record BaseProps_Tpoly "Fluid state record"
          extends Modelica.Icons.Record;
          SI.Temperature T "Temperature";
          SI.Pressure p "Pressure";
          //    SI.Density d "Density";
        end BaseProps_Tpoly;
      end Common;

      package TableBased "Incompressible medium properties based on tables"
        import Poly = Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
        extends Modelica.Media.Interfaces.PartialMedium(
           ThermoStates = if enthalpyOfT then Modelica.Media.Interfaces.Choices.IndependentVariables.T
                                                                             else Modelica.Media.Interfaces.Choices.IndependentVariables.pT,
           final reducedX=true,
           final fixedX = true,
           mediumName="tableMedium",
           redeclare record ThermodynamicState=Common.BaseProps_Tpoly,
           singleState=true,
           reference_p = 1.013e5,
           Temperature(min = T_min, max = T_max));

        constant Boolean enthalpyOfT=true
          "True if enthalpy is approximated as a function of T only, (p-dependence neglected)";

        constant Boolean densityOfT = size(tableDensity,1) > 1
          "True if density is a function of temperature";

        constant Modelica.SIunits.Temperature T_min
          "Minimum temperature valid for medium model";

        constant Modelica.SIunits.Temperature T_max
          "Maximum temperature valid for medium model";

        constant Temperature T0=273.15 "Reference Temperature";

        constant SpecificEnthalpy h0=0 "Reference enthalpy at T0, reference_p";

        constant SpecificEntropy s0=0 "Reference entropy at T0, reference_p";

        constant MolarMass MM_const=0.1 "Molar mass";

        constant Integer npol=2 "Degree of polynomial used for fitting";

        constant Integer npolDensity=npol
          "Degree of polynomial used for fitting rho(T)";

        constant Integer npolHeatCapacity=npol
          "Degree of polynomial used for fitting Cp(T)";

        constant Integer npolViscosity=npol
          "Degree of polynomial used for fitting eta(T)";

        constant Integer npolConductivity=npol
          "Degree of polynomial used for fitting lambda(T)";

        constant Integer neta=size(tableViscosity,1)
          "Number of data points for viscosity";

        constant Real[:,2] tableDensity "Table for rho(T)";

        constant Real[:,2] tableHeatCapacity "Table for Cp(T)";

        constant Real[:,2] tableViscosity "Table for eta(T)";

        constant Real[:,2] tableConductivity "Table for lambda(T)";

        constant Boolean TinK "True if T[K],Kelvin used for table temperatures";

        constant Boolean hasDensity = not (size(tableDensity,1)==0)
          "True if table tableDensity is present";

        constant Boolean hasHeatCapacity = not (size(tableHeatCapacity,1)==0)
          "True if table tableHeatCapacity is present";

        constant Boolean hasViscosity = not (size(tableViscosity,1)==0)
          "True if table tableViscosity is present";

        final constant Real invTK[neta] = if size(tableViscosity,1) > 0 then
            (if TinK then 1 ./ tableViscosity[:,1] else 1 ./ Cv.from_degC(tableViscosity[:,1])) else fill(0,neta);

        final constant Real poly_rho[:] = if hasDensity then
                                             Poly.fitting(tableDensity[:,1],tableDensity[:,2],npolDensity) else
                                               zeros(npolDensity+1);

        final constant Real poly_Cp[:] = if hasHeatCapacity then
                                             Poly.fitting(tableHeatCapacity[:,1],tableHeatCapacity[:,2],npolHeatCapacity) else
                                               zeros(npolHeatCapacity+1);

        final constant Real poly_eta[:] = if hasViscosity then
                                             Poly.fitting(invTK, Math.log(tableViscosity[:,2]),npolViscosity) else
                                               zeros(npolViscosity+1);

        final constant Real poly_lam[:] = if size(tableConductivity,1)>0 then
                                             Poly.fitting(tableConductivity[:,1],tableConductivity[:,2],npolConductivity) else
                                               zeros(npolConductivity+1);

        redeclare model extends BaseProperties(
          final standardOrderComponents=true,
          p_bar=Cv.to_bar(p),
          T_degC(start = T_start-273.15)=Cv.to_degC(T),
          T(start = T_start,
            stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default))
          "Base properties of T dependent medium"
        //  redeclare parameter SpecificHeatCapacity R=Modelica.Constants.R,

          SI.SpecificHeatCapacity cp "Specific heat capacity";
          parameter SI.Temperature T_start = 298.15 "Initial temperature";
        equation
          assert(hasDensity,"Medium " + mediumName +
                            " can not be used without assigning tableDensity.");
          assert(T >= T_min and T <= T_max, "Temperature T (= " + String(T) +
                 " K) is not in the allowed range (" + String(T_min) +
                 " K <= T <= " + String(T_max) + " K) required from medium model \""
                 + mediumName + "\".");
          R = Modelica.Constants.R/MM_const;
          cp = Poly.evaluate(poly_Cp,if TinK then T else T_degC);
          h = if enthalpyOfT then h_T(T) else  h_pT(p,T,densityOfT);
          u = h - (if singleState then  reference_p/d else state.p/d);
          d = Poly.evaluate(poly_rho,if TinK then T else T_degC);
          state.T = T;
          state.p = p;
          MM = MM_const;
          annotation(Documentation(info="<html>
<p>
Note that the inner energy neglects the pressure dependence, which is only
true for an incompressible medium with d = constant. The neglected term is
p-reference_p)/rho*(T/rho)*(partial rho /partial T). This is very small for
liquids due to proportionality to 1/d^2, but can be problematic for gases that are
modeled incompressible.
</p>
<p>It should be noted that incompressible media only have 1 state per control volume (usually T),
but have both T and p as inputs for fully correct properties. The error of using only T-dependent
properties is small, therefore a Boolean flag enthalpyOfT exists. If it is true, the
enumeration Choices.independentVariables  is set to  Choices.independentVariables.T otherwise
it is set to Choices.independentVariables.pT.</p>
<p>
Enthalpy is never a function of T only (h = h(T) + (p-reference_p)/d), but the
error is also small and non-linear systems can be avoided. In particular,
non-linear systems are small and local as opposed to large and over all volumes.
</p>

<p>
Entropy is calculated as
</p>
<pre>
  s = s0 + integral(Cp(T)/T,dt)
</pre>
<p>
which is only exactly true for a fluid with constant density d=d0.
</p>
</html>"));
        end BaseProperties;

        redeclare function extends setState_pTX
          "Returns state record, given pressure and temperature"
        algorithm
          state := ThermodynamicState(p=p,T=T);
          annotation(smoothOrder=3);
        end setState_pTX;

        redeclare function extends setState_dTX
          "Returns state record, given pressure and temperature"
        algorithm
          assert(false, "For incompressible media with d(T) only, state can not be set from density and temperature");
        end setState_dTX;

        redeclare function extends setState_phX
          "Returns state record, given pressure and specific enthalpy"
        algorithm
          state :=ThermodynamicState(p=p,T=T_ph(p,h));
          annotation(Inline=true,smoothOrder=3);
        end setState_phX;

        redeclare function extends setState_psX
          "Returns state record, given pressure and specific entropy"
        algorithm
          state :=ThermodynamicState(p=p,T=T_ps(p,s));
          annotation(Inline=true,smoothOrder=3);
        end setState_psX;

            redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
            algorithm
              state :=ThermodynamicState(p=Media.Common.smoothStep(x, state_a.p, state_b.p, x_small),
                                         T=Media.Common.smoothStep(x, state_a.T, state_b.T, x_small));
              annotation(Inline=true,smoothOrder=3);
            end setSmoothState;

        redeclare function extends specificHeatCapacityCv
          "Specific heat capacity at constant volume (or pressure) of medium"

        algorithm
          assert(hasHeatCapacity,"Specific Heat Capacity, Cv, is not defined for medium "
                                                 + mediumName + ".");
          cv := Poly.evaluate(poly_Cp,if TinK then state.T else state.T - 273.15);
         annotation(smoothOrder=2);
        end specificHeatCapacityCv;

        redeclare function extends specificHeatCapacityCp
          "Specific heat capacity at constant volume (or pressure) of medium"

        algorithm
          assert(hasHeatCapacity,"Specific Heat Capacity, Cv, is not defined for medium "
                                                 + mediumName + ".");
          cp := Poly.evaluate(poly_Cp,if TinK then state.T else state.T - 273.15);
         annotation(smoothOrder=2);
        end specificHeatCapacityCp;

        redeclare function extends dynamicViscosity
          "Return dynamic viscosity as a function of the thermodynamic state record"

        algorithm
          assert(size(tableViscosity,1)>0,"DynamicViscosity, eta, is not defined for medium "
                                                 + mediumName + ".");
          eta := Math.exp(Poly.evaluate(poly_eta, 1/state.T));
         annotation(smoothOrder=2);
        end dynamicViscosity;

        redeclare function extends thermalConductivity
          "Return thermal conductivity as a function of the thermodynamic state record"

        algorithm
          assert(size(tableConductivity,1)>0,"ThermalConductivity, lambda, is not defined for medium "
                                                 + mediumName + ".");
          lambda := Poly.evaluate(poly_lam,if TinK then state.T else Cv.to_degC(state.T));
         annotation(smoothOrder=2);
        end thermalConductivity;

        function s_T "Compute specific entropy"
          extends Modelica.Icons.Function;
          input Temperature T "Temperature";
          output SpecificEntropy s "Specific entropy";
        algorithm
          s := s0 + (if TinK then
            Poly.integralValue(poly_Cp[1:npol],T, T0) else
            Poly.integralValue(poly_Cp[1:npol],Cv.to_degC(T),Cv.to_degC(T0)))
            + Modelica.Math.log(T/T0)*
            Poly.evaluate(poly_Cp,if TinK then 0 else Modelica.Constants.T_zero);
         annotation(Inline=true,smoothOrder=2);
        end s_T;

        redeclare function extends specificEntropy
          "Return specific entropy as a function of the thermodynamic state record"

      protected
          Integer npol=size(poly_Cp,1)-1;
        algorithm
          assert(hasHeatCapacity,"Specific Entropy, s(T), is not defined for medium "
                                                 + mediumName + ".");
          s := s_T(state.T);
         annotation(smoothOrder=2);
        end specificEntropy;

        function h_T "Compute specific enthalpy from temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Temperature T "Temperature";
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T";
        algorithm
          h :=h0 + Poly.integralValue(poly_Cp, if TinK then T else Cv.to_degC(T), if TinK then
          T0 else Cv.to_degC(T0));
         annotation(derivative=h_T_der);
        end h_T;

        function h_T_der "Compute specific enthalpy from temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Temperature T "Temperature";
          input Real dT "Temperature derivative";
          output Real dh "Derivative of Specific enthalpy at T";
        algorithm
          dh :=Poly.evaluate(poly_Cp, if TinK then T else Cv.to_degC(T))*dT;
         annotation(smoothOrder=1);
        end h_T_der;

        function h_pT "Compute specific enthalpy from pressure and temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input Boolean densityOfT = false
            "Include or neglect density derivative dependence of enthalpy" annotation(Evaluate);
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T";
        algorithm
          h :=h0 + Poly.integralValue(poly_Cp, if TinK then T else Cv.to_degC(T), if TinK then
          T0 else Cv.to_degC(T0)) + (p - reference_p)/Poly.evaluate(poly_rho, if TinK then
                  T else Cv.to_degC(T))
            *(if densityOfT then (1 + T/Poly.evaluate(poly_rho, if TinK then T else Cv.to_degC(T))
          *Poly.derivativeValue(poly_rho,if TinK then T else Cv.to_degC(T))) else 1.0);
         annotation(smoothOrder=2);
        end h_pT;

        redeclare function extends temperature
          "Return temperature as a function of the thermodynamic state record"
        algorithm
         T := state.T;
         annotation(Inline=true,smoothOrder=2);
        end temperature;

        redeclare function extends pressure
          "Return pressure as a function of the thermodynamic state record"
        algorithm
         p := state.p;
         annotation(Inline=true,smoothOrder=2);
        end pressure;

        redeclare function extends density
          "Return density as a function of the thermodynamic state record"
        algorithm
          d := Poly.evaluate(poly_rho,if TinK then state.T else Cv.to_degC(state.T));
         annotation(Inline=true,smoothOrder=2);
        end density;

        redeclare function extends specificEnthalpy
          "Return specific enthalpy as a function of the thermodynamic state record"
        algorithm
          h := if enthalpyOfT then h_T(state.T) else h_pT(state.p,state.T);
         annotation(Inline=true,smoothOrder=2);
        end specificEnthalpy;

        redeclare function extends specificInternalEnergy
          "Return specific internal energy as a function of the thermodynamic state record"
        algorithm
          u := (if enthalpyOfT then h_T(state.T) else h_pT(state.p,state.T)) - (if singleState then  reference_p else state.p)/density(state);
         annotation(Inline=true,smoothOrder=2);
        end specificInternalEnergy;

        function T_ph "Compute temperature from pressure and specific enthalpy"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          output Temperature T "Temperature";
      protected
          package Internal
            "Solve h(T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;

            redeclare record extends f_nonlinear_Data
              "Superfluous record, fix later when better structure of inverse functions exists"
                constant Real[5] dummy = {1,2,3,4,5};
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear "P is smuggled in via vector"
            algorithm
              y := if singleState then h_T(x) else h_pT(p,x);
            end f_nonlinear;

          end Internal;
        algorithm
         T := Internal.solve(h, T_min, T_max, p, {1}, Internal.f_nonlinear_Data());
          annotation(Inline=false, LateInline=true, inverse(h=h_pT(p,T)));
        end T_ph;

        function T_ps "Compute temperature from pressure and specific enthalpy"
          extends Modelica.Icons.Function;

          input AbsolutePressure p "Pressure";
          input SpecificEntropy s "Specific entropy";
          output Temperature T "Temperature";
      protected
          package Internal
            "Solve h(T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;

            redeclare record extends f_nonlinear_Data
              "Superfluous record, fix later when better structure of inverse functions exists"
                constant Real[5] dummy = {1,2,3,4,5};
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear "P is smuggled in via vector"
            algorithm
              y := s_T(x);
            end f_nonlinear;

          end Internal;
        algorithm
         T := Internal.solve(s, T_min, T_max, p, {1}, Internal.f_nonlinear_Data());
        end T_ps;

        package Polynomials_Temp
        "Temporary Functions operating on polynomials (including polynomial fitting); only to be used in Modelica.Media.Incompressible.TableBased"
          extends Modelica.Icons.Package;

          function evaluate "Evaluate polynomial at a given abscissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of polynomial at u";
          algorithm
            y := p[1];
            for j in 2:size(p, 1) loop
              y := p[j] + u*y;
            end for;
            annotation(derivative(zeroDerivative=p)=evaluate_der);
          end evaluate;

          function evaluateWithRange
            "Evaluate polynomial at a given abscissa value with linear extrapolation outside of the defined range"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real uMin "Polynomial valid in the range uMin .. uMax";
            input Real uMax "Polynomial valid in the range uMin .. uMax";
            input Real u "Abscissa value";
            output Real y
              "Value of polynomial at u. Outside of uMin,uMax, linear extrapolation is used";
          algorithm
            if u < uMin then
              y := evaluate(p, uMin) - evaluate_der(
                      p,
                      uMin,
                      uMin - u);
            elseif u > uMax then
              y := evaluate(p, uMax) + evaluate_der(
                      p,
                      uMax,
                      u - uMax);
            else
              y := evaluate(p, u);
            end if;
            annotation (derivative(
                zeroDerivative=p,
                zeroDerivative=uMin,
                zeroDerivative=uMax) = evaluateWithRange_der);
          end evaluateWithRange;

          function derivativeValue
            "Value of derivative of polynomial at abscissa value u"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            y := p[1]*(n - 1);
            for j in 2:size(p, 1)-1 loop
              y := p[j]*(n - j) + u*y;
            end for;
            annotation(derivative(zeroDerivative=p)=derivativeValue_der);
          end derivativeValue;

          function secondDerivativeValue
            "Value of 2nd derivative of polynomial at abscissa value u"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of 2nd derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            y := p[1]*(n - 1)*(n - 2);
            for j in 2:size(p, 1)-2 loop
              y := p[j]*(n - j)*(n - j - 1) + u*y;
            end for;
          end secondDerivativeValue;

          function integralValue "Integral of polynomial p(u) from u_low to u_high"
            extends Modelica.Icons.Function;
            input Real p[:] "Polynomial coefficients";
            input Real u_high "High integrand value";
            input Real u_low=0 "Low integrand value, default 0";
            output Real integral=0.0
              "Integral of polynomial p from u_low to u_high";
        protected
            Integer n=size(p, 1) "Degree of integrated polynomial";
            Real y_low=0 "Value at lower integrand";
          algorithm
            for j in 1:n loop
              integral := u_high*(p[j]/(n - j + 1) + integral);
              y_low := u_low*(p[j]/(n - j + 1) + y_low);
            end for;
            integral := integral - y_low;
            annotation(derivative(zeroDerivative=p)=integralValue_der);
          end integralValue;

          function fitting
            "Computes the coefficients of a polynomial that fits a set of data points in a least-squares sense"
            extends Modelica.Icons.Function;
            input Real u[:] "Abscissa data values";
            input Real y[size(u, 1)] "Ordinate data values";
            input Integer n(min=1)
              "Order of desired polynomial that fits the data points (u,y)";
            output Real p[n + 1]
              "Polynomial coefficients of polynomial that fits the date points";
        protected
            Real V[size(u, 1), n + 1] "Vandermonde matrix";
          algorithm
            // Construct Vandermonde matrix
            V[:, n + 1] := ones(size(u, 1));
            for j in n:-1:1 loop
              V[:, j] := {u[i] * V[i, j + 1] for i in 1:size(u,1)};
            end for;

            // Solve least squares problem
            p :=Modelica.Math.Matrices.leastSquares(V, y);
            annotation (Documentation(info="<html>
<p>
Polynomials.fitting(u,y,n) computes the coefficients of a polynomial
p(u) of degree \"n\" that fits the data \"p(u[i]) - y[i]\"
in a least squares sense. The polynomial is
returned as a vector p[n+1] that has the following definition:
</p>
<pre>
  p(u) = p[1]*u^n + p[2]*u^(n-1) + ... + p[n]*u + p[n+1];
</pre>
</html>"));
          end fitting;

          function evaluate_der
            "Evaluate derivative of polynomial at a given abscissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            input Real du "Delta of abscissa value";
            output Real dy "Value of derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            dy := p[1]*(n - 1);
            for j in 2:size(p, 1)-1 loop
              dy := p[j]*(n - j) + u*dy;
            end for;
            dy := dy*du;
          end evaluate_der;

          function evaluateWithRange_der
            "Evaluate derivative of polynomial at a given abscissa value with extrapolation outside of the defined range"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real uMin "Polynomial valid in the range uMin .. uMax";
            input Real uMax "Polynomial valid in the range uMin .. uMax";
            input Real u "Abscissa value";
            input Real du "Delta of abscissa value";
            output Real dy "Value of derivative of polynomial at u";
          algorithm
            if u < uMin then
              dy := evaluate_der(
                      p,
                      uMin,
                      du);
            elseif u > uMax then
              dy := evaluate_der(
                      p,
                      uMax,
                      du);
            else
              dy := evaluate_der(
                      p,
                      u,
                      du);
            end if;
          end evaluateWithRange_der;

          function integralValue_der
            "Time derivative of integral of polynomial p(u) from u_low to u_high, assuming only u_high as time-dependent (Leibniz rule)"
            extends Modelica.Icons.Function;
            input Real p[:] "Polynomial coefficients";
            input Real u_high "High integrand value";
            input Real u_low=0 "Low integrand value, default 0";
            input Real du_high "High integrand value";
            input Real du_low=0 "Low integrand value, default 0";
            output Real dintegral=0.0
              "Integral of polynomial p from u_low to u_high";
          algorithm
            dintegral := evaluate(p,u_high)*du_high;
          end integralValue_der;

          function derivativeValue_der
            "Time derivative of derivative of polynomial"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            input Real du "Delta of abscissa value";
            output Real dy
              "Time-derivative of derivative of polynomial w.r.t. input variable at u";
        protected
            Integer n=size(p, 1);
          algorithm
            dy := secondDerivativeValue(p,u)*du;
          end derivativeValue_der;
          annotation (Documentation(info="<html>
<p>
This package contains functions to operate on polynomials,
in particular to determine the derivative and the integral
of a polynomial and to use a polynomial to fit a given set
of data points.
</p>

<p>
Copyright &copy; 2004-2019, Modelica Association and contributors
</p>
</html>",         revisions="<html>
<ul>
<li><em>Oct. 22, 2004</em> by Martin Otter (DLR):<br>
       Renamed functions to not have abbreviations.<br>
       Based fitting on LAPACK<br>
       New function to return the polynomial of an indefinite integral</li>
<li><em>Sept. 3, 2004</em> by Jonas Eborn (Scynamics):<br>
       polyderval, polyintval added</li>
<li><em>March 1, 2004</em> by Martin Otter (DLR):<br>
       first version implemented</li>
</ul>
</html>"));
        end Polynomials_Temp;
      annotation(Documentation(info="<html>
<p>
This is the base package for medium models of incompressible fluids based on
tables. The minimal data to provide for a useful medium description is tables
of density and heat capacity as functions of temperature.
</p>

<p>It should be noted that incompressible media only have 1 state per control volume (usually T),
but have both T and p as inputs for fully correct properties. The error of using only T-dependent
properties is small, therefore a Boolean flag enthalpyOfT exists. If it is true, the
enumeration Choices.independentVariables  is set to  Choices.independentVariables.T otherwise
it is set to Choices.independentVariables.pT.</p>

<h4>Using the package TableBased</h4>
<p>
To implement a new medium model, create a package that <strong>extends</strong> TableBased
and provides one or more of the constant tables:
</p>

<pre>
tableDensity        = [T, d];
tableHeatCapacity   = [T, Cp];
tableConductivity   = [T, lam];
tableViscosity      = [T, eta];
tableVaporPressure  = [T, pVap];
</pre>

<p>
The table data is used to fit constant polynomials of order <strong>npol</strong>, the
temperature data points do not need to be same for different properties. Properties
like enthalpy, inner energy and entropy are calculated consistently from integrals
and derivatives of d(T) and Cp(T). The minimal
data for a useful medium model is thus density and heat capacity. Transport
properties and vapor pressure are optional, if the data tables are empty the corresponding
function calls can not be used.
</p>
</html>"));
      end TableBased;
      annotation (
        Documentation(info="<html>
<h4>Incompressible media package</h4>
<p>
This package provides a structure and examples of how to create simple
medium models of incompressible fluids, meaning fluids with very little
pressure influence on density. The medium properties is typically described
in terms of tables, functions or polynomial coefficients.
</p>
<h4>Definitions</h4>
<p>
The common meaning of <em>incompressible</em> is that properties like density
and enthalpy are independent of pressure. Thus properties are conveniently
described as functions of temperature, e.g., as polynomials density(T) and cp(T).
However, enthalpy can not be independent of pressure since h = u - p/d. For liquids
it is anyway
common to neglect this dependence since for constant density the neglected term
is (p - p0)/d, which in comparison with cp is very small for most liquids. For
water, the equivalent change of temperature to increasing pressure 1 bar is
0.025 Kelvin.
</p>
<p>
Two Boolean flags are used to choose how enthalpy and inner energy is calculated:
</p>
<ul>
<li><strong>enthalpyOfT</strong>=true, means assuming that enthalpy is only a function
of temperature, neglecting the pressure dependent term.</li>
<li><strong>singleState</strong>=true, means also neglect the pressure influence on inner
energy, which makes all medium properties pure functions of temperature.</li>
</ul>
<p>
The default setting for both these flags is true, which enables the simulation tool
to choose temperature as the only medium state and avoids non-linear equation
systems, see the section about
<a href=\"modelica://Modelica.Media.UsersGuide.MediumDefinition.StaticStateSelection\">Static
state selection</a> in the Modelica.Media User's Guide.
</p>

<h4>Contents</h4>
<p>
Currently, the package contains the following parts:
</p>
<ol>
<li> <a href=\"modelica://Modelica.Media.Incompressible.TableBased\">
      Table based medium models</a></li>
<li> <a href=\"modelica://Modelica.Media.Incompressible.Examples\">
      Example medium models</a></li>
</ol>

<p>
A few examples are given in the Examples package. The model
<a href=\"modelica://Modelica.Media.Incompressible.Examples.Glycol47\">
Examples.Glycol47</a> shows how the medium models can be used. For more
realistic examples of how to implement volume models with medium properties
look in the <a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage\">Medium
usage section</a> of the User's Guide.
</p>

</html>"));
    end Incompressible;

    package Water "Medium models for water"
    extends Modelica.Icons.VariantsPackage;
    import Modelica.Media.Water.ConstantPropertyLiquidWater.simpleWaterConstants;

    package ConstantPropertyLiquidWater
      "Water: Simple liquid water medium (incompressible, constant data)"

      //   redeclare record extends FluidConstants
      //   end FluidConstants;

      constant Modelica.Media.Interfaces.Types.Basic.FluidConstants[1]
        simpleWaterConstants(
        each chemicalFormula="H2O",
        each structureFormula="H2O",
        each casRegistryNumber="7732-18-5",
        each iupacName="oxidane",
        each molarMass=0.018015268);

      extends Interfaces.PartialSimpleMedium(
        mediumName="SimpleLiquidWater",
        cp_const=4184,
        cv_const=4184,
        d_const=995.586,
        eta_const=1.e-3,
        lambda_const=0.598,
        a_const=1484,
        T_min=Cv.from_degC(-1),
        T_max=Cv.from_degC(130),
        T0=273.15,
        MM_const=0.018015268,
        fluidConstants=simpleWaterConstants);

      annotation (Documentation(info="<html>

</html>"));
    end ConstantPropertyLiquidWater;
    annotation (Documentation(info="<html>
<p>This package contains different medium models for water:</p>
<ul>
<li><strong>ConstantPropertyLiquidWater</strong><br>
    Simple liquid water medium (incompressible, constant data).</li>
<li><strong>IdealSteam</strong><br>
    Steam water medium as ideal gas from Media.IdealGases.SingleGases.H2O</li>
<li><strong>WaterIF97 derived models</strong><br>
    High precision water model according to the IAPWS/IF97 standard
    (liquid, steam, two phase region). Models with different independent
    variables are provided as well as models valid only
    for particular regions. The <strong>WaterIF97_ph</strong> model is valid
    in all regions and is the recommended one to use.</li>
</ul>
<h4>Overview of WaterIF97 derived water models</h4>
<p>
The WaterIF97 models calculate medium properties
for water in the <strong>liquid</strong>, <strong>gas</strong> and <strong>two phase</strong> regions
according to the IAPWS/IF97 standard, i.e., the accepted industrial standard
and best compromise between accuracy and computation time.
It has been part of the ThermoFluid Modelica library and been extended,
reorganized and documented to become part of the Modelica Standard library.</p>
<p>An important feature that distinguishes this implementation of the IF97 steam property standard
is that this implementation has been explicitly designed to work well in dynamic simulations. Computational
performance has been of high importance. This means that there often exist several ways to get the same result
from different functions if one of the functions is called often but can be optimized for that purpose.
</p>
<p>Three variable pairs can be the independent variables of the model:
</p>
<ol>
<li>Pressure <strong>p</strong> and specific enthalpy <strong>h</strong> are
    the most natural choice for general applications.
    This is the recommended choice for most general purpose
    applications, in particular for power plants.</li>
<li>Pressure <strong>p</strong> and temperature <strong>T</strong> are the most natural
    choice for applications where water is always in the same phase,
    both for liquid water and steam.</li>
<li>Density <strong>d</strong> and temperature <strong>T</strong> are explicit
    variables of the Helmholtz function in the near-critical
    region and can be the best choice for applications with
    super-critical or near-critical states.</li>
</ol>
<p>
The following quantities are always computed in Medium.BaseProperties:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>d</td>
      <td>kg/m^3</td>
      <td>density</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>pressure</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
</table>
<p>
In some cases additional medium properties are needed.
A component that needs these optional properties has to call
one of the following functions:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Function call</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>Medium.dynamicViscosity(medium.state)</td>
      <td>Pa.s</td>
      <td>dynamic viscosity</td></tr>
  <tr><td>Medium.thermalConductivity(medium.state)</td>
      <td>W/(m.K)</td>
      <td>thermal conductivity</td></tr>
  <tr><td>Medium.prandtlNumber(medium.state)</td>
      <td>1</td>
      <td>Prandtl number</td></tr>
  <tr><td>Medium.specificEntropy(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific entropy</td></tr>
  <tr><td>Medium.heatCapacity_cp(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific heat capacity at constant pressure</td></tr>
  <tr><td>Medium.heatCapacity_cv(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific heat capacity at constant density</td></tr>
  <tr><td>Medium.isentropicExponent(medium.state)</td>
      <td>1</td>
      <td>isentropic exponent</td></tr>
  <tr><td>Medium.isentropicEnthalpy(pressure, medium.state)</td>
      <td>J/kg</td>
      <td>isentropic enthalpy</td></tr>
  <tr><td>Medium.velocityOfSound(medium.state)</td>
      <td>m/s</td>
      <td>velocity of sound</td></tr>
  <tr><td>Medium.isobaricExpansionCoefficient(medium.state)</td>
      <td>1/K</td>
      <td>isobaric expansion coefficient</td></tr>
  <tr><td>Medium.isothermalCompressibility(medium.state)</td>
      <td>1/Pa</td>
      <td>isothermal compressibility</td></tr>
  <tr><td>Medium.density_derp_h(medium.state)</td>
      <td>kg/(m3.Pa)</td>
      <td>derivative of density by pressure at constant enthalpy</td></tr>
  <tr><td>Medium.density_derh_p(medium.state)</td>
      <td>kg2/(m3.J)</td>
      <td>derivative of density by enthalpy at constant pressure</td></tr>
  <tr><td>Medium.density_derp_T(medium.state)</td>
      <td>kg/(m3.Pa)</td>
      <td>derivative of density by pressure at constant temperature</td></tr>
  <tr><td>Medium.density_derT_p(medium.state)</td>
      <td>kg/(m3.K)</td>
      <td>derivative of density by temperature at constant pressure</td></tr>
  <tr><td>Medium.density_derX(medium.state)</td>
      <td>kg/m3</td>
      <td>derivative of density by mass fraction</td></tr>
  <tr><td>Medium.molarMass(medium.state)</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
<p>More details are given in
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.OptionalProperties\">
Modelica.Media.UsersGuide.MediumUsage.OptionalProperties</a>.

Many additional optional functions are defined to compute properties of
saturated media, either liquid (bubble point) or vapour (dew point).
The argument to such functions is a SaturationProperties record, which can be
set starting from either the saturation pressure or the saturation temperature.
With reference to a model defining a pressure p, a temperature T, and a
SaturationProperties record sat, the following functions are provided:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Function call</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>Medium.saturationPressure(T)</td>
      <td>Pa</td>
      <td>Saturation pressure at temperature T</td></tr>
  <tr><td>Medium.saturationTemperature(p)</td>
      <td>K</td>
      <td>Saturation temperature at pressure p</td></tr>
  <tr><td>Medium.saturationTemperature_derp(p)</td>
      <td>K/Pa</td>
      <td>Derivative of saturation temperature with respect to pressure</td></tr>
  <tr><td>Medium.bubbleEnthalpy(sat)</td>
      <td>J/kg</td>
      <td>Specific enthalpy at bubble point</td></tr>
  <tr><td>Medium.dewEnthalpy(sat)</td>
      <td>J/kg</td>
      <td>Specific enthalpy at dew point</td></tr>
  <tr><td>Medium.bubbleEntropy(sat)</td>
      <td>J/(kg.K)</td>
      <td>Specific entropy at bubble point</td></tr>
  <tr><td>Medium.dewEntropy(sat)</td>
      <td>J/(kg.K)</td>
      <td>Specific entropy at dew point</td></tr>
  <tr><td>Medium.bubbleDensity(sat)</td>
      <td>kg/m3</td>
      <td>Density at bubble point</td></tr>
  <tr><td>Medium.dewDensity(sat)</td>
      <td>kg/m3</td>
      <td>Density at dew point</td></tr>
  <tr><td>Medium.dBubbleDensity_dPressure(sat)</td>
      <td>kg/(m3.Pa)</td>
      <td>Derivative of density at bubble point with respect to pressure</td></tr>
  <tr><td>Medium.dDewDensity_dPressure(sat)</td>
      <td>kg/(m3.Pa)</td>
      <td>Derivative of density at dew point with respect to pressure</td></tr>
  <tr><td>Medium.dBubbleEnthalpy_dPressure(sat)</td>
      <td>J/(kg.Pa)</td>
      <td>Derivative of specific enthalpy at bubble point with respect to pressure</td></tr>
  <tr><td>Medium.dDewEnthalpy_dPressure(sat)</td>
      <td>J/(kg.Pa)</td>
      <td>Derivative of specific enthalpy at dew point with respect to pressure</td></tr>
  <tr><td>Medium.surfaceTension(sat)</td>
      <td>N/m</td>
      <td>Surface tension between liquid and vapour phase</td></tr>
</table>
<p>Details on usage and some examples are given in:
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.TwoPhase\">
Modelica.Media.UsersGuide.MediumUsage.TwoPhase</a>.
</p>
<p>Many further properties can be computed. Using the well-known Bridgman's Tables,
all first partial derivatives of the standard thermodynamic variables can be computed easily.
</p>
<p>
The documentation of the IAPWS/IF97 steam properties can be freely
distributed with computer implementations and are included here
(in directory Modelica/Resources/Documentation/Media/Water/IF97documentation):
</p>
<ul>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/IF97.pdf\">IF97.pdf</a> The standards document for the main part of the IF97.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/Back3.pdf\">Back3.pdf</a> The backwards equations for region 3.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/crits.pdf\">crits.pdf</a> The critical point data.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/meltsub.pdf\">meltsub.pdf</a> The melting- and sublimation line formulation (not implemented)</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/surf.pdf\">surf.pdf</a> The surface tension standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/thcond.pdf\">thcond.pdf</a> The thermal conductivity standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/visc.pdf\">visc.pdf</a> The viscosity standard definition</li>
</ul>
</html>"));
    end Water;
  annotation (preferredView="info",Documentation(info="<html>
<p>
This library contains <a href=\"modelica://Modelica.Media.Interfaces\">interface</a>
definitions for media and the following <strong>property</strong> models for
single and multiple substance fluids with one and multiple phases:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Media.IdealGases\">Ideal gases:</a><br>
     1241 high precision gas models based on the
     NASA Glenn coefficients, plus ideal gas mixture models based
     on the same data.</li>
<li> <a href=\"modelica://Modelica.Media.Water\">Water models:</a><br>
     ConstantPropertyLiquidWater, WaterIF97 (high precision
     water model according to the IAPWS/IF97 standard)</li>
<li> <a href=\"modelica://Modelica.Media.Air\">Air models:</a><br>
     SimpleAir, DryAirNasa, ReferenceAir, MoistAir, ReferenceMoistAir.</li>
<li> <a href=\"modelica://Modelica.Media.Incompressible\">
     Incompressible media:</a><br>
     TableBased incompressible fluid models (properties are defined by tables rho(T),
     HeatCapacity_cp(T), etc.)</li>
<li> <a href=\"modelica://Modelica.Media.CompressibleLiquids\">
     Compressible liquids:</a><br>
     Simple liquid models with linear compressibility</li>
<li> <a href=\"modelica://Modelica.Media.R134a\">Refrigerant Tetrafluoroethane (R134a)</a>.</li>
</ul>
<p>
The following parts are useful, when newly starting with this library:</p>
<ul>
<li> <a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage\">Modelica.Media.UsersGuide.MediumUsage</a>
     describes how to use a medium model in a component model.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumDefinition\">
     Modelica.Media.UsersGuide.MediumDefinition</a>
     describes how a new fluid medium model has to be implemented.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.ReleaseNotes\">Modelica.Media.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Media.Examples\">Modelica.Media.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>February 01, 2017</em> by Thomas Beutlich:<br/>
    Fixed data errors of the NASA Glenn coefficients in some ideal gases (CH2, CH3, CH3OOH, C2CL2, C2CL4, C2CL6, C2HCL, C2HCL3, CH2CO_ketene, O_CH_2O, HO_CO_2OH, CH2BrminusCOOH, C2H3CL, CH2CLminusCOOH, HO2, HO2minus, OD, ODminus), see <a href=\"https://github.com/modelica/ModelicaStandardLibrary/issues/1922\">#1922</a></li>
<li><em>May 16, 2013</em> by Stefan Wischhusen (XRG Simulation):<br/>
    Added new media models Air.ReferenceMoistAir, Air.ReferenceAir, R134a.</li>
<li><em>May 25, 2011</em> by Francesco Casella:<br/>Added min/max attributes to Water, TableBased, MixtureGasNasa, SimpleAir and MoistAir local types.</li>
<li><em>May 25, 2011</em> by Stefan Wischhusen:<br/>Added individual settings for polynomial fittings of properties.</li>
</ul>
</html>"),
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175}),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175}),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175}),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175})}));
  end Media;

  package Thermal
  "Library of thermal system components to model heat transfer and simple thermo-fluid pipe flow"
    extends Modelica.Icons.Package;

    package HeatTransfer
    "Library of 1-dimensional heat transfer with lumped elements"
      extends Modelica.Icons.Package;

      package Components "Lumped thermal components"
      extends Modelica.Icons.Package;

        model HeatCapacitor "Lumped thermal element storing heat"
          parameter Modelica.SIunits.HeatCapacity C
            "Heat capacity of element (= cp*m)";
          Modelica.SIunits.Temperature T(start=293.15, displayUnit="degC")
            "Temperature of element";
          Modelica.SIunits.TemperatureSlope der_T(start=0)
            "Time derivative of temperature (= der(T))";
          Interfaces.HeatPort_a port annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90)));
        equation
          T = port.T;
          der_T = der(T);
          C*der(T) = port.Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,110},{150,70}},
                  textString="%name",
                  lineColor={0,0,255}),
                Polygon(
                  points={{0,67},{-20,63},{-40,57},{-52,43},{-58,35},{-68,25},{-72,
                      13},{-76,-1},{-78,-15},{-76,-31},{-76,-43},{-76,-53},{-70,-65},
                      {-64,-73},{-48,-77},{-30,-83},{-18,-83},{-2,-85},{8,-89},{22,
                      -89},{32,-87},{42,-81},{54,-75},{56,-73},{66,-61},{68,-53},{
                      70,-51},{72,-35},{76,-21},{78,-13},{78,3},{74,15},{66,25},{54,
                      33},{44,41},{36,57},{26,65},{0,67}},
                  lineColor={160,160,164},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-58,35},{-68,25},{-72,13},{-76,-1},{-78,-15},{-76,-31},{
                      -76,-43},{-76,-53},{-70,-65},{-64,-73},{-48,-77},{-30,-83},{-18,
                      -83},{-2,-85},{8,-89},{22,-89},{32,-87},{42,-81},{54,-75},{42,
                      -77},{40,-77},{30,-79},{20,-81},{18,-81},{10,-81},{2,-77},{-12,
                      -73},{-22,-73},{-30,-71},{-40,-65},{-50,-55},{-56,-43},{-58,-35},
                      {-58,-25},{-60,-13},{-60,-5},{-60,7},{-58,17},{-56,19},{-52,
                      27},{-48,35},{-44,45},{-40,57},{-58,35}},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-69,7},{71,-24}},
                  textString="%C")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Polygon(
                  points={{0,67},{-20,63},{-40,57},{-52,43},{-58,35},{-68,25},{-72,
                      13},{-76,-1},{-78,-15},{-76,-31},{-76,-43},{-76,-53},{-70,-65},
                      {-64,-73},{-48,-77},{-30,-83},{-18,-83},{-2,-85},{8,-89},{22,
                      -89},{32,-87},{42,-81},{54,-75},{56,-73},{66,-61},{68,-53},{
                      70,-51},{72,-35},{76,-21},{78,-13},{78,3},{74,15},{66,25},{54,
                      33},{44,41},{36,57},{26,65},{0,67}},
                  lineColor={160,160,164},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-58,35},{-68,25},{-72,13},{-76,-1},{-78,-15},{-76,-31},{
                      -76,-43},{-76,-53},{-70,-65},{-64,-73},{-48,-77},{-30,-83},{-18,
                      -83},{-2,-85},{8,-89},{22,-89},{32,-87},{42,-81},{54,-75},{42,
                      -77},{40,-77},{30,-79},{20,-81},{18,-81},{10,-81},{2,-77},{-12,
                      -73},{-22,-73},{-30,-71},{-40,-65},{-50,-55},{-56,-43},{-58,-35},
                      {-58,-25},{-60,-13},{-60,-5},{-60,7},{-58,17},{-56,19},{-52,
                      27},{-48,35},{-44,45},{-40,57},{-58,35}},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,-1},{6,-12}},
                  lineColor={255,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{11,13},{50,-25}},
                  textString="T"),
                Line(points={{0,-12},{0,-96}}, color={255,0,0})}),
            Documentation(info="<html>
<p>
This is a generic model for the heat capacity of a material.
No specific geometry is assumed beyond a total volume with
uniform temperature for the entire volume.
Furthermore, it is assumed that the heat capacity
is constant (independent of temperature).
</p>
<p>
The temperature T [Kelvin] of this component is a <strong>state</strong>.
A default of T = 25 degree Celsius (= SIunits.Conversions.from_degC(25))
is used as start value for initialization.
This usually means that at start of integration the temperature of this
component is 25 degrees Celsius. You may, of course, define a different
temperature as start value for initialization. Alternatively, it is possible
to set parameter <strong>steadyStateStart</strong> to <strong>true</strong>. In this case
the additional equation '<strong>der</strong>(T) = 0' is used during
initialization, i.e., the temperature T is computed in such a way that
the component starts in <strong>steady state</strong>. This is useful in cases,
where one would like to start simulation in a suitable operating
point without being forced to integrate for a long time to arrive
at this point.
</p>
<p>
Note, that parameter <strong>steadyStateStart</strong> is not available in
the parameter menu of the simulation window, because its value
is utilized during translation to generate quite different
equations depending on its setting. Therefore, the value of this
parameter can only be changed before translating the model.
</p>
<p>
This component may be used for complicated geometries where
the heat capacity C is determined my measurements. If the component
consists mainly of one type of material, the <strong>mass m</strong> of the
component may be measured or calculated and multiplied with the
<strong>specific heat capacity cp</strong> of the component material to
compute C:
</p>
<pre>
   C = cp*m.
   Typical values for cp at 20 degC in J/(kg.K):
      aluminium   896
      concrete    840
      copper      383
      iron        452
      silver      235
      steel       420 ... 500 (V2A)
      wood       2500
</pre>
</html>"));
        end HeatCapacitor;

        model ThermalConductor
          "Lumped thermal element transporting heat without storing it"
          extends Interfaces.Element1D;
          parameter Modelica.SIunits.ThermalConductance G
            "Constant thermal conductance of material";

        equation
          Q_flow = G*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-90,70},{90,-70}},
                  pattern=LinePattern.None,
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-90,70},{-90,-70}},
                  thickness=0.5),
                Line(
                  points={{90,70},{90,-70}},
                  thickness=0.5),
                Text(
                  extent={{-150,115},{150,75}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-75},{150,-105}},
                  textString="G=%G")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{-80,0},{80,0}},
                  color={255,0,0},
                  thickness=0.5,
                  arrow={Arrow.None,Arrow.Filled}),
                Text(
                  extent={{-100,-20},{100,-40}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Text(
                  extent={{-100,40},{100,20}},
                  textString="dT = port_a.T - port_b.T")}),
            Documentation(info="<html>
<p>
This is a model for transport of heat without storing it; see also:
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ThermalResistor\">ThermalResistor</a>.
It may be used for complicated geometries where
the thermal conductance G (= inverse of thermal resistance)
is determined by measurements and is assumed to be constant
over the range of operations. If the component consists mainly of
one type of material and a regular geometry, it may be calculated,
e.g., with one of the following equations:
</p>
<ul>
<li><p>
    Conductance for a <strong>box</strong> geometry under the assumption
    that heat flows along the box length:</p>
    <pre>
    G = k*A/L
    k: Thermal conductivity (material constant)
    A: Area of box
    L: Length of box
    </pre>
    </li>
<li><p>
    Conductance for a <strong>cylindrical</strong> geometry under the assumption
    that heat flows from the inside to the outside radius
    of the cylinder:</p>
    <pre>
    G = 2*pi*k*L/log(r_out/r_in)
    pi   : Modelica.Constants.pi
    k    : Thermal conductivity (material constant)
    L    : Length of cylinder
    log  : Modelica.Math.log;
    r_out: Outer radius of cylinder
    r_in : Inner radius of cylinder
    </pre>
    </li>
</ul>
<pre>
    Typical values for k at 20 degC in W/(m.K):
      aluminium   220
      concrete      1
      copper      384
      iron         74
      silver      407
      steel        45 .. 15 (V2A)
      wood         0.1 ... 0.2
</pre>
</html>"));
        end ThermalConductor;

        model ThermalResistor
          "Lumped thermal element transporting heat without storing it"
          extends Interfaces.Element1D;
          parameter Modelica.SIunits.ThermalResistance R
            "Constant thermal resistance of material";

        equation
          dT = R*Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-90,70},{90,-70}},
                  pattern=LinePattern.None,
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Forward),
                Line(
                  points={{-90,70},{-90,-70}},
                  thickness=0.5),
                Line(
                  points={{90,70},{90,-70}},
                  thickness=0.5),
                Text(
                  extent={{-150,115},{150,75}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-75},{150,-105}},
                  textString="R=%R")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{-80,0},{80,0}},
                  color={255,0,0},
                  thickness=0.5,
                  arrow={Arrow.None,Arrow.Filled}),
                Text(
                  extent={{-100,-20},{100,-40}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Text(
                  extent={{-100,40},{100,20}},
                  textString="dT = port_a.T - port_b.T")}),
            Documentation(info="<html>
<p>
This is a model for transport of heat without storing it, same as the
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ThermalConductor\">ThermalConductor</a>
but using the thermal resistance instead of the thermal conductance as a parameter.
This is advantageous for series connections of ThermalResistors,
especially if it shall be allowed that a ThermalResistance is defined to be zero (i.e. no temperature difference).
</p>
</html>"));
        end ThermalResistor;

        model Convection
          "Lumped thermal element for heat convection (Q_flow = Gc*dT)"
          Modelica.SIunits.HeatFlowRate Q_flow "Heat flow rate from solid -> fluid";
          Modelica.SIunits.TemperatureDifference dT "= solid.T - fluid.T";
          Modelica.Blocks.Interfaces.RealInput Gc(unit="W/K")
            "Signal representing the convective thermal conductance in [W/K]"
            annotation (Placement(transformation(
                origin={0,100},
                extent={{-20,-20},{20,20}},
                rotation=270)));
          Interfaces.HeatPort_a solid annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b fluid annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          Q_flow = Gc*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-62,80},{98,-80}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{-150,-90},{150,-130}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0}),
                Text(
                  extent={{22,124},{92,98}},
                  textString="Gc")}),
            Documentation(info="<html>
<p>
This is a model of linear heat convection, e.g., the heat transfer between a plate and the surrounding air; see also:
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor\">ConvectiveResistor</a>.
It may be used for complicated solid geometries and fluid flow over the solid by determining the
convective thermal conductance Gc by measurements. The basic constitutive equation for convection is
</p>
<pre>
   Q_flow = Gc*(solid.T - fluid.T);
   Q_flow: Heat flow rate from connector 'solid' (e.g., a plate)
      to connector 'fluid' (e.g., the surrounding air)
</pre>
<p>
Gc = G.signal[1] is an input signal to the component, since Gc is
nearly never constant in practice. For example, Gc may be a function
of the speed of a cooling fan. For simple situations,
Gc may be <em>calculated</em> according to
</p>
<pre>
   Gc = A*h
   A: Convection area (e.g., perimeter*length of a box)
   h: Heat transfer coefficient
</pre>
<p>
where the heat transfer coefficient h is calculated
from properties of the fluid flowing over the solid. Examples:
</p>
<p>
<strong>Machines cooled by air</strong> (empirical, very rough approximation according
to R. Fischer: Elektrische Maschinen, 10th edition, Hanser-Verlag 1999,
p. 378):
</p>
<pre>
    h = 7.8*v^0.78 [W/(m2.K)] (forced convection)
      = 12         [W/(m2.K)] (free convection)
    where
      v: Air velocity in [m/s]
</pre>
<p><strong>Laminar</strong> flow with constant velocity of a fluid along a
<strong>flat plate</strong> where the heat flow rate from the plate
to the fluid (= solid.Q_flow) is kept constant
(according to J.P.Holman: Heat Transfer, 8th edition,
McGraw-Hill, 1997, p.270):
</p>
<pre>
   h  = Nu*k/x;
   Nu = 0.453*Re^(1/2)*Pr^(1/3);
   where
      h  : Heat transfer coefficient
      Nu : = h*x/k       (Nusselt number)
      Re : = v*x*rho/mue (Reynolds number)
      Pr : = cp*mue/k    (Prandtl number)
      v  : Absolute velocity of fluid
      x  : distance from leading edge of flat plate
      rho: density of fluid (material constant
      mue: dynamic viscosity of fluid (material constant)
      cp : specific heat capacity of fluid (material constant)
      k  : thermal conductivity of fluid (material constant)
   and the equation for h holds, provided
      Re &lt; 5e5 and 0.6 &lt; Pr &lt; 50
</pre>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-40,40},{80,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}));
        end Convection;

        model ConvectiveResistor
          "Lumped thermal element for heat convection (dT = Rc*Q_flow)"
          Modelica.SIunits.HeatFlowRate Q_flow "Heat flow rate from solid -> fluid";
          Modelica.SIunits.TemperatureDifference dT "= solid.T - fluid.T";
          Modelica.Blocks.Interfaces.RealInput Rc(unit="K/W")
            "Signal representing the convective thermal resistance in [K/W]"
            annotation (Placement(transformation(
                origin={0,100},
                extent={{-20,-20},{20,20}},
                rotation=270)));
          Interfaces.HeatPort_a solid annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b fluid annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          dT = Rc*Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-62,80},{98,-80}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Forward),
                Text(
                  extent={{-150,-90},{150,-130}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0}),
                Text(
                  extent={{22,124},{92,98}},
                  textString="Rc")}),
            Documentation(info="<html>
<p>
This is a model of linear heat convection, e.g., the heat transfer between a plate and the surrounding air; same as the
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.Convection\">Convection</a> component
but using the convective resistance instead of the convective conductance as an input.
This is advantageous for series connections of ConvectiveResistors,
especially if it shall be allowed that a convective resistance is defined to be zero (i.e. no temperature difference).
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Forward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-40,40},{80,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}));
        end ConvectiveResistor;

        model ThermalCollector "Collects m heat flows"
          parameter Integer m(min=1)=3 "Number of collected heat flows";
          Interfaces.HeatPort_a port_a[m]
            annotation (Placement(transformation(extent={{-10,110},{10,90}})));
          Interfaces.HeatPort_b port_b
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));

        equation
          port_b.Q_flow + sum(port_a.Q_flow) = 0;
          port_a.T = fill(port_b.T, m);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,-30},{150,-70}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,80},{150,50}},
                  textString="m=%m"),
                Line(
                  points={{0,90},{0,40}},
                  color={181,0,0}),
                Rectangle(
                  extent={{-60,40},{60,30}},
                  lineColor={181,0,0},
                  fillColor={181,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-60,30},{0,-30},{0,-90}},
                  color={181,0,0}),
                Line(
                  points={{0,-30},{-20,30}},
                  color={181,0,0}),
                Line(
                  points={{0,-30},{20,30}},
                  color={181,0,0}),
                Line(
                  points={{0,-30},{60,30}},
                  color={181,0,0})}),
            Documentation(info="<html>
<p>
This is a model to collect the heat flows from <em>m</em> heatports to one single heatport.
</p>
</html>"));
        end ThermalCollector;
        annotation (Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Rectangle(
            origin = {12,40},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Backward,
            extent = {{-100,-100},{-70,18}}),
          Line(
            origin = {12,40},
            points = {{-44,16},{-44,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,16},{-4,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,18},{30,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,18},{66,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,-100},{76,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,-100},{56,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,-100},{40,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,-100},{20,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,-100},{6,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,-100},{-14,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-44,-100},{-34,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-44,-100},{-54,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-70,-60},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-70},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-50},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-30},{66,-20}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-10},{66,-20}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{-70,-20},{66,-20}},
            color = {191,0,0})}), Documentation(
              info="<html>

</html>"));
      end Components;

      package Sensors "Thermal sensors"
        extends Modelica.Icons.SensorsPackage;

        model TemperatureSensor "Absolute temperature sensor in Kelvin"

          Modelica.Blocks.Interfaces.RealOutput T(unit="K")
            "Absolute temperature as output signal"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Interfaces.HeatPort_a port annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
        equation
          T = port.T;
          port.Q_flow = 0;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-20,-98},{20,-60}},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,40},{12,-68}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{12,0},{90,0}}, color={0,0,255}),
                Line(points={{-94,0},{-14,0}}, color={191,0,0}),
                Polygon(
                  points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{
                      12,80},{12,40},{-12,40}},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-64}},
                  thickness=0.5),
                Line(
                  points={{12,40},{12,-64}},
                  thickness=0.5),
                Line(points={{-40,-20},{-12,-20}}),
                Line(points={{-40,20},{-12,20}}),
                Line(points={{-40,60},{-12,60}}),
                Text(
                  extent={{102,-28},{60,-78}},
                  textString="K")}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-20,-98},{20,-60}},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,40},{12,-68}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{12,0},{90,0}}, color={0,0,255}),
                Line(points={{-90,0},{-12,0}}, color={191,0,0}),
                Polygon(
                  points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},
                      {12,80},{12,40},{-12,40}},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-64}},
                  thickness=0.5),
                Line(
                  points={{12,40},{12,-64}},
                  thickness=0.5),
                Line(points={{-40,-20},{-12,-20}}),
                Line(points={{-40,20},{-12,20}}),
                Line(points={{-40,60},{-12,60}}),
                Text(
                  extent={{126,-20},{26,-120}},
                  textString="K"),
                Text(
                  extent={{-150,130},{150,90}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
This is an ideal absolute temperature sensor which returns
the temperature of the connected port in Kelvin as an output
signal.  The sensor itself has no thermal interaction with
whatever it is connected to.  Furthermore, no
thermocouple-like lags are associated with this
sensor model.
</p>
</html>"));
        end TemperatureSensor;

        model HeatFlowSensor "Heat flow rate sensor"
          extends Modelica.Icons.RotationalSensor;
          Modelica.Blocks.Interfaces.RealOutput Q_flow(unit="W")
            "Heat flow from port_a to port_b as output signal" annotation (Placement(
                transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=270)));
          Interfaces.HeatPort_a port_a annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b port_b annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          port_a.T = port_b.T;
          port_a.Q_flow + port_b.Q_flow = 0;
          Q_flow = port_a.Q_flow;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(points={{-70,0},{-95,0}}, color={191,0,0}),
                Line(points={{0,-70},{0,-90}}, color={0,0,127}),
                Line(points={{94,0},{69,0}}, color={191,0,0})}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{5,-86},{116,-110}},
                  textString="Q_flow"),
                Line(points={{-70,0},{-90,0}}, color={191,0,0}),
                Line(points={{69,0},{90,0}}, color={191,0,0}),
                Line(points={{0,-70},{0,-90}}, color={0,0,127}),
                Text(
                  extent={{-150,125},{150,85}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
This model is capable of monitoring the heat flow rate flowing through
this component. The sensed value of heat flow rate is the amount that
passes through this sensor while keeping the temperature drop across the
sensor zero.  This is an ideal model so it does not absorb any energy
and it has no direct effect on the thermal response of a system it is included in.
The output signal is positive, if the heat flows from port_a to port_b.
</p>
</html>"));
        end HeatFlowSensor;
        annotation (Documentation(info="<html>

</html>"));
      end Sensors;

      package Sources "Thermal sources"
      extends Modelica.Icons.SourcesPackage;

        model FixedTemperature "Fixed temperature boundary condition in Kelvin"

          parameter Modelica.SIunits.Temperature T "Fixed temperature at port";
          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
        equation
          port.T = T;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-110},{150,-140}},
                  textString="T=%T"),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Line(
                  points={{-52,0},{56,0}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{50,-20},{50,20},{90,0},{50,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This model defines a fixed temperature T at its port in Kelvin,
i.e., it defines a fixed temperature as a boundary condition.
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-101}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-52,0},{56,0}},
                  color={191,0,0},
                  thickness=0.5),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Polygon(
                  points={{52,-20},{52,20},{90,0},{52,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}));
        end FixedTemperature;

        model PrescribedTemperature
          "Variable temperature boundary condition in Kelvin"

          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
          Modelica.Blocks.Interfaces.RealInput T(unit="K") annotation (Placement(transformation(
                  extent={{-140,-20},{-100,20}})));
        equation
          port.T = T;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-102,0},{64,0}},
                  color={191,0,0},
                  thickness=0.5),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Polygon(
                  points={{50,-20},{50,20},{90,0},{50,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This model represents a variable temperature boundary condition.
The temperature in [K] is given as input signal <strong>T</strong>
to the model. The effect is that an instance of this model acts as
an infinite reservoir able to absorb or generate as much energy
as required to keep the temperature at the specified value.
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Line(
                  points={{-102,0},{64,0}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{52,-20},{52,20},{90,0},{52,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}));
        end PrescribedTemperature;

        model FixedHeatFlow "Fixed heat flow boundary condition"
          parameter Modelica.SIunits.HeatFlowRate Q_flow
            "Fixed heat flow rate at port";
          parameter Modelica.SIunits.Temperature T_ref=293.15
            "Reference temperature";
          parameter Modelica.SIunits.LinearTemperatureCoefficient alpha=0
            "Temperature coefficient of heat flow rate";
          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
        equation
          port.Q_flow = -Q_flow*(1 + alpha*(port.T - T_ref));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,100},{150,60}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-55},{150,-85}},
                  textString="Q_flow=%Q_flow"),
                Line(
                  points={{-100,-20},{48,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-100,20},{46,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{40,0},{40,40},{70,20},{40,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{40,-40},{40,0},{70,-20},{40,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{70,40},{90,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Text(
                  extent={{-100,40},{0,-36}},
                  textString="Q_flow=const."),
                Line(
                  points={{-48,-20},{60,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-48,20},{60,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{60,0},{60,40},{90,20},{60,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{60,-40},{60,0},{90,-20},{60,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The constant amount of heat
flow rate Q_flow is given as a parameter. The heat flows into the
component to which the component FixedHeatFlow is connected,
if parameter Q_flow is positive.
</p>
<p>
If parameter alpha is &lt;&gt; 0, the heat flow is multiplied by (1 + alpha*(port.T - T_ref))
in order to simulate temperature dependent losses (which are given with respect to reference temperature T_ref).
</p>
</html>"));
        end FixedHeatFlow;

        model PrescribedHeatFlow "Prescribed heat flow boundary condition"
          parameter Modelica.SIunits.Temperature T_ref=293.15
            "Reference temperature";
          parameter Modelica.SIunits.LinearTemperatureCoefficient alpha=0
            "Temperature coefficient of heat flow rate";
          Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
                annotation (Placement(transformation(
                origin={-100,0},
                extent={{20,-20},{-20,20}},
                rotation=180)));
          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
        equation
          port.Q_flow = -Q_flow*(1 + alpha*(port.T - T_ref));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(
                  points={{-60,-20},{40,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-60,20},{40,20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{40,0},{40,40},{70,20},{40,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{40,-40},{40,0},{70,-20},{40,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{70,40},{90,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,100},{150,60}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
If parameter alpha is &lt;&gt; 0, the heat flow is multiplied by (1 + alpha*(port.T - T_ref))
in order to simulate temperature dependent losses (which are given with respect to reference temperature T_ref).
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{-60,-20},{68,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-60,20},{68,20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{60,0},{60,40},{90,20},{60,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{60,-40},{60,0},{90,-20},{60,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}));
        end PrescribedHeatFlow;
        annotation (Documentation(info="<html>

</html>"));
      end Sources;

      package Interfaces "Connectors and partial models"
        extends Modelica.Icons.InterfacesPackage;

        partial connector HeatPort "Thermal port for 1-dim. heat transfer"
          Modelica.SIunits.Temperature T "Port temperature";
          flow Modelica.SIunits.HeatFlowRate Q_flow
            "Heat flow rate (positive if flowing from outside into the component)";
          annotation (Documentation(info="<html>

</html>"));
        end HeatPort;

        connector HeatPort_a
          "Thermal port for 1-dim. heat transfer (filled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_a",
            Documentation(info="<html>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<pre>
   T       Temperature in [Kelvin].
   Q_flow  Heat flow rate in [Watt].
</pre>
<p>According to the Modelica sign convention, a <strong>positive</strong> heat flow
rate <strong>Q_flow</strong> is considered to flow <strong>into</strong> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <strong>HeatPort_a</strong> and
<strong>HeatPort_b</strong> are identical with the only exception of the different
<strong>icon layout</strong>.</p></html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-120,120},{100,60}},
                  lineColor={191,0,0},
                  textString="%name")}));
        end HeatPort_a;

        connector HeatPort_b
          "Thermal port for 1-dim. heat transfer (unfilled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_b",
            Documentation(info="<html>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<pre>
   T       Temperature in [Kelvin].
   Q_flow  Heat flow rate in [Watt].
</pre>
<p>According to the Modelica sign convention, a <strong>positive</strong> heat flow
rate <strong>Q_flow</strong> is considered to flow <strong>into</strong> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <strong>HeatPort_a</strong> and
<strong>HeatPort_b</strong> are identical with the only exception of the different
<strong>icon layout</strong>.</p></html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-100,120},{120,60}},
                  lineColor={191,0,0},
                  textString="%name")}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end HeatPort_b;

        partial model Element1D
          "Partial heat transfer element with two HeatPort connectors that does not store energy"

          Modelica.SIunits.HeatFlowRate Q_flow
            "Heat flow rate from port_a -> port_b";
          Modelica.SIunits.TemperatureDifference dT "port_a.T - port_b.T";
      public
          HeatPort_a port_a annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          HeatPort_b port_b annotation (Placement(transformation(extent={{90,-10},{
                    110,10}})));
        equation
          dT = port_a.T - port_b.T;
          port_a.Q_flow = Q_flow;
          port_b.Q_flow = -Q_flow;
          annotation (Documentation(info="<html>
<p>
This partial model contains the basic connectors and variables to
allow heat transfer models to be created that <strong>do not store energy</strong>,
This model defines and includes equations for the temperature
drop across the element, <strong>dT</strong>, and the heat flow rate
through the element from port_a to port_b, <strong>Q_flow</strong>.
</p>
<p>
By extending this model, it is possible to write simple
constitutive equations for many types of heat transfer components.
</p>
</html>"));
        end Element1D;
        annotation (Documentation(info="<html>

</html>"));
      end Interfaces;
      annotation (
         Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Polygon(
            origin = {13.758,27.517},
            lineColor = {128,128,128},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{-54,-6},{-61,-7},{-75,-15},{-79,-24},{-80,-34},{-78,-42},{-73,-49},{-64,-51},{-57,-51},{-47,-50},{-41,-43},{-38,-35},{-40,-27},{-40,-20},{-42,-13},{-47,-7},{-54,-5},{-54,-6}}),
        Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{-75,-15},{-79,-25},{-80,-34},{-78,-42},{-72,-49},{-64,-51},{-57,-51},{-47,-50},{-57,-47},{-65,-45},{-71,-40},{-74,-33},{-76,-23},{-75,-15},{-75,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {160,160,164},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{39,-6},{32,-7},{18,-15},{14,-24},{13,-34},{15,-42},{20,-49},{29,-51},{36,-51},{46,-50},{52,-43},{55,-35},{53,-27},{53,-20},{51,-13},{46,-7},{39,-5},{39,-6}}),
          Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{18,-15},{14,-25},{13,-34},{15,-42},{21,-49},{29,-51},{36,-51},{46,-50},{36,-47},{28,-45},{22,-40},{19,-33},{17,-23},{18,-15},{18,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-9,-23},{-9,-10},{18,-17},{-9,-23}}),
          Line(
            origin = {13.758,27.517},
            points = {{-41,-17},{-9,-17}},
            color = {191,0,0},
            thickness = 0.5),
          Line(
            origin = {13.758,27.517},
            points = {{-17,-40},{15,-40}},
            color = {191,0,0},
            thickness = 0.5),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-17,-46},{-17,-34},{-40,-40},{-17,-46}})}),
                                Documentation(info="<html>
<p>
This package contains components to model <strong>1-dimensional heat transfer</strong>
with lumped elements. This allows especially to model heat transfer in
machines provided the parameters of the lumped elements, such as
the heat capacity of a part, can be determined by measurements
(due to the complex geometries and many materials used in machines,
calculating the lumped element parameters from some basic analytic
formulas is usually not possible).
</p>
<p>
Example models how to use this library are given in subpackage <strong>Examples</strong>.<br>
For a first simple example, see <strong>Examples.TwoMasses</strong> where two masses
with different initial temperatures are getting in contact to each
other and arriving after some time at a common temperature.<br>
<strong>Examples.ControlledTemperature</strong> shows how to hold a temperature
within desired limits by switching on and off an electric resistor.<br>
A more realistic example is provided in <strong>Examples.Motor</strong> where the
heating of an electrical motor is modelled, see the following screen shot
of this example:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Thermal/HeatTransfer/driveWithHeatTransfer.png\" alt=\"driveWithHeatTransfer\">
</p>

<p>
The <strong>filled</strong> and <strong>non-filled red squares</strong> at the left and
right side of a component represent <strong>thermal ports</strong> (connector HeatPort).
Drawing a line between such squares means that they are thermally connected.
The variables of a HeatPort connector are the temperature <strong>T</strong> at the port
and the heat flow rate <strong>Q_flow</strong> flowing into the component (if Q_flow is positive,
the heat flows into the element, otherwise it flows out of the element):
</p>
<pre>   Modelica.SIunits.Temperature  T  \"absolute temperature at port in Kelvin\";
   Modelica.SIunits.HeatFlowRate Q_flow  \"flow rate at the port in Watt\";
</pre>
<p>
Note, that all temperatures of this package, including initial conditions,
are given in Kelvin. For convenience, in subpackages <strong>HeatTransfer.Celsius</strong>,
 <strong>HeatTransfer.Fahrenheit</strong> and <strong>HeatTransfer.Rankine</strong> components are provided such that source and
sensor information is available in degree Celsius, degree Fahrenheit, or degree Rankine,
respectively. Additionally, in package <strong>SIunits.Conversions</strong> conversion
functions between the units Kelvin and Celsius, Fahrenheit, Rankine are
provided. These functions may be used in the following way:
</p>
<pre>  <strong>import</strong> SI=Modelica.SIunits;
  <strong>import</strong> Modelica.SIunits.Conversions.*;
     ...
  <strong>parameter</strong> SI.Temperature T = from_degC(25);  // convert 25 degree Celsius to Kelvin
</pre>

<p>
There are several other components available, such as AxialConduction (discretized PDE in
axial direction), which have been temporarily removed from this library. The reason is that
these components reference material properties, such as thermal conductivity, and currently
the Modelica design group is discussing a general scheme to describe material properties.
</p>
<p>
For technical details in the design of this library, see the following reference:<br>
<strong>Michael Tiller (2001)</strong>: <a href=\"http://www.amazon.de\">
Introduction to Physical Modeling with Modelica</a>.
Kluwer Academic Publishers Boston.
</p>
<p>
<strong>Acknowledgements:</strong><br>
Several helpful remarks from the following persons are acknowledged:
John Batteh, Ford Motors, Dearborn, U.S.A;
<a href=\"https://www.haumer.at/\">Anton Haumer</a>, Technical Consulting &amp; Electrical Engineering, Germany;
Ludwig Marvan, VA TECH ELIN EBG Elektronik GmbH, Wien, Austria;
Hans Olsson, Dassault Syst&egrave;mes AB, Sweden;
Hubertus Tummescheit, Lund Institute of Technology, Lund, Sweden.
</p>
<dl>
  <dt><strong>Main Authors:</strong></dt>
  <dd>
  <p>
  <a href=\"https://www.haumer.at/\">Anton Haumer</a><br>
  Technical Consulting &amp; Electrical Engineering<br>
  D-93049 Regensburg, Germany<br>
  email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
</p>
  </dd>
</dl>
<p>
Copyright &copy; 2001-2019, Modelica Association and contributors
</p>
</html>",     revisions="<html>
<ul>
<li><em>July 15, 2002</em>
       by Michael Tiller, <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Nikolaus Sch&uuml;rmann:<br>
       Implemented.
</li>
<li><em>June 13, 2005</em>
       by <a href=\"https://www.haumer.at/\">Anton Haumer</a><br>
       Refined placing of connectors (cosmetic).<br>
       Refined all Examples; removed Examples.FrequencyInverter, introducing Examples.Motor<br>
       Introduced temperature dependent correction (1 + alpha*(T - T_ref)) in Fixed/PrescribedHeatFlow<br>
</li>
  <li> v1.1.1 2007/11/13 Anton Haumer<br>
       components moved to sub-packages</li>
  <li> v1.2.0 2009/08/26 Anton Haumer<br>
       added component ThermalCollector</li>

</ul>
</html>"));
    end HeatTransfer;
    annotation (
     Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Line(
      origin={-47.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={-50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={2.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={0.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={52.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}})}),
      Documentation(info="<html>
<p>
This package contains libraries to model heat transfer
and fluid heat flow.
</p>
</html>"));
  end Thermal;

  package Math
  "Library of mathematical functions (e.g., sin, cos) and of functions operating on vectors and matrices"
  import SI = Modelica.SIunits;
  extends Modelica.Icons.Package;

    package BooleanVectors "Library of functions operating on Boolean vectors"
     extends Modelica.Icons.Package;

    function allTrue
        "Returns true, if all elements of the Boolean input vector are true ('and')"
      extends Modelica.Icons.Function;
      input Boolean b[:] "Boolean vector";
      output Boolean result "= true, if all elements of b are true";
    algorithm
      result := size(b,1) > 0;
      for i in 1:size(b,1) loop
         result := result and b[i];
      end for;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>allTrue</strong>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
Returns <strong>true</strong> if all elements of the Boolean input vector b are <strong>true</strong>.
Otherwise the function returns <strong>false</strong>. If b is an empty vector,
i.e., size(b,1)=0, the function returns <strong>false</strong>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Boolean b1[3] = {true, true, true};
  Boolean b2[3] = {false, true, false};
  Boolean r1, r2;
<strong>algorithm</strong>
  r1 = allTrue(b1);  // r1 = true
  r2 = allTrue(b2);  // r2 = false
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.anyTrue\">anyTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.countTrue\">countTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.enumerate\">enumerate</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.index\">index</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>.
</p>

</html>"));
    end allTrue;
      annotation (Documentation(info="<html>
<p>
This library provides functions operating on vectors that have
a Boolean vector as input argument.
</p>
</html>"),     Icon(graphics={Rectangle(
              extent={{-16,62},{14,14}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-16,-18},{14,-66}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}));
    end BooleanVectors;

  package Matrices "Library of functions operating on matrices"
    extends Modelica.Icons.Package;

    function solve
      "Solve real system of linear equations A*x=b with a b vector (Gaussian elimination with partial pivoting)"

      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)] "Matrix A of A*x = b";
      input Real b[size(A, 1)] "Vector b of A*x = b";
      output Real x[size(b, 1)] "Vector x such that A*x = b";

  protected
      Integer info;
    algorithm
      (x,info) := LAPACK.dgesv_vec(A, b);
      assert(info == 0, "Solving a linear system of equations with function
\"Matrices.solve\" is not possible, because the system has either
no or infinitely many solutions (A is singular).");
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<strong>solve</strong>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <strong>x</strong> of the linear system of equations
</p>
<blockquote>
<p>
<strong>A</strong>*<strong>x</strong> = <strong>b</strong>
</p>
</blockquote>
<p>
If a unique solution <strong>x</strong> does not exist (since <strong>A</strong> is singular),
an assertion is triggered. If this is not desired, use instead
<a href=\"modelica://Modelica.Math.Matrices.leastSquares\">Matrices.leastSquares</a>
and inquire the singularity of the solution with the return argument rank
(a unique solution is computed if rank = size(A,1)).
</p>

<p>
Note, the solution is computed with the LAPACK function \"dgesv\",
i.e., by Gaussian elimination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b[3] = {10,22,12};
  Real x[3];
<strong>algorithm</strong>
  x := Matrices.solve(A,b);  // x = {3,2,1}
</pre></blockquote>
<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.LU\">Matrices.LU</a>,
<a href=\"modelica://Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>,
<a href=\"modelica://Modelica.Math.Matrices.leastSquares\">Matrices.leastSquares</a>.
</html>"));
    end solve;

    function leastSquares
      "Solve linear equation A*x = b (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix A";
      input Real b[size(A, 1)] "Vector b";
      input Real rcond=100*Modelica.Constants.eps
        "Reciprocal condition number to estimate the rank of A";
      output Real x[size(A, 2)]
        "Vector x such that min|A*x-b|^2 if size(A,1) >= size(A,2) or min|x|^2 and A*x=b, if size(A,1) < size(A,2)";
      output Integer rank "Rank of A";
  protected
      Integer info;
      Real xx[max(size(A, 1), size(A, 2))];
    algorithm
      if min(size(A)) > 0 then
        (xx,info,rank) := LAPACK.dgelsy_vec(
              A,
              b,
              rcond);
        x := xx[1:size(A, 2)];
        assert(info == 0,
          "Solving an overdetermined or underdetermined linear system\n" +
          "of equations with function \"Matrices.leastSquares\" failed.");
      else
        x := fill(0.0, size(A, 2));
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<strong>leastSquares</strong>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns a solution of equation A*x = b in a least
square sense (A may be rank deficient):
</p>
<pre>
  minimize | A*x - b |
</pre>

<p>
Several different cases can be distinguished (note, <strong>rank</strong> is an
output argument of this function):
</p>

<p>
<strong>size(A,1) = size(A,2)</strong>
</p>

<p> A solution is returned for a regular, as well as a singular matrix A:
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     A is <strong>regular</strong> and the returned solution x fulfills the equation
     A*x = b uniquely.</li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     A is <strong>singular</strong> and no unique solution for equation A*x = b exists.
     <ul>
     <li>  If an infinite number of solutions exists, the one is selected that fulfills
           the equation and at the same time has the minimum norm |x| for all solution
           vectors that fulfill the equation.</li>
     <li>  If no solution exists, x is selected such that |A*x - b| is as small as
           possible (but A*x - b is not zero).</li>
     </ul></li>
</ul>

<p>
<strong>size(A,1) &gt; size(A,2):</strong>
</p>

<p>
The equation A*x = b has no unique solution. The solution x is selected such that
|A*x - b| is as small as possible. If rank = size(A,2), this minimum norm solution is
unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the
same minimum value of |A*x - b|. From these infinite number of solutions, the one with the
minimum norm |x| is selected. This gives a unique solution that minimizes both
|A*x - b| and |x|.
</p>

<p>
<strong>size(A,1) &lt; size(A,2):</strong>
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     There are an infinite number of solutions that fulfill the equation A*x = b.
     From this infinite number, the unique solution is selected that minimizes |x|.
     </li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     There is either no solution of equation A*x = b, or there are again an infinite
     number of solutions. The unique solution x is returned that minimizes
      both |A*x - b| and |x|.</li>
</ul>

<p>
Note, the solution is computed with the LAPACK function \"dgelsy\",
i.e., QR or LQ factorization of A with column pivoting.
</p>

<h4>Algorithmic details</h4>

<p>
The function first computes a QR factorization with column pivoting:
</p>

<pre>
      A * P = Q * [ R11 R12 ]
                  [  0  R22 ]
</pre>

<p>
with R11 defined as the largest leading submatrix whose estimated
condition number is less than 1/rcond.  The order of R11, <strong>rank</strong>,
is the effective rank of A.
</p>

<p>
Then, R22 is considered to be negligible, and R12 is annihilated
by orthogonal transformations from the right, arriving at the
complete orthogonal factorization:
</p>

<pre>
     A * P = Q * [ T11 0 ] * Z
                 [  0  0 ]
</pre>

<p>
The minimum-norm solution is then
</p>

<pre>
     x = P * Z' [ inv(T11)*Q1'*b ]
                [        0       ]
</pre>

<p>
where Q1 consists of the first \"rank\" columns of Q.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">Matrices.leastSquares2</a>
(same as leastSquares, but with a right hand side matrix),<br>
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>
(for square, regular matrices A)
</p>

</html>"));
    end leastSquares;

    function inv "Return inverse of a matrix (try to avoid inv(..))"
      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)];
      output Real invA[size(A, 1), size(A, 2)] "Inverse of matrix A";
  protected
      Integer info;
      Integer pivots[size(A, 1)] "Pivot vector";
      Real LU[size(A, 1), size(A, 2)] "LU factors of A";
    algorithm
      (LU,pivots,info) := LAPACK.dgetrf(A);

      assert(info == 0, "Calculating an inverse matrix with function
\"Matrices.inv\" is not possible, since matrix A is singular.");

      invA := LAPACK.dgetri(LU, pivots);

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
invA = Matrices.<strong>inv</strong>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns the inverse of matrix A, i.e., A*inv(A) = identity(size(A,1))
computed by a LU decomposition with row pivoting.
Usually, this function should not be used, because
there are nearly always better numerical algorithms
as by computing directly the inverse. Example:
</p>

<blockquote>
Use x = <a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>(A,b)
to solve the linear equation A*x = b, instead of computing the solution by
x = inv(A)*b, because this is much more efficient and much more reliable.
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>
<a href=\"modelica://Modelica.Math.Matrices.solve2\">Matrices.solve2</a>
</html>"));
    end inv;

    package LAPACK
    "Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)"
      extends Modelica.Icons.Package;

      function dgelsy_vec
        "Computes the minimum-norm solution to a real linear least squares problem with rank deficient A"

        extends Modelica.Icons.Function;
        input Real A[:, :];
        input Real b[size(A, 1)];
        input Real rcond=0.0 "Reciprocal condition number to estimate rank";
        output Real x[max(size(A, 1), size(A, 2))]=cat(
                  1,
                  b,
                  zeros(max(nrow, ncol) - nrow))
          "solution is in first size(A,2) rows";
        output Integer info;
        output Integer rank "Effective rank of A";
    protected
        Integer nrow=size(A, 1);
        Integer ncol=size(A, 2);
        Integer nrhs=1;
        Integer nx=max(nrow, ncol);
        Integer lwork=max(min(nrow, ncol) + 3*ncol + 1, 2*min(nrow, ncol) + 1);
        Real work[max(min(size(A, 1), size(A, 2)) + 3*size(A, 2) + 1, 2*min(size(A, 1),
          size(A, 2)) + 1)];
        Real Awork[size(A, 1), size(A, 2)]=A;
        Integer jpvt[size(A, 2)]=zeros(ncol);

      external"FORTRAN 77" dgelsy(
                nrow,
                ncol,
                nrhs,
                Awork,
                nrow,
                x,
                nx,
                jpvt,
                rcond,
                rank,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGELSY computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z' [ inv(T11)*Q1'*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    This routine is basically identical to the original xGELSX except
    three differences:
      o The call to the subroutine xGEQPF has been substituted by
        the call to the subroutine xGEQP3. This subroutine is a Blas-3
        version of the QR factorization with column pivoting.
      o Matrix B (the right hand side) is updated with Blas-3.
      o The permutation of matrix B (the right hand side) is faster and
        more simple.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB >= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of AP, otherwise column i is a free column.
            On exit, if JPVT(i) = k, then the i-th column of AP
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number < 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            The unblocked strategy requires that:
               LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),
            where MN = min( M, N ).
            The block algorithm requires that:
               LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
            where NB is an upper bound on the blocksize returned
            by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR,
            and DORMRZ.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: If INFO = -i, the i-th argument had an illegal value.
"));
      end dgelsy_vec;

      function dgesv_vec
        "Solve real system of linear equations A*x=b with a b vector"
        extends Modelica.Icons.Function;
        input Real A[:, size(A, 1)];
        input Real b[size(A, 1)];
        output Real x[size(A, 1)]=b;
        output Integer info;
    protected
        Integer n=size(A, 1);
        Integer nrhs=1;
        Real Awork[size(A, 1), size(A, 1)]=A;
        Integer lda=max(1, size(A, 1));
        Integer ldb=max(1, size(b, 1));
        Integer ipiv[size(A, 1)];

      external"FORTRAN 77" dgesv(
                n,
                nrhs,
                Awork,
                lda,
                ipiv,
                x,
                ldb,
                info) annotation (Library="lapack");
        annotation (Documentation(info="
Same as function LAPACK.dgesv, but right hand side is a vector and not a matrix.
For details of the arguments, see documentation of dgesv.
"));
      end dgesv_vec;

      function dgetrf
        "Compute LU factorization of square or rectangular matrix A (A = P*L*U)"

        extends Modelica.Icons.Function;
        input Real A[:, :] "Square or rectangular matrix";
        output Real LU[size(A, 1), size(A, 2)]=A;
        output Integer pivots[min(size(A, 1), size(A, 2))] "Pivot vector";
        output Integer info "Information";
    protected
        Integer m=size(A, 1);
        Integer n=size(A, 2);
        Integer lda=max(1, size(A, 1));

      external"FORTRAN 77" dgetrf(
                m,
                n,
                LU,
                lda,
                pivots,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGETRF computes an LU factorization of a general M-by-N matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).

    This is the right-looking Level 3 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    IPIV    (output) INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 <= i <= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
"));
      end dgetrf;

      function dgetri
        "Computes the inverse of a matrix using the LU factorization from dgetrf(..)"

        extends Modelica.Icons.Function;
        input Real LU[:, size(LU, 1)]
          "LU factorization of dgetrf of a square matrix";
        input Integer pivots[size(LU, 1)] "Pivot vector of dgetrf";
        output Real inv[size(LU, 1), size(LU, 2)]=LU "Inverse of matrix P*L*U";
        output Integer info;

    protected
        Integer n=size(LU, 1);
        Integer lda=max(1, size(LU, 1));
        Integer lwork=max(1, min(10, size(LU, 1))*size(LU, 1))
          "Length of work array";
        Real work[max(1, min(10, size(LU, 1))*size(LU, 1))];

      external"FORTRAN 77" dgetri(
                n,
                inv,
                lda,
                pivots,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGETRI computes the inverse of a matrix using the LU factorization
    computed by DGETRF.

    This method inverts U and then computes inv(A) by solving the system
    inv(A)*L = inv(U) for inv(A).

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by DGETRF.
            On exit, if INFO = 0, the inverse of the original matrix A.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1<=i<=N, row i of the
            matrix was interchanged with row IPIV(i).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, then WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimal performance LWORK >= N*NB, where NB is
            the optimal blocksize returned by ILAENV.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
"));
      end dgetri;
      annotation (Documentation(info="<html>
<p>
This package contains external Modelica functions as interface to the
LAPACK library
(<a href=\"http://www.netlib.org/lapack\">http://www.netlib.org/lapack</a>)
that provides FORTRAN subroutines to solve linear algebra
tasks. Usually, these functions are not directly called, but only via
the much more convenient interface of
<a href=\"modelica://Modelica.Math.Matrices\">Modelica.Math.Matrices</a>.
The documentation of the LAPACK functions is a copy of the original
FORTRAN code. The details of LAPACK are described in:
</p>

<dl>
<dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
    Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
<dd> <a href=\"http://www.netlib.org/lapack/lug/lapack_lug.html\">Lapack Users' Guide</a>.
     Third Edition, SIAM, 1999.</dd>
</dl>

<p>
See also <a href=\"http://en.wikipedia.org/wiki/Lapack\">http://en.wikipedia.org/wiki/Lapack</a>.
</p>

<p>
This package contains a direct interface to the LAPACK subroutines
</p>

</html>"));
    end LAPACK;
    annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
This library provides functions operating on matrices. Below, the
functions are ordered according to categories and a typical
call of the respective function is shown.
Most functions are solely an interface to the external
<a href=\"modelica://Modelica.Math.Matrices.LAPACK\">LAPACK</a> library.
</p>

<p>
Note: A' is a short hand notation of transpose(A):
</p>

<p><strong>Basic Information</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.toString\">toString</a>(A)
     - returns the string representation of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.isEqual\">isEqual</a>(M1, M2)
     - returns true if matrices M1 and M2 have the same size and the same elements.</li>
</ul>

<p><strong>Linear Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.solve\">solve</a>(A,b)
     - returns solution x of the linear equation A*x=b (where b is a vector,
       and A is a square matrix that must be regular).</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.solve2\">solve2</a>(A,B)
     - returns solution X of the linear equation A*X=B (where B is a matrix,
       and A is a square matrix that must be regular)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares\">leastSquares</a>(A,b)
     - returns solution x of the linear equation A*x=b in a least squares sense
       (where b is a vector and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">leastSquares2</a>(A,B)
     - returns solution X of the linear equation A*X=B in a least squares sense
       (where B is a matrix and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.equalityLeastSquares\">equalityLeastSquares</a>(A,a,B,b)
     - returns solution x of a linear equality constrained least squares problem:
       min|A*x-a|^2 subject to B*x=b</li>

<li> (LU,p,info) = <a href=\"modelica://Modelica.Math.Matrices.LU\">LU</a>(A)
     - returns the LU decomposition with row pivoting of a rectangular matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve\">LU_solve</a>(LU,p,b)
     - returns solution x of the linear equation L*U*x[p]=b with a b
       vector and an LU decomposition from \"LU(..)\".</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve2\">LU_solve2</a>(LU,p,B)
     - returns solution X of the linear equation L*U*X[p,:]=B with a B
       matrix and an LU decomposition from \"LU(..)\".</li>
</ul>

<p><strong>Matrix Factorizations</strong></p>
<ul>
<li> (eval,evec) = <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">eigenValues</a>(A)
     - returns eigen values \"eval\" and eigen vectors \"evec\" for a real,
       nonsymmetric matrix A in a Real representation.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">eigenValueMatrix</a>(eval)
     - returns real valued block diagonal matrix of the eigenvalues \"eval\" of matrix A.</li>

<li> (sigma,U,VT) = <a href=\"modelica://Modelica.Math.Matrices.singularValues\">singularValues</a>(A)
     - returns singular values \"sigma\" and left and right singular vectors U and VT
       of a rectangular matrix A.</li>

<li> (Q,R,p) = <a href=\"modelica://Modelica.Math.Matrices.QR\">QR</a>(A)
     - returns the QR decomposition with column pivoting of a rectangular matrix A
       such that Q*R = A[:,p].</li>

<li> (H,U) = <a href=\"modelica://Modelica.Math.Matrices.hessenberg\">hessenberg</a>(A)
     - returns the upper Hessenberg form H and the orthogonal transformation matrix U
       of a square matrix A such that H = U'*A*U.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.realSchur\">realSchur</a>(A)
     - returns the real Schur form of a square matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.cholesky\">cholesky</a>(A)
     - returns the cholesky factor H of a real symmetric positive definite matrix A so that A = H'*H.</li>

<li> (D,Aimproved) = <a href=\"modelica://Modelica.Math.Matrices.balance\">balance</a>(A)
     - returns an improved form Aimproved of a square matrix A that has a smaller condition as A,
       with Aimproved = inv(diagonal(D))*A*diagonal(D).</li>
</ul>

<p><strong>Matrix Properties</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.trace\">trace</a>(A)
     - returns the trace of square matrix A, i.e., the sum of the diagonal elements.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.det\">det</a>(A)
     - returns the determinant of square matrix A (using LU decomposition; try to avoid det(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.inv\">inv</a>(A)
     - returns the inverse of square matrix A (try to avoid, use instead \"solve2(..) with B=identity(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rank\">rank</a>(A)
     - returns the rank of square matrix A (computed with singular value decomposition)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.conditionNumber\">conditionNumber</a>(A)
     - returns the condition number norm(A)*norm(inv(A)) of a square matrix A in the range 1..&infin;.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rcond\">rcond</a>(A)
     - returns the reciprocal condition number 1/conditionNumber(A) of a square matrix A in the range 0..1.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.norm\">norm</a>(A)
     - returns the 1-, 2-, or infinity-norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.frobeniusNorm\">frobeniusNorm</a>(A)
     - returns the Frobenius norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.nullSpace\">nullSpace</a>(A)
     - returns the null space of matrix A.</li>
</ul>

<p><strong>Matrix Exponentials</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.exp\">exp</a>(A)
     - returns the exponential e^A of a matrix A by adaptive Taylor series
       expansion with scaling and balancing</li>

<li> (phi, gamma) = <a href=\"modelica://Modelica.Math.Matrices.integralExp\">integralExp</a>(A,B)
     - returns the exponential phi=e^A and the integral gamma=integral(exp(A*t)*dt)*B as needed
       for a discretized system with zero order hold.</li>

<li> (phi, gamma, gamma1) = <a href=\"modelica://Modelica.Math.Matrices.integralExpT\">integralExpT</a>(A,B)
     - returns the exponential phi=e^A, the integral gamma=integral(exp(A*t)*dt)*B,
       and the time-weighted integral gamma1 = integral((T-t)*exp(A*t)*dt)*B as needed
       for a discretized system with first order hold.</li>
</ul>

<p><strong>Matrix Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.continuousLyapunov\">continuousLyapunov</a>(A,C)
     - returns solution X of the continuous-time Lyapunov equation X*A + A'*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousSylvester\">continuousSylvester</a>(A,B,C)
     - returns solution X of the continuous-time Sylvester equation A*X + X*B = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousRiccati\">continuousRiccati</a>(A,B,R,Q)
     - returns solution X of the continuous-time algebraic Riccati equation
       A'*X + X*A - X*B*inv(R)*B'*X + Q = 0</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteLyapunov\">discreteLyapunov</a>(A,C)
     - returns solution X of the discrete-time Lyapunov equation A'*X*A + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteSylvester\">discreteSylvester</a>(A,B,C)
     - returns solution X of the discrete-time Sylvester equation A*X*B + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteRiccati\">discreteRiccati</a>(A,B,R,Q)
     - returns solution X of the discrete-time algebraic Riccati equation
       A'*X*A - X - A'*X*B*inv(R + B'*X*B)*B'*X*A + Q = 0</li>
</ul>

<p><strong>Matrix Manipulation</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.sort\">sort</a>(M)
     - returns the sorted rows or columns of matrix M in ascending or descending order.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipLeftRight\">flipLeftRight</a>(M)
     - returns matrix M so that the columns of M are flipped in left/right direction.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipUpDown\">flipUpDown</a>(M)
     - returns matrix M so that the rows of M are flipped in up/down direction.</li>
</ul>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Vectors\">Vectors</a>

</html>"),   Icon(graphics={
          Rectangle(
            extent={{-60,66},{-30,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,66},{58,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,-18},{-30,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,-18},{58,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid)}));
  end Matrices;

    package Nonlinear "Library of functions operating on nonlinear equations"
      extends Modelica.Icons.Package;

      package Interfaces "Interfaces for functions"
        extends Modelica.Icons.InterfacesPackage;

      encapsulated partial function partialScalarFunction
          "Interface for a function with one input and one output Real signal"
        import Modelica;
        extends Modelica.Icons.Function;
        input Real u "Independent variable";
        output Real y "Dependent variable y=f(u)";
          annotation (Documentation(info="<html>
<p>
This partial function defines the interface of a function with
one input and one output Real signal. The scalar functions
of <a href=\"modelica://Modelica.Math.Nonlinear\">Modelica.Math.Nonlinear</a>
are derived from this base type by inheritance.
This allows to use these functions directly as function arguments
to a function, see, .e.g.,
<a href=\"modelica://Modelica.Math.Nonlinear.Examples\">Math.Nonlinear.Examples</a>.
</p>

</html>"));
      end partialScalarFunction;
        annotation (Documentation(info="<html>
<p>
Interface definitions of functions. The main purpose is to use functions
derived from these interface definitions as function arguments
to a function, see, .e.g.,
<a href=\"modelica://Modelica.Math.Nonlinear.Examples\">Math.Nonlinear.Examples</a>.
</p>
</html>"));
      end Interfaces;

      function quadratureLobatto
        "Return the integral of an integrand function using an adaptive Lobatto rule"
        extends Modelica.Icons.Function;
        input Modelica.Math.Nonlinear.Interfaces.partialScalarFunction f
          "Integrand function";
        input Real a "Lower limit of integration interval";
        input Real b "Upper limit of integration interval";
        input Real tolerance = 100*Modelica.Constants.eps
          "Relative tolerance for integral value";
        output Real integral "integral value";

    protected
        constant Real x1=0.942882415695480;
        constant Real x2=0.641853342345781;
        constant Real x3=0.236383199662150;
        constant Real eps=10*Modelica.Constants.eps;
        Real m;
        Real h;
        Real alpha;
        Real beta;
        Real x[13];
        Real y[13];
        Real fa;
        Real fb;
        Real i1;
        Real i2;
        Real is;
        Real erri1;
        Real erri2;
        Real R;
        Real tol;
        Integer s;

        function quadStep "Recursive function used by quadrature"
          input Modelica.Math.Nonlinear.Interfaces.partialScalarFunction f;
          input Real a "Right interval end";
          input Real b "Left interval end";
          input Real fa "Function value at a";
          input Real fb "Function value at b";
          input Real is "First approximation of the integral";
          output Real I "integral value";
      protected
          Real m;
          Real h;
          Real alpha;
          Real beta;
          Real x[5];
          Real y[5];
          Real mll;
          Real ml;
          Real mr;
          Real mrr;
          Real fmll;
          Real fml;
          Real fm;
          Real fmr;
          Real fmrr;
          Real i1;
          Real i2;
        algorithm
          h := (b - a)/2;
          m := (a + b)/2;
          alpha := sqrt(2/3);
          beta := 1/sqrt(5);
          mll := m - alpha*h;
          ml := m - beta*h;
          mr := m + beta*h;
          mrr := m + alpha*h;
          x := {mll,ml,m,mr,mrr};
          for i in 1:size(x,1) loop
            y[i] := f(x[i]);
          end for;
          fmll := y[1];
          fml := y[2];
          fm := y[3];
          fmr := y[4];
          fmrr := y[5];
          i2 := (h/6)*(fa + fb + 5*(fml + fmr));
          i1 := (h/1470)*(77*(fa + fb) + 432*(fmll + fmrr) + 625*(fml + fmr) +
            672*fm);

          if (is + (i1 - i2) == is) or (mll <= a) or (b <= mrr) then
            I := i1;

          else
            I := quadStep(f, a, mll, fa, fmll, is) +
                 quadStep(f, mll, ml, fmll, fml, is) +
                 quadStep(f, ml, m, fml, fm, is) +
                 quadStep(f, m, mr, fm, fmr, is) +
                 quadStep(f, mr, mrr, fmr, fmrr, is) +
                 quadStep(f, mrr, b, fmrr, fb, is);
          end if;
        end quadStep;

      algorithm
        /*
        Numerically evaluate integral using adaptive
        Lobatto rule.
        see Walter Gander: Adaptive Quadrature - Revisited, 1998
                        ftp.inf.ethz.ch in pub/publications/tech-reports/3xx/306.ps

        x[:] are the nodes
        y[:] = f(x[:]) are function values at the nodes
        */
        tol := tolerance;
        m := (a + b)/2;
        h := (b - a)/2;
        alpha := sqrt(2/3);
        beta := 1/sqrt(5);
        x := {a,
              m - x1*h,
              m - alpha*h,
              m - x2*h,
              m - beta*h,
              m - x3*h,
              m,
              m + x3*h,
              m + beta*h,
              m + x2*h,
              m + alpha*h,
              m + x1*h,
              b};
        for i in 1:size(x,1) loop
          y[i] := f(x[i]);
        end for;
        fa := y[1];
        fb := y[13];
        i2 := (h/6)*(y[1] + y[13] + 5*(y[5] + y[9]));
        i1 := (h/1470)*(77*(y[1] + y[13]) + 432*(y[3] + y[11]) + 625*(y[5] + y[9])
           + 672*y[7]);
        is := h*(0.0158271919734802*(y[1] + y[13]) +0.0942738402188500 *(y[2] + y[
          12]) +0.155071987336585 *(y[3] + y[11]) +0.188821573960182 *(y[4] + y[10])
           +0.199773405226859 *(y[5] + y[9]) +0.224926465333340 *(y[6] + y[8]) +0.242611071901408
                          *y[7]);
        s := sign(is);
        if (s == 0) then
          s := 1;
        end if;
        erri1 := abs(i1 - is);
        erri2 := abs(i2 - is);
        R := 1;
        if (erri2 <> 0) then
          R := erri1/erri2;
        end if;
        if (R > 0 and R < 1) then
          tol := tol/R;
        end if;
        is := s*abs(is)*tol/eps;
        if (is == 0) then
          is := b - a;
        end if;
        integral := quadStep(
              f,
              a,
              b,
              fa,
              fb,
              is);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>quadratureLobatto</strong>(function f(), a, b);
<strong>quadratureLobatto</strong>(function f(), a, b, tolerance=100*Modelica.Constants.eps);
</pre></blockquote>

<h4>Description</h4>

<p>
Compute definite integral over function f(u,...) from u=a up to u=b
using the adaptive Lobatto rule according to:
</p>

<blockquote>
<dl>
<dt>Walter Gander:</dt>
<dd> <strong>Adaptive Quadrature - Revisited</strong>. 1998.
     <a href=\"ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/3xx/306.ps\">ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/3xx/306.ps</a>
     </dd>
</dl>
</blockquote>

<h4>Example</h4>

<p>
See the examples in <a href=\"modelica://Modelica.Math.Nonlinear.Examples\">Modelica.Math.Nonlinear.Examples</a>.
</p>

</html>"));
      end quadratureLobatto;
      annotation (Documentation(info="<html>
<p>
This package contains functions to perform tasks such as numerically integrating
a function, or solving a nonlinear algebraic equation system.
The common feature of the functions in this package is
that the nonlinear characteristics are passed as user definable
functions.
</p>

<p>
For details about how to define and to use functions as input arguments
to functions, see
<a href=\"modelica://ModelicaReference.Classes.'function'\">ModelicaReference.Classes.'function'</a>
or the Modelica Language  Specification, Chapter 12.4.2.
</p>

</html>",     revisions="<html>
<ul>
<li><em>July 2010 </em> by Martin Otter (DLR-RM):<br>
    Included in MSL3.2, adapted, and documentation improved</li>

<li><em>March 2010 </em> by Andreas Pfeiffer (DLR-RM):<br>
    Adapted the quadrature function from Gerhard Schillhuber and
    the solution of one non-linear equation in one unknown from
    Modelica.Media.Common.OneNonLinearEquation so that
    function objects are used.</li>

<li><em>June 2002 </em> by Gerhard Schillhuber (master thesis at DLR-RM):<br>
       Adaptive quadrature to compute the curve length of a Spline.</li>
</ul>
</html>"),     Icon(graphics={Polygon(points={{-44,-52},{-44,-26},{-17.1,
                  44.4},{-11.4,52.6},{-5.8,57.1},{-0.2,57.8},{5.4,54.6},{11.1,47.7},
                  {16.7,37.4},{23.1,22.1},{31.17,-0.8},{48,-52},{-44,-52}},
              lineColor={135,135,135},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid)}));
    end Nonlinear;

    package Special "Library of special mathematical functions"
      extends Modelica.Icons.Package;

      function erf "Error function erf(u) = 2/sqrt(pi)*Integral_0_u exp(-t^2)*d"
        extends Modelica.Icons.Function;
        input Real u "Input argument";
        output Real y "= 2/sqrt(pi)*Integral_0_u exp(-t^2)*dt";
    protected
         Boolean inv;
         Real z;
         Real zz;
         constant Real y1 = 1.044948577880859375;
         constant Real P[5] = {0.0834305892146531832907,
                               -0.338165134459360935041,
                               -0.0509990735146777432841,
                               -0.00772758345802133288487,
                               -0.000322780120964605683831};
         constant Real Q[5] = {1,
                               0.455004033050794024546,
                               0.0875222600142252549554,
                               0.00858571925074406212772,
                               0.000370900071787748000569};
      algorithm
         if u >= 0 then
            z :=u;
            inv :=false;
         else
            z :=-u;
            inv :=true;
         end if;

         if z < 0.5 then
            if z <= 0 then
               y := 0;
            elseif z < 1.0e-10 then
               y := z*1.125 + z*0.003379167095512573896158903121545171688;
            else
               // Maximum Deviation Found:                     1.561e-17
               // Expected Error Term:                         1.561e-17
               // Maximum Relative Change in Control Points:   1.155e-04
               // Max Error found at double precision =        2.961182e-17
               zz := z*z;
               y := z*(y1 + Internal.polyEval(P, zz)/Internal.polyEval(Q, zz));
            end if;

         elseif z < 5.8 then
            y :=1 - Internal.erfcUtil(z);

         else
            y :=1;
         end if;

         if inv then
            y :=-y;
         end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Special.<strong>erf</strong>(u);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the error function erf(u) = 2/sqrt(pi)*Integral_0_u exp(-t^2)*dt numerically with a relative precision of about 1e-15. The implementation utilizes the formulation of the Boost library
(53-bit implementation of <a href=\"http://www.boost.org/doc/libs/1_57_0/boost/math/special_functions/erf.hpp\">erf.hpp</a>,
developed by John Maddock). Plot
of the function:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Math/Special/erf.png\">
</blockquote>

<p>
For more details, see <a href=\"http://en.wikipedia.org/wiki/Error_function\">Wikipedia</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  erf(0)    // = 0
  erf(10)   // = 1
  erf(0.5)  // = 0.520499877813047
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Special.erfc\">erfc</a>,
<a href=\"modelica://Modelica.Math.Special.erfInv\">erfInv</a>,
<a href=\"modelica://Modelica.Math.Special.erfcInv\">erfcInv</a>.
</p>
</html>",       revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
      end erf;

      package Internal
      "Internal utility functions that should not be directly utilized by the user"
         extends Modelica.Icons.InternalPackage;

        function polyEval "Evaluate a polynomial c[1] + c[2]*u + c[3]*u^2 + ...."
          extends Modelica.Icons.Function;
          input Real  c[:] "Polynomial coefficients";
          input Real  u "Abscissa value";
          output Real y "= c[1] + u*(c[2] + u*(c[3] + u*(c[4]*u^3 + ...)))";
        algorithm
          y := c[size(c,1)];
          for j in size(c, 1)-1:-1:1 loop
             y := c[j] + u*y;
          end for;
         annotation (Documentation(info="<html>
<p>
Evaluate a polynomial using Horner's scheme.
</p>
</html>",      revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
        end polyEval;

        function erfcUtil "Evaluate erfc(z) for 0.5 <= z "
          extends Modelica.Icons.Function;
          input Real z "Input argument 0.5 <= z required (but not checked)";
          output Real y "Result erfc(z) for 0.5 <= z";
      protected
           constant Real y1 = 0.405935764312744140625;
           constant Real P1[6] = {-0.098090592216281240205,
                                   0.178114665841120341155,
                                   0.191003695796775433986,
                                   0.0888900368967884466578,
                                   0.0195049001251218801359,
                                   0.00180424538297014223957};
           constant Real Q1[7] = {1,
                                  1.84759070983002217845,
                                  1.42628004845511324508,
                                  0.578052804889902404909,
                                  0.12385097467900864233,
                                  0.0113385233577001411017,
                                  0.337511472483094676155e-5};

           constant Real y2 = 0.50672817230224609375;
           constant Real P2[6] = {-0.0243500476207698441272,
                                   0.0386540375035707201728,
                                   0.04394818964209516296,
                                   0.0175679436311802092299,
                                   0.00323962406290842133584,
                                   0.000235839115596880717416};
           constant Real Q2[6] = {1,
                                  1.53991494948552447182,
                                  0.982403709157920235114,
                                  0.325732924782444448493,
                                  0.0563921837420478160373,
                                  0.00410369723978904575884};

           constant Real y3 = 0.5405750274658203125;
           constant Real P3[6] = {0.00295276716530971662634,
                                  0.0137384425896355332126,
                                  0.00840807615555585383007,
                                  0.00212825620914618649141,
                                  0.000250269961544794627958,
                                  0.113212406648847561139e-4};
           constant Real Q3[6] = {1,
                                  1.04217814166938418171,
                                  0.442597659481563127003,
                                  0.0958492726301061423444,
                                  0.0105982906484876531489,
                                  0.000479411269521714493907};

           constant Real y4 = 0.5579090118408203125;
           constant Real P4[7] = {0.00628057170626964891937,
                                  0.0175389834052493308818,
                                 -0.212652252872804219852,
                                 -0.687717681153649930619,
                                 -2.5518551727311523996,
                                 -3.22729451764143718517,
                                 -2.8175401114513378771};
           constant Real Q4[7] = {1,
                                  2.79257750980575282228,
                                 11.0567237927800161565,
                                 15.930646027911794143,
                                 22.9367376522880577224,
                                 13.5064170191802889145,
                                  5.48409182238641741584};

        algorithm
           if z < 1.5 then
              // Maximum Deviation Found:                     3.702e-17
              // Expected Error Term:                         3.702e-17
              // Maximum Relative Change in Control Points:   2.845e-04
              // Max Error found at double precision =        4.841816e-17
              y :=y1 + polyEval(P1, z - 0.5)/polyEval(Q1, z - 0.5);

           elseif z < 2.5 then
              // Max Error found at double precision =        6.599585e-18
              // Maximum Deviation Found:                     3.909e-18
              // Expected Error Term:                         3.909e-18
              // Maximum Relative Change in Control Points:   9.886e-05
              y :=y2 + polyEval(P2, z - 1.5)/polyEval(Q2, z - 1.5);

           elseif z < 4.5 then
              // Maximum Deviation Found:                     1.512e-17
              // Expected Error Term:                         1.512e-17
              // Maximum Relative Change in Control Points:   2.222e-04
              // Max Error found at double precision =        2.062515e-17
              y :=y3 + polyEval(P3, z - 3.5)/polyEval(Q3, z - 3.5);

           else
              // Max Error found at double precision =        2.997958e-17
              // Maximum Deviation Found:                     2.860e-17
              // Expected Error Term:                         2.859e-17
              // Maximum Relative Change in Control Points:   1.357e-05
              y :=y4 + polyEval(P4, 1/z)/polyEval(Q4, 1/z);
           end if;

           y := y*(exp(-z * z) / z);
         annotation (Documentation(info="<html>
<p>
Utility function in order to compute part of erf(..) and erfc(..).
</p>
</html>",      revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
        end erfcUtil;
        annotation (Documentation(info="<html>
<p>
This package contains internal utility functions for the computation of
erf, erfc, erfInc and erfcInv. These functions should not be directly used
by the user.
</p>
</html>",       revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
      end Internal;
    annotation (Icon(graphics={Line(
          points={{-80,-80},{-20,-80},{20,80},{80,80}},
          smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This sublibrary contains functions to compute often used mathematical operators that
cannot be expressed analytically.
</p>
</html>",     revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
    end Special;

  package Icons "Icons for Math"
    extends Modelica.Icons.IconsPackage;

    partial function AxisLeft
      "Basic icon for mathematical function with y-axis on left side"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
            Polygon(
              points={{-80,90},{-88,68},{-72,68},{-80,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              lineColor={0,0,255})}),
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                100,100}}), graphics={Line(points={{-80,80},{-88,80}}, color={95,95,95}),
              Line(points={{-80,-80},{-88,-80}}, color={95,95,95}),Line(
              points={{-80,-90},{-80,84}}, color={95,95,95}),Text(
                  extent={{-75,104},{-55,84}},
                  lineColor={95,95,95},
                  textString="y"),Polygon(
                  points={{-80,98},{-86,82},{-74,82},{-80,98}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis on the left side.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisLeft;

    partial function AxisCenter
      "Basic icon for mathematical function with y-axis in the center"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-80},{0,68}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              lineColor={0,0,255})}),
        Diagram(graphics={Line(points={{0,80},{-8,80}}, color={95,95,95}),Line(
              points={{0,-80},{-8,-80}}, color={95,95,95}),Line(points={{0,-90},{
              0,84}}, color={95,95,95}),Text(
                  extent={{5,104},{25,84}},
                  lineColor={95,95,95},
                  textString="y"),Polygon(
                  points={{0,98},{-6,82},{6,82},{0,98}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis in the middle.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisCenter;
  end Icons;

  function sin "Sine"
    extends Modelica.Math.Icons.AxisLeft;
    input Modelica.SIunits.Angle u;
    output Real y;

  external "builtin" y = sin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
                {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},
                {-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},
                {29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{
                57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}),
          Text(
            extent={{12,84},{84,36}},
            lineColor={192,192,192},
            textString="sin")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{100,0},{84,6},{84,-6},{100,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
              {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},{-14.9,
              44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},{29.3,-73.1},
              {35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{57.5,-61.9},{63.9,
              -47.2},{72,-24.8},{80,0}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-105,72},{-85,88}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{70,25},{90,5}},
              textString="2*pi",
              lineColor={0,0,255}),Text(
              extent={{-103,-72},{-83,-88}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{82,-6},{102,-26}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-80,80},{-28,80}},
              color={175,175,175}),Line(
              points={{-80,-80},{50,-80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = sin(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/sin.png\">
</p>
</html>"));
  end sin;

  function cos "Cosine"
    extends Modelica.Math.Icons.AxisLeft;
    input SI.Angle u;
    output Real y;

  external "builtin" y = cos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
                {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
                {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},
                {24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,
                73.4},{75.2,78.6},{80,80}}),
          Text(
            extent={{-36,82},{36,34}},
            lineColor={192,192,192},
            textString="cos")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-103,72},{-83,88}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{-103,-72},{-83,-88}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{70,25},{90,5}},
              textString="2*pi",
              lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
              {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
              {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},{
              24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,
              73.4},{75.2,78.6},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{78,-6},{98,-26}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-80,-80},{18,-80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = cos(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cos.png\">
</p>
</html>"));
  end cos;

  function tan "Tangent (u shall not be -pi/2, pi/2, 3*pi/2, ...)"
    extends Modelica.Math.Icons.AxisCenter;
    input SI.Angle u;
    output Real y;

  external "builtin" y = tan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
                {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
                {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
                47.4},{76,56.1},{77.6,63.8},{80,80}}),
          Text(
            extent={{-90,72},{-18,24}},
            lineColor={192,192,192},
            textString="tan")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-37,-72},{-17,-88}},
              textString="-5.8",
              lineColor={0,0,255}),Text(
              extent={{-33,86},{-13,70}},
              textString=" 5.8",
              lineColor={0,0,255}),Text(
              extent={{68,-13},{88,-33}},
              textString="1.4",
              lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
              {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
              {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
              47.4},{76,56.1},{77.6,63.8},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{82,22},{102,2}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{86,80}},
              color={175,175,175}),Line(
              points={{80,88},{80,-16}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = tan(u), with -&infin; &lt; u &lt; &infin;
(if u is a multiple of (2n-1)*pi/2, y = tan(u) is +/- infinity).
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tan.png\">
</p>
</html>"));
  end tan;

  function asin "Inverse sine (-1 <= u <= 1)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output SI.Angle y;

  external "builtin" y = asin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,
                -49.8},{-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,
                52.7},{75.2,62.2},{77.6,67.5},{80,80}}),
          Text(
            extent={{-88,78},{-16,30}},
            lineColor={192,192,192},
            textString="asin")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-40,-72},{-15,-88}},
              textString="-pi/2",
              lineColor={0,0,255}),Text(
              extent={{-38,88},{-13,72}},
              textString=" pi/2",
              lineColor={0,0,255}),Text(
              extent={{68,-9},{88,-29}},
              textString="+1",
              lineColor={0,0,255}),Text(
              extent={{-90,21},{-70,1}},
              textString="-1",
              lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,
              -49.8},{-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,
              52.7},{75.2,62.2},{77.6,67.5},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{82,24},{102,4}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{86,80}},
              color={175,175,175}),Line(
              points={{80,86},{80,-10}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = asin(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/asin.png\">
</p>
</html>"));
  end asin;

  function acos "Inverse cosine (-1 <= u <= 1)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output SI.Angle y;

  external "builtin" y = acos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-80},{68,-80}}, color={192,192,192}),
          Polygon(
            points={{90,-80},{68,-72},{68,-88},{90,-80}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-79.2,72.8},{-77.6,67.5},{-73.6,59.4},{-66.3,
                49.8},{-53.5,37.3},{-30.2,19.7},{37.4,-24.8},{57.5,-40.8},{68.7,-52.7},
                {75.2,-62.2},{77.6,-67.5},{80,-80}}),
          Text(
            extent={{-86,-14},{-14,-62}},
            lineColor={192,192,192},
            textString="acos")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,-80},{84,-80}}, color={95,95,95}),
            Polygon(
              points={{98,-80},{82,-74},{82,-86},{98,-80}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,80},{-79.2,72.8},{-77.6,67.5},{-73.6,59.4},{-66.3,49.8},
              {-53.5,37.3},{-30.2,19.7},{37.4,-24.8},{57.5,-40.8},{68.7,-52.7},{
              75.2,-62.2},{77.6,-67.5},{80,-80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-30,88},{-5,72}},
              textString=" pi",
              lineColor={0,0,255}),Text(
              extent={{-94,-57},{-74,-77}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{60,-81},{80,-101}},
              textString="+1",
              lineColor={0,0,255}),Text(
              extent={{82,-56},{102,-76}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-2,80},{84,80}},
              color={175,175,175}),Line(
              points={{80,82},{80,-86}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = acos(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/acos.png\">
</p>
</html>"));
  end acos;

  function atan "Inverse tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output SI.Angle y;

  external "builtin" y = atan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},
                {-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,21},
                {9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,
                73.6},{69.5,78.6},{80,80}}),
          Text(
            extent={{-86,68},{-14,20}},
            lineColor={192,192,192},
            textString="atan")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{96,0},{80,6},{80,-6},{96,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},
              {-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,21},{
              9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,73.6},
              {65,77},{80,78}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-34,87},{-14,74}},
              textString="pi/2",
              lineColor={0,0,255}),Text(
              extent={{-32,-71},{-12,-91}},
              textString="-pi/2",
              lineColor={0,0,255}),Text(
              extent={{84,-4},{104,-24}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-2,80},{84,80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = atan(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/atan.png\">
</p>
</html>"));
  end atan;

  function atan2 "Four quadrant inverse tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u1;
    input Real u2;
    output SI.Angle y;

  external "builtin" y = atan2(u1, u2);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{0,-80},{8.93,-67.2},{17.1,-59.3},{27.3,-53.6},{42.1,-49.4},
                {69.9,-45.8},{80,-45.1}}),
          Line(points={{-80,-34.9},{-46.1,-31.4},{-29.4,-27.1},{-18.3,-21.5},{-10.3,
                -14.5},{-2.03,-3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{
                62.1,33.5},{80,34.9}}),
          Line(points={{-80,45.1},{-45.9,48.7},{-29.1,52.9},{-18.1,58.6},{-10.2,
                65.8},{-1.82,77.2},{0,80}}),
          Text(
            extent={{-90,-46},{-18,-94}},
            lineColor={192,192,192},
            textString="atan2")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{96,0},{80,6},{80,-6},{96,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{0,-80},{8.93,-67.2},{17.1,-59.3},{27.3,-53.6},{42.1,-49.4},
              {69.9,-45.8},{80,-45.1}},
              color={0,0,255},
              thickness=0.5),Line(
              points={{-80,-34.9},{-46.1,-31.4},{-29.4,-27.1},{-18.3,-21.5},{-10.3,
              -14.5},{-2.03,-3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{
              62.1,33.5},{80,34.9}},
              color={0,0,255},
              thickness=0.5),Line(
              points={{-80,45.1},{-45.9,48.7},{-29.1,52.9},{-18.1,58.6},{-10.2,
              65.8},{-1.82,77.2},{0,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-32,89},{-10,74}},
              textString="pi",
              lineColor={0,0,255}),Text(
              extent={{-32,-72},{-4,-88}},
              textString="-pi",
              lineColor={0,0,255}),Text(
              extent={{0,55},{20,42}},
              textString="pi/2",
              lineColor={0,0,255}),Line(points={{0,40},{-8,40}}, color={192,192,192}),
            Line(points={{0,-40},{-8,-40}}, color={192,192,192}),Text(
              extent={{0,-23},{20,-42}},
              textString="-pi/2",
              lineColor={0,0,255}),Text(
              extent={{62,-4},{94,-26}},
              lineColor={95,95,95},
              textString="u1, u2"),Line(
              points={{-88,40},{86,40}},
              color={175,175,175}),Line(
              points={{-86,-40},{86,-40}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = atan2(u1,u2) such that tan(y) = u1/u2 and
y is in the range -pi &lt; y &le; pi. u2 may be zero, provided
u1 is not zero. Usually u1, u2 is provided in such a form that
u1 = sin(y) and u2 = cos(y):
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/atan2.png\">
</p>

</html>"));
  end atan2;

  function cosh "Hyperbolic cosine"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  external "builtin" y = cosh(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-86.083},{68,-86.083}}, color={192,192,192}),
          Polygon(
            points={{90,-86.083},{68,-78.083},{68,-94.083},{90,-86.083}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-77.6,61.1},{-74.4,39.3},{-71.2,20.7},{-67.1,
                1.29},{-63.1,-14.6},{-58.3,-29.8},{-52.7,-43.5},{-46.2,-55.1},{-39,
                -64.3},{-30.2,-71.7},{-18.9,-77.1},{-4.42,-79.9},{10.9,-79.1},{
                23.7,-75.2},{34.2,-68.7},{42.2,-60.6},{48.6,-51.2},{54.3,-40},{
                59.1,-27.5},{63.1,-14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{
                77.6,61.1},{80,80}}),
          Text(
            extent={{4,66},{66,20}},
            lineColor={192,192,192},
            textString="cosh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,-84.083},{84,-84.083}}, color=
             {95,95,95}),Polygon(
              points={{98,-84.083},{82,-78.083},{82,-90.083},{98,-84.083}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,80},{-77.6,61.1},{-74.4,39.3},{-71.2,20.7},{-67.1,1.29},
              {-63.1,-14.6},{-58.3,-29.8},{-52.7,-43.5},{-46.2,-55.1},{-39,-64.3},
              {-30.2,-71.7},{-18.9,-77.1},{-4.42,-79.9},{10.9,-79.1},{23.7,-75.2},
              {34.2,-68.7},{42.2,-60.6},{48.6,-51.2},{54.3,-40},{59.1,-27.5},{
              63.1,-14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{77.6,61.1},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-31,72},{-11,88}},
              textString="27",
              lineColor={0,0,255}),Text(
              extent={{64,-83},{84,-103}},
              textString="4",
              lineColor={0,0,255}),Text(
              extent={{-94,-63},{-74,-83}},
              textString="-4",
              lineColor={0,0,255}),Text(
              extent={{80,-60},{100,-80}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175}),Line(
              points={{80,84},{80,-90}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = cosh(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cosh.png\">
</p>
</html>"));
  end cosh;

  function tanh "Hyperbolic tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  external "builtin" y = tanh(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-47.8,-78.7},{-35.8,-75.7},{-27.7,-70.6},{-22.1,
                -64.2},{-17.3,-55.9},{-12.5,-44.3},{-7.64,-29.2},{-1.21,-4.82},{
                6.83,26.3},{11.7,42},{16.5,54.2},{21.3,63.1},{26.9,69.9},{34.2,75},
                {45.4,78.4},{72,79.9},{80,80}}),
          Text(
            extent={{-88,72},{-16,24}},
            lineColor={192,192,192},
            textString="tanh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{96,0},{80,6},{80,-6},{96,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80.5},{-47.8,-79.2},{-35.8,-76.2},{-27.7,-71.1},{-22.1,
              -64.7},{-17.3,-56.4},{-12.5,-44.8},{-7.64,-29.7},{-1.21,-5.32},{
              6.83,25.8},{11.7,41.5},{16.5,53.7},{21.3,62.6},{26.9,69.4},{34.2,
              74.5},{45.4,77.9},{72,79.4},{80,79.5}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-29,72},{-9,88}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{3,-72},{23,-88}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{82,-2},{102,-22}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = tanh(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tanh.png\">
</p>
</html>"));
  end tanh;

  function asinh "Inverse of sinh (area hyperbolic sine)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  algorithm
    y := Modelica.Math.log(u + sqrt(u*u + 1));
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-56.7,-68.4},{-39.8,-56.8},{-26.9,-44.7},{-17.3,
                -32.4},{-9.25,-19},{9.25,19},{17.3,32.4},{26.9,44.7},{39.8,56.8},
                {56.7,68.4},{80,80}}),
          Text(
            extent={{-90,80},{-6,26}},
            lineColor={192,192,192},
            textString="asinh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-56.7,-68.4},{-39.8,-56.8},{-26.9,-44.7},{-17.3,
              -32.4},{-9.25,-19},{9.25,19},{17.3,32.4},{26.9,44.7},{39.8,56.8},{
              56.7,68.4},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-31,72},{-11,88}},
              textString="2.31",
              lineColor={0,0,255}),Text(
              extent={{-35,-88},{-15,-72}},
              textString="-2.31",
              lineColor={0,0,255}),Text(
              extent={{72,-13},{92,-33}},
              textString="5",
              lineColor={0,0,255}),Text(
              extent={{-96,21},{-76,1}},
              textString="-5",
              lineColor={0,0,255}),Text(
              extent={{80,22},{100,2}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175}),Line(
              points={{80,86},{80,-12}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
The function returns the area hyperbolic sine of its
input argument u. This inverse of sinh(..) is unique
and there is no restriction on the input argument u of
asinh(u) (-&infin; &lt; u &lt; &infin;):
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/asinh.png\">
</p>
</html>"));
  end asinh;

  function exp "Exponential, base e"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  external "builtin" y = exp(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-80.3976},{68,-80.3976}}, color={192,192,192}),
          Polygon(
            points={{90,-80.3976},{68,-72.3976},{68,-88.3976},{90,-80.3976}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},
                {34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{
                67.1,18.6},{72,38.2},{76,57.6},{80,80}}),
          Text(
            extent={{-86,50},{-14,2}},
            lineColor={192,192,192},
            textString="exp")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,-80.3976},{84,-80.3976}},
            color={95,95,95}),Polygon(
              points={{98,-80.3976},{82,-74.3976},{82,-86.3976},{98,-80.3976}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},{
              34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{67.1,
              18.6},{72,38.2},{76,57.6},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-31,72},{-11,88}},
              textString="20",
              lineColor={0,0,255}),Text(
              extent={{-92,-81},{-72,-101}},
              textString="-3",
              lineColor={0,0,255}),Text(
              extent={{66,-81},{86,-101}},
              textString="3",
              lineColor={0,0,255}),Text(
              extent={{2,-69},{22,-89}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{78,-54},{98,-74}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175}),Line(
              points={{80,84},{80,-84}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = exp(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/exp.png\">
</p>
</html>"));
  end exp;

  function log "Natural (base e) logarithm (u shall be > 0)"
    extends Modelica.Math.Icons.AxisLeft;
    input Real u;
    output Real y;

  external "builtin" y = log(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
          Text(
            extent={{-6,-24},{66,-72}},
            lineColor={192,192,192},
            textString="log")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{100,0},{84,6},{84,-6},{100,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-78,-80},{-77.2,-50.6},{-76.4,-37},{-75.6,-28},{-74.8,-21.3},
              {-73.2,-11.4},{-70.8,-1.31},{-67.5,8.08},{-62.7,17.9},{-55.5,28},{-45,
              38.1},{-29.8,48.1},{-8.1,58},{24.1,68},{70.7,78.1},{82,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-105,72},{-85,88}},
              textString="3",
              lineColor={0,0,255}),Text(
              extent={{60,-3},{80,-23}},
              textString="20",
              lineColor={0,0,255}),Text(
              extent={{-78,-7},{-58,-27}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{84,26},{104,6}},
              lineColor={95,95,95},
              textString="u"),Text(
              extent={{-100,9},{-80,-11}},
              textString="0",
              lineColor={0,0,255}),Line(
              points={{-80,80},{84,80}},
              color={175,175,175}),Line(
              points={{82,82},{82,-6}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = log(10) (the natural logarithm of u),
with u &gt; 0:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/log.png\">
</p>
</html>"));
  end log;

  function log10 "Base 10 logarithm (u shall be > 0)"
    extends Modelica.Math.Icons.AxisLeft;
    input Real u;
    output Real y;

  external "builtin" y = log10(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-79.8,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
          Text(
            extent={{-30,-22},{60,-70}},
            lineColor={192,192,192},
            textString="log10")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-77.8,-80},{-77.2,-50.6},{-76.4,-37},{-75.6,-28},{-74.8,-21.3},
              {-73.2,-11.4},{-70.8,-1.31},{-67.5,8.08},{-62.7,17.9},{-55.5,28},{-45,
              38.1},{-29.8,48.1},{-8.1,58},{24.1,68},{70.7,78.1},{82,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{66,-13},{86,-33}},
              textString="20",
              lineColor={0,0,255}),Text(
              extent={{-78,-1},{-58,-21}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{-83,62},{-63,78}},
              textString=" 1.3",
              lineColor={0,0,255}),Text(
              extent={{80,24},{100,4}},
              lineColor={95,95,95},
              textString="u"),Text(
              extent={{-100,9},{-80,-11}},
              textString="0",
              lineColor={0,0,255}),Line(
              points={{-80,80},{86,80}},
              color={175,175,175}),Line(
              points={{80,92},{80,-12}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = log10(u),
with u &gt; 0:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/log10.png\">
</p>
</html>"));
  end log10;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
            {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
              {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
              -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
              -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
              {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
              0,0,0}, smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This package contains <strong>basic mathematical functions</strong> (such as sin(..)),
as well as functions operating on
<a href=\"modelica://Modelica.Math.Vectors\">vectors</a>,
<a href=\"modelica://Modelica.Math.Matrices\">matrices</a>,
<a href=\"modelica://Modelica.Math.Nonlinear\">nonlinear functions</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors\">Boolean vectors</a>.
</p>

<h4>Main Authors</h4>
<p><a href=\"http://www.robotic.dlr.de/Martin.Otter/\"><strong>Martin Otter</strong></a>
and <strong>Marcus Baur</strong><br>
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e.V. (DLR)<br>
Institut f&uuml;r Systemdynamik und Regelungstechnik (DLR-SR)<br>
Forschungszentrum Oberpfaffenhofen<br>
D-82234 Wessling<br>
Germany<br>
email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a>
</p>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>August 24, 2016</em>
       by Christian Kral: added wrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Function tempInterpol2 added.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Icons for icon and diagram level introduced.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>

</html>"));
  end Math;

  package ComplexMath
  "Library of complex mathematical functions (e.g., sin, cos) and of functions operating on complex vectors and matrices"
    extends Modelica.Icons.Package;

    function 'abs' "Absolute value of complex number"
      extends Modelica.Icons.Function;
      input Complex c "Complex number";
      output Real result "= abs(c)";
    algorithm
      result := (c.re^2 + c.im^2)^0.5; //changed from sqrt
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the Real absolute of the Complex input, i.e., its length.</p>
</html>"));
    end 'abs';

    function conj "Conjugate of complex number"
      extends Modelica.Icons.Function;
      input Complex c1 "Complex number";
      output Complex c2 "= c1.re - j*c1.im";
    algorithm
      c2 := Complex(c1.re, -c1.im);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the Complex conjugate of the Complex input.</p>
</html>"));
    end conj;

    function real "Real part of complex number"
      extends Modelica.Icons.Function;
      input Complex c "Complex number";
      output Real r "= c.re";
    algorithm
      r := c.re;
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the real part of the Complex input.</p>
</html>"));
    end real;

    function imag "Imaginary part of complex number"
      extends Modelica.Icons.Function;
      input Complex c "Complex number";
      output Real r "= c.im";
    algorithm
      r := c.im;
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the imaginary part of the Complex input.</p>
</html>"));
    end imag;
    annotation (Documentation(info="<html>
<p>
This package contains <strong>basic mathematical functions</strong>
operating on complex numbers (such as sin(..)),
as well as functions operating on vectors of complex numbers.
</p>

</html>"),   Icon(coordinateSystem(extent={{-100,-100},{100,100}},
            preserveAspectRatio=false), graphics={
          Line(points={{32,-86},{32,88}}, color={175,175,175}),
          Line(points={{-84,2},{88,2}}, color={175,175,175}),
          Line(
            points={{-50,75},{-5,30}}),
          Line(
            points={{-50,30},{-5,75}}),
          Line(
            points={{-50,-30},{-5,-75}}),
          Line(
            points={{-50,-75},{-5,-30}})}));
  end ComplexMath;

  package Utilities
  "Library of utility functions dedicated to scripting (operating on files, streams, strings, system)"
    extends Modelica.Icons.UtilitiesPackage;

    package Files "Functions to work with files and directories"
      extends Modelica.Icons.FunctionsPackage;

    function createDirectory
        "Create directory (if directory already exists, ignore call)"
      extends Modelica.Icons.Function;
      input String directoryName
          "Name of directory to be created (if present, ignore call)";
    //..............................................................
    protected
      function existDirectory
          "Inquire whether directory exists; if present and not a directory, trigger an error"
         extends Modelica.Icons.Function;
         input String directoryName;
         output Boolean exists "true if directory exists";
      protected
         Types.FileType fileType = Modelica.Utilities.Internal.FileSystem.stat(
                                                 directoryName);
      algorithm
         if fileType == Types.FileType.RegularFile or
            fileType == Types.FileType.SpecialFile then
            Streams.error("Directory \"" + directoryName + "\" cannot be created\n" +
                          "because this is an existing file.");
         elseif fileType == Types.FileType.Directory then
            exists :=true;
         else
            exists :=false;
         end if;
         annotation(__ModelicaAssociation_Impure=true);
      end existDirectory;

      function assertCorrectIndex
          "Print error, if index to last essential character in directory is wrong"
         extends Modelica.Icons.Function;
         input Integer index "Index must be > 0";
         input String directoryName "Directory name for error message";
      algorithm
         if index < 1 then
            Streams.error("It is not possible to create the directory\n" +
                          "\"" + directoryName + "\"\n" +
                          "because this directory name is not valid");
         end if;
      end assertCorrectIndex;

    //..............................................................
      String fullName;
      Integer index;
      Integer oldIndex;
      Integer lastIndex;
      Boolean found;
      Boolean finished;
      Integer nDirectories = 0 "Number of directories that need to be generated";
    algorithm
      // Ignore call, if directory exists
      if not existDirectory(directoryName) then
         fullName := Files.fullPathName(directoryName);

         // Remove a trailing "/"
            index :=Strings.length(fullName);
            if Strings.substring(fullName,index,index) == "/" then
               index :=index - 1;
               assertCorrectIndex(index,fullName);
            end if;
            lastIndex := index;
            fullName := Strings.substring(fullName,1,index);

         // Search upper directories until a directory is found that exists
         // ??? check the following while loop later, if also cases such as
         //  "c:/", "c:", "//name" are handled correctly ???
            found := false;
            while not found loop
               oldIndex := index;
               index := Strings.findLast(fullName,"/",startIndex=index);
               if index == 0 then
                  index := oldIndex;
                  found := true;
               else
                  index := index - 1;
                  assertCorrectIndex(index, fullName);
                  found := existDirectory(Strings.substring(fullName,1,index));
               end if;
            end while;
            index := oldIndex;

         // Create directories
            finished := false;
            while not finished loop
               Modelica.Utilities.Internal.FileSystem.mkdir(
                              Strings.substring(fullName,1,index));
               if index >= lastIndex then
                  finished := true;
               elseif index < lastIndex then
                  index := Strings.find(fullName, "/", startIndex=index+2);
                  if index == 0 then
                     index :=lastIndex;
                  end if;
               end if;
            end while;
      end if;

      annotation (__ModelicaAssociation_Impure=true,
    Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Files.<strong>createDirectory</strong>(directoryName);
</pre></blockquote>
<h4>Description</h4>
<p>
Creates directory \"directoryName\". If this directory already exists,
the function call is ignored. If several directories in \"directoryName\"
do not exist, all of them are created. For example, assume
that directory \"E:/test1\" exists and that directory
\"E:/test1/test2/test3\" shall be created. In this case
the directories \"test2\" in \"test1\" and \"test3\" in \"test2\"
are created.
</p>
<p>
This function is silent, i.e., it does not print a message.
In case of error (e.g., \"directoryName\" is an existing regular
file), an assert is triggered.
</p>
</html>"));
    end createDirectory;

    function exist "Inquire whether file or directory exists"
      extends Modelica.Icons.Function;
      input String name "Name of file or directory";
      output Boolean result "= true, if file or directory exists";
    algorithm
      result := Modelica.Utilities.Internal.FileSystem.stat(
                              name) > Types.FileType.NoFile;

      annotation (__ModelicaAssociation_Impure=true,
    Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Files.<strong>exist</strong>(name);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns true, if \"name\" is an existing file or directory.
If this is not the case, the function returns false.
</p>
</html>"));
    end exist;

    function fullPathName "Get full path name of file or directory name"
      extends Modelica.Icons.Function;
      input String name "Absolute or relative file or directory name";
      output String fullName "Full path of 'name'";
    external "C" fullName = ModelicaInternal_fullPathName(name) annotation(Library="ModelicaExternalC");

      annotation (__ModelicaAssociation_Impure=true,
    Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
fullName = Files.<strong>fullPathName</strong>(name);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the full path name of a file or directory \"name\".
</p>
</html>"));
    end fullPathName;

      function loadResource
        "Return the absolute path name of a URI or local file name"
         extends
        Modelica.Utilities.Internal.PartialModelicaServices.ExternalReferences.PartialLoadResource;
         extends ModelicaServices.ExternalReferences.loadResource;
        annotation (
          Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
fileReference = Files.<strong>loadResource</strong>(uri);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Files.<strong>loadResource</strong>(uri)</code>\" returns the
<strong>absolute path name</strong> of the file that is either defined by an URI or by a local
path name. With the returned file name it is possible to
access the file with function calls of the C standard library.
If the data or file is stored in a data-base,
this might require copying the resource to a temporary folder and referencing that.
</p>

<p>
The implementation of this function is tool specific. However, at least Modelica URIs
(see \"chapter 13.2.3 External Resources\" of the Modelica Specification),
as well as absolute local file path names are supported.
</p>

<h4>Example</h4>
<blockquote><pre>
  file1 = loadResource(\"modelica://Modelica/Resources/Data/Utilities/Examples_readRealParameters.txt\")
          // file1 is the absolute path name of the file
  file2 = loadResource(\"C:\\\\data\\\\readParameters.txt\")
          file2 = \"C:/data/readParameters.txt\"
</pre></blockquote>
</html>"));
      end loadResource;
        annotation (
    Documentation(info="<html>
<p>
This package contains functions to work with files and directories.
As a general convention of this package, '/' is used as directory
separator both for input and output arguments of all functions.
For example:
</p>
<pre>
   exist(\"Modelica/Mechanics/Rotational.mo\");
</pre>
<p>
The functions provide the mapping to the directory separator of the
underlying operating system. Note, that on Windows system the usage
of '\\' as directory separator would be inconvenient, because this
character is also the escape character in Modelica and C Strings.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.list\">list</a>(name)</td>
      <td> List content of file or of directory.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.copy\">copy</a>(oldName, newName)<br>
          <a href=\"modelica://Modelica.Utilities.Files.copy\">copy</a>(oldName, newName, replace=false)</td>
      <td> Generate a copy of a file or of a directory.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.move\">move</a>(oldName, newName)<br>
          <a href=\"modelica://Modelica.Utilities.Files.move\">move</a>(oldName, newName, replace=false)</td>
      <td> Move a file or a directory to another place.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.remove\">remove</a>(name)</td>
      <td> Remove file or directory (ignore call, if it does not exist).</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.removeFile\">removeFile</a>(name)</td>
      <td> Remove file (ignore call, if it does not exist)</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.createDirectory\">createDirectory</a>(name)</td>
      <td> Create directory (if directory already exists, ignore call).</td>
  </tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Files.exist\">exist</a>(name)</td>
      <td> Inquire whether file or directory exists.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.assertNew\">assertNew</a>(name,message)</td>
      <td> Trigger an assert, if a file or directory exists.</td>
  </tr>
  <tr><td>fullName = <a href=\"modelica://Modelica.Utilities.Files.fullPathName\">fullPathName</a>(name)</td>
      <td> Get full path name of file or directory name.</td>
  </tr>
  <tr><td>(directory, name, extension) = <a href=\"modelica://Modelica.Utilities.Files.splitPathName\">splitPathName</a>(name)</td>
      <td> Split path name in directory, file name kernel, file name extension.</td>
  </tr>
  <tr><td>fileName = <a href=\"modelica://Modelica.Utilities.Files.temporaryFileName\">temporaryFileName</a>()</td>
      <td> Return arbitrary name of a file that does not exist<br>
           and is in a directory where access rights allow to<br>
           write to this file (useful for temporary output of files).</td>
  </tr>
  <tr><td>fileReference = <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>(uri)</td>
      <td>Return the absolute path name of a URI or local file name.</td>
  </tr>
</table>
</html>"));
    end Files;

    package Streams "Read from files and write to files"
      extends Modelica.Icons.FunctionsPackage;

      function print "Print string to terminal or file"
        extends Modelica.Icons.Function;
        input String string="" "String to be printed";
        input String fileName=""
          "File where to print (empty string is the terminal)"
                     annotation(Dialog(saveSelector(filter="Text files (*.txt)",
                            caption="Text file to store the output of print(..)")));
      external "C" ModelicaInternal_print(string, fileName) annotation(Library="ModelicaExternalC");

        annotation (__ModelicaAssociation_Impure=true, Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>print</strong>(string);
Streams.<strong>print</strong>(string,fileName);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>print</strong>(..) opens automatically the given file, if
it is not yet open. If the file does not exist, it is created.
If the file does exist, the given string is appended to the file.
If this is not desired, call \"Files.remove(fileName)\" before calling print
(\"remove(..)\" is silent, if the file does not exist).
The Modelica environment may close the file whenever appropriate.
This can be enforced by calling <strong>Streams.close</strong>(fileName).
After every call of \"print(..)\" a \"new line\" is printed automatically.
</p>
<h4>Example</h4>
<blockquote><pre>
  Streams.print(\"x = \" + String(x));
  Streams.print(\"y = \" + String(y));
  Streams.print(\"x = \" + String(y), \"mytestfile.txt\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.error\">Streams.error</a>,
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end print;

      function readLine "Read a line of text from a file and return it in a string"
        extends Modelica.Icons.Function;
        input String fileName "Name of the file that shall be read"
                            annotation(Dialog(loadSelector(filter="Text files (*.txt)",
                            caption="Open text file for reading")));
        input Integer lineNumber(min=1) "Number of line to read";
        output String string "Line of text";
        output Boolean endOfFile
          "If true, end-of-file was reached when trying to read line";
       external "C" string = ModelicaInternal_readLine(fileName,lineNumber,endOfFile) annotation(Library="ModelicaExternalC");
        annotation (__ModelicaAssociation_Impure=true, Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
(string, endOfFile) = Streams.<strong>readLine</strong>(fileName, lineNumber)
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>readLine</strong>(..) opens the given file, reads enough of the
content to get the requested line, and returns the line as a string.
Lines are separated by LF or CR-LF; the returned string does not
contain the line separator. The file might remain open after
the call.
</p>
<p>
If lineNumber > countLines(fileName), an empty string is returned
and endOfFile=true. Otherwise endOfFile=false.
</p>
</html>"));
      end readLine;

      function error "Print error message and cancel all actions - in case of an unrecoverable error"
        extends Modelica.Icons.Function;
        input String string "String to be printed to error message window";
        external "C" ModelicaError(string) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>error</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
In case of an unrecoverable error (i.e., if the solver is unable to recover from the error),
print the string \"string\" as error message and cancel all actions.
This function is semantically equivalent with the built-in function <strong>assert</strong> if called with the (default) <strong>AssertionLevel.error</strong>.
Line breaks are characterized by \"\\n\" in the string.
</p>
<h4>Example</h4>
<blockquote><pre>
  Streams.error(\"x (= \" + String(x) + \")\\nhas to be in the range 0 .. 1\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.print\">Streams.print</a>,
<a href=\"modelica://ModelicaReference.Operators.'assert()'\">ModelicaReference.Operators.'assert()'</a>
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end error;

      function readRealMatrix "Read Real matrix from MATLAB MAT file"
        extends Modelica.Icons.Function;
        input String fileName "File where external data is stored" annotation(Dialog(loadSelector(filter="MATLAB MAT files (*.mat)", caption="Open MATLAB MAT file")));
        input String matrixName "Name / identifier of the 2D Real array on the file";
        input Integer nrow "Number of rows of the 2D Real array";
        input Integer ncol "Number of columns of the 2D Real array";
        input Boolean verboseRead = true
          "= true: Print info message; = false: No info message";
        output Real matrix[nrow, ncol] "2D Real array";
        external "C" ModelicaIO_readRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), verboseRead)
        annotation(Library={"ModelicaIO", "ModelicaMatIO", "zlib"});
        annotation (Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
matrix = Streams.<strong>readRealMatrix</strong>(fileName, matrixName, nrow, ncol, verboseRead)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <strong>readRealMatrix</strong>(..) opens the given MATLAB MAT file
(in format v4, v6, v7, and if HDF is supported in the Modelica tool, also v7.3),
and reads the given matrix from this file. The dimensions of this matrix must first
be inquired with function
<a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>
and passed via arguments nrow and ncol to this function.
</p>

<h4>Example</h4>
<p>
See <a href=\"modelica://Modelica.Utilities.Examples.ReadRealMatrixFromFile\">Examples.ReadRealMatrixFromFile</a>.
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>,
<a href=\"modelica://Modelica.Utilities.Streams.writeRealMatrix\">writeRealMatrix</a>
</p>
</html>"));
      end readRealMatrix;

      function writeRealMatrix "Write Real matrix to a MATLAB MAT file"
        extends Modelica.Icons.Function;
        input String fileName "File where external data is to be stored" annotation(Dialog(saveSelector(filter="MATLAB MAT files (*.mat)", caption="Save MATLAB MAT file")));
        input String matrixName "Name / identifier of the 2D Real array on the file";
        input Real matrix[:,:] "2D Real array";
        input Boolean append = false "Append values to file";
        input String format = "4" "MATLAB MAT file version: \"4\" -> v4, \"6\" -> v6, \"7\" -> v7"
          annotation(choices(choice="4" "MATLAB v4 MAT file",
                             choice="6" "MATLAB v6 MAT file",
                             choice="7" "MATLAB v7 MAT file"));
        output Boolean success "true if successful";
        external "C" success = ModelicaIO_writeRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), append, format)
        annotation(Library={"ModelicaIO", "ModelicaMatIO", "zlib"});

        annotation(__ModelicaAssociation_Impure=true, Documentation(info=
                       "<html>

<h4>Syntax</h4>
<blockquote><pre>
success = Streams.<strong>writeRealMatrix</strong>(fileName, matrixName, matrix, append, format)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <strong>writeRealMatrix</strong>(..) writes the given matrix to a new or an existing MATLAB MAT file
(in format v4, v6, v7, and if HDF is supported in the Modelica tool, also v7.3).
If <code>append = false</code> (= default), the file is newly created
(or an existing file is deleted and re-created).
If <code>append = true</code>, the matrix is included in an existing file or if the
file does not yet exists this flag is ignored. If the file exists and
<code>append = true</code>, argument format is ignored.
</p>

<p>
Parameter <strong>format</strong> defines the format in which the values are stored on file.
The following formats are supported:<br>&nbsp;
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td>format = </td><td>Type of format</td></tr>
<tr><td>\"4\"  </td><td>MATLAB MAT version v4</td></tr>
<tr><td>\"6\"  </td><td>MATLAB MAT version v6</td></tr>
<tr><td>\"7\"  </td><td>MATLAB MAT version v7</td></tr>
<tr><td>\"7.3\"</td><td>MATLAB MAT version v7.3<br>
                      (requires HDF support in the Modelica tool)</td></tr>
</table>

<p>
The function returns <code>success = true</code> if the matrix was successfully written
to file. Otherwise, an error message is printed and the function returns with
<code>success = false</code>.
</p>

<h4>Example</h4>
<p>
See <a href=\"modelica://Modelica.Utilities.Examples.WriteRealMatrixToFile\">Examples.WriteRealMatrixToFile</a>.
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>,
<a href=\"modelica://Modelica.Utilities.Streams.readRealMatrix\">readRealMatrix</a>
</p>
</html>"));
      end writeRealMatrix;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Streams</strong> contains functions to input and output strings
to a message window or on files, as well as reading matrices from file
and writing matrices to file. Note that a string is interpreted
and displayed as html text (e.g., with print(..) or error(..))
if it is enclosed with the Modelica html quotation, e.g.,
</p>
<blockquote><p>
string = \"&lt;html&gt; first line &lt;br&gt; second line &lt;/html&gt;\".
</p></blockquote>
<p>
It is a quality of implementation, whether (a) all tags of html are supported
or only a subset, (b) how html tags are interpreted if the output device
does not allow to display formatted text.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string)<br>
          <a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string,fileName)</td>
      <td> Print string \"string\" or vector of strings to message window or on
           file \"fileName\".</td>
  </tr>
  <tr><td>stringVector =
         <a href=\"modelica://Modelica.Utilities.Streams.readFile\">readFile</a>(fileName)</td>
      <td> Read complete text file and return it as a vector of strings.</td>
  </tr>
  <tr><td>(string, endOfFile) =
         <a href=\"modelica://Modelica.Utilities.Streams.readLine\">readLine</a>(fileName, lineNumber)</td>
      <td>Returns from the file the content of line lineNumber.</td>
  </tr>
  <tr><td>lines =
         <a href=\"modelica://Modelica.Utilities.Streams.countLines\">countLines</a>(fileName)</td>
      <td>Returns the number of lines in a file.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.error\">error</a>(string)</td>
      <td> Print error message \"string\" to message window
           and cancel all actions</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.close\">close</a>(fileName)</td>
      <td> Close file if it is still open. Ignore call if
           file is already closed or does not exist. </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>(fileName, matrixName)</td>
      <td> Read dimensions of a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readRealMatrix\">readRealMatrix</a>(fileName, matrixName, nrow, ncol)</td>
      <td> Read a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.writeRealMatrix\">writeRealMatrix</a>(fileName, matrixName, matrix, append, format)</td>
      <td> Write Real matrix to a MATLAB MAT file. </td></tr>
</table>
<p>
Use functions <strong>scanXXX</strong> from package
<a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
to parse a string.
</p>
<p>
If Real, Integer or Boolean values shall be printed
or used in an error message, they have to be first converted
to strings with the builtin operator
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>(...).
Example:
</p>
<pre>
  <strong>if</strong> x &lt; 0 <strong>or</strong> x &gt; 1 <strong>then</strong>
     Streams.error(\"x (= \" + String(x) + \") has to be in the range 0 .. 1\");
  <strong>end if</strong>;
</pre>
</html>"));
    end Streams;

    package Strings "Operations on strings"
      extends Modelica.Icons.FunctionsPackage;

      function length "Return length of string"
        extends Modelica.Icons.Function;
        input String string;
        output Integer result "Number of characters of string";
      external "C" result = ModelicaStrings_length(string) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>length</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of characters of \"string\".
</p>
</html>"));
      end length;

      function substring "Return a substring defined by start and end index"

        extends Modelica.Icons.Function;
        input String string "String from which a substring is inquired";
        input Integer startIndex(min=1)
          "Character position of substring begin (index=1 is first character in string)";
        input Integer endIndex(min=1) "Character position of substring end";
        output String result
          "String containing substring string[startIndex:endIndex]";
      external "C" result=ModelicaStrings_substring(string,startIndex,endIndex) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<strong>substring</strong>(string, startIndex, endIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns
the substring from position startIndex
up to and including position endIndex of \"string\" .
</p>
<p>
If index, startIndex, or endIndex are not correct, e.g.,
if endIndex &gt; length(string), an assert is triggered.
</p>
<h4>Example</h4>
<blockquote><pre>
  string1 := \"This is line 111\";
  string2 := Strings.substring(string1,9,12); // string2 = \"line\"
</pre></blockquote>
</html>"));
      end substring;

      function compare "Compare two strings lexicographically"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true "= false, if case of letters is ignored";
        output Modelica.Utilities.Types.Compare result "Result of comparison";
      external "C" result = ModelicaStrings_compare(string1, string2, caseSensitive) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Strings.<strong>compare</strong>(string1, string2);
result = Strings.<strong>compare</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compares two strings. If the optional argument caseSensitive=false,
upper case letters are treated as if they would be lower case letters.
The result of the comparison is returned as:
</p>
<pre>
  result = Modelica.Utilities.Types.Compare.Less     // string1 &lt; string2
         = Modelica.Utilities.Types.Compare.Equal    // string1 = string2
         = Modelica.Utilities.Types.Compare.Greater  // string1 &gt; string2
</pre>
<p>
Comparison is with regards to lexicographical order,
e.g., \"a\" &lt; \"b\";
</p>
</html>"));
      end compare;

      function isEqual "Determine whether two strings are identical"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the comparison";
        output Boolean identical "True, if string1 is identical to string2";
      algorithm
        identical :=compare(string1, string2, caseSensitive) == Types.Compare.Equal;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>isEqual</strong>(string1, string2);
Strings.<strong>isEqual</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compare whether two strings are identical,
optionally ignoring case.
</p>
</html>"));
      end isEqual;

      function isEmpty
        "Return true if a string is empty (has only white space characters)"
        extends Modelica.Icons.Function;
        input String string;
        output Boolean result "True, if string is empty";
    protected
        Integer nextIndex;
        Integer len;
      algorithm
        nextIndex := Strings.Advanced.skipWhiteSpace(string);
        len := Strings.length(string);
        if len < 1 or nextIndex > len then
          result := true;
        else
          result := false;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>isEmpty</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns true if the string has no characters or if the string consists
only of white space characters. Otherwise, false is returned.
</p>

<h4>Example</h4>
<blockquote><pre>
  isEmpty(\"\");       // returns true
  isEmpty(\"   \");    // returns true
  isEmpty(\"  abc\");  // returns false
  isEmpty(\"a\");      // returns false
</pre></blockquote>
</html>"));
      end isEmpty;

      function find "Find first occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=1)=1 "Start search at index startIndex";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the search";
         output Integer index
          "Index of the beginning of the first occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lengthSearchString = length(searchString);
        Integer len = lengthSearchString-1;
        Integer i = startIndex;
        Integer i_max = length(string) - lengthSearchString + 1;
      algorithm
        index := 0;
        while i <= i_max loop
           if isEqual(substring(string,i,i+len),
                      searchString, caseSensitive) then
              index := i;
              i := i_max + 1;
           else
              i := i+1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<strong>find</strong>(string, searchString);
index = Strings.<strong>find</strong>(string, searchString, startIndex=1,
                     caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurrence of \"searchString\" within \"string\"
and return the corresponding index.
Start search at index \"startIndex\" (default = 1).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>"));
      end find;

      function findLast "Find last occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=0)=0
          "Start search at index startIndex. If startIndex = 0, start at length(string)";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the search";
        output Integer index
          "Index of the beginning of the last occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lenString = length(string);
        Integer lenSearchString = length(searchString);
        Integer iMax=lenString - lenSearchString + 1;
        Integer i;
      algorithm
        i := if startIndex == 0 or startIndex > iMax then iMax else startIndex;
        index := 0;
        while i >= 1 loop
           if isEqual(substring(string,i,i+lenSearchString-1),
                      searchString, caseSensitive) then
              index := i;
              i := 0;
           else
              i := i-1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<strong>findLast</strong>(string, searchString);
index = Strings.<strong>findLast</strong>(string, searchString,
                         startIndex=length(string), caseSensitive=true,
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurrence of \"searchString\" within \"string\"
when searching from the last character of \"string\"
backwards, and return the corresponding index.
Start search at index \"startIndex\" (default = 0;
if startIndex = 0, search starts at length(string)).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>"));
      end findLast;

      package Advanced "Advanced scanning functions"
        extends Modelica.Icons.FunctionsPackage;

        function scanReal "Scan a signed real number"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1 "Index where scanning starts";
          input Boolean unsigned=false
            "= true, if number shall not start with '+' or '-'";
          output Integer nextIndex
            "Index after the found token (success=true) or index at which scanning failed (success=false)";
          output Real number "Value of Real number";
          external "C" ModelicaStrings_scanReal(string, startIndex, unsigned, nextIndex, number) annotation(Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(nextIndex, realNumber) = <strong>scanReal</strong>(string, startIndex=1, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a number
of type Real with an optional sign according to the Modelica grammar:
</p>
<pre>
    real     ::= [sign] unsigned [fraction] [exponent]
    sign     ::= '+' | '-'
    unsigned ::= digit [unsigned]
    fraction ::= '.' [unsigned]
    exponent ::= ('e' | 'E') [sign] unsigned
    digit    ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
</pre>
<p>
If successful, the function returns nextIndex = index of character
directly after the found real number, as well as the value
in the second output argument.
</p>
<p>
If not successful, on return nextIndex = startIndex and
the second output argument is zero.
</p>
<p>
If the optional argument \"unsigned\" is <strong>true</strong>, the number
shall not start with '+' or '-'. The default of \"unsigned\" is <strong>false</strong>.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end scanReal;

        function skipWhiteSpace "Scan white space"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1;
          output Integer nextIndex;
          external "C" nextIndex = ModelicaStrings_skipWhiteSpace(string, startIndex) annotation(Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
nextIndex = <strong>skipWhiteSpace</strong>(string, startIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\" and
skips white space. The function returns nextIndex = index of character
of the first non white space character.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end skipWhiteSpace;
        annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings.Advanced</strong> contains basic scanning
functions. These functions should be <strong>not called</strong> directly, because
it is much simpler to utilize the higher level functions \"Strings.scanXXX\".
The functions of the \"Strings.Advanced\" library provide
the basic interface in order to implement the higher level
functions in package \"Strings\".
</p>
<p>
Library \"Advanced\" provides the following functions:
</p>
<pre>
  (nextIndex, realNumber)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>        (string, startIndex, unsigned=false);
  (nextIndex, integerNumber) = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>     (string, startIndex, unsigned=false);
  (nextIndex, string2)       = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>      (string, startIndex);
  (nextIndex, identifier)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>  (string, startIndex);
   nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipWhiteSpace\">skipWhiteSpace</a>  (string, startIndex);
   nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a>(string, startIndex);
</pre>
<p>
All functions perform the following actions:
</p>
<ol>
<li> Scanning starts at character position \"startIndex\" of
     \"string\" (startIndex has a default of 1).</li>
<li> First, white space is skipped, such as blanks (\" \"), tabs (\"\\t\"), or newline (\"\\n\")</li>
<li> Afterwards, the required token is scanned.</li>
<li> If successful, on return nextIndex = index of character
     directly after the found token and the token value is returned
     as second output argument.<br>
     If not successful, on return nextIndex = startIndex.
     </li>
</ol>
<p>
The following additional rules apply for the scanning:
</p>
<ul>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>:<br>
     Scans a full number including one optional leading \"+\" or \"-\" (if unsigned=false)
     according to the Modelica grammar. For example, \"+1.23e-5\", \"0.123\" are
     Real numbers, but \".1\" is not.
     Note, an Integer number, such as \"123\" is also treated as a Real number.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>:<br>
     Scans an Integer number including one optional leading \"+\"
     or \"-\" (if unsigned=false) according to the Modelica (and C/C++) grammar.
     For example, \"+123\", \"20\" are Integer numbers.
     Note, a Real number, such as \"123.4\" is not an Integer and
     scanInteger returns nextIndex = startIndex.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>:<br>
     Scans a String according to the Modelica (and C/C++) grammar, e.g.,
     \"This is a \"string\"\" is a valid string token.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>:<br>
     Scans a Modelica identifier, i.e., the identifier starts either
     with a letter, followed by letters, digits or \"_\".
     For example, \"w_rel\", \"T12\".<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a><br>
     Skips white space and Modelica (C/C++) line comments iteratively.
     A line comment starts with \"//\" and ends either with an
     end-of-line (\"\\n\") or the end of the \"string\".</li>
</ul>
</html>"));
      end Advanced;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings</strong> contains functions to manipulate strings.
</p>
<p>
In the table below an example
call to every function is given using the <strong>default</strong> options.
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td>len = <a href=\"modelica://Modelica.Utilities.Strings.length\">length</a>(string)</td>
      <td>Returns length of string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.substring\">substring</a>(string1,startIndex,endIndex)
       </td>
      <td>Returns a substring defined by start and end index</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n)<br>
 result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n,string)</td>
      <td>Repeat a blank or a string n times.</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.compare\">compare</a>(string1, string2)</td>
      <td>Compares two substrings with regards to alphabetical order</td></tr>
  <tr><td>identical =
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">isEqual</a>(string1,string2)</td>
      <td>Determine whether two strings are identical</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.count\">count</a>(string,searchString)</td>
      <td>Count the number of occurrences of a string</td></tr>
  <tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.find\">find</a>(string,searchString)</td>
      <td>Find first occurrence of a string in another string</td></tr>
<tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.findLast\">findLast</a>(string,searchString)</td>
      <td>Find last occurrence of a string in another string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.replace\">replace</a>(string,searchString,replaceString)</td>
      <td>Replace one or all occurrences of a string</td></tr>
  <tr><td>stringVector2 = <a href=\"modelica://Modelica.Utilities.Strings.sort\">sort</a>(stringVector1)</td>
      <td>Sort vector of strings in alphabetic order</td></tr>
  <tr><td>hash = <a href=\"modelica://Modelica.Utilities.Strings.hashString\">hashString</a>(string)</td>
      <td>Create a hash value of a string</td></tr>
  <tr><td>(token, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanToken\">scanToken</a>(string,startIndex)</td>
      <td>Scan for a token (Real/Integer/Boolean/String/Identifier/Delimiter/NoToken)</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanReal\">scanReal</a>(string,startIndex)</td>
      <td>Scan for a Real constant</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanInteger\">scanInteger</a>(string,startIndex)</td>
      <td>Scan for an Integer constant</td></tr>
  <tr><td>(boolean, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanBoolean\">scanBoolean</a>(string,startIndex)</td>
      <td>Scan for a Boolean constant</td></tr>
  <tr><td>(string2, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanString\">scanString</a>(string,startIndex)</td>
      <td>Scan for a String constant</td></tr>
  <tr><td>(identifier, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanIdentifier\">scanIdentifier</a>(string,startIndex)</td>
      <td>Scan for an identifier</td></tr>
  <tr><td>(delimiter, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanDelimiter\">scanDelimiter</a>(string,startIndex)</td>
      <td>Scan for delimiters</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.scanNoToken\">scanNoToken</a>(string,startIndex)</td>
      <td>Check that remaining part of string consists solely of<br>
          white space or line comments (\"// ...\\n\").</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.syntaxError\">syntaxError</a>(string,index,message)</td>
      <td> Print a \"syntax error message\" as well as a string and the<br>
           index at which scanning detected an error</td></tr>
</table>
<p>
The functions \"compare\", \"isEqual\", \"count\", \"find\", \"findLast\", \"replace\", \"sort\"
have the optional
input argument <strong>caseSensitive</strong> with default <strong>true</strong>.
If <strong>false</strong>, the operation is carried out without taking
into account whether a character is upper or lower case.
</p>
</html>"));
    end Strings;

    package Types "Type definitions used in package Modelica.Utilities"
      extends Modelica.Icons.TypesPackage;

      type Compare = enumeration(
        Less   "String 1 is lexicographically less than string 2",
        Equal   "String 1 is identical to string 2",
        Greater   "String 1 is lexicographically greater than string 2")
        "Enumeration defining comparison of two strings";

      type FileType = enumeration(
        NoFile   "No file exists",
        RegularFile   "Regular file",
        Directory   "Directory",
        SpecialFile   "Special file (pipe, FIFO, device, etc.)")
        "Enumeration defining the type of a file";
      annotation (Documentation(info="<html>
<p>
This package contains type definitions used in Modelica.Utilities.
</p>

</html>"));
    end Types;

    package Internal
    "Internal components that a user should usually not directly utilize"
      extends Modelica.Icons.InternalPackage;

    partial package PartialModelicaServices
        "Interfaces of components requiring a tool specific implementation"
        extends Modelica.Icons.InternalPackage;
      package Animation "Models and functions for 3-dim. animation"
        extends Modelica.Icons.Package;
      partial model PartialShape "Interface for 3D animation of elementary shapes"

            import SI = Modelica.SIunits;
            import Modelica.Mechanics.MultiBody.Frames;
            import Modelica.Mechanics.MultiBody.Types;

        parameter Types.ShapeType shapeType="box"
              "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring, <external shape>)";
        input Frames.Orientation R=Frames.nullRotation()
              "Orientation object to rotate the world frame into the object frame"
                                                                                annotation(Dialog);
        input SI.Position r[3]={0,0,0}
              "Position vector from origin of world frame to origin of object frame, resolved in world frame"
                                                                                                          annotation(Dialog);
        input SI.Position r_shape[3]={0,0,0}
              "Position vector from origin of object frame to shape origin, resolved in object frame"
                                                                                                  annotation(Dialog);
        input Real lengthDirection[3](each final unit="1")={1,0,0}
              "Vector in length direction, resolved in object frame"
                                                                  annotation(Dialog);
        input Real widthDirection[3](each final unit="1")={0,1,0}
              "Vector in width direction, resolved in object frame"
                                                                 annotation(Dialog);
        input SI.Length length=0 "Length of visual object" annotation(Dialog);
        input SI.Length width=0 "Width of visual object" annotation(Dialog);
        input SI.Length height=0 "Height of visual object" annotation(Dialog);
        input Types.ShapeExtra extra=0.0
              "Additional size data for some of the shape types" annotation(Dialog);
        input Real color[3]={255,0,0} "Color of shape" annotation(Dialog(colorSelector=true));
        input Types.SpecularCoefficient specularCoefficient = 0.7
              "Reflection of ambient light (= 0: light is completely absorbed)"
                                                                            annotation(Dialog);
        annotation (
          Documentation(info="<html>

<p>
This model is documented at
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape</a>.
</p>

</html>"));

      end PartialShape;

        model PartialSurface "Interface for 3D animation of surfaces"

            import Modelica.Mechanics.MultiBody.Frames;
            import Modelica.Mechanics.MultiBody.Types;

          input Frames.Orientation R=Frames.nullRotation()
              "Orientation object to rotate the world frame into the surface frame"
            annotation(Dialog(group="Surface frame"));
          input Modelica.SIunits.Position r_0[3]={0,0,0}
              "Position vector from origin of world frame to origin of surface frame, resolved in world frame"
            annotation(Dialog(group="Surface frame"));

          parameter Integer nu=2 "Number of points in u-Dimension" annotation(Dialog(group="Surface properties"));
          parameter Integer nv=2 "Number of points in v-Dimension" annotation(Dialog(group="Surface properties"));
          replaceable function surfaceCharacteristic =
             Modelica.Mechanics.MultiBody.Interfaces.partialSurfaceCharacteristic
              "Function defining the surface characteristic"
                  annotation(choicesAllMatching=true,Dialog(group="Surface properties"));

          parameter Boolean wireframe=false
              "= true: 3D model will be displayed without faces"
            annotation (Dialog(group="Material properties"),choices(checkBox=true));
          parameter Boolean multiColoredSurface=false
              "= true: Color is defined for each surface point"
              annotation(Dialog(group="Material properties"),choices(checkBox=true));
          input Real color[3]={255,0,0} "Color of surface" annotation(Dialog(colorSelector=true,group="Material properties", enable=not multiColoredSurface));
          input Types.SpecularCoefficient specularCoefficient = 0.7
              "Reflection of ambient light (= 0: light is completely absorbed)"
                                                                              annotation(Dialog(group="Material properties"));
          input Real transparency=0
              "Transparency of shape: 0 (= opaque) ... 1 (= fully transparent)"
                                       annotation(Dialog(group="Material properties"));
          annotation (Documentation(info="<html>
<p>
This model is documented at
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface</a>.
</p>

</html>"));
        end PartialSurface;
      end Animation;

      package ExternalReferences "Functions to access external resources"
        extends Modelica.Icons.InternalPackage;
        partial function PartialLoadResource
            "Interface for tool specific function to return the absolute path name of a URI or local file name"
          extends Modelica.Icons.Function;
          input String uri "URI or local file name";
          output String fileReference "Absolute path name of file";
          annotation (Documentation(info="<html>
<p>
This partial function defines the function interface of a tool-specific implementation
in package ModelicaServices. The interface is documented at
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Internal.FileSystem.loadResource</a>.
</p>

</html>"));
        end PartialLoadResource;
      end ExternalReferences;

      package System "System dependent functions"
        extends Modelica.Icons.InternalPackage;
        partial function exitBase "Interface for tool specific function to terminate the execution of the Modelica environment"
          extends Modelica.Icons.Function;
          input Integer status=0 "Result to be returned by environment (0 means success)";
          annotation (Documentation(info="<html>
<p>
This partial function defines the function interface of a tool-specific implementation
in package ModelicaServices.
</p>
</html>"));
        end exitBase;
      end System;
        annotation (Documentation(info="<html>

<p>
This package contains interfaces of a set of functions and models used in the
Modelica Standard Library that requires a <strong>tool specific implementation</strong>.
There is an associated package called <strong>ModelicaServices</strong>. A tool vendor
should provide a proper implementation of this library for the corresponding
tool. The default implementation is \"do nothing\".
In the Modelica Standard Library, the models and functions of ModelicaServices
are used.
</p>
</html>"));
    end PartialModelicaServices;

    package FileSystem
      "Internal package with external functions as interface to the file system"
     extends Modelica.Icons.InternalPackage;

      function mkdir "Make directory (POSIX: 'mkdir')"
        extends Modelica.Icons.Function;
        input String directoryName "Make a new directory";
      external "C" ModelicaInternal_mkdir(directoryName) annotation(Library="ModelicaExternalC");
      annotation(__ModelicaAssociation_Impure=true);
      end mkdir;

      function stat "Inquire file information (POSIX function 'stat')"
        extends Modelica.Icons.Function;
        input String name "Name of file, directory, pipe etc.";
        output Types.FileType fileType "Type of file";
      external "C" fileType = ModelicaInternal_stat(name) annotation(Library="ModelicaExternalC");
      annotation(__ModelicaAssociation_Impure=true);
      end stat;
      annotation (
    Documentation(info="<html>
<p>
Package <strong>Internal.FileSystem</strong> is an internal package that contains
low level functions as interface to the file system.
These functions should not be called directly in a scripting
environment since more convenient functions are provided
in packages Files and Systems.
</p>
<p>
Note, the functions in this package are direct interfaces to
functions of POSIX and of the standard C library. Errors
occurring in these functions are treated by triggering
a Modelica assert. Therefore, the functions in this package
return only for a successful operation. Furthermore, the
representation of a string is hidden by this interface,
especially if the operating system supports Unicode characters.
</p>
</html>"));
    end FileSystem;
    end Internal;
      annotation (
  Documentation(info="<html>
<p>
This package contains Modelica <strong>functions</strong> that are
especially suited for <strong>scripting</strong>. The functions might
be used to work with strings, read data from file, write data
to file or copy, move and remove files.
</p>
<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.UsersGuide\">Modelica.Utilities.User's Guide</a>
     discusses the most important aspects of this library.</li>
<li> <a href=\"modelica://Modelica.Utilities.Examples\">Modelica.Utilities.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
The following main sublibraries are available:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.Files\">Files</a>
     provides functions to operate on files and directories, e.g.,
     to copy, move, remove files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>
     provides functions to read from files and write to files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
     provides functions to operate on strings. E.g.
     substring, find, replace, sort, scanToken.</li>
<li> <a href=\"modelica://Modelica.Utilities.System\">System</a>
     provides functions to interact with the environment.
     E.g., get or set the working directory or environment
     variables and to send a command to the default shell.</li>
</ul>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>"));
  end Utilities;

  package Constants
  "Library of mathematical constants and constants of nature (e.g., pi, eps, R, sigma)"
    import SI = Modelica.SIunits;
    import NonSI = Modelica.SIunits.Conversions.NonSIunits;
    extends Modelica.Icons.Package;

    final constant Real pi=2*Modelica.Math.asin(1.0);

    final constant Real eps=ModelicaServices.Machine.eps
      "Biggest number such that 1.0 + eps = 1.0";

    final constant Real small=ModelicaServices.Machine.small
      "Smallest number such that small and -small are representable on the machine";

    final constant Real inf=ModelicaServices.Machine.inf
      "Biggest Real number such that inf and -inf are representable on the machine";

    final constant SI.Acceleration g_n=9.80665
      "Standard acceleration of gravity on earth";

    final constant Real R(final unit="J/(mol.K)") = 8.3144598
      "Molar gas constant (previous value: 8.314472)";

    final constant Real sigma(final unit="W/(m2.K4)") = 5.670367e-8
      "Stefan-Boltzmann constant (previous value: 5.670400e-8)";

    final constant NonSI.Temperature_degC T_zero=-273.15
      "Absolute zero temperature";
    annotation (
      Documentation(info="<html>
<p>
This package provides often needed constants from mathematics, machine
dependent constants and constants from nature. The latter constants
(name, value, description) are from the following source:
</p>

<dl>
<dt>Peter J. Mohr, David B. Newell, and Barry N. Taylor:</dt>
<dd><strong>CODATA Recommended Values of the Fundamental Physical Constants: 2014</strong>.
<a href= \"http://dx.doi.org/10.5281/zenodo.22826\">http://dx.doi.org/10.5281/zenodo.22826</a>, 2015. See also <a href=
\"http://physics.nist.gov/cuu/Constants/index.html\">http://physics.nist.gov/cuu/Constants/index.html</a></dd>
</dl>

<p>CODATA is the Committee on Data for Science and Technology.</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 We&szlig;ling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
</dl>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>Nov 4, 2015</em>
       by Thomas Beutlich:<br>
       Constants updated according to 2014 CODATA values.</li>
<li><em>Nov 8, 2004</em>
       by Christian Schweiger:<br>
       Constants updated according to 2002 CODATA values.</li>
<li><em>Dec 9, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants updated according to 1998 CODATA values. Using names, values
       and description text from this source. Included magnetic and
       electric constant.</li>
<li><em>Sep 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants eps, inf, small introduced.</li>
<li><em>Nov 15, 1997</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>
</html>"),
      Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Polygon(
          origin={-9.2597,25.6673},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={-19.9923,-8.3993},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={23.753,-11.5422},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
          smooth=Smooth.Bezier)}));
  end Constants;

  package Icons "Library of icons"
    extends Icons.Package;

    partial package ExamplesPackage
      "Icon for packages containing runnable examples"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(
              origin={8.0,14.0},
              lineColor={78,138,73},
              fillColor={78,138,73},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}), Documentation(info="<html>
<p>This icon indicates a package that contains executable examples.</p>
</html>"));
    end ExamplesPackage;

    partial model Example "Icon for runnable examples"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Ellipse(lineColor = {75,138,73},
                    fillColor={255,255,255},
                    fillPattern = FillPattern.Solid,
                    extent = {{-100,-100},{100,100}}),
            Polygon(lineColor = {0,0,255},
                    fillColor = {75,138,73},
                    pattern = LinePattern.None,
                    fillPattern = FillPattern.Solid,
                    points = {{-36,60},{64,0},{-36,-60},{-36,60}})}), Documentation(info="<html>
<p>This icon indicates an example. The play button suggests that the example can be executed.</p>
</html>"));
    end Example;

    partial package Package "Icon for standard packages"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0)}), Documentation(info="<html>
<p>Standard package icon.</p>
</html>"));
    end Package;

    partial package BasesPackage "Icon for packages containing base classes"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(
              extent={{-30.0,-30.0},{30.0,30.0}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains base models and classes, respectively.</p>
</html>"));
    end BasesPackage;

    partial package VariantsPackage "Icon for package containing variants"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                {100,100}}), graphics={
            Ellipse(
              origin={10.0,10.0},
              fillColor={76,76,76},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-80.0,-80.0},{-20.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,-80.0},{60.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,0.0},{60.0,60.0}}),
            Ellipse(
              origin={10.0,10.0},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-80.0,0.0},{-20.0,60.0}})}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains several variants of one component.</p>
</html>"));
    end VariantsPackage;

    partial package InterfacesPackage "Icon for packages containing interfaces"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={20.0,0.0},
              lineColor={64,64,64},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-10.0,70.0},{10.0,70.0},{40.0,20.0},{80.0,20.0},{80.0,-20.0},{40.0,-20.0},{10.0,-70.0},{-10.0,-70.0}}),
            Polygon(fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-100.0,20.0},{-60.0,20.0},{-30.0,70.0},{-10.0,70.0},{-10.0,-70.0},{-30.0,-70.0},{-60.0,-20.0},{-100.0,-20.0}})}),
                                Documentation(info="<html>
<p>This icon indicates packages containing interfaces.</p>
</html>"));
    end InterfacesPackage;

    partial package SourcesPackage "Icon for packages containing sources"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={23.3333,0.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
            Rectangle(
              fillColor = {128,128,128},
              pattern = LinePattern.None,
              fillPattern = FillPattern.Solid,
              extent = {{-70,-4.5},{0,4.5}})}),
                                Documentation(info="<html>
<p>This icon indicates a package which contains sources.</p>
</html>"));
    end SourcesPackage;

    partial package SensorsPackage "Icon for packages containing sensors"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(origin={0.0,-30.0},
              fillColor={255,255,255},
              extent={{-90.0,-90.0},{90.0,90.0}},
              startAngle=20.0,
              endAngle=160.0),
            Ellipse(origin={0.0,-30.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-20.0,-20.0},{20.0,20.0}}),
            Line(origin={0.0,-30.0},
              points={{0.0,60.0},{0.0,90.0}}),
            Ellipse(origin={-0.0,-30.0},
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-10.0,-10.0},{10.0,10.0}}),
            Polygon(
              origin={-0.0,-30.0},
              rotation=-35.0,
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-7.0,0.0},{-3.0,85.0},{0.0,90.0},{3.0,85.0},{7.0,0.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a package containing sensors.</p>
</html>"));
    end SensorsPackage;

    partial package UtilitiesPackage "Icon for utility packages"
      extends Modelica.Icons.Package;
       annotation (Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}),
      Documentation(info="<html>
<p>This icon indicates a package containing utility classes.</p>
</html>"));
    end UtilitiesPackage;

    partial package TypesPackage "Icon for packages containing type definitions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-12.167,-23},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},
                  {14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,
                  -30},{4.167,20},{12.167,65}},
              smooth=Smooth.Bezier), Polygon(
              origin={2.7403,1.6673},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,
                10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,
                4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
              smooth=Smooth.Bezier)}));
    end TypesPackage;

    partial package FunctionsPackage "Icon for packages containing functions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
              Text(
                lineColor={128,128,128},
                extent={{-90,-90},{90,90}},
                textString="f")}));
    end FunctionsPackage;

    partial package IconsPackage "Icon for packages containing icons"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}));
    end IconsPackage;

    partial package InternalPackage
      "Icon for an internal package (indicating that the package should not be directly utilized by user)"

    annotation (
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
              100}}), graphics={
          Rectangle(
            lineColor={215,215,215},
            fillColor={255,255,255},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25),
          Rectangle(
            lineColor={215,215,215},
            extent={{-100,-100},{100,100}},
            radius=25),
          Ellipse(
            extent={{-80,80},{80,-80}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid),
          Ellipse(
            extent={{-55,55},{55,-55}},
            lineColor={255,255,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,14},{60,-14}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid,
            rotation=45)}),
      Documentation(info="<html>

<p>
This icon shall be used for a package that contains internal classes not to be
directly utilized by a user.
</p>
</html>"));
    end InternalPackage;

    partial package MaterialPropertiesPackage
      "Icon for package containing property classes"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(
              lineColor={102,102,102},
              fillColor={204,204,204},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Sphere,
              extent={{-60.0,-60.0},{60.0,60.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a package that contains properties</p>
</html>"));
    end MaterialPropertiesPackage;

    partial class MaterialProperty "Icon for property classes"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}), graphics={
            Ellipse(lineColor={102,102,102},
              fillColor={204,204,204},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Sphere,
              extent={{-100.0,-100.0},{100.0,100.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a property class.</p>
</html>"));
    end MaterialProperty;

    partial class RotationalSensor "Icon representing a round measurement device"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              fillColor={245,245,245},
              fillPattern=FillPattern.Solid,
              extent={{-70.0,-70.0},{70.0,70.0}}),
            Line(points={{0.0,70.0},{0.0,40.0}}),
            Line(points={{22.9,32.8},{40.2,57.3}}),
            Line(points={{-22.9,32.8},{-40.2,57.3}}),
            Line(points={{37.6,13.7},{65.8,23.9}}),
            Line(points={{-37.6,13.7},{-65.8,23.9}}),
            Ellipse(
              lineColor={64,64,64},
              fillColor={255,255,255},
              extent={{-12.0,-12.0},{12.0,12.0}}),
            Polygon(
              rotation=-17.5,
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-5.0,0.0},{-2.0,60.0},{0.0,65.0},{2.0,60.0},{5.0,0.0}}),
            Ellipse(
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-7.0,-7.0},{7.0,7.0}})}),
        Documentation(info="<html>
<p>
This icon is designed for a <strong>rotational sensor</strong> model.
</p>
</html>"));
    end RotationalSensor;

    partial class TranslationalSensor
      "Icon representing a linear measurement device"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              fillColor={245,245,245},
              fillPattern=FillPattern.Solid,
              extent={{-70.0,-60.0},{70.0,20.0}}),
            Polygon(
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{0.0,-40.0},{-10.0,-16.0},{10.0,-16.0},{0.0,-40.0}}),
            Line(points={{0.0,0.0},{0.0,-16.0}}),
            Line(points={{-70.0,0.0},{0.0,0.0}}),
            Line(points={{-50.0,-40.0},{-50.0,-60.0}}),
            Line(points={{-30.0,-40.0},{-30.0,-60.0}}),
            Line(points={{-10.0,-40.0},{-10.0,-60.0}}),
            Line(points={{10.0,-40.0},{10.0,-60.0}}),
            Line(points={{30.0,-40.0},{30.0,-60.0}}),
            Line(points={{50.0,-40.0},{50.0,-60.0}})}),
        Documentation(info="<html>
<p>
This icon is designed for a <strong>translational sensor</strong> model.
</p></html>"));
    end TranslationalSensor;

    partial function Function "Icon for functions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Text(
              lineColor={0,0,255},
              extent={{-150,105},{150,145}},
              textString="%name"),
            Ellipse(
              lineColor = {108,88,49},
              fillColor = {255,215,136},
              fillPattern = FillPattern.Solid,
              extent = {{-100,-100},{100,100}}),
            Text(
              lineColor={108,88,49},
              extent={{-90.0,-90.0},{90.0,90.0}},
              textString="f")}),
    Documentation(info="<html>
<p>This icon indicates Modelica functions.</p>
</html>"));
    end Function;

    partial record Record "Icon for records"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Text(
              lineColor={0,0,255},
              extent={{-150,60},{150,100}},
              textString="%name"),
            Rectangle(
              origin={0.0,-25.0},
              lineColor={64,64,64},
              fillColor={255,215,136},
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-75.0},{100.0,75.0}},
              radius=25.0),
            Line(
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-50.0},
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-25.0},
              points={{0.0,75.0},{0.0,-75.0}},
              color={64,64,64})}), Documentation(info="<html>
<p>
This icon is indicates a record.
</p>
</html>"));
    end Record;

    type TypeReal "Icon for Real types"
        extends Real;
        annotation(Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Text(
                lineColor={255,255,255},
                extent={{-90.0,-50.0},{90.0,50.0}},
                textString="R")}),Documentation(info="<html>
<p>
This icon is designed for a <strong>Real</strong> type.
</p>
</html>"));
    end TypeReal;

    type TypeString "Icon for String types"
        extends String;
        annotation(Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Text(
                lineColor={255,255,255},
                extent={{-90.0,-50.0},{90.0,50.0}},
                textString="S")}),Documentation(info="<html>
<p>
This icon is designed for a <strong>String</strong> type.
</p>
</html>"));
    end TypeString;

    expandable connector SignalBus "Icon for signal bus"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}, initialScale=0.2), graphics={
              Rectangle(
                lineColor={255,204,51},
                lineThickness=0.5,
                extent={{-20.0,-2.0},{20.0,2.0}}),
              Polygon(
                fillColor={255,215,136},
                fillPattern=FillPattern.Solid,
                points={{-80.0,50.0},{80.0,50.0},{100.0,30.0},{80.0,-40.0},{60.0,-50.0},{-60.0,-50.0},{-80.0,-40.0},{-100.0,30.0}},
                smooth=Smooth.Bezier),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-65.0,15.0},{-55.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-5.0,15.0},{5.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{55.0,15.0},{65.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-35.0,-25.0},{-25.0,-15.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{25.0,-25.0},{35.0,-15.0}})}),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            initialScale=0.2), graphics={
            Polygon(
              points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,-20},{-50,15}},
              fillColor={255,204,51},
              fillPattern=FillPattern.Solid,
              smooth=Smooth.Bezier),
            Ellipse(
              extent={{-32.5,7.5},{-27.5,12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-2.5,12.5},{2.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{27.5,12.5},{32.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-17.5,-7.5},{-12.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{12.5,-7.5},{17.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,70},{150,40}},
              textString="%name")}),
        Documentation(info="<html>
This icon is designed for a <strong>signal bus</strong> connector.
</html>"));
    end SignalBus;

    partial class ObsoleteModel
      "Icon for classes that are obsolete and will be removed in later versions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-102,102},{102,-102}},
              lineColor={255,0,0},
              pattern=LinePattern.Dash,
              lineThickness=0.5)}), Documentation(info="<html>
<p>
This partial class is intended to provide a <u>default icon
for an obsolete model</u> that will be removed from the
corresponding library in a future release.
</p>
</html>"));
    end ObsoleteModel;

    partial package Library
      "This icon will be removed in future Modelica versions, use Package instead"
      extends Modelica.Icons.ObsoleteModel;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0)}), Documentation(info="<html>
<p>This icon of a package will be removed in future versions of the library.</p>
<h5>Note</h5>
<p>This icon will be removed in future versions of the Modelica Standard Library. Instead the icon <a href=\"modelica://Modelica.Icons.Package\">Package</a> shall be used.</p>
</html>"),
      obsolete = "Obsolete package - use Modelica.Icons.Package instead");
    end Library;
    annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}), Documentation(info="<html>
<p>This package contains definitions for the graphical layout of components which may be used in different libraries. The icons can be utilized by inheriting them in the desired class using &quot;extends&quot; or by directly copying the &quot;icon&quot; layer.</p>

<h4>Main Authors:</h4>

<dl>
<dt><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a></dt>
    <dd>Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)</dd>
    <dd>Oberpfaffenhofen</dd>
    <dd>Postfach 1116</dd>
    <dd>D-82230 Wessling</dd>
    <dd>email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
<dt>Christian Kral</dt>

    <dd>  <a href=\"https://christiankral.net/\">Electric Machines, Drives and Systems</a><br>
</dd>
    <dd>1060 Vienna, Austria</dd>
    <dd>email: <a href=\"mailto:dr.christian.kral@gmail.com\">dr.christian.kral@gmail.com</a></dd>
<dt>Johan Andreasson</dt>
    <dd><a href=\"http://www.modelon.se/\">Modelon AB</a></dd>
    <dd>Ideon Science Park</dd>
    <dd>22370 Lund, Sweden</dd>
    <dd>email: <a href=\"mailto:johan.andreasson@modelon.se\">johan.andreasson@modelon.se</a></dd>
</dl>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>"));
  end Icons;

  package SIunits
  "Library of type and unit definitions based on SI units according to ISO 31-1992"
    extends Modelica.Icons.Package;

    package Icons "Icons for SIunits"
      extends Modelica.Icons.IconsPackage;

      partial function Conversion "Base icon for conversion functions"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={191,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0}),
              Polygon(
                points={{90,0},{30,20},{30,-20},{90,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-115,155},{115,105}},
                textString="%name",
                lineColor={0,0,255})}));
      end Conversion;
    end Icons;

    package Conversions
    "Conversion functions to/from non SI units and type definitions of non SI units"
      extends Modelica.Icons.Package;

      package NonSIunits "Type definitions of non SI units"
        extends Modelica.Icons.Package;

        type Temperature_degC = Real (final quantity="ThermodynamicTemperature",
              final unit="degC")
          "Absolute temperature in degree Celsius (for relative temperature use SIunits.TemperatureDifference)" annotation(absoluteValue=true);

        type Angle_deg = Real (final quantity="Angle", final unit="deg")
          "Angle in degree";

        type AngularVelocity_rpm = Real (final quantity="AngularVelocity", final unit=
                   "rev/min")
          "Angular velocity in revolutions per minute. Alias unit names that are outside of the SI system: rpm, r/min, rev/min";

        type Time_hour = Real (final quantity="Time", final unit="h")
          "Time in hours";

        type Pressure_bar = Real (final quantity="Pressure", final unit="bar")
          "Absolute pressure in bar";
        annotation (Documentation(info="<html>
<p>
This package provides predefined types, such as <strong>Angle_deg</strong> (angle in
degree), <strong>AngularVelocity_rpm</strong> (angular velocity in revolutions per
minute) or <strong>Temperature_degF</strong> (temperature in degree Fahrenheit),
which are in common use but are not part of the international standard on
units according to ISO 31-1992 \"General principles concerning quantities,
units and symbols\" and ISO 1000-1992 \"SI units and recommendations for
the use of their multiples and of certain other units\".</p>
<p>If possible, the types in this package should not be used. Use instead
types of package Modelica.SIunits. For more information on units, see also
the book of Francois Cardarelli <strong>Scientific Unit Conversion - A
Practical Guide to Metrication</strong> (Springer 1997).</p>
<p>Some units, such as <strong>Temperature_degC/Temp_C</strong> are both defined in
Modelica.SIunits and in Modelica.Conversions.NonSIunits. The reason is that these
definitions have been placed erroneously in Modelica.SIunits although they
are not SIunits. For backward compatibility, these type definitions are
still kept in Modelica.SIunits.</p>
</html>"),   Icon(coordinateSystem(extent={{-100,-100},{100,100}}), graphics={
        Text(
          origin={15.0,51.8518},
          extent={{-105.0,-86.8518},{75.0,-16.8518}},
          textString="[km/h]")}));
      end NonSIunits;

      function to_degC "Convert from Kelvin to degCelsius"
        extends Modelica.SIunits.Icons.Conversion;
        input Temperature Kelvin "Kelvin value";
        output NonSIunits.Temperature_degC Celsius "Celsius value";
      algorithm
        Celsius := Kelvin + Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                textString="K"), Text(
                extent={{100,-20},{20,-100}},
                textString="degC")}));
      end to_degC;

      function from_degC "Convert from degCelsius to Kelvin"
        extends Modelica.SIunits.Icons.Conversion;
        input NonSIunits.Temperature_degC Celsius "Celsius value";
        output Temperature Kelvin "Kelvin value";
      algorithm
        Kelvin := Celsius - Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                textString="degC"), Text(
                extent={{100,-20},{20,-100}},
                textString="K")}));
      end from_degC;

      function from_deg "Convert from degree to radian"
        extends Modelica.SIunits.Icons.Conversion;
        input NonSIunits.Angle_deg degree "degree value";
        output Angle radian "radian value";
      algorithm
        radian := (Modelica.Constants.pi/180.0)*degree;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{4,100},{-102,46}},
                textString="deg"), Text(
                extent={{100,-32},{-18,-100}},
                textString="rad")}));
      end from_deg;

      function to_hour "Convert from second to hour"
        extends Modelica.SIunits.Icons.Conversion;
        input Time s "second value";
        output NonSIunits.Time_hour hour "hour value";
      algorithm
        hour := s/3600;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{12,100},{-100,50}},
                textString="s"), Text(
                extent={{100,-56},{-20,-100}},
                textString="hour")}));
      end to_hour;

      function to_bar "Convert from Pascal to bar"
        extends Modelica.SIunits.Icons.Conversion;
        input Pressure Pa "Pascal value";
        output NonSIunits.Pressure_bar bar "bar value";
      algorithm
        bar := Pa/1e5;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-12,100},{-100,56}},
                textString="Pa"), Text(
                extent={{98,-52},{-4,-100}},
                textString="bar")}));
      end to_bar;
      annotation (Documentation(info="<html>
<p>This package provides conversion functions from the non SI Units
defined in package Modelica.SIunits.Conversions.NonSIunits to the
corresponding SI Units defined in package Modelica.SIunits and vice
versa. It is recommended to use these functions in the following
way (note, that all functions have one Real input and one Real output
argument):</p>
<pre>
  <strong>import</strong> SI = Modelica.SIunits;
  <strong>import</strong> Modelica.SIunits.Conversions.*;
     ...
  <strong>parameter</strong> SI.Temperature     T   = from_degC(25);   // convert 25 degree Celsius to Kelvin
  <strong>parameter</strong> SI.Angle           phi = from_deg(180);   // convert 180 degree to radian
  <strong>parameter</strong> SI.AngularVelocity w   = from_rpm(3600);  // convert 3600 revolutions per minutes
                                                      // to radian per seconds
</pre>

</html>"));
    end Conversions;

    type Angle = Real (
        final quantity="Angle",
        final unit="rad",
        displayUnit="deg");

    type Length = Real (final quantity="Length", final unit="m");

    type Position = Length;

    type Distance = Length (min=0);

    type Height = Length(min=0);

    type Radius = Length(min=0);

    type Diameter = Length(min=0);

    type Area = Real (final quantity="Area", final unit="m2");

    type Volume = Real (final quantity="Volume", final unit="m3");

    type Time = Real (final quantity="Time", final unit="s");

    type Duration = Time;

    type AngularVelocity = Real (
        final quantity="AngularVelocity",
        final unit="rad/s");

    type Velocity = Real (final quantity="Velocity", final unit="m/s");

    type Acceleration = Real (final quantity="Acceleration", final unit="m/s2");

    type Frequency = Real (final quantity="Frequency", final unit="Hz");

    type Mass = Real (
        quantity="Mass",
        final unit="kg",
        min=0);

    type Density = Real (
        final quantity="Density",
        final unit="kg/m3",
        displayUnit="g/cm3",
        min=0.0);

    type SpecificVolume = Real (
        final quantity="SpecificVolume",
        final unit="m3/kg",
        min=0.0);

    type Pressure = Real (
        final quantity="Pressure",
        final unit="Pa",
        displayUnit="bar");

    type AbsolutePressure = Pressure (min=0.0, nominal = 1e5);

    type PressureDifference = Pressure;

    type DynamicViscosity = Real (
        final quantity="DynamicViscosity",
        final unit="Pa.s",
        min=0);

    type KinematicViscosity = Real (
        final quantity="KinematicViscosity",
        final unit="m2/s",
        min=0);

    type Energy = Real (final quantity="Energy", final unit="J");

    type Power = Real (final quantity="Power", final unit="W");

    type EnthalpyFlowRate = Real (final quantity="EnthalpyFlowRate", final unit=
            "W");

    type Efficiency = Real (
        final quantity="Efficiency",
        final unit="1",
        min=0);

    type MassFlowRate = Real (quantity="MassFlowRate", final unit="kg/s");

    type VolumeFlowRate = Real (final quantity="VolumeFlowRate", final unit=
            "m3/s");

    type ThermodynamicTemperature = Real (
        final quantity="ThermodynamicTemperature",
        final unit="K",
        min = 0.0,
        start = 288.15,
        nominal = 300,
        displayUnit="degC")
      "Absolute temperature (use type TemperatureDifference for relative temperatures)" annotation(absoluteValue=true);

    type Temp_K = ThermodynamicTemperature;

    type Temperature = ThermodynamicTemperature;

    type TemperatureDifference = Real (
        final quantity="ThermodynamicTemperature",
        final unit="K") annotation(absoluteValue=false);

    type TemperatureSlope = Real (final quantity="TemperatureSlope",
        final unit="K/s");

    type LinearTemperatureCoefficient = Real(final quantity = "LinearTemperatureCoefficient", final unit="1/K");

    type Compressibility = Real (final quantity="Compressibility", final unit=
            "1/Pa");

    type IsothermalCompressibility = Compressibility;

    type Heat = Real (final quantity="Energy", final unit="J");

    type HeatFlowRate = Real (final quantity="Power", final unit="W");

    type HeatFlux = Real (final quantity="HeatFlux", final unit="W/m2");

    type ThermalConductivity = Real (final quantity="ThermalConductivity", final unit=
               "W/(m.K)");

    type CoefficientOfHeatTransfer = Real (final quantity=
            "CoefficientOfHeatTransfer", final unit="W/(m2.K)");

    type ThermalInsulance = Real (final quantity="ThermalInsulance", final unit=
            "m2.K/W");

    type ThermalResistance = Real (final quantity="ThermalResistance", final unit=
           "K/W");

    type ThermalConductance = Real (final quantity="ThermalConductance", final unit=
               "W/K");

    type ThermalDiffusivity = Real (final quantity="ThermalDiffusivity", final unit=
               "m2/s");

    type HeatCapacity = Real (final quantity="HeatCapacity", final unit="J/K");

    type SpecificHeatCapacity = Real (final quantity="SpecificHeatCapacity",
          final unit="J/(kg.K)");

    type RatioOfSpecificHeatCapacities = Real (final quantity=
            "RatioOfSpecificHeatCapacities", final unit="1");

    type IsentropicExponent = Real (final quantity="IsentropicExponent", final unit=
               "1");

    type SpecificEntropy = Real (final quantity="SpecificEntropy",
                                 final unit="J/(kg.K)");

    type SpecificEnergy = Real (final quantity="SpecificEnergy",
                                final unit="J/kg");

    type SpecificInternalEnergy = SpecificEnergy;

    type SpecificEnthalpy = SpecificEnergy;

    type DerDensityByEnthalpy = Real (final unit="kg.s2/m5");

    type DerDensityByPressure = Real (final unit="s2/m2");

    type DerDensityByTemperature = Real (final unit="kg/(m3.K)");

    type RadiantEnergyFluenceRate = Real (final quantity=
            "RadiantEnergyFluenceRate", final unit="W/m2");

    type Irradiance = Real (final quantity="Irradiance", final unit="W/m2");

    type Emissivity = Real (final quantity="Emissivity", final unit="1");

    type Illuminance = Real (final quantity="Illuminance", final unit="lx");

    type LuminousEfficacy = Real (final quantity="LuminousEfficacy", final unit=
            "lm/W");

    type MolarMass = Real (final quantity="MolarMass", final unit="kg/mol",min=0);

    type MolarVolume = Real (final quantity="MolarVolume", final unit="m3/mol", min=0);

    type MassFraction = Real (final quantity="MassFraction", final unit="1",
                              min=0, max=1);

    type MoleFraction = Real (final quantity="MoleFraction", final unit="1",
                              min = 0, max = 1);

    type ReynoldsNumber = Real (final quantity="ReynoldsNumber", final unit="1");

    type PrandtlNumber = Real (final quantity="PrandtlNumber", final unit="1");
    annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
              -100},{100,100}}), graphics={
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{-80,-40},{-80,-40},{-55,50},{-52.5,62.5},{-65,60},{-65,65},{-35,77.5},{-32.5,60},{-50,0},{-50,0},{-30,15},{-20,27.5},{-32.5,27.5},{-32.5,27.5},{-32.5,32.5},{-32.5,32.5},{2.5,32.5},{2.5,32.5},{2.5,27.5},{2.5,27.5},{-7.5,27.5},{-30,7.5},{-30,7.5},{-25,-25},{-17.5,-28.75},{-10,-25},{-5,-26.25},{-5,-32.5},{-16.25,-41.25},{-31.25,-43.75},{-40,-33.75},{-45,-5},{-45,-5},{-52.5,-10},{-52.5,-10},{-60,-40},{-60,-40}},
          smooth = Smooth.Bezier),
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{87.5,30},{62.5,30},{62.5,30},{55,33.75},{36.25,35},{16.25,25},{7.5,6.25},{11.25,-7.5},{22.5,-12.5},{22.5,-12.5},{6.25,-22.5},{6.25,-35},{16.25,-38.75},{16.25,-38.75},{21.25,-41.25},{21.25,-41.25},{45,-48.75},{47.5,-61.25},{32.5,-70},{12.5,-65},{7.5,-51.25},{21.25,-41.25},{21.25,-41.25},{16.25,-38.75},{16.25,-38.75},{6.25,-41.25},{-6.25,-50},{-3.75,-68.75},{30,-76.25},{65,-62.5},{63.75,-35},{27.5,-26.25},{22.5,-20},{27.5,-15},{27.5,-15},{30,-7.5},{30,-7.5},{27.5,-2.5},{28.75,11.25},{36.25,27.5},{47.5,30},{53.75,22.5},{51.25,8.75},{45,-6.25},{35,-11.25},{30,-7.5},{30,-7.5},{27.5,-15},{27.5,-15},{43.75,-16.25},{65,-6.25},{72.5,10},{70,20},{70,20},{80,20}},
          smooth = Smooth.Bezier)}), Documentation(info="<html>
<p>This package provides predefined types, such as <em>Mass</em>,
<em>Angle</em>, <em>Time</em>, based on the international standard
on units, e.g.,
</p>

<pre>   <strong>type</strong> Angle = Real(<strong>final</strong> quantity = \"Angle\",
                     <strong>final</strong> unit     = \"rad\",
                     displayUnit    = \"deg\");
</pre>

<p>
Some of the types are derived SI units that are utilized in package Modelica
(such as ComplexCurrent, which is a complex number where both the real and imaginary
part have the SI unit Ampere).
</p>

<p>
Furthermore, conversion functions from non SI-units to SI-units and vice versa
are provided in subpackage
<a href=\"modelica://Modelica.SIunits.Conversions\">Conversions</a>.
</p>

<p>
For an introduction how units are used in the Modelica standard library
with package SIunits, have a look at:
<a href=\"modelica://Modelica.SIunits.UsersGuide.HowToUseSIunits\">How to use SIunits</a>.
</p>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>May 25, 2011</em> by Stefan Wischhusen:<br/>Added molar units for energy and enthalpy.</li>
<li><em>Jan. 27, 2010</em> by Christian Kral:<br/>Added complex units.</li>
<li><em>Dec. 14, 2005</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Add User&#39;s Guide and removed &quot;min&quot; values for Resistance and Conductance.</li>
<li><em>October 21, 2002</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Christian Schweiger:<br/>Added new package <strong>Conversions</strong>. Corrected typo <em>Wavelenght</em>.</li>
<li><em>June 6, 2000</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Introduced the following new types<br/>type Temperature = ThermodynamicTemperature;<br/>types DerDensityByEnthalpy, DerDensityByPressure, DerDensityByTemperature, DerEnthalpyByPressure, DerEnergyByDensity, DerEnergyByPressure<br/>Attribute &quot;final&quot; removed from min and max values in order that these values can still be changed to narrow the allowed range of values.<br/>Quantity=&quot;Stress&quot; removed from type &quot;Stress&quot;, in order that a type &quot;Stress&quot; can be connected to a type &quot;Pressure&quot;.</li>
<li><em>Oct. 27, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>New types due to electrical library: Transconductance, InversePotential, Damping.</li>
<li><em>Sept. 18, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Renamed from SIunit to SIunits. Subpackages expanded, i.e., the SIunits package, does no longer contain subpackages.</li>
<li><em>Aug 12, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Type &quot;Pressure&quot; renamed to &quot;AbsolutePressure&quot; and introduced a new type &quot;Pressure&quot; which does not contain a minimum of zero in order to allow convenient handling of relative pressure. Redefined BulkModulus as an alias to AbsolutePressure instead of Stress, since needed in hydraulics.</li>
<li><em>June 29, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Bug-fix: Double definition of &quot;Compressibility&quot; removed and appropriate &quot;extends Heat&quot; clause introduced in package SolidStatePhysics to incorporate ThermodynamicTemperature.</li>
<li><em>April 8, 1998</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Astrid Jaschinski:<br/>Complete ISO 31 chapters realized.</li>
<li><em>Nov. 15, 1997</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Hubertus Tummescheit:<br/>Some chapters realized.</li>
</ul>
</html>"));
  end SIunits;
annotation (
preferredView="info",
version="3.2.3",
versionBuild=2,
versionDate="2019-01-23",
dateModified = "2019-03-20 12:00:00Z",
revisionId="8f65f621a 2019-03-20 09:22:19 +0100",
uses(Complex(version="3.2.3"), ModelicaServices(version="3.2.3")),
conversion(
 noneFromVersion="3.2.2",
 noneFromVersion="3.2.1",
 noneFromVersion="3.2",
 noneFromVersion="3.1",
 noneFromVersion="3.0.1",
 noneFromVersion="3.0",
 from(version="2.1", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2.1", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2.2", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos")),
Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
  Polygon(
    origin={-6.9888,20.048},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    points={{-93.0112,10.3188},{-93.0112,10.3188},{-73.011,24.6},{-63.011,31.221},{-51.219,36.777},{-39.842,38.629},{-31.376,36.248},{-25.819,29.369},{-24.232,22.49},{-23.703,17.463},{-15.501,25.135},{-6.24,32.015},{3.02,36.777},{15.191,39.423},{27.097,37.306},{32.653,29.633},{35.035,20.108},{43.501,28.046},{54.085,35.19},{65.991,39.952},{77.897,39.688},{87.422,33.338},{91.126,21.696},{90.068,9.525},{86.099,-1.058},{79.749,-10.054},{71.283,-21.431},{62.816,-33.337},{60.964,-32.808},{70.489,-16.14},{77.368,-2.381},{81.072,10.054},{79.749,19.05},{72.605,24.342},{61.758,23.019},{49.587,14.817},{39.003,4.763},{29.214,-6.085},{21.012,-16.669},{13.339,-26.458},{5.401,-36.777},{-1.213,-46.037},{-6.24,-53.446},{-8.092,-52.387},{-0.684,-40.746},{5.401,-30.692},{12.81,-17.198},{19.424,-3.969},{23.658,7.938},{22.335,18.785},{16.514,23.283},{8.047,23.019},{-1.478,19.05},{-11.267,11.113},{-19.734,2.381},{-29.259,-8.202},{-38.519,-19.579},{-48.044,-31.221},{-56.511,-43.392},{-64.449,-55.298},{-72.386,-66.939},{-77.678,-74.612},{-79.53,-74.083},{-71.857,-61.383},{-62.861,-46.037},{-52.278,-28.046},{-44.869,-15.346},{-38.784,-2.117},{-35.344,8.731},{-36.403,19.844},{-42.488,23.813},{-52.013,22.49},{-60.744,16.933},{-68.947,10.054},{-76.884,2.646},{-93.0112,-12.1707},{-93.0112,-12.1707}},
    smooth=Smooth.Bezier),
  Ellipse(
    origin={40.8208,-37.7602},
    fillColor={161,0,4},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    extent={{-17.8562,-17.8563},{17.8563,17.8562}})}),
Documentation(info="<html>
<p>
Package <strong>Modelica&reg;</strong> is a <strong>standardized</strong> and <strong>free</strong> package
that is developed together with the Modelica&reg; language from the
Modelica Association, see
<a href=\"https://www.Modelica.org\">https://www.Modelica.org</a>.
It is also called <strong>Modelica Standard Library</strong>.
It provides model components in many domains that are based on
standardized interface definitions. Some typical examples are shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/UsersGuide/ModelicaLibraries.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.UsersGuide.Overview\">Overview</a>
  provides an overview of the Modelica Standard Library
  inside the <a href=\"modelica://Modelica.UsersGuide\">User's Guide</a>.</li>
<li><a href=\"modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>
 summarizes the changes of new versions of this package.</li>
<li> <a href=\"modelica://Modelica.UsersGuide.Contact\">Contact</a>
  lists the contributors of the Modelica Standard Library.</li>
<li> The <strong>Examples</strong> packages in the various libraries, demonstrate
  how to use the components of the corresponding sublibrary.</li>
</ul>

<p>
This version of the Modelica Standard Library consists of
</p>
<ul>
<li><strong>1288</strong> component models and blocks,</li>
<li><strong>404</strong> example models, and</li>
<li><strong>1227</strong> functions</li>
</ul>
<p>
that are directly usable (= number of public, non-partial, non-internal and non-obsolete classes). It is fully compliant
to <a href=\"https://www.modelica.org/documents/ModelicaSpec32Revision2.pdf\">Modelica Specification Version 3.2 Revision 2</a>
and it has been tested with Modelica tools from different vendors.
</p>

<p>
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 1998-2019, Modelica Association and <a href=\"modelica://Modelica.UsersGuide.Contact\">contributors</a>.
</p>

<p>
<em>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the 3-Clause BSD license. For license conditions (including the disclaimer of warranty) visit <a href=\"https://modelica.org/licenses/modelica-3-clause-bsd\">https://modelica.org/licenses/modelica-3-clause-bsd</a>.</em>
</p>

<p>
<strong>Modelica&reg;</strong> is a registered trademark of the Modelica Association.
</p>
</html>"));
end Modelica;

package IDEAS "Integrated District Energy Assessment Simulation"
extends Modelica.Icons.Library;
import SI = Modelica.SIunits;

  package BoundaryConditions "Package with models for boundary conditions"
    extends Modelica.Icons.Package;

    package Interfaces
    extends Modelica.Icons.InterfacesPackage;

      partial model PartialSimInfoManager
        "Partial providing structure for SimInfoManager"
        parameter String filNam=
          Modelica.Utilities.Files.loadResource("modelica://IDEAS/Resources/weatherdata/Uccle.TMY")
          "File name of TMY3 weather file";
        parameter Modelica.SIunits.Angle lat(displayUnit="deg") = weaDat.lat
          "Latitude of the location"
          annotation(Dialog(tab="Advanced"));
        parameter Modelica.SIunits.Angle lon(displayUnit="deg") = weaDat.lon
          "Longitude of the location"
          annotation(Dialog(tab="Advanced"));
        parameter Modelica.SIunits.Time timZon(displayUnit="h") = weaDat.timZon
          "Time zone for which the simulation time t=0 corresponds to midnight, january 1st";


        parameter SI.Angle incAndAziInBus[:,:] = {{IDEAS.Types.Tilt.Ceiling,0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},
                               {IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}, {IDEAS.Types.Tilt.Floor,0}}
                              "Combination of inclination and azimuth which are pre-computed and added to solBus." annotation(Dialog(tab="Incidence angles"));

        parameter Boolean computeConservationOfEnergy=false
          "Add equations for verifying conservation of energy"
          annotation (Evaluate=true, Dialog(tab="Conservation of energy"));
        parameter Boolean strictConservationOfEnergy=false
          "This adds an assert statement to make sure that energy is conserved"
          annotation (Evaluate=true, Dialog(tab="Conservation of energy", enable=
                computeConservationOfEnergy));
        parameter Boolean openSystemConservationOfEnergy=false
          "Compute conservation of energy for open system" annotation (Evaluate=true,
            Dialog(tab="Conservation of energy", enable=computeConservationOfEnergy));

        parameter Boolean lineariseDymola=false "Linearises building model equations for Dymola linearisation approach"
          annotation (Dialog(tab="Linearisation"));
        parameter Boolean lineariseJModelica=false "Linearises building model equations for optimisations in JModelica"
          annotation (Dialog(tab="Linearisation"));
        parameter Boolean createOutputs = false
          "Creates output connections when linearising windows"
          annotation(Dialog(tab="Linearisation"));
        parameter Boolean outputAngles=not lineariseDymola
          "Output angles in weaBus. Set to false when linearising" annotation(Dialog(tab="Linearisation"));
        parameter Boolean linIntCon=false
          "= true, if interior convective heat transfer should be linearised"
          annotation (Dialog(tab="Linearisation", group="Convection"));
        parameter Boolean linExtCon=false
          "= true, if exterior convective heat transfer should be linearised (uses average wind speed)"
          annotation (Dialog(tab="Linearisation", group="Convection"));
        parameter Boolean linIntRad=true
          "= true, if interior radiative heat transfer should be linearised"
          annotation (Dialog(tab="Linearisation", group="Radiation"));
        parameter Boolean linExtRad=false
          "= true, if exterior radiative heat transfer for walls should be linearised"
          annotation (Dialog(tab="Linearisation", group="Radiation"));
        // separate parameter linExtRadWin since window dynamics are steady state by default
        parameter Boolean linExtRadWin=true
          "= true, if exterior radiative heat transfer for windows should be linearised"
          annotation (Dialog(tab="Linearisation", group="Radiation"));
        parameter Modelica.SIunits.Energy Emax=1
          "Error bound for violation of conservation of energy" annotation (Evaluate=true,
            Dialog(tab="Conservation of energy", enable=strictConservationOfEnergy));
        parameter Modelica.SIunits.Temperature Tenv_nom= 280
          "Nominal ambient temperature, only used when linearising equations";

        parameter Integer nWindow = 1
          "Number of windows in the to be linearised model"
          annotation(Dialog(tab="Linearisation"));
        parameter Integer nLayWin= 3
          "Number of window layers in the to be linearised model; should be maximum of all windows"
          annotation(Dialog(tab="Linearisation"));
        parameter Real ppmCO2 = 400
          "Default CO2 concentration in [ppm] when using air medium containing CO2"
          annotation(Dialog(tab="Advanced", group="CO2"));
        final parameter Integer numIncAndAziInBus = size(incAndAziInBus,1)
          "Number of pre-computed azimuth";
        final parameter Modelica.SIunits.Temperature Tdes=-8 + 273.15
          "design outdoor temperature";
        final parameter Modelica.SIunits.Temperature TdesGround=10 + 273.15
          "design ground temperature";
        final parameter Boolean linearise=lineariseDymola or lineariseJModelica
          "Linearises building model equations"
          annotation (Dialog(tab="Linearisation"));

        Modelica.SIunits.Temperature Te
          "ambient outdoor temperature for determination of sky radiation exchange";
        Modelica.SIunits.Temperature Tsky "effective overall sky temperature";
        Modelica.SIunits.Temperature TeAv
          "running average of ambient outdoor temperature of the last 5 days, not yet implemented";
        Modelica.SIunits.Temperature Tground "ground temperature";
        Modelica.SIunits.Velocity Va "air velocity";

        Real relHum(final unit="1") "Relative humidity";
        Modelica.SIunits.Temperature TDewPoi "Dewpoint";


        Modelica.SIunits.Energy Etot "Total internal energy";
        Modelica.SIunits.Energy Qint "Total energy from boundary";


        Real hCon=IDEAS.Utilities.Math.Functions.spliceFunction(
            x=Va - 5,
            pos=7.1*abs(Va)^(0.78),
            neg=4.0*Va + 5.6,
            deltax=0.5)
          "Convection coefficient due to wind speed";
        IDEAS.Utilities.Psychrometrics.X_pTphi XiEnv(use_p_in=false)
          annotation (Placement(transformation(extent={{-20,20},{0,40}})));

        // Icon of weaBus is made very small as it is not intended that a user would use it.
        // weaBus is still directly connected in the zone model and the connector should
        // therefore not be protected.
        // Connector weaDatBus is made available for the user and it should be used instead
        // of weaBus.
        IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(numSolBus=numIncAndAziInBus,
            final outputAngles=outputAngles)
          annotation (Placement(transformation(extent={{90,30},{110,50}}),
              iconTransformation(extent={{90,30},{90,30}})));
        IDEAS.BoundaryConditions.SolarIrradiation.ShadedRadSol[numIncAndAziInBus] radSol(
          inc=incAndAziInBus[:, 1],
          azi=incAndAziInBus[:, 2],
          each lat=lat,
          each outputAngles=outputAngles)
          "Model for computing solar irradiation and properties of predefined set of tilted surfaces"
          annotation (Placement(transformation(extent={{40,60},{60,80}})));

        Modelica.Blocks.Sources.RealExpression TskyPow4Expr(y=Tsky^4)
          "Power 4 of sky temperature"
          annotation (Placement(transformation(extent={{-20,94},{0,114}})));
        Modelica.Blocks.Sources.RealExpression TePow4Expr(y=Te^4)
          "Power 4 of ambient temperature"
          annotation (Placement(transformation(extent={{-20,106},{0,126}})));
        Modelica.Blocks.Sources.RealExpression hConExpr(y=hCon)
          "Exterior convective heat transfer coefficient"
          annotation (Placement(transformation(extent={{60,-14},{80,6}})));
        Modelica.Blocks.Sources.RealExpression TdesExpr(y=Tdes)
          "Expression for design temperature"
          annotation (Placement(transformation(extent={{60,0},{80,20}})));

        Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=10e6)
          "Fixed temperature";
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a Qgai
          "Thermal gains in model"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
        IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.EnergyPort E
          "Model internal energy"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));

        Modelica.Blocks.Sources.RealExpression CEnv(y=ppmCO2*MMFraction/1e6)
          "Concentration of trace substance in surroundings"
          annotation (Placement(transformation(extent={{60,-30},{80,-10}})));

        input IDEAS.Buildings.Components.Interfaces.WindowBus[nWindow] winBusOut(
            each nLay=nLayWin) if createOutputs
          "Bus for windows in case of linearisation";
        Modelica.Blocks.Routing.RealPassThrough solTim
          "Solar time"
          annotation (Placement(transformation(extent={{-86,-2},{-78,6}})));
        IDEAS.BoundaryConditions.WeatherData.Bus weaDatBus
          "Weather data bus connectable to weaBus connector from Buildings Library"
          annotation (Placement(transformation(extent={{-110,-20},{-90,0}}),
              iconTransformation(
              extent={{-20,-19},{20,19}},
              rotation=270,
              origin={99,3.55271e-015})));

    protected
        final parameter Integer yr=2014 "depcited year for DST only";

        final constant Real MMFraction=1.528635
          "Molar mass of CO2 divided by the molar mass of moist air";
        IDEAS.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
          filNam=filNam)
          annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
        IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.RelativeAirMass
          relativeAirMass "Computation of relative air mass"
          annotation (Placement(transformation(extent={{-60,60},{-40,80}})));
        IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.SkyBrightness
          skyBrightness "Computation of sky brightness"
          annotation (Placement(transformation(extent={{-30,60},{-10,80}})));
        IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.SkyClearness skyClearness
          "Computation of sky clearness"
          annotation (Placement(transformation(extent={{-60,100},{-40,120}})));

        IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.BrighteningCoefficient
          skyBrightnessCoefficients
          "Computation of sky brightness coefficients F1 and F2"
          annotation (Placement(transformation(extent={{0,80},{20,100}})));
        Modelica.Blocks.Sources.RealExpression TGround(y=TdesGround)
          annotation (Placement(transformation(extent={{60,-44},{80,-24}})));
        Modelica.Blocks.Sources.RealExpression u_dummy(y=1)
          annotation (Placement(transformation(extent={{60,-58},{80,-38}})));
        Modelica.Blocks.Routing.RealPassThrough solHouAng "Solar hour angle"
          annotation (Placement(transformation(extent={{-86,66},{-78,74}})));
        Modelica.Blocks.Routing.RealPassThrough solDec "Solar declination angle"
          annotation (Placement(transformation(extent={{-86,52},{-78,60}})));
        Modelica.Blocks.Routing.RealPassThrough HDirNor "Beam solar irradiation"
          annotation (Placement(transformation(extent={{-86,40},{-78,48}})));
        Modelica.Blocks.Routing.RealPassThrough phiEnv "Relative humidity"
          annotation (Placement(transformation(extent={{-86,12},{-78,20}})));
        Modelica.Blocks.Routing.RealPassThrough TDryBul "Dry bulb air temperature"
          annotation (Placement(transformation(extent={{-86,26},{-78,34}})));
        Modelica.Blocks.Routing.RealPassThrough angZen "Solar zenith angle"
          annotation (Placement(transformation(extent={{-86,80},{-78,88}})));
        Modelica.Blocks.Routing.RealPassThrough HGloHor
          "Global/total solar irradiation on a horizontal plane"
          annotation (Placement(transformation(extent={{-86,108},{-78,116}})));
        Modelica.Blocks.Routing.RealPassThrough HDifHor
          "Diffuse solar irradiation on a horizontal plane"
          annotation (Placement(transformation(extent={{-86,94},{-78,102}})));

      initial equation
        if not linearise and computeConservationOfEnergy then
          Etot = 0;
        end if;
      equation
        if strictConservationOfEnergy and computeConservationOfEnergy then
          assert(abs(Etot) < Emax, "Conservation of energy violation > Emax J!");
        end if;

        if not linearise and computeConservationOfEnergy then
          der(Qint) = Qgai.Q_flow;
        else
          Qint = 0;
        end if;
        Etot = Qint - E.E;
        E.Etot = Etot;

        connect(skyClearness.skyCle, skyBrightnessCoefficients.skyCle) annotation (
            Line(
            points={{-39,110},{-36,110},{-36,96},{-2,96}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyBrightness.skyBri, skyBrightnessCoefficients.skyBri) annotation (
            Line(
            points={{-9,70},{-8,70},{-8,90},{-2,90}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(relativeAirMass.relAirMas, skyBrightness.relAirMas) annotation (Line(
            points={{-39,70},{-38,70},{-38,74},{-32,74}},
            color={0,0,127},
            smooth=Smooth.None));

        for i in 1:numIncAndAziInBus loop
          connect(solTim.y, radSol[i].solTim) annotation (Line(points={{-77.6,2},{18,2},
                  {18,74},{38,74},{38,73},{39.6,73}},   color={0,0,127}));
          connect(solHouAng.y, radSol[i].angHou) annotation (Line(points={{-77.6,70},{
                  -74,70},{-74,48},{30,48},{30,68},{39.6,68}}, color={0,0,127}));
          connect(angZen.y, radSol[i].angZen) annotation (Line(points={{-77.6,84},{-68,
                  84},{-68,54},{32,54},{32,66},{39.6,66}}, color={0,0,127}));
          connect(solDec.y, radSol[i].angDec) annotation (Line(points={{-77.6,56},{-76,
                  56},{-76,46},{28,46},{28,70},{39.6,70}}, color={0,0,127}));
          connect(radSol[i].solDirPer,HDirNor. y) annotation (Line(points={{39.6,80},{
                  22,80},{22,44},{-77.6,44}}, color={0,0,127}));
          connect(radSol[i].solDifHor,HDifHor. y) annotation (Line(points={{39.6,76},{
                  26,76},{26,52},{-70,52},{-70,98},{-77.6,98}}, color={0,0,127}));
          connect(HGloHor.y, radSol[i].solGloHor) annotation (Line(points={{-77.6,112},
                  {-72,112},{-72,50},{24,50},{24,78},{39.6,78}}, color={0,0,127}));
          connect(radSol[i].F2, skyBrightnessCoefficients.F2) annotation (Line(points={{39.6,60},
                  {28,60},{28,86},{21,86}},         color={0,0,127}));
          connect(radSol[i].F1, skyBrightnessCoefficients.F1) annotation (Line(points={{39.6,62},
                  {26,62},{26,94},{21,94}},         color={0,0,127}));
          connect(TskyPow4Expr.y, radSol[i].TskyPow4) annotation (Line(points={{1,104},
                  {48,104},{48,80.6}}, color={0,0,127}));
          connect(TePow4Expr.y, radSol[i].TePow4) annotation (Line(points={{1,116},{54,
                  116},{54,80.6}},               color={0,0,127}));
        end for;
        if not lineariseDymola then
          connect(solTim.y, weaBus.solTim) annotation (Line(points={{-77.6,2},{18,2},{
                18,36},{100.05,36},{100.05,40.05}}, color={0,0,127}));
          connect(angZen.y, weaBus.angZen) annotation (Line(
            points={{-77.6,84},{-68,84},{-68,54},{100.05,54},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(solHouAng.y, weaBus.angHou) annotation (Line(
              points={{-77.6,70},{-74,70},{-74,48},{100.05,48},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(solDec.y, weaBus.angDec) annotation (Line(
              points={{-77.6,56},{-76,56},{-76,46},{100.05,46},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HGloHor.y, weaBus.solGloHor) annotation (Line(
              points={{-77.6,112},{-72,112},{-72,50},{100.05,50},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDifHor.y, weaBus.solDifHor) annotation (Line(
              points={{-77.6,98},{-70,98},{-70,40.05},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirNor.y, weaBus.solDirPer) annotation (Line(
              points={{-77.6,44},{100.05,44},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(phiEnv.y, weaBus.phi) annotation (Line(points={{-77.6,16},{-70,16},{
                -70,42},{100.05,42},{100.05,40.05}},
                                                   color={0,0,127}));
          connect(TDryBul.y, weaBus.Te) annotation (Line(points={{-77.6,30},{100.05,30},
                {100.05,40.05}}, color={0,0,127}));
          connect(CEnv.y, weaBus.CEnv) annotation (Line(points={{81,-20},{100.05,-20},
                  {100.05,40.05}},
                               color={0,0,127}));
          connect(XiEnv.X[1], weaBus.X_wEnv) annotation (Line(points={{1,30},{100.05,30},
                  {100.05,40.05}},                             color={0,0,127}));
          connect(TdesExpr.y, weaBus.Tdes) annotation (Line(
            points={{81,10},{100.05,10},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(u_dummy.y, weaBus.dummy) annotation (Line(points={{81,-48},{100.05,-48},
                  {100.05,40.05}},          color={0,0,127}));
          connect(TGround.y, weaBus.TGroundDes) annotation (Line(points={{81,-34},{100.05,
                  -34},{100.05,40.05}},    color={0,0,127}));
          connect(hConExpr.y, weaBus.hConExt) annotation (Line(
            points={{81,-4},{100.05,-4},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(XiEnv.X[1], weaDatBus.X_wEnv) annotation (Line(points={{1,30},{-100,
                  30},{-100,-10}},                             color={0,0,127}));
          connect(skyBrightnessCoefficients.F1, weaBus.F1) annotation (Line(
            points={{21,94},{26,94},{26,38},{100.05,38},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(skyBrightnessCoefficients.F2, weaBus.F2) annotation (Line(
            points={{21,86},{28,86},{28,34},{100.05,34},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(TskyPow4Expr.y, weaBus.TskyPow4) annotation (Line(
            points={{1,104},{100.05,104},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(TePow4Expr.y, weaBus.TePow4) annotation (Line(
            points={{1,116},{100.05,116},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          for i in 1:numIncAndAziInBus loop
            connect(radSol[i].solBus, weaBus.solBus[i]) annotation (Line(
            points={{60,70},{100.05,70},{100.05,40.05}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
          end for;
         end if;
        connect(fixedTemperature.port, Qgai)
          annotation (Line(points={{0,-92},{0,-100}},          color={191,0,0}));

        connect(TDryBul.y, XiEnv.T) annotation (Line(
            points={{-77.6,30},{-22,30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(phiEnv.y, XiEnv.phi) annotation (Line(
            points={{-77.6,16},{-22,16},{-22,24}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyBrightnessCoefficients.zen, angZen.y)
          annotation (Line(points={{-2,84},{-77.6,84}}, color={0,0,127}));
        connect(skyBrightness.HDifHor,HDifHor. y) annotation (Line(points={{-32,66},{-70,
                66},{-70,98},{-77.6,98}}, color={0,0,127}));
        connect(relativeAirMass.zen, angZen.y) annotation (Line(points={{-62,70},{-68,
                70},{-68,84},{-77.6,84}}, color={0,0,127}));
        connect(skyClearness.zen, angZen.y) annotation (Line(points={{-62,104},{-68,104},
                {-68,84},{-77.6,84}}, color={0,0,127}));
        connect(skyClearness.HDifHor,HDifHor. y) annotation (Line(points={{-62,110},{-70,
                110},{-70,98},{-77.6,98}},color={0,0,127}));
        connect(skyClearness.HGloHor,HGloHor. y) annotation (Line(points={{-62,116},{-72,
                116},{-72,112},{-77.6,112}},color={0,0,127}));
        connect(solTim.u, weaDatBus.solTim)
          annotation (Line(points={{-86.8,2},{-100,2},{-100,-10}},color={0,0,127}));
        connect(angZen.u, weaDatBus.solZen) annotation (Line(points={{-86.8,84},{-100,
                84},{-100,-10}},color={0,0,127}));
        connect(HDifHor.u, weaDatBus.HDifHor) annotation (Line(points={{-86.8,98},{
                -100,98},{-100,-10}},
                                color={0,0,127}));
        connect(HGloHor.u, weaDatBus.HGloHor) annotation (Line(points={{-86.8,112},{
                -100,112},{-100,-10}},
                                 color={0,0,127}));
        connect(HDirNor.u, weaDatBus.HDirNor) annotation (Line(points={{-86.8,44},{
                -100,44},{-100,-10}},
                                color={0,0,127}));
        connect(solDec.u, weaDatBus.solDec) annotation (Line(points={{-86.8,56},{-100,
                56},{-100,-10}},color={0,0,127}));
        connect(solHouAng.u, weaDatBus.solHouAng) annotation (Line(points={{-86.8,70},
                {-100,70},{-100,-10}},color={0,0,127}));
        connect(TDryBul.u, weaDatBus.TDryBul) annotation (Line(points={{-86.8,30},{
                -100,30},{-100,-10}},
                                color={0,0,127}));
        connect(phiEnv.u, weaDatBus.relHum) annotation (Line(points={{-86.8,16},{-100,
                16},{-100,-10}},color={0,0,127}));
        connect(weaDat.weaBus, weaDatBus) annotation (Line(
            points={{-80,-50},{-80,-40},{-80,-10},{-100,-10}},
            color={255,204,51},
            thickness=0.5));
        connect(CEnv.y, weaDatBus.CEnv) annotation (Line(points={{81,-20},{82,-20},{
                82,-10},{40,-10},{40,-10},{-100,-10}}, color={0,0,127}));
          annotation (
          defaultComponentName="sim",
          defaultComponentPrefixes="inner",
          missingInnerMessage=
              "Your model is using an outer \"sim\" component. An inner \"sim\" component is not defined. For simulation drag IDEAS.BoundaryConditions.SimInfoManager into your model.",
          Icon(graphics={
              Line(points={{-80,-30},{88,-30}}, color={0,0,0}),
              Line(points={{-76,-68},{-46,-30}}, color={0,0,0}),
              Line(points={{-42,-68},{-12,-30}}, color={0,0,0}),
              Line(points={{-8,-68},{22,-30}}, color={0,0,0}),
              Line(points={{28,-68},{58,-30}}, color={0,0,0}),
              Rectangle(
                extent={{-60,76},{60,-24}},
                lineColor={95,95,95},
                fillPattern=FillPattern.Solid,
                fillColor={95,95,95}),
              Rectangle(
                extent={{-50,66},{50,-4}},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                pattern=LinePattern.None),
              Rectangle(
                extent={{-10,-34},{10,-24}},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{-40,-60},{-40,-60}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-40,-34},{40,-34},{50,-44},{-52,-44},{-40,-34}},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{44,0},{38,40}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{34,0},{28,12}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{24,0},{18,56}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{14,0},{8,36}},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{4,0},{-2,12}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Line(
                points={{-6,0},{-46,0}},
                color={0,0,127},
                smooth=Smooth.None),
              Text(
                extent={{-50,66},{-20,26}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                textStyle={TextStyle.Italic},
                fontName="Bookman Old Style",
                textString="i")}),
          Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  120}})),
          Documentation(info="<html>
</html>",       revisions="<html>
<ul>
<li>
January 25, 2019 by Filip Jorissen:<br/>
Corrected molar mass fraction for consistency.
See <a href=https://github.com/open-ideas/IDEAS/issues/1004>#1004</a>.
</li>
<li>
April 10, 2019 by Filip Jorissen:<br/>
Avoided redundant consistent initial equation for <code>Etot</code>.
See <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added outputs <code>CEnv</code> and <code>X_wEnv</code> to <code>weaDatBus</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
June 21, 2018, by Damien Picard:<br/>
Reduce the icon size of weaBus to something very small such that users would
not try to connect to it.
Rename and make public the connector weaDatBus such that it can be connected 
to models from the Buildings library.
</li>
<li>
June 12, 2018, by Filip Jorissen:<br/>
Refactored implementation such that we use more computations from the weather
data reader instead of computing them ourself using equations.
</li>
<li>
June 11, 2018, by Filip Jorissen:<br/>
Revised implementation such that longitude, latitude and time zone are read from
the TMY3 weather file.
Removed split between file path and file name to avoid confusion
and incorrectly formatted paths.
</li>
<li>
June 11, 2018, by Filip Jorissen:<br/>
Changed table name of TMY3 file from 'data' to IBPSA final default 'tab1'
for issue <a href=https://github.com/open-ideas/IDEAS/issues/808>#808</a>.
</li>
<li>
June 8, 2018, by Filip Jorissen:<br/>
Moved input TMY3 file.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/821>#821</a>.
</li>
<li>
June 7, 2018 by Filip Jorissen:<br/>
Created 'input' for TSky, Va and Fc such that
they can be overwriten from the extends clause.
This is for
<a href=\"https://github.com/open-ideas/IDEAS/issues/838\">#838</a>.
</li>
<li>
March 27, 2018, by Filip Jorissen:<br/>
Added relative humidity to weather bus.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/780>#780</a>.
</li>
<li>
January 26, 2018, by Filip Jorissen:<br/>
Added floor orientation to set of precomputed boundary conditions.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/764>#764</a>.
</li>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Added <code>solTim</code> connections for revised azimuth computations.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed linearisation implementation for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
January 10, 2017 by Filip Jorissen:<br/>
Set <code>linExtRad = false</code>
and added new parameter <code>linExtRadWin = true</code>
since only for windows is it necessary that
<code>linExtRad</code> is true.
See <a href=https://github.com/open-ideas/IDEAS/issues/615>#615</a>.
</li>
<li>
September 22, 2016 by Filip Jorissen:<br/>
Reworked implementation such that we use Annex 60 
baseclasses for boundary condition computations.
</li>
<li>
March 25, 2016 by Filip Jorissen:<br/>
Reworked radSol implementation to use RealInputs instead of weaBus.
This simplifies translation and interpretation.
Also cleaned up connections.
</li>
<li>
January 29, 2015, Filip Jorissen:<br/>
Made changes for allowing a proper implementation of <code>airLeakage</code>.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
      end PartialSimInfoManager;
    end Interfaces;

    model SimInfoManager
      "Simulation information manager for handling time and climate data required in each for simulation."
      extends BoundaryConditions.Interfaces.PartialSimInfoManager;

  protected
      Modelica.Blocks.Routing.RealPassThrough HDirNorData;
      Modelica.Blocks.Routing.RealPassThrough HGloHorData;
      Modelica.Blocks.Routing.RealPassThrough HDiffHorData;
      Modelica.Blocks.Routing.RealPassThrough TDryBulData;
      Modelica.Blocks.Routing.RealPassThrough relHumData;
      Modelica.Blocks.Routing.RealPassThrough TDewPoiData;
      Modelica.Blocks.Routing.RealPassThrough nOpaData;
      Modelica.Blocks.Routing.RealPassThrough winSpeData;
      Modelica.Blocks.Routing.RealPassThrough TBlaSkyData;
    equation
      Te = TDryBul.y;
      TeAv = Te;
      Tground=TdesGround;
      relHum = phiEnv.y;
      TDewPoi = TDewPoiData.y;
      Tsky = TBlaSkyData.y;
      Va = winSpeData.y;

      connect(HDirNorData.u, weaDatBus.HDirNor);
      connect(HGloHorData.u, weaDatBus.HGloHor);
      connect(HDiffHorData.u, weaDatBus.HDifHor);
      connect(TDryBulData.u, weaDatBus.TDryBul);
      connect(relHumData.u, weaDatBus.relHum);
      connect(TDewPoiData.u, weaDatBus.TDewPoi);
      connect(nOpaData.u, weaDatBus.nOpa);
      connect(winSpeData.u, weaDatBus.winSpe);
      connect(TBlaSkyData.u, weaDatBus.TBlaSky);
      annotation (
        defaultComponentName="sim",
        defaultComponentPrefixes="inner",
        missingInnerMessage=
            "Your model is using an outer \"sim\" component. An inner \"sim\" component is not defined. For simulation drag IDEAS.BoundaryConditions.SimInfoManager into your model.",
        Icon(graphics={
            Bitmap(extent={{22,-8},{20,-8}}, fileName="")}),
        Diagram(graphics,
                coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}})),
        Documentation(info="<html>
<p>
The SimInfoManager manages all simulation information. 
It loads TMY3 weather data files and applies transformations 
for computing the solar irradiance on the zone surfaces. 
</p>
<h4>Typical use and important parameters</h4>
<ul>
<li>
Parameters <code>filNam</code> and <code>filDir</code> can be used to set the path to the TMY3 weather file.
This file should include the latitude, longitude and time zone corresponding to the weather file.
See the included weather files for the correct format.
</li>
</ul>
<h4>Options</h4>
<ul>
<li>
IDEAS contains an efficient implementation for computing the solar 
incidence angles on surfaces that are part of large building models.
When a model has many parallel surfaces the default implementation computes
the solar irradiance separately for each of these surfaces, 
while the result for all of them should be the same.
The SimInfoManager computes five default orientations (azimuth angels): 
south, west, east, north and horizontal.
Whenever a surface needs the solar incidence angels for one of these orientations
these precomputed values will be used.
The default orientations can be changed using parameters 
<code>incAndAziInBus</code>.
<code>incAndAziInBus</code> determines for which inclination and azimuth the solar radiation is pre-computed.
</li>
<li>Conservation of energy within the building can be checked by setting <code>computeConservationOfEnergy=true</code>.
Conservation of energy is checked by computing the internal energy for 
all components that are within \"the system\" and by adding to this the 
integral of all heat flows entering/leaving the system.
There are two options for choosing the extent of the system based 
on parameter <code>openSystemConservationOfEnergy</code>. 
Either conservation of energy for a closed system is computed, 
or it is computed for an open system. <br/>
When choosing the closed system the conservation of energy 
check should always work when using IDEAS as intended. 
In this case conservation of energy is only checked for all components in the <code>Buildings</code> package. 
I.e. all heat flows at embedded ports <code>port_emb</code> of walls, 
fluid ports of the zones, <code>zone.gainCon</code> and <code>zone.gainRad</code> are 
considered to be a heat gain to the system and every other component 
is considered to be outside of the system for which conservation of energy is checked. <br/>
When computing an open system by setting <code>openSystemConservationOfEnergy=true</code> 
these heat flow rates are not taken into account because they are assumed 
to flow between components that are both within the bounds of the system.
The user then needs to choose how large the system is and he should make sure that
all heat flow rates entering the system are added to <code>sim.Qgai.Q_flow</code> and 
that all internal energy of the system is added to <code>sim.E.E</code>.
</li>
<li>
The default latitude and longitude, which are read by the TMY3 reader, can be overwritten. 
This should only be done if a custom weather data reader instead 
of the TMY3 weather data reader is used.
</li>
</ul>
<h4>TMY3 weather data files</h4>
IDEAS uses TMY3 input files. For detailed documentation see 
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.ReaderTMY3\">IDEAS.BoundaryConditions.WeatherData.ReaderTMY3</a>.
</html>",     revisions="<html>
<ul>
<li>
January 21, 2019 by Filip Jorissen:<br/>
Improved documentation by adding weather data reader
reference and more TMY3 file examples.
This is for
<a href=\"https://github.com/open-ideas/IDEAS/issues/956\">#956</a>.
</li>
<li>
June 7, 2018 by Filip Jorissen:<br/>
Overwriting TSky, Va and Fc from the extends clause
such that they can be overwriten again in BESTEST SimInfoManager.
This is for
<a href=\"https://github.com/open-ideas/IDEAS/issues/838\">#838</a>.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Added documentation
</li>
</ul>
</html>"));
    end SimInfoManager;

    package SkyTemperature "Package with models to compute the sky temperature"
      extends Modelica.Icons.VariantsPackage;

      block BlackBody "Calculate black body sky temperature"
        extends Modelica.Blocks.Icons.Block;
        parameter IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation calTSky=
          IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Computation of black-body sky temperature"
          annotation(choicesAllMatching=true,
                     Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dry bulb temperature at ground level"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput TDewPoi(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dew point temperature"
          annotation (Placement(transformation(extent={{-140,10},{-100,50}})));
        Modelica.Blocks.Interfaces.RealInput nOpa( min=0, max=1, unit="1")
          "Opaque sky cover [0, 1]"
          annotation (Placement(transformation(extent={{-140,-50},{-100,-10}})));
        Modelica.Blocks.Interfaces.RealOutput TBlaSky(
          final quantity="ThermodynamicTemperature",
          displayUnit="degC",
          final unit="K") "Black-body sky temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput HHorIR(
          unit="W/m2",
          min=0,
          nominal=100) "Horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
    protected
        Modelica.SIunits.Temperature TDewPoiK "Dewpoint temperature";
        Modelica.SIunits.Emissivity epsSky "Black-body absorptivity of sky";
        Real nOpa10(min=0, max=10) "Opaque sky cover in [0, 10]";
      equation
        if calTSky == IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover then
          TDewPoiK =  IDEAS.Utilities.Math.Functions.smoothMin(TDryBul, TDewPoi, 0.1);
          nOpa10 =  10*nOpa "Input nOpa is scaled to [0,1] instead of [0,10]";
          epsSky =  (0.787 + 0.764*Modelica.Math.log(-TDewPoiK/Modelica.Constants.T_zero))*(1 + 0.0224*nOpa10 -
            0.0035*(nOpa10^2) + 0.00028*(nOpa10^3));
          TBlaSky =  TDryBul*(epsSky^0.25);
        else
          TDewPoiK =  273.15;
          nOpa10   =  0.0;
          epsSky   =  0.0;
          TBlaSky  =  (HHorIR/Modelica.Constants.sigma)^0.25;
        end if;
        annotation (
          defaultComponentName="TBlaSky",
          Documentation(info="<html>
<p>
This component computes the black-body sky temperature.
</p>
<p>
For <code>calTSky = 0</code>, the model uses horizontal infrared irradiation.
Otherwise, it uses dry buld temperature, dew point temperature and opaque sky cover.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2017, by Michael Wetter:<br/>
Removed <code>import</code> statement.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/852\">#852</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed unit and comment of input <code>nOpa</code> for correct display of units
in <code>weaBus</code> and input <code>radHorIR</code> to <code>HHorIR</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code>.
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Used enumeration to set the sky temperature computation.
Fixed error in <code>if-then</code> statement that led to
a selection of the wrong branch to compute the sky temperature.
</li>
<li>
March 16, 2011, by Michael Wetter:<br/>
Added types for parameters and attributes for variables.
Removed default parameter value.
</li>
<li>
March 15, 2011, by Wangda Zuo:<br/>
Use <code>smoothMin()</code> instead of <code>min()</code>.
</li>
<li>
June 1, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-50,44},{56,-40}},
                lineColor={0,0,255},
                textString="T"),
              Text(
                extent={{-96,84},{-66,74}},
                lineColor={0,0,127},
                textString="TDry"),
              Text(
                extent={{-90,36},{-66,24}},
                lineColor={0,0,127},
                textString="TDewPoi"),
              Text(
                extent={{-92,-74},{-62,-88}},
                lineColor={0,0,127},
                textString="radHorIR"),
              Text(
                extent={{16,-6},{54,-28}},
                lineColor={0,0,255},
                textString="bs"),
              Text(
                extent={{-88,-24},{-64,-36}},
                lineColor={0,0,127},
                textString="nOpa")}));
      end BlackBody;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the black body sky temperature.
</html>"));
    end SkyTemperature;

    package SolarGeometry "Package with models to compute solar geometry"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Package with base classes for IDEAS.BoundaryConditions.SolarGeometry"
        extends Modelica.Icons.BasesPackage;

        block AltitudeAngle "Solar altitude angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
            "Zenith angle"
        annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput alt(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar altitude angle"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          alt = (Modelica.Constants.pi/2) - zen;
          annotation (Icon(graphics={Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/AltitudeAngle.png")}),
            defaultComponentName="altAng", Documentation(info="<html>
<p>
This block computes the altitude angle of the sun with respect to a horizontal surface.
The altitude angle is the angle between the sun ray and the projection of the ray
on a horizontal surface.
It is the complementory angle to the zenith angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the output connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak:<br/>
First implementation.
</li>
</ul>
</html>"));
        end AltitudeAngle;

        block Declination "Declination angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nDay(quantity="Time", unit="s")
            "Day number with units of seconds"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput decAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar declination angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          constant Real k1 = sin(23.45*2*Modelica.Constants.pi/360) "Constant";
          constant Real k2 = 2*Modelica.Constants.pi/365.25 "Constant";
        equation
          decAng = Modelica.Math.asin(-k1 * Modelica.Math.cos((nDay/86400 + 10)*k2))
            "(A4.5)";
          annotation (
            defaultComponentName="decAng",
            Documentation(info="<html>
<p>
This component computes the solar declination, which is
the angle between the equatorial plane and the solar beam.
The input signal <code>nDay</code> is the one-based number of the day, but in seconds.
Hence, during January 1, we should have <code>nDay = 86400</code> seconds.
Since the effect of using a continuous number rather than an integer is small,
we approximate this so that <code>nDay = 0</code> at the start of January 1,
and <code>nDay = 86400</code> at the end of January 1.
</p>
<h4>Validation</h4>
<p>
A validation with a more detailed calculation can be found at
<a href=\"modelica://IDEAS.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination\">
IDEAS.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 6, 2015, by Michael Wetter:<br/>
Updated documentation and added validation.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/382\">issue 382</a>.
</li>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of output signal as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
November 11, 2015, by Michael Wetter:<br/>
Corrected typo in documentation.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/Declination.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end Declination;

        block IncidenceAngle "The solar incidence angle on a tilted surface"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle lat "Latitude";
          parameter Modelica.SIunits.Angle azi(displayUnit="deg")
            "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south";
          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
            "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Declination"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}})));
          Modelica.Blocks.Interfaces.RealOutput incAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Incidence angle on a tilted surface"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real dec_c=Modelica.Math.cos(decAng) "Cosine of declination angle";
          Real dec_s=Modelica.Math.sin(decAng) "Sine of declination angle";
          Real sol_c=Modelica.Math.cos(solHouAng) "Cosine of solar hour angle";
          Real sol_s=Modelica.Math.sin(solHouAng) "Sine of solar hour angle";
          Real lat_c=Modelica.Math.cos(lat) "Cosine of latitude";
          Real lat_s=Modelica.Math.sin(lat) "Sine of latitude";
        equation
          incAng = Modelica.Math.acos(Modelica.Math.cos(til)*(dec_c*sol_c*lat_c + dec_s
            *lat_s) + Modelica.Math.sin(til)*(Modelica.Math.sin(azi)*dec_c*sol_s +
            Modelica.Math.cos(azi)*(dec_c*sol_c*lat_s - dec_s*lat_c))) "(A.4.13)";
          annotation (
            defaultComponentName="incAng",
            Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface using the solar hour angle and the declination angle as input.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/IncidenceAngle.png"),
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,60},{-56,50}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-42},{-42,-54}},
                  lineColor={0,0,127},
                  textString="solHouAng")}));
        end IncidenceAngle;

        block SolarAzimuth "Solar azimuth"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle lat "Latitude";
          Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
            "Zenith angle"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
            "Solar time" annotation (Placement(transformation(extent={{-140,-80},{-100,
                    -40}}), iconTransformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealOutput solAzi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar Azimuth"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Declination angle"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
      protected
          Real arg "cos(solAzi) after data validity check";
          Real tmp "cos(solAzi) before data validity check";
          Real solAziTem "Temporary variable for solar azimuth";
          constant Modelica.SIunits.Time day=86400 "Number of seconds in a day";
          constant Modelica.SIunits.Angle polarCircle = 1.1617
            "Latitude of polar circle (66 degree 33 min 44 sec)";
          final parameter Boolean outsidePolarCircle = lat < polarCircle and lat > -polarCircle
            "Flag, true if latitude is outside polar region";
        equation
          tmp = (Modelica.Math.sin(lat)*Modelica.Math.cos(zen) - Modelica.Math.sin(
            decAng))/(Modelica.Math.cos(lat)*Modelica.Math.sin(zen));
          arg = min(1.0, max(-1.0, tmp));
          solAziTem =  Modelica.Math.acos(arg); // Solar azimuth (A4.9a and b) as a positive number
          if outsidePolarCircle then
            // Outside the polar circle, the only non-differentiability is at night when the sun is set.
            // Hence, we use noEvent.
            if noEvent(solTim - integer(solTim/day)*day < 43200) then
              solAzi =-solAziTem;
            else
              solAzi = solAziTem;
            end if;
          else
            // Inside the polar circle, there is a jump at (solar-)midnight when the sun can
            // be above the horizon. Hence, we do not use noEvent(...)
            if solTim - integer(solTim/day)*day < 43200 then
              solAzi =-solAziTem;
            else
              solAzi = solAziTem;
            end if;
          end if;
          annotation (
            defaultComponentName="solAzi",
            Documentation(info="<html>
<p>
This component computes the solar azimuth angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 13, 2017, by Michael Wetter:<br/>
Reformulated to use equation rather than algorithm section.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/834\">issue 834</a>.
</li>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed model to avoid an event at solar noon.
</li>
<li>
February 28, 2012, by Wangda Zuo:<br/>
Add solar time conversion since it is removed from <code>solTim</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarAzimuth.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-100,68},{-58,58}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{-102,-54},{-60,-64}},
                  lineColor={0,0,127},
                  textString="solTim"),
                Text(
                  extent={{-102,6},{-60,-4}},
                  lineColor={0,0,127},
                  textString="decAng")}));
        end SolarAzimuth;

        block SolarHourAngle "Solar hour angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
            "Solar time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput solHouAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar hour angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solHouAng = (solTim/3600 - 12)*2*Modelica.Constants.pi/24
            "Our unit is s instead of h in (A4.6)";
          annotation (
            defaultComponentName="solHouAng",
            Documentation(info="<html>
<p>
This component computes the solar hour angle,
which is defined as the angle between the circle
that passes through an observer, the north pole and the south pole,
and the circle that passes through the sun, the north and the south pole.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarHourAngle.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end SolarHourAngle;

        block ZenithAngle "Zenith angle"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle lat "Latitude";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
            "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Solar declination angle"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}}),
                iconTransformation(extent={{-140,34},{-100,74}})));
          Modelica.Blocks.Interfaces.RealOutput zen(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Zenith angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          zen =  Modelica.Math.acos(Modelica.Math.cos(lat)*Modelica.Math.cos(decAng)*
            Modelica.Math.cos(solHouAng) + Modelica.Math.sin(lat)*Modelica.Math.sin(
            decAng)) "(A4.8)";
          annotation (
            defaultComponentName="zen",
            Documentation(info="<html>
<p>
This component computes the zenith angle, which is the angle between the earth surface normal and the sun's beam.
Input are the solar hour angle and the declination angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the input connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-86,-88},{94,92}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/ZenithAngle.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,62},{-46,46}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-40},{-22,-58}},
                  lineColor={0,0,127},
                  textString="solHouAng")}));
        end ZenithAngle;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.BoundaryConditions.SolarGeometry\">IDEAS.BoundaryConditions.SolarGeometry</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the solar geometry and incidence
angles on tilted surfaces.
</html>"));
    end SolarGeometry;

    package SolarIrradiation "Package with models to compute solar irradition"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Package with base classes for IDEAS.BoundaryConditions.SolarIrradiation"
        extends Modelica.Icons.BasesPackage;

        block BrighteningCoefficient "Circumsolar and horizon brightening coefficients"
          extends Modelica.Blocks.Icons.Block;
          import H = IDEAS.Utilities.Math.Functions.regStep;
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput skyCle
            "Sky clearness. skyCle=1: overcast sky; skyCle=8 clear sky"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput skyBri "Sky brightness [0,1]"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput F1
            "Circumsolar brightening coefficient"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));
          Modelica.Blocks.Interfaces.RealOutput F2 "Horizon brightening coefficient"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
      protected
          Real F11;
          Real F12;
          Real F13;
          Real F21;
          Real F22;
          Real F23;
          Real d=0.01;
          Real a1;
          Real a2;
          Real a3;
          Real a4;
          Real a5;
          Real a6;
          Real a7;
          Real a8;
          Real b1;
          Real b2;
          Real b3;
          Real b4;
          Real b5;
          Real b6;
          Real b7;
          Real b8;
        equation
          b1 = H(
            y1=1,
            y2=0,
            x=1.065 - skyCle,
            x_small=d);
          b2 = H(
            y1=1,
            y2=0,
            x=1.23 - skyCle,
            x_small=d);
          b3 = H(
            y1=1,
            y2=0,
            x=1.50 - skyCle,
            x_small=d);
          b4 = H(
            y1=1,
            y2=0,
            x=1.95 - skyCle,
            x_small=d);
          b5 = H(
            y1=1,
            y2=0,
            x=2.80 - skyCle,
            x_small=d);
          b6 = H(
            y1=1,
            y2=0,
            x=4.50 - skyCle,
            x_small=d);
          b7 = H(
            y1=1,
            y2=0,
            x=6.20 - skyCle,
            x_small=d);
          b8 = H(
            y1=1,
            y2=0,
            x=skyCle - 6.20,
            x_small=d);
          a1 = b1;
          a2 = b2 - b1;
          a3 = b3 - b2;
          a4 = b4 - b3;
          a5 = b5 - b4;
          a6 = b6 - b5;
          a7 = b7 - b6;
          a8 = b8;
          F11 = -0.0083117*a1 + 0.1299457*a2 + 0.3296958*a3 + 0.5682053*a4 + 0.8730280*
            a5 + 1.1326077*a6 + 1.0601591*a7 + 0.6777470*a8;
          F12 = 0.5877285*a1 + 0.6825954*a2 + 0.4868735*a3 + 0.1874525*a4 - 0.3920403*
            a5 - 1.2367284*a6 - 1.5999137*a7 - 0.3272588*a8;
          F13 = -0.0620636*a1 - 0.1513725*a2 - 0.2210958*a3 - 0.2951290*a4 - 0.3616149*
            a5 - 0.4118494*a6 - 0.3589221*a7 - 0.2504286*a8;
          F21 = -0.0596012*a1 - 0.0189325*a2 + 0.0554140*a3 + 0.1088631*a4 + 0.2255647*
            a5 + 0.2877813*a6 + 0.2642124*a7 + 0.1561313*a8;
          F22 = 0.0721249*a1 + 0.0659650*a2 - 0.0639588*a3 - 0.1519229*a4 - 0.4620442*
            a5 - 0.8230357*a6 - 1.1272340*a7 - 1.3765031*a8;
          F23 = -0.0220216*a1 - 0.0288748*a2 - 0.0260542*a3 - 0.0139754*a4 + 0.0012448*
            a5 + 0.0558651*a6 + 0.1310694*a7 + 0.2506212*a8;
          F1 = IDEAS.Utilities.Math.Functions.smoothMax(
            0,
            F11 + F12*skyBri + F13*zen,
            0.01);
          F2 = F21 + F22*skyBri + F23*zen;
          annotation (
            defaultComponentName="briCoe",
            Documentation(info="<html>
<p>
This component computes the circumsolar and horizon brightening coefficients.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
May 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-96,72},{-52,50}},
                  lineColor={0,0,127},
                  textString="skyCle"),
                Text(
                  extent={{-96,14},{-52,-8}},
                  lineColor={0,0,127},
                  textString="skyBri"),
                Text(
                  extent={{-96,-46},{-52,-68}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{62,50},{106,28}},
                  lineColor={0,0,127},
                  textString="F1"),
                Text(
                  extent={{60,-30},{104,-52}},
                  lineColor={0,0,127},
                  textString="F2")}));
        end BrighteningCoefficient;

        block DiffusePerez
          "Hemispherical diffuse irradiation on a tilted surface with Perez's anisotropic model"
          extends Modelica.Blocks.Icons.Block;
          parameter Real rho=0.2 "Ground reflectance";
          parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt angle";
          Modelica.Blocks.Interfaces.RealInput briCof1 "Brightening Coeffcient F1"
            annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
          Modelica.Blocks.Interfaces.RealInput briCof2 "Brightening Coeffcient F2"
            annotation (Placement(transformation(extent={{-140,-30},{-100,10}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Diffuse horizontal solar radiation"
            annotation (Placement(transformation(extent={{-140,30},{-100,70}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2") "Global horizontal radiation"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Solar incidence angle on the surface"
            annotation (Placement(transformation(extent={{-140,-90},{-100,-50}})));
          Modelica.Blocks.Interfaces.RealOutput HGroDifTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Hemispherical diffuse solar irradiation on a tilted surface from the ground"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
          Modelica.Blocks.Interfaces.RealOutput HSkyDifTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Hemispherical diffuse solar irradiation on a tilted surface from the sky"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));
      protected
          Real a;
          Real b;
          constant Real bMin=Modelica.Math.cos(Modelica.Constants.pi*85/180)
            "Lower bound for b";
        equation
          a = IDEAS.Utilities.Math.Functions.smoothMax(
            0,
            Modelica.Math.cos(incAng),
            0.01);
          b = IDEAS.Utilities.Math.Functions.smoothMax(
            bMin,
            Modelica.Math.cos(zen),
            0.01);
          HSkyDifTil = HDifHor*(0.5*(1 - briCof1)*(1 + Modelica.Math.cos(til)) +
            briCof1*a/b + briCof2*Modelica.Math.sin(til));
          HGroDifTil = HGloHor*0.5*rho*(1 - Modelica.Math.cos(til));
          annotation (
            defaultComponentName="HDifTil",
            Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface by using an anisotropic model proposed by Perez.
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Separated the contribution from the sky and the ground.
</li>
</ul>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,74},{-100,86}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-50,44},{-102,56}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-50,14},{-102,26}},
                  lineColor={0,0,127},
                  textString="briCof1"),
                Text(
                  extent={{-50,-16},{-102,-4}},
                  lineColor={0,0,127},
                  textString="briCof2"),
                Text(
                  extent={{-50,-46},{-102,-34}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{-52,-76},{-104,-64}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DiffusePerez;

        block DirectTiltedSurface "Direct solar irradiation on a tilted surface"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Incidence angle of the sun beam on a tilted surface"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDirNor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2") "Direct normal radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput HDirTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Direct solar irradiation on a tilted surface"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          HDirTil =  max(0, Modelica.Math.cos(incAng)*HDirNor);
          annotation (
            defaultComponentName="HDirTil",
            Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-50,56},{-102,68}},
                  lineColor={0,0,127},
                  textString="HDirNor"),
                Text(
                  extent={{-54,-66},{-106,-54}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DirectTiltedSurface;

        block RelativeAirMass "Relative air mass"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relAirMas "Relative air mass"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real zenLim "Zenith angle bounded from above by 90 degree";
          Real zenDeg "Zenith angle in degree";
        equation
          zenLim = IDEAS.Utilities.Math.Functions.smoothMin(
            zen,
            Modelica.Constants.pi/2,
            0.01);
          zenDeg = zenLim*180/Modelica.Constants.pi;
          relAirMas = 1/(Modelica.Math.cos(zenLim) + 0.15*(93.9 - zenDeg)^(-1.253));
          annotation (
            defaultComponentName="relAirMas",
            Documentation(info="<html>
<p>
This component computes the relative air mass for sky brightness.
</p>
<h4>References</h4>
R. Perez (1999).
<i>Fortran Function irrpz.f</i>,
Emailed by R. Perez to F.C. Winkelmann on May 21, 1999.<br/>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end RelativeAirMass;

        block SkyBrightness "Sky brightness"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput relAirMas "Relative air mass"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealOutput skyBri "Sky brightness"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          skyBri = IDEAS.Utilities.Math.Functions.smoothMin(
            HDifHor*relAirMas/1367,
            1,
            0.025);
          annotation (
            defaultComponentName="skyBri",
            Documentation(info="<html>
<p>
This component computes the sky brightness.
</p>
<h4>References</h4>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</html>",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-44,36},{-96,48}},
                  lineColor={0,0,127},
                  textString="relAirMas"),
                Text(
                  extent={{-44,-46},{-96,-34}},
                  lineColor={0,0,127},
                  textString="HDifHor")}));
        end SkyBrightness;

        block SkyClearness "Sky clearness"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degreeC") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal global solar radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput skyCle
            "Sky clearness. skyCle=1: overast sky; skyCle=8: clear sky"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          // Set hSmall so that hSmall + deltaX < 1E-4. See info section.
      protected
          constant Modelica.SIunits.Irradiance hSmall = 0.5e-4
            "Small radiation for regularization";
          constant Modelica.SIunits.Irradiance deltaX = hSmall/2
            "Small radiation for regularization";
          constant Real k = 5.534e-6*(180/Modelica.Constants.pi)^3 "Constant factor";
          Real tmp1 "Intermediate variable";
          Modelica.SIunits.Irradiance HDifHorBou
            "Diffuse horizontal irradiation, bounded away from zero";
        equation
          tmp1 =  k*zen^3;
          HDifHorBou = IDEAS.Utilities.Math.Functions.smoothMax(
                         x1 = HDifHor,
                         x2 = hSmall,
                         deltaX = deltaX);
          // In the Buildings library, HGloHor is always larger than 1E-4
          // (minus some small undershoot due to regularization. Hence,
          // it makes no sense to simplify the equation for
          // HGloHor < Modelica.Constants.small.
          skyCle = IDEAS.Utilities.Math.Functions.smoothLimit(
                x = (HGloHor/HDifHorBou + tmp1)/(1 + tmp1),
                l = 1,
                u = 8,
                deltaX = 0.01);
          annotation (
            defaultComponentName="skyCle",
            Documentation(info="<html>
<p>
This component computes the sky clearness.
</p>
<h4>Implementation</h4>
<p>
In the <code>IDEAS</code> library, <code>HGloHor</code>
is always larger than <i>1E-4</i>,
minus some small undershoot due to regularization. Hence,
the implementation is not simplified for
<code>HGloHor &lt; Modelica.Constants.small</code>.
</p>
<p>
The function call
<code>IDEAS.Utilities.Math.Functions.smoothMax</code>
is such that the regularization is usually not triggered.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 23, 2016, by Michael Wetter:<br/>
Changed <code>deltaX</code> from <code>0.1</code> to <code>0.01</code>,
and also optimized the code.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/521\">issue 521</a>.
</li>
<li>
May 5, 2015, by Michael Wetter:<br/>
Introduced constant <code>k</code> to reduce number of operations.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,-6},{-100,6}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-48,54},{-100,66}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-48,-66},{-100,-54}},
                  lineColor={0,0,127},
                  textString="zen")}));
        end SkyClearness;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.BoundaryConditions.SolarIrradiation\">IDEAS.BoundaryConditions.SolarIrradiation</a>.
</p>
</html>"));
      end BaseClasses;

      model RadSol "Block that computes surface-dependent environment data"
        extends Modelica.Blocks.Interfaces.BlockIcon;
        parameter Real rho=0.2 "Ground reflectance";
        parameter Modelica.SIunits.Angle inc(displayUnit="degree") "inclination";
        parameter Modelica.SIunits.Angle azi(displayUnit="degree") "azimuth";
        parameter Modelica.SIunits.Angle lat(displayUnit="degree") "latitude";
        parameter Boolean remDefVals = false "Remove default signal values";
        parameter Boolean outputAngles=true "Set to false when linearising only";
        output Buildings.Components.Interfaces.SolBus solBus(outputAngles=
              outputAngles)
          annotation (Placement(transformation(extent={{80,-20},{120,20}})));
        Modelica.Blocks.Interfaces.RealInput angZen "Zenith angle"
          annotation (Placement(transformation(extent={{-124,-60},{-84,-20}})));
        Modelica.Blocks.Interfaces.RealInput solDifHor
          "Diffuse solar irradiation on horizontal surface"
          annotation (Placement(transformation(extent={{-124,40},{-84,80}})));
        Modelica.Blocks.Interfaces.RealInput solGloHor
          "Global solar irradiation on horizontal surface"
          annotation (Placement(transformation(extent={{-124,60},{-84,100}})));
        Modelica.Blocks.Interfaces.RealInput F1 "Circumsolar brightening coefficient"
          annotation (Placement(transformation(extent={{-124,-100},{-84,-60}})));
        Modelica.Blocks.Interfaces.RealInput F2 "Horizon brightening coefficient"
          annotation (Placement(transformation(extent={{-124,-120},{-84,-80}})));
        Modelica.Blocks.Interfaces.RealInput solDirPer
          "Beam solar irradiation on surface perpendicular to beam direction"
          annotation (Placement(transformation(extent={{-124,80},{-84,120}})));
        Modelica.Blocks.Interfaces.RealInput angHou "Hour angle"
          annotation (Placement(transformation(extent={{-124,-40},{-84,0}})));
        Modelica.Blocks.Interfaces.RealInput angDec "Declination angle"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=0,
              origin={-104,0})));
        Modelica.Blocks.Interfaces.RealInput solTim "Solar time" annotation (
            Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=0,
              origin={-104,30})));
        SolarGeometry.BaseClasses.IncidenceAngle incAng(
          lat=lat,
          azi=azi,
          til=inc) "Inclination angle"
          annotation (Placement(transformation(extent={{-40,60},{-20,40}})));
        SolarIrradiation.BaseClasses.DiffusePerez HDifTil(rho=rho, til=inc)
          "Computation of diffuse solar irradiation on tilted surface"
          annotation (Placement(transformation(extent={{0,-20},{20,0}})));
    protected
        SolarIrradiation.BaseClasses.DirectTiltedSurface
                              solDirTil
          "Computation of direct solar irradiation on tilted surface"
          annotation (Placement(transformation(extent={{0,20},{20,40}})));
        Modelica.Blocks.Sources.Constant dummyValAzi(k=0) if not remDefVals
          "angAzi dummy value when not needed"
          annotation (Placement(transformation(extent={{-20,-98},{-8,-86}})));
        Modelica.Blocks.Sources.Constant dummyValTenv(k=Modelica.Constants.inf) if
                                                           not remDefVals
          "Tenv dummy value when not needed"
          annotation (Placement(transformation(extent={{-20,-76},{-8,-64}})));
      equation
        connect(angZen, solBus.angZen) annotation (Line(points={{-104,-40},{100.1,-40},
                {100.1,0.1}}, color={0,0,127}));
        connect(dummyValAzi.y, solBus.angAzi) annotation (Line(
            points={{-7.4,-92},{100.1,-92},{100.1,0.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(dummyValTenv.y, solBus.Tenv) annotation (Line(
            points={{-7.4,-70},{100.1,-70},{100.1,0.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solDirTil.HDirNor, solDirPer) annotation (Line(points={{-2,36},{-8,36},
                {-8,100},{-104,100}}, color={0,0,127}));
        connect(incAng.incAng, solBus.angInc) annotation (Line(points={{-19,50},{
                100.1,50},{100.1,0.1}}, color={0,0,127}));
        connect(incAng.decAng, angDec) annotation (Line(points={{-42.2,44.6},{-62,44.6},
                {-62,0},{-104,0}},       color={0,0,127}));
        connect(incAng.solHouAng, angHou) annotation (Line(points={{-42,54.8},{-60,54.8},
                {-60,46},{-60,-20},{-104,-20}},       color={0,0,127}));
        connect(HDifTil.HGloHor, solGloHor) annotation (Line(points={{-2,-2},{-46,-2},
                {-46,80},{-104,80}}, color={0,0,127}));
        connect(HDifTil.HDifHor, solDifHor) annotation (Line(points={{-2,-5},{-48,-5},
                {-48,60},{-104,60}}, color={0,0,127}));
        connect(HDifTil.briCof2, F2) annotation (Line(points={{-2,-11},{-48,-11},{-48,
                -32},{-48,-100},{-104,-100}}, color={0,0,127}));
        connect(HDifTil.briCof1, F1) annotation (Line(points={{-2,-8},{-50,-8},{-50,
                -80},{-104,-80}}, color={0,0,127}));
        connect(HDifTil.incAng, incAng.incAng) annotation (Line(points={{-2,-17},{-14,
                -17},{-14,50},{-19,50}}, color={0,0,127}));
        connect(HDifTil.zen, angZen) annotation (Line(points={{-2,-14},{-2,-16},{-52,
                -16},{-52,-40},{-104,-40}}, color={0,0,127}));
        connect(HDifTil.HSkyDifTil, solBus.HSkyDifTil) annotation (Line(points={{21,
                -6},{100.1,-6},{100.1,0.1}}, color={0,0,127}));
        connect(HDifTil.HGroDifTil, solBus.HGroDifTil) annotation (Line(points={{21,
                -14},{36,-14},{100.1,-14},{100.1,0.1}}, color={0,0,127}));
        connect(solDirTil.HDirTil, solBus.HDirTil) annotation (Line(points={{21,30},{
                100.1,30},{100.1,0.1}}, color={0,0,127}));
        annotation (Diagram(graphics,
                            coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}})),  Icon(graphics={
              Polygon(
                points={{-90,-80},{-40,-40},{40,-40},{90,-80},{-90,-80}},
                lineColor={95,95,95},
                smooth=Smooth.None),
              Polygon(
                points={{16,-46},{22,-72},{-72,-4},{-18,-22},{16,-46}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Ellipse(
                extent={{88,84},{40,38}},
                lineColor={255,255,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid)}),
          Documentation(revisions="<html>
<ul>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Added input <code>solTim</code> for azimuth computations.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
September 22, 2016 by Filip Jorissen:<br/>
Reworked implementation such that we use Annex 60 baseclasses.
</li>
<li>
March 25, 2016 by Filip Jorissen:<br/>
Reworked radSol implementation to use RealInputs instead of weaBus.
This simplifies translation and interpretation.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
      end RadSol;

      model RadSolData "Selects or generates correct solar data for this surface"
        parameter Modelica.SIunits.Angle inc "inclination";
        parameter Modelica.SIunits.Angle azi "azimuth";
        parameter Modelica.SIunits.Angle lat "latitude";
        parameter Boolean useLinearisation = false
          "Set to true if used for linearisation";
        parameter Integer numIncAndAziInBus "Number of pre-computed combination of inc and azi for solar radiation";
        parameter Modelica.SIunits.Angle[numIncAndAziInBus,2] incAndAziInBus "Combination of {inclination, azimuth} for which the solar data is available in weaBus.";
        parameter Boolean outputAngles=true "Set to false when linearising only";
        input IDEAS.Buildings.Components.Interfaces.WeaBus
          weaBus(numSolBus=numIncAndAziInBus,
              outputAngles=outputAngles)
          annotation (HideResults=true,Placement(transformation(extent={{90,70},{110,90}})));
        Modelica.Blocks.Interfaces.RealOutput HDirTil
          "Direct solar irradiation on a tilted surface"
          annotation (Placement(transformation(extent={{96,30},{116,50}})));
        Modelica.Blocks.Interfaces.RealOutput HGroDifTil
          "Diffuse sky solar irradiance on a tilted surface"
          annotation (Placement(transformation(extent={{96,-10},{116,10}})));
        Modelica.Blocks.Interfaces.RealOutput HSkyDifTil
          "Diffuse sky solar irradiance on a tilted surface"
          annotation (Placement(transformation(extent={{96,10},{116,30}})));
        Modelica.Blocks.Interfaces.RealOutput angInc
          annotation (Placement(transformation(extent={{96,-50},{116,-30}})));
        Modelica.Blocks.Interfaces.RealOutput angZen
          annotation (Placement(transformation(extent={{96,-70},{116,-50}})));
        Modelica.Blocks.Interfaces.RealOutput angAzi
          annotation (Placement(transformation(extent={{96,-90},{116,-70}})));
        Modelica.Blocks.Interfaces.RealOutput angHou "Hour angle"
          annotation (Placement(transformation(extent={{96,-110},{116,-90}})));
        Modelica.Blocks.Interfaces.RealOutput Tenv "Environment temperature"
          annotation (Placement(transformation(extent={{96,-30},{116,-10}})));
    protected
        final parameter Integer numMatches=
          sum( {if     IDEAS.Utilities.Math.Functions.isAngle(incAndAziInBus[i,1],inc)
                   and IDEAS.Utilities.Math.Functions.isAngle(incAndAziInBus[i,2],azi)
                then 1
                else 0 for i in 1:numIncAndAziInBus});
        final parameter Boolean solDataInBus = numMatches==1
          "True if the {inc,azi} combination is found in incAndAziInBus" annotation(Evaluate=true);
        final parameter Integer solDataIndex=
          sum( {if     IDEAS.Utilities.Math.Functions.isAngle(incAndAziInBus[i,1],inc)
                   and IDEAS.Utilities.Math.Functions.isAngle(incAndAziInBus[i,2],azi)
                then i
                else 0 for i in 1:numIncAndAziInBus})
          "Index of the {inc,azi} combination in incAndAziInBus" annotation(Evaluate=true);
        IDEAS.BoundaryConditions.SolarIrradiation.ShadedRadSol radSol(
          final inc=inc,
          final azi=azi,
          lat=lat,
          outputAngles=outputAngles) if
                            not solDataInBus
          "determination of incident solar radiation on wall based on inclination and azimuth"
          annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
        output Buildings.Components.Interfaces.SolBus
                                               solBusDummy(outputAngles=outputAngles)
          "Required for avoiding warnings?"
                                           annotation (HideResults=true, Placement(
              transformation(extent={{-60,10},{-20,50}})));
        Modelica.Blocks.Sources.Constant constAngLin(k=1) if
                                                       solDataInBus and not outputAngles
          "Dummy inputs when linearising. This avoids unnecessary state space inputs."
          annotation (Placement(transformation(extent={{-100,-70},{-80,-50}})));
      equation
          assert(numMatches<=1, "In "+getInstanceName()+
            ": The parameter sim.incAndAziInBus contains duplicates. 
      This is not allowed. Remove the duplicate entry.");
          assert( not useLinearisation or (useLinearisation and solDataInBus), "The solar data must come
      from the weabus when the model is linearised. Add the combination {inc,azi} = {"      +String(inc)+","+String(azi)+"}
      to the parameter incAndAziInBus of the SimInfoManager.");
        connect(radSol.solBus, solBusDummy) annotation (Line(
            points={{-60,30},{-40,30}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        if solDataInBus then
          connect(weaBus.solBus[solDataIndex], solBusDummy) annotation (Line(
            points={{100.05,80.05},{-40,80.05},{-40,30}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        end if;
        connect(HDirTil, solBusDummy.HDirTil) annotation (Line(
            points={{106,40},{-39.9,40},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(Tenv, solBusDummy.Tenv) annotation (Line(
            points={{106,-20},{-39.9,-20},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        if not (solDataInBus and not outputAngles) then
        connect(angInc, solBusDummy.angInc) annotation (Line(
            points={{106,-40},{-40,-40},{-40,-42},{-39.9,-42},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(angZen, solBusDummy.angZen) annotation (Line(
            points={{106,-60},{-39.9,-60},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(angAzi, solBusDummy.angAzi) annotation (Line(
            points={{106,-80},{-39.9,-80},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        end if;
        connect(radSol.TePow4, weaBus.TePow4) annotation (Line(points={{-66,40.6},{-66,
                54},{100.05,54},{100.05,80.05}},
                                        color={0,0,127}));
        connect(radSol.TskyPow4, weaBus.TskyPow4) annotation (Line(points={{-72,40.6},
                {-72,56},{100.05,56},{100.05,80.05}},
                                             color={0,0,127}));
        connect(radSol.solDirPer, weaBus.solDirPer) annotation (Line(points={{-80.4,40},
                {-80.4,58},{100.05,58},{100.05,80.05}},
                                               color={0,0,127}));
        connect(radSol.solGloHor, weaBus.solGloHor) annotation (Line(points={{-80.4,38},
                {-82,38},{-82,60},{100.05,60},{100.05,80.05}}, color={0,0,127}));
        connect(radSol.solDifHor, weaBus.solDifHor) annotation (Line(points={{-80.4,36},
                {-84,36},{-84,62},{100.05,62},{100.05,80.05}},
                                                      color={0,0,127}));
        connect(radSol.angDec, weaBus.angDec) annotation (Line(points={{-80.4,30},{-88,
                30},{-88,66},{100.05,66},{100.05,80.05}},
                                                 color={0,0,127}));
        connect(radSol.angHou, weaBus.angHou) annotation (Line(points={{-80.4,28},{-90,
                28},{-90,68},{100.05,68},{100.05,80.05}},
                                                 color={0,0,127}));
        connect(radSol.angZen, weaBus.angZen) annotation (Line(points={{-80.4,26},{-92,
                26},{-92,70},{100.05,70},{100.05,80.05}},
                                                 color={0,0,127}));
        connect(radSol.F1, weaBus.F1) annotation (Line(points={{-80.4,22},{-94,22},{-94,
                72},{100.05,72},{100.05,80.05}},
                                        color={0,0,127}));
        connect(radSol.F2, weaBus.F2) annotation (Line(points={{-80.4,20},{-96,20},{-96,
                74},{100.05,74},{100.05,80.05}},
                                        color={0,0,127}));
          connect(constAngLin.y, angInc) annotation (Line(points={{-79,-60},{-78,-60},{-78,
                -40},{106,-40}}, color={0,0,127}));
        connect(constAngLin.y, angZen)
          annotation (Line(points={{-79,-60},{-78,-60},{106,-60}}, color={0,0,127}));
        connect(constAngLin.y, angAzi)
                                      annotation (Line(points={{-79,-60},{-78,-60},{-78,
                -80},{106,-80}}, color={0,0,127}));
        connect(HSkyDifTil, solBusDummy.HSkyDifTil) annotation (Line(points={{106,20},
                {-39.9,20},{-39.9,30.1}}, color={0,0,127}));
        connect(HGroDifTil, solBusDummy.HGroDifTil) annotation (Line(points={{106,0},
                {-39.9,0},{-39.9,30.1}}, color={0,0,127}));
        connect(angHou, weaBus.angHou) annotation (Line(points={{106,-100},{80,-100},
                {80,80.05},{100.05,80.05}}, color={0,0,127}));
        connect(radSol.solTim, weaBus.solTim) annotation (Line(points={{-80.4,33},{-86,
                33},{-86,64},{100.05,64},{100.05,80.05}},
                                                      color={0,0,127}));
        annotation (Diagram(graphics,
                            coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}})),           Documentation(info="<html>
<p>This model usually takes the appropriate solar data from the bus. If the correct data is not contained by the bus, custom solar data is calculated.</p>
</html>",       revisions="<html>
<ul>
<li>
August 9, 2018 by Filip Jorissen:<br/>
Revised implementation for checking solData index and added
assert to avoid duplicate entries in <code>incAndAziInBus</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/881\">
#881</a>.
</li>
<li>
March 26, 2018 by Iago Cupeiro &amp; Damien Picard:<br/>
Solved bug in linearisation
</li>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Added <code>solTim</code> connection for revised azimuth computations.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
March 25, 2016 by Filip Jorissen:<br/>
Reworked radSol implementation to use RealInputs instead of weaBus.
This simplifies translation and interpretation.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
      end RadSolData;

      model ShadedRadSol "Block that computes surface-dependent environment data"
        extends IDEAS.BoundaryConditions.SolarIrradiation.RadSol(
          final remDefVals = true);
        Modelica.Blocks.Interfaces.RealInput TskyPow4
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=270,
              origin={-20,106})));
        Modelica.Blocks.Interfaces.RealInput TePow4
          annotation (Placement(transformation(extent={{-18,-18},{18,18}},
              rotation=270,
              origin={40,106})));
        IDEAS.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth solAzi(lat=lat) "Solar azimuth angle"
          annotation (Placement(transformation(extent={{36,-18},{56,-38}})));
        Modelica.Blocks.Math.Add relAzi(k2=-1)
          "Azimuth angle relative to surface azimuth"
          annotation (Placement(transformation(extent={{68,-52},{88,-32}})));
        Modelica.Blocks.Sources.Constant surfAzi(k=azi) "Surface azimuth angle"
          annotation (Placement(transformation(extent={{-20,-54},{-8,-42}})));
    protected
        final parameter Real Fssky=(1 + cos(inc))/2
          "radiant-interchange configuration factor between surface and sky";
        final parameter Real beta = cos(inc/2)
          "Additional factor for taking into account the line of sight through the atmosphere";
        final parameter Real coeffSky = Fssky*beta
          "Dummy parameter for speeding up computations";
        final parameter Real coeffEnv = 1-Fssky*beta
          "Dummy parameter for speeding up computations";
        Modelica.Blocks.Sources.RealExpression TenvExpr(
          y=(coeffSky*TskyPow4 + coeffEnv*TePow4)^0.25)
          "Environment temperature"
          annotation (Placement(transformation(extent={{0,70},{60,90}})));
      equation
        connect(TenvExpr.y, solBus.Tenv) annotation (Line(
            points={{63,80},{100.1,80},{100.1,0.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solDirTil.incAng, incAng.incAng) annotation (Line(points={{-2,24},{
                -14,24},{-14,50},{-19,50}}, color={0,0,127}));
        connect(solAzi.zen, angZen) annotation (Line(points={{34,-34},{34,-40},{-104,-40}},
                             color={0,0,127}));
        connect(surfAzi.y, relAzi.u2)
          annotation (Line(points={{-7.4,-48},{66,-48}}, color={0,0,127}));
        connect(relAzi.u1, solAzi.solAzi) annotation (Line(points={{66,-36},{60,-36},{
                60,-28},{57,-28}}, color={0,0,127}));
        connect(solAzi.solTim, solTim) annotation (Line(points={{34,-22},{-64,-22},{-64,
                30},{-104,30}}, color={0,0,127}));
        connect(relAzi.y, solBus.angAzi) annotation (Line(points={{89,-42},{100.1,-42},
                {100.1,0.1}}, color={0,0,127}));
        connect(solAzi.decAng, angDec) annotation (Line(points={{34,-28},{-62,-28},{-62,
                0},{-104,0}}, color={0,0,127}));
        annotation (Diagram(graphics,
                            coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}})),  Icon(coordinateSystem(preserveAspectRatio=false,
                extent={{-100,-100},{100,100}}),
                                            graphics={
              Polygon(
                points={{-90,-80},{-40,-40},{40,-40},{90,-80},{-90,-80}},
                lineColor={95,95,95},
                smooth=Smooth.None),
              Polygon(
                points={{16,-46},{22,-72},{-72,-4},{-18,-22},{16,-46}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Ellipse(
                extent={{88,84},{40,38}},
                lineColor={255,255,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid)}),
          Documentation(revisions="<html>
<ul>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Revised azimuth angle computation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
January 20, 2017 by Filip Jorissen:<br/>
Changed computation of Tenv.
See issue 
<a href=https://github.com/open-ideas/IDEAS/issues/623>#623</a>.
</li>
<li>
September 22, 2016 by Filip Jorissen:<br/>
Reworked implementation such that we use Annex 60 baseclasses.
</li>
<li>
March 25, 2016 by Filip Jorissen:<br/>
Reworked radSol implementation to use RealInputs instead of weaBus.
This simplifies translation and interpretation.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>",       info="<html>
<p>
Model of equivalent radiative temperature is according to page 73 in
</p>
<p>
Walton, G. N. 1983. Thermal Analysis Research Program Reference Manual. NBSSIR 83-2655. National Bureau of Standards
</p>
</html>"));
      end ShadedRadSol;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models that compute the solar irradiation
with different sky models.
</html>"));
    end SolarIrradiation;

    package Types "Package with type definitions"
     extends Modelica.Icons.TypesPackage;

      type DataSource = enumeration(
        File   "Use data from file",
        Parameter   "Use parameter",
        Input   "Use input connector") "Enumeration to define data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions="<html>
<ul>
<li>
July 20, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type RadiationDataSource = enumeration(
        File   "Use data from file",
        Input_HGloHor_HDifHor
            "Global horizontal and diffuse horizontal radiation from connector",
        Input_HDirNor_HDifHor
            "Direct normal and diffuse horizontal radiation from connector",
        Input_HDirNor_HGloHor
            "Direct normal and global horizontal radiation from connector")
        "Enumeration to define solar radiation data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions="<html>
<ul>
<li>
August 13, 2012, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));

      type SkyTemperatureCalculation = enumeration(
        HorizontalRadiation
            "Use horizontal irradiation",
        TemperaturesAndSkyCover
            "Use dry-bulb and dew-point temperatures and sky cover")
        "Enumeration for computation of sky temperature" annotation (Documentation(
            info =                 "<html>
<p>
Enumeration to define the method used to compute the sky temperature.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 3, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
    end Types;

    package WeatherData "Weather data reader"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Package with base classes for IDEAS.BoundaryConditions.WeatherData"
        extends Modelica.Icons.BasesPackage;

        block CheckBlackBodySkyTemperature
          "Check the validity of the black-body sky temperature data"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Black-body sky temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TOut(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Black-body sky temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          parameter Modelica.SIunits.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.SIunits.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";
        equation
          TOut = TIn;
          assert(TOut > TMin, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          assert(TOut < TMax, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          annotation (
            defaultComponentName="cheSkyBlaBodTem",
            Documentation(info="<html>
<p>
This component checks the value of the black-body sky temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 5, 2015 by Michael Wetter:<br/>
First implementation, based on
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature\">
IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature</a>.
This was implemented to get the corrected documentation string in the weather bus connector.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{56,12},{-68,-16}},
                  lineColor={0,0,0},
                  textString="TSkyBlaBod")}));
        end CheckBlackBodySkyTemperature;

        block CheckCeilingHeight
          "Ensures that the ceiling height is above a lower bound"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput ceiHeiIn(
            final quantity="Height",
            final unit="m") "Input ceiling height"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput ceiHeiOut(
            final quantity="Height",
            final unit="m") "Ceiling height"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Height ceiHeiMin=0 "Minimum allowed ceiling height";
        equation
          ceiHeiOut = IDEAS.Utilities.Math.Functions.smoothMax(
            ceiHeiIn,
            ceiHeiMin,
            0.1);
          annotation (
            defaultComponentName="cheCeiHei",
            Documentation(info="<html>
<p>
This component ensures that the ceiling height is at least <i>0</i> meters.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="m")}));
        end CheckCeilingHeight;

        block CheckIRRadiation "Ensure that the radiation is not smaller than 0"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput HIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Input horizontal infrared irradiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Horizontal infrared irradiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.RadiantEnergyFluenceRate HMin=0.0001
            "Minimum value for radiation";
        equation
          HOut = IDEAS.Utilities.Math.Functions.smoothMax(
            x1=HIn,
            x2=HMin,
            deltaX=HMin/10);
          annotation (
            defaultComponentName="cheRad",
            Documentation(info="<html>
<p>
This block ensures that the radiation is not smaller than <i>0</i>.
The Modelica data reader will interpolate data when it reads the data from a file.
Thus, it is possible to generate negative values due to the interpolation.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 7, 2016, by Michael Wetter:<br/>
Updated comment.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end CheckIRRadiation;

        block CheckPressure
          "Ensures that the interpolated pressure is between prescribed bounds"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput PIn(
            final quantity="Pressure",
            final unit="Pa") "Input pressure"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput POut(
            final quantity="Pressure",
            final unit="Pa") "Atmospheric pressure"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Pressure PMin=3100 "Minimum allowed pressure";
          constant Modelica.SIunits.Pressure PMax=120000 "Maximum allowed pressure";
        equation
          assert(PIn > PMin, "Pressure out of bounds.\n" + "   PIn = " + String(PIn));
          assert(PIn < PMax, "Pressure out of bounds.\n" + "   PIn = " + String(PIn));
          POut = PIn;
          annotation (
            defaultComponentName="chePre",
            Documentation(info="<html>
<p>
This component ensures that the interpolated pressure is between <i>31,000</i> Pa and <i>120,000</i> Pa.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="P")}));
        end CheckPressure;

        block CheckRadiation "Ensure that the radiation is not smaller than 0"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput HIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Input radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Radiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.RadiantEnergyFluenceRate HMin=0.0001
            "Minimum value for radiation";
        equation
          HOut = IDEAS.Utilities.Math.Functions.smoothMax(
            x1=HIn,
            x2=HMin,
            deltaX=HMin/10);
          annotation (
            defaultComponentName="cheRad",
            Documentation(info="<html>
<p>
This block ensures that the radiation is not smaller than <i>0</i>.
The Modelica data reader will interpolate data when it reads the data from a file.
Thus, it is possible to generate negative values due to the interpolation.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 7, 2016, by Michael Wetter:<br/>
Updated comment.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end CheckRadiation;

        block CheckRelativeHumidity "Check the validity of relative humidity"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput relHumIn(final unit="1")
            "Input relative humidity"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relHumOut(final unit="1")
            "Relative humidity"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Real delta=0.01 "Smoothing parameter";
      protected
          constant Real relHumMin=delta "Lower bound";
          constant Real relHumMax=1 - delta "Upper bound";
        equation
          relHumOut = IDEAS.Utilities.Math.Functions.smoothLimit(
            relHumIn,
            relHumMin,
            relHumMax,
            delta/10);
          annotation (
            defaultComponentName="cheRelHum",
            Documentation(info="<html>
<p>
This component constrains the value of relative humidity to a range of <i>[0, 1]</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Bitmap(extent={{-74,-78},{76,74}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/WeatherData/BaseClasses/relativeHumidity.png")}));
        end CheckRelativeHumidity;

        block CheckSkyCover "Constrains the sky cover to [0, 1]"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nIn(min=0, max=1)
            "Input sky cover [0, 10]"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput nOut(min=0, max=1, unit="1")
            "Sky cover [0, 1]"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Real delta=0.01 "Smoothing parameter";
      protected
          constant Real nMin=delta "Lower bound";
          constant Real nMax=10 - delta "Upper bound";
        equation
          nOut = IDEAS.Utilities.Math.Functions.smoothLimit(
            nIn,
            nMin,
            nMax,
            delta/10);
          annotation (
            defaultComponentName="cheSkyCov",
            Documentation(info="<html>
<p>
This component constrains the interpolated sky cover between <i>0</i> and <i>1</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 4, 2015, by Michael Wetter:<br/>
Removed wrong unit string for input signal.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed model as
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.ReaderTMY3\">
IDEAS.BoundaryConditions.WeatherData.ReaderTMY3</a>
send a signal between <i>0</i> and <i>1</i>.
Added <code>min</code> and <code>max</code>
attributes.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-64,48},{70,-48}},
                  lineColor={0,0,255},
                  textString="Sky")}));
        end CheckSkyCover;

        block CheckTemperature "Check the validity of temperature data"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Input Temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TOut(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Output temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          parameter Modelica.SIunits.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.SIunits.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";
        equation
          TOut = TIn;
          assert(TOut > TMin, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          assert(TOut < TMax, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          annotation (
            defaultComponentName="cheTem",
            Documentation(info="<html>
<p>
This component checks the value of temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{42,44},{-38,-36}},
                  lineColor={0,0,0},
                  textString="T")}));
        end CheckTemperature;

        block CheckWindDirection "Constrains the wind direction to [0, 2*pi] degree"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nIn(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Input wind direction"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput nOut(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Wind direction"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Real delta=0.01 "Smoothing parameter";
      protected
          constant Real nMin=0 "Lower bound";
          constant Real nMax=2*Modelica.Constants.pi "Upper bound";
        equation
          nOut = IDEAS.Utilities.Math.Functions.smoothLimit(
            nIn,
            nMin,
            nMax,
            delta/10);
          annotation (
            defaultComponentName="cheWinDir",
            Documentation(info="<html>
<p>
This component constrains the interpolated wind direction between <i>0</i> and <i>360</i> degree.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part since it will be done outside.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end CheckWindDirection;

        block CheckWindSpeed "Ensures that the wind speed is non-negative"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput winSpeIn(final quantity="Velocity",
              final unit="m/s") "Input wind speed"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput winSpeOut(final quantity="Velocity",
              final unit="m/s") "Wind speed"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Velocity winSpeMin=1e-6
            "Minimum allowed wind speed";
        equation
          // Modelica Table will interpolate data when it reads the weather data file.
          // It can generate negative values due to the interpolation.
          winSpeOut = IDEAS.Utilities.Math.Functions.smoothMax(
            x1=winSpeIn,
            x2=winSpeMin,
            deltaX=winSpeMin/10);
          annotation (
            defaultComponentName="cheWinSpe",
            Documentation(info="<html>
<p>
This component ensures that the wind speed is non-negative.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="m/s")}));
        end CheckWindSpeed;

        block ConvertRadiation
          "Convert the unit of solar radiation received from the TMY3 data file"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput HIn(final unit="W.h/m2")
            "Input radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Radiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          constant Modelica.SIunits.Time Hou=3600 "1 hour";
        equation
          HOut = HIn/Modelica.SIunits.Conversions.to_hour(Hou);
          annotation (
            defaultComponentName="conRad",
            Documentation(info="<html>
<p>
The TMY3 data for solar radiation is the radiation accumulated in one hour. Thus, it used a unit of <code>Wh/m2</code>.
This component converts <code>Wh/m2</code> to <code>W/m2</code> that is the standard unit in Modelica.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Add the unit conversion and delete the data validity check.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end ConvertRadiation;

        block ConvertRelativeHumidity
          "Convert the relative humidity from percentage to real"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput relHumIn(unit="1")
            "Value of relative humidity in percentage"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relHumOut(unit="1")
            "Relative humidity between 0 and 1"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          relHumOut = relHumIn/100;
          annotation (
            defaultComponentName="conRelHum",
            Documentation(info="<html>
<p>
This component converts the relative humidity from percentage to real.
Input is the relative humidity in percentage, as this is the data
format that is used in the Typical Meteorological Year weather data.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Separate the checking function to CheckRelativeHumidity.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Bitmap(extent={{-74,-78},{76,74}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/WeatherData/BaseClasses/relativeHumidity.png")}));
        end ConvertRelativeHumidity;

        block ConvertTime
          "Converts the simulation time to calendar time in scale of 1 year (365 days)"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput modTim(
            final quantity="Time",
            final unit="s") "Simulation time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput calTim(
            final quantity="Time",
            final unit="s") "Calendar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          constant Modelica.SIunits.Time year=31536000 "Number of seconds in a year";
          discrete Modelica.SIunits.Time tStart "Start time of period";
        initial equation
          tStart = integer(modTim/year)*year;
        equation
          when modTim - pre(tStart) > year then
            tStart = integer(modTim/year)*year;
          end when;
          calTim = modTim - tStart;
          annotation (
            defaultComponentName="conTim",
            Documentation(info="<html>
<p>
This component converts the simulation time to calendar time in a scale of 1 year (365 days).
</p>
</html>",         revisions="<html>
<ul>
<li>
September 27, 2011, by Wangda Zuo, Michael Wetter:<br/>
Modify it to convert negative value of time.
Use the when-then to allow dymola differentiating this model when conducting index reduction which is not allowed in previous implementation.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
Renamed the component.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-98,6},{-74,-4}},
                  lineColor={0,0,127},
                  textString="modTim"),
                Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim"),
                Rectangle(
                  extent={{-66,76},{60,58}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  fillColor={120,120,120}),
                Rectangle(extent={{-66,58},{60,-62}}, lineColor={0,0,0}),
                Line(
                  points={{-24,-62},{-24,58}}),
                Line(
                  points={{18,-62},{18,58}}),
                Line(
                  points={{60,28},{-66,28}}),
                Line(
                  points={{60,-2},{-66,-2}}),
                Line(
                  points={{60,-32},{-66,-32}})}));
        end ConvertTime;

        block EquationOfTime "Equation of time"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nDay(
            quantity="Time",
            unit="s")
            "Zero-based day number in seconds (January 1=0, January 2=86400)"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput eqnTim(
            final quantity="Time",
            final unit="s",
            displayUnit="min") "Equation of time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real Bt "Intermediate variable";
        equation
          Bt = Modelica.Constants.pi*((nDay + 86400)/86400 - 81)/182
            "Our unit is s instead of day in (A.4.2b)";
          eqnTim = 60*(9.87*Modelica.Math.sin(2*Bt) - 7.53*Modelica.Math.cos(Bt) - 1.5*
            Modelica.Math.sin(Bt)) "Our unit is s instead of min in (A.4.2a)";
          annotation (
            defaultComponentName="eqnTim",
            Documentation(info="<html>
<p>
This component computes the difference between solar noon and noon of local civic time.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-58,38},{38,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-6,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="equ")}));
        end EquationOfTime;

        function getHeaderElementTMY3
          "Gets an element from the header of a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         input String start "Start of the string that contains the elements";
         input String name "Name of data element, used in error reporting";
         input Integer position(min=1)
            "Position of the element on the line that contains 'start'";
         output String element
            "Element at position 'pos' of the line that starts with 'start'";
      protected
         String lin "Line that is used in parser";
         Integer iLin "Line number";
         Integer index =  0 "Index of string #LOCATION";
         Integer staInd "Start index used when parsing a real number";
         Integer nexInd "Next index used when parsing a real number";
         Boolean found "Flag, true if #LOCATION has been found";
         Boolean EOF "Flag, true if EOF has been reached";
         String fouDel "Found delimiter";
        algorithm
          // Get line that starts with 'start'
          iLin :=0;
          EOF :=false;
          while (not EOF) and (index == 0) loop
            iLin:=iLin + 1;
            (lin, EOF) :=Modelica.Utilities.Streams.readLine(fileName=filNam,
              lineNumber=iLin);
            index :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=start,
              startIndex=1,
              caseSensitive=false);
          end while;
          assert(not EOF, "Error: Did not find '" + start + "' when scanning the weather file."
                              + "\n   Check for correct weather file syntax.");
          // Loop over the tokens until the position is reached
          nexInd :=1;
          for i in 1:position-1 loop
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString = ",",
              startIndex=nexInd+1);
           assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                lin + "'.");
          end for;
          staInd := nexInd;
          // Find the next delimiter
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString = ",",
              startIndex=nexInd+1);
          assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                 lin + "'.");
          // Get the element
          element :=Modelica.Utilities.Strings.substring(lin, startIndex=staInd+1, endIndex=nexInd-1);
          annotation (Inline=false,
          Documentation(info="<html>
This function scans the weather data file for a line that starts with the string <pre>
start
</pre>
where <code>start</code> is a parameter.
When this line is found, the function returns the element at the position number
<code>position</code>, where <code>position</code> is a parameter.
A comma is used as the delimiter of the elements.
</html>",         revisions="<html>
<ul>
<li>
April 21, 2016, by Michael Wetter:<br/>
Removed call to
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
because this function calls
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">
Modelica.Utilities.Files.loadResource</a>, which needs to be resolved at compilation
time, which is difficult if it is inside a function.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Removed default value for parameter <code>name</code>.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getHeaderElementTMY3;

        function getLatitudeTMY3 "Gets the latitude from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Angle lat "Latitude from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            IDEAS.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "longitude",
              position=7);
           (nexInd, lat) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the latitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lat :=lat*Modelica.Constants.pi/180;
           // Check if latitude is valid
           assert(abs(lat) <= Modelica.Constants.pi+Modelica.Constants.eps,
               "Wrong value for latitude. Received lat = " +
               String(lat) + " (= " + String(lat*180/Modelica.Constants.pi) + " degrees).");
          annotation (Documentation(info="<html>
This function returns the latitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLatitudeTMY3;

        function getLongitudeTMY3 "Gets the longitude from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Angle lon "Longitude from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            IDEAS.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "longitude",
              position=8);
           (nexInd, lon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the longitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lon :=lon*Modelica.Constants.pi/180;
           // Check if longitude is valid
           assert(abs(lon) < 2*Modelica.Constants.pi,
               "Wrong value for longitude. Received lon = " +
               String(lon) + " (= " + String(lon*180/Modelica.Constants.pi) + " degrees).");
          annotation (Documentation(info="<html>
This function returns the longitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLongitudeTMY3;

        function getTimeZoneTMY3 "Gets the time zone from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Time timZon "Time zone from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            IDEAS.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "longitude",
              position=9);
           (nexInd, timZon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the time zone '" +
                              element + "' from a String to a Real.");
           timZon :=timZon*3600;
           // Check if time zone is valid
           assert(abs(timZon) < 24*3600,
               "Wrong value for time zone. Received timZon = " +
               String(timZon) + " (= " + String(timZon/3600) + " hours).");
          annotation (Documentation(info="<html>
This function returns the time zone of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getTimeZoneTMY3;

        block LocalCivilTime "Converts the clock time to local civil time."
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput cloTim(
            final quantity="Time",
            final unit="s") "Clock time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          parameter Modelica.SIunits.Time timZon(displayUnit="h") "Time zone";
          parameter Modelica.SIunits.Angle lon(displayUnit="deg") "Longitude";
          Modelica.Blocks.Interfaces.RealOutput locTim(
            final quantity="Time",
            final unit="s") "Local civil time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          final parameter Modelica.SIunits.Time diff = - timZon + lon*43200/Modelica.Constants.pi
            "Difference between local and clock time";
        equation
          locTim = cloTim + diff;
          annotation (
            defaultComponentName="locTim",
            Documentation(info="<html>
<p>
This component converts the clock time to local civil time.
The parameter <code>timZon</code> represents the time zone of the facility  (relative to Greenwich Mean Time or the 0th meridian). Time zones west of GMT (e.g. North America) are represented as negative;
east of GMT as positive. Fraction of hours are represented in decimals (e.g. for <i>6:30</i>, use <i>6.5</i>).
</p>
<p>
The formula is based on Michael Wetter's thesis (A4.1):
</p>
<pre>
  locTim = greTim + (lon*180/pi)*86400/360 = cloTim - timZon + lon*43200/pi
</pre>
</html>",         revisions="<html>
<ul>
<li>
November 14, 2015, by Michael Wetter:<br/>
Introduced <code>diff</code>.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-98,6},{-60,-6}},
                  lineColor={0,0,127},
                  textString="cloTim"), Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim")}));
        end LocalCivilTime;

        block SolarTime "Solar time"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput locTim(quantity="Time", unit="s")
            "Local time" annotation (Placement(transformation(extent={{-140,-74},{-100,
                    -34}}), iconTransformation(extent={{-140,-74},{-100,-34}})));
          Modelica.Blocks.Interfaces.RealInput equTim(quantity="Time", unit="s")
            "Equation of time" annotation (Placement(transformation(extent={{-140,40},{
                    -100,80}}), iconTransformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput solTim(
            final quantity="Time",
            final unit="s",
            displayUnit="s") "Solar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solTim = locTim + equTim "Our unit is s in stead of h in (A.4.3)";
          annotation (
            defaultComponentName="solTim",
            Documentation(info="<html>
<p>
This component computes the local solar time.
</p>
<p>
<b>Note:</b> To avoid events, this block does not convert solar time to a scale of 24 hours.
</p>
</html>",         revisions="<html>
<ul>
<li>
Feb. 16, 2012, by Michael Wetter:<br/>
Removed section that limits solar time to
<code>0 &le; solTim &le; 86400</code> as this triggers
events, and is not needed because solar time is used in
trigonometric functions only.
</li>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-54,38},{42,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-4,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="sol"),
                Text(
                  extent={{-94,66},{-42,50}},
                  lineColor={0,0,127},
                  textString="equTim"),
                Text(
                  extent={{-96,-44},{-44,-60}},
                  lineColor={0,0,127},
                  textString="locTim")}));
        end SolarTime;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData\">IDEAS.BoundaryConditions.WeatherData</a>.
</p>
</html>"));
      end BaseClasses;

      expandable connector Bus "Data bus that stores weather data"
        extends Modelica.Icons.SignalBus;
        annotation (
          defaultComponentName="weaBus",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-20,2},{22,-2}},
                lineColor={255,204,51},
                lineThickness=0.5)}),
          Documentation(info="<html>
<p>
This component is an expandable connector that is used to implement a bus that contains the weather data.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Bus;

      block ReaderTMY3 "Reader for TMY3 weather data"
        parameter Boolean computeWetBulbTemperature = true
          "If true, then this model computes the wet bulb temperature"
          annotation(Evaluate=true);
        //--------------------------------------------------------------
        // Atmospheric pressure
        parameter IDEAS.BoundaryConditions.Types.DataSource pAtmSou=IDEAS.BoundaryConditions.Types.DataSource.Parameter
          "Atmospheric pressure"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Pressure pAtm=101325
          "Atmospheric pressure (used if pAtmSou=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput pAtm_in(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="Pa") if (pAtmSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input pressure"
          annotation (Placement(transformation(extent={{-240,254},{-200,294}}),
              iconTransformation(extent={{-240,254},{-200,294}})));
        //--------------------------------------------------------------
        // Ceiling height
        parameter IDEAS.BoundaryConditions.Types.DataSource ceiHeiSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Ceiling height" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real ceiHei(
          final quantity="Height",
          final unit="m",
          displayUnit="m") = 20000 "Ceiling height (used if ceiHei=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput ceiHei_in(
          final quantity="Height",
          final unit="m",
          displayUnit="m") if (ceiHeiSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input ceiling height"
          annotation (Placement(transformation(extent={{-242,-14},{-202,26}}),
              iconTransformation(extent={{-242,-14},{-202,26}})));
        //--------------------------------------------------------------
        // Total sky cover
        parameter IDEAS.BoundaryConditions.Types.DataSource totSkyCovSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Total sky cover" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real totSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Total sky cover (used if totSkyCov=Parameter). Use 0 <= totSkyCov <= 1"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput totSkyCov_in(
          min=0,
          max=1,
          unit="1") if (totSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input total sky cover"
          annotation (Placement(transformation(extent={{-240,-58},{-200,-18}}),
              iconTransformation(extent={{-240,-58},{-200,-18}})));
        // Opaque sky cover
        parameter IDEAS.BoundaryConditions.Types.DataSource opaSkyCovSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Opaque sky cover" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real opaSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Opaque sky cover (used if opaSkyCov=Parameter). Use 0 <= opaSkyCov <= 1"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput opaSkyCov_in(
          min=0,
          max=1,
          unit="1") if (opaSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input opaque sky cover"
          annotation (Placement(transformation(extent={{-240,32},{-200,72}}),
              iconTransformation(extent={{-240,32},{-200,72}})));
        //--------------------------------------------------------------
        // Dry bulb temperature
        parameter IDEAS.BoundaryConditions.Types.DataSource TDryBulSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Dry bulb temperature"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Temperature TDryBul(displayUnit="degC") = 293.15
          "Dry bulb temperature (used if TDryBul=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDryBul_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDryBulSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input dry bulb temperature"
          annotation (Placement(transformation(extent={{-240,160},{-200,200}})));
        //--------------------------------------------------------------
        // Dew point temperature
        parameter IDEAS.BoundaryConditions.Types.DataSource TDewPoiSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Dew point temperature"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Temperature TDewPoi(displayUnit="degC") = 283.15
          "Dew point temperature (used if TDewPoi=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDewPoi_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDewPoiSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input dew point temperature"
          annotation (Placement(transformation(extent={{-240,204},{-200,244}})));
        //--------------------------------------------------------------
        // Black body sky temperature
        parameter IDEAS.BoundaryConditions.Types.DataSource TBlaSkySou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Black-body sky temperature" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Temperature TBlaSky=273.15
          "Black-body sky temperature (used if TBlaSkySou=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput TBlaSky_in(
          final quantity="ThermodynamicTemperature",
          displayUnit="degC",
          final unit="K") if
          (TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Black-body sky temperature"
          annotation (Placement(transformation(extent={{-240,120},{-200,160}}),
              iconTransformation(extent={{-240,120},{-200,160}})));
        //--------------------------------------------------------------
        // Relative humidity
        parameter IDEAS.BoundaryConditions.Types.DataSource relHumSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Relative humidity" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real relHum(
          min=0,
          max=1,
          unit="1") = 0.5 "Relative humidity (used if relHum=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput relHum_in(
          min=0,
          max=1,
          unit="1") if (relHumSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input relative humidity"
          annotation (Placement(transformation(extent={{-240,80},{-200,120}}),
              iconTransformation(extent={{-240,80},{-200,120}})));
        //--------------------------------------------------------------
        // Wind speed
        parameter IDEAS.BoundaryConditions.Types.DataSource winSpeSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Wind speed" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Velocity winSpe(min=0) = 1
          "Wind speed (used if winSpe=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput winSpe_in(
          final quantity="Velocity",
          final unit="m/s",
          min=0) if (winSpeSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input wind speed"
          annotation (Placement(transformation(extent={{-240,-98},{-200,-58}}),
              iconTransformation(extent={{-240,-98},{-200,-58}})));
        //--------------------------------------------------------------
        // Wind direction
        parameter IDEAS.BoundaryConditions.Types.DataSource winDirSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Wind direction" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Angle winDir=1.0
          "Wind direction (used if winDir=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput winDir_in(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") if (winDirSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input wind direction"
          annotation (Placement(transformation(extent={{-240,-140},{-200,-100}}),
              iconTransformation(extent={{-240,-140},{-200,-100}})));
        //--------------------------------------------------------------
        // Infrared horizontal radiation
        parameter IDEAS.BoundaryConditions.Types.DataSource HInfHorSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Infrared horizontal radiation" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.HeatFlux HInfHor=0.0
          "Infrared horizontal radiation (used if HInfHorSou=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput HInfHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HInfHorSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input infrared horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-210},{-200,-170}}),
              iconTransformation(extent={{-240,-210},{-200,-170}})));
         parameter IDEAS.BoundaryConditions.Types.RadiationDataSource HSou=IDEAS.BoundaryConditions.Types.RadiationDataSource.File
          "Global, diffuse, and direct normal radiation"
           annotation (Evaluate=true, Dialog(group="Data source"));
        //--------------------------------------------------------------
        // Global horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HGloHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input global horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-280},{-200,-240}}),
              iconTransformation(extent={{-240,-280},{-200,-240}})));
        //--------------------------------------------------------------
        // Diffuse horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HDifHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor)
          "Input diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-276},{-200,-236}}),
              iconTransformation(extent={{-240,-172},{-200,-132}})));
        //--------------------------------------------------------------
        // Direct normal radiation
        Modelica.Blocks.Interfaces.RealInput HDirNor_in(final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
                                (HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input direct normal radiation"
          annotation (Placement(transformation(extent={{-240,-320},{-200,-280}}),
              iconTransformation(extent={{-240,-240},{-200,-200}})));
        //--------------------------------------------------------------
        parameter String filNam="" "Name of weather data file" annotation (
          Dialog(loadSelector(filter="Weather files (*.mos)",
                              caption="Select weather file")));
        final parameter Modelica.SIunits.Angle lon(displayUnit="deg")=
          IDEAS.BoundaryConditions.WeatherData.BaseClasses.getLongitudeTMY3(
          filNam) "Longitude";
        final parameter Modelica.SIunits.Angle lat(displayUnit="deg")=
          IDEAS.BoundaryConditions.WeatherData.BaseClasses.getLatitudeTMY3(
          filNam) "Latitude";
        final parameter Modelica.SIunits.Time timZon(displayUnit="h")=
          IDEAS.BoundaryConditions.WeatherData.BaseClasses.getTimeZoneTMY3(filNam)
          "Time zone";
        Bus weaBus "Weather data bus" annotation (Placement(transformation(extent={{
                  290,-10},{310,10}}), iconTransformation(extent={{190,-10},{210,10}})));
        parameter IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation
          calTSky=IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Computation of black-body sky temperature" annotation (
          choicesAllMatching=true,
          Evaluate=true,
          Dialog(group="Sky temperature"));
        constant Real epsCos = 1e-6 "Small value to avoid division by 0";
        constant Modelica.SIunits.HeatFlux solCon = 1367.7 "Solar constant";
    protected
        Modelica.Blocks.Tables.CombiTable1Ds datRea(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns={2,3,4,5,6,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
              28,29,30,8})
                         "Data reader"
          annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature
          cheTemDryBul "Check dry bulb temperature "
          annotation (Placement(transformation(extent={{160,-200},{180,-180}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature
          cheTemDewPoi "Check dew point temperature"
          annotation (Placement(transformation(extent={{160,-240},{180,-220}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.ConvertRelativeHumidity
          conRelHum "Convert the relative humidity from percentage to [0, 1] "
          annotation (Placement(transformation(extent={{120,20},{140,40}})));
        BaseClasses.CheckPressure chePre "Check the air pressure"
          annotation (Placement(transformation(extent={{160,60},{180,80}})));
        BaseClasses.CheckSkyCover cheTotSkyCov "Check the total sky cover"
          annotation (Placement(transformation(extent={{160,-40},{180,-20}})));
        BaseClasses.CheckSkyCover cheOpaSkyCov "Check the opaque sky cover"
          annotation (Placement(transformation(extent={{160,-160},{180,-140}})));
        BaseClasses.CheckRadiation cheGloHorRad
          "Check the global horizontal radiation"
          annotation (Placement(transformation(extent={{160,180},{180,200}})));
        BaseClasses.CheckRadiation cheDifHorRad
          "Check the diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{160,140},{180,160}})));
        BaseClasses.CheckRadiation cheDirNorRad "Check the direct normal radiation"
          annotation (Placement(transformation(extent={{160,220},{180,240}})));
        BaseClasses.CheckCeilingHeight cheCeiHei "Check the ceiling height"
          annotation (Placement(transformation(extent={{160,-120},{180,-100}})));
        BaseClasses.CheckWindSpeed cheWinSpe "Check the wind speed"
          annotation (Placement(transformation(extent={{160,-80},{180,-60}})));
        BaseClasses.CheckIRRadiation
                                   cheHorRad
          "Check the horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{160,100},{180,120}})));
        BaseClasses.CheckWindDirection cheWinDir "Check the wind direction"
          annotation (Placement(transformation(extent={{160,-280},{180,-260}})));
        SkyTemperature.BlackBody TBlaSkyCom(final calTSky=calTSky) if
             not (TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Parameter or
                  TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Computation of the black-body sky temperature"
          annotation (Placement(transformation(extent={{240,-220},{260,-200}})));
        Utilities.Time.ModelTime modTim "Model time"
          annotation (Placement(transformation(extent={{-180,-10},{-160,10}})));
        Modelica.Blocks.Math.Add add
          "Add 30 minutes to time to shift weather data reader"
          annotation (Placement(transformation(extent={{-140,180},{-120,200}})));
        Modelica.Blocks.Sources.Constant con30mins(final k=1800)
          "Constant used to shift weather data reader"
          annotation (Placement(transformation(extent={{-180,212},{-160,232}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.LocalCivilTime locTim(
            final lon=lon, final timZon=timZon) "Local civil time"
          annotation (Placement(transformation(extent={{-120,-160},{-100,-140}})));
        Modelica.Blocks.Tables.CombiTable1Ds datRea1(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns=9:11) "Data reader"
          annotation (Placement(transformation(extent={{-80,180},{-60,200}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim1
          "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-110,180},{-90,200}})));
        BaseClasses.ConvertTime conTim "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-120,-40},{-100,-20}})));
        BaseClasses.EquationOfTime eqnTim "Equation of time"
          annotation (Placement(transformation(extent={{-120,-120},{-100,-100}})));
        BaseClasses.SolarTime solTim "Solar time"
          annotation (Placement(transformation(extent={{-80,-140},{-60,-120}})));
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput pAtm_in_internal(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="bar") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput ceiHei_in_internal(
          final quantity="Height",
          final unit="m",
          displayUnit="m") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput totSkyCov_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput opaSkyCov_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput TDryBul_in_internal(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput TDewPoi_in_internal(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput TBlaSky_in_internal(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput relHum_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput winSpe_in_internal(
          final quantity="Velocity",
          final unit="m/s") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput winDir_in_internal(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HGloHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HDifHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HDirNor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HInfHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Math.UnitConversions.From_deg conWinDir
          "Convert the wind direction unit from [deg] to [rad]"
          annotation (Placement(transformation(extent={{120,-280},{140,-260}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDryBul
          annotation (Placement(transformation(extent={{120,-200},{140,-180}})));
        BaseClasses.ConvertRadiation conHorRad
          annotation (Placement(transformation(extent={{120,100},{140,120}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDewPoi
          "Convert the dew point temperature form [degC] to [K]"
          annotation (Placement(transformation(extent={{120,-240},{140,-220}})));
        BaseClasses.ConvertRadiation conDirNorRad
          annotation (Placement(transformation(extent={{120,220},{140,240}})));
        BaseClasses.ConvertRadiation conGloHorRad
          annotation (Placement(transformation(extent={{120,180},{140,200}})));
        BaseClasses.ConvertRadiation conDifHorRad
          annotation (Placement(transformation(extent={{120,140},{140,160}})));
        BaseClasses.CheckRelativeHumidity cheRelHum
          annotation (Placement(transformation(extent={{160,20},{180,40}})));
        SolarGeometry.BaseClasses.AltitudeAngle altAng "Solar altitude angle"
          annotation (Placement(transformation(extent={{-30,-280},{-10,-260}})));
         SolarGeometry.BaseClasses.ZenithAngle zenAng(
           final lat = lat) "Zenith angle"
          annotation (Placement(transformation(extent={{-80,-226},{-60,-206}})));
         SolarGeometry.BaseClasses.Declination decAng "Declination angle"
          annotation (Placement(transformation(extent={{-140,-220},{-120,-200}})));
         SolarGeometry.BaseClasses.SolarHourAngle
          solHouAng
          annotation (Placement(transformation(extent={{-140,-250},{-120,-230}})));
        Latitude latitude(final latitude=lat) "Latitude"
          annotation (Placement(transformation(extent={{-180,-280},{-160,-260}})));
        Longitude longitude(final longitude=lon) "Longitude"
          annotation (Placement(transformation(extent={{-140,-280},{-120,-260}})));
        //---------------------------------------------------------------------------
        // Optional instanciation of a block that computes the wet bulb temperature.
        // This block may be needed for evaporative cooling towers.
        // By default, it is enabled. This introduces a nonlinear equation, but
        // we have not observed an increase in computing time because of this equation.
        IDEAS.Utilities.Psychrometrics.TWetBul_TDryBulPhi tWetBul_TDryBulXi(
            redeclare package Medium = IDEAS.Media.Air,
            TDryBul(displayUnit="degC")) if computeWetBulbTemperature
          annotation (Placement(transformation(extent={{244,-66},{264,-46}})));
        //---------------------------------------------------------------------------
        // Conversion blocks for sky cover
        Modelica.Blocks.Math.Gain conTotSkyCov(final k=0.1) if
             totSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{120,-40},{140,-20}})));
        Modelica.Blocks.Math.Gain conOpaSkyCov(final k=0.1) if
             opaSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{120,-158},{140,-138}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckBlackBodySkyTemperature cheTemBlaSky(TMin=0)
          "Check black body sky temperature"
          annotation (Placement(transformation(extent={{240,-260},{260,-240}})));
        // Blocks that are added in order to set the name of the output signal,
        // which then is displayed in the GUI of the weather data connector.
        block Latitude "Generate constant signal of type Real"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle latitude "Latitude";
          Modelica.Blocks.Interfaces.RealOutput y(
            unit="rad",
            displayUnit="deg") "Latitude of the location"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          y = latitude;
          annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-81,32},{84,-24}},
                lineColor={0,0,0},
                  textString="Latitude")}),
          Documentation(info="<html>
<p>
Block to output the latitude of the location.
This block is added so that the latitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the latitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Latitude;

        block Longitude "Generate constant signal of type Real"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle longitude "Longitude";
          Modelica.Blocks.Interfaces.RealOutput y(
            unit="rad",
            displayUnit="deg") "Longitude of the location"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          y = longitude;
          annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-81,32},{84,-24}},
                lineColor={0,0,0},
                  textString="Longitude")}),
          Documentation(info="<html>
<p>
Block to output the longitude of the location.
This block is added so that the longitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the longitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Longitude;
      equation
        //---------------------------------------------------------------------------
        // Select atmospheric pressure connector
        if pAtmSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          pAtm_in_internal = pAtm;
        elseif pAtmSou == IDEAS.BoundaryConditions.Types.DataSource.File then
          connect(datRea.y[4], pAtm_in_internal);
        else
          connect(pAtm_in, pAtm_in_internal);
        end if;
        connect(pAtm_in_internal, chePre.PIn);
        //---------------------------------------------------------------------------
        // Select ceiling height connector
        if ceiHeiSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          ceiHei_in_internal = ceiHei;
        elseif ceiHeiSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(ceiHei_in, ceiHei_in_internal);
        else
          connect(datRea.y[16], ceiHei_in_internal);
        end if;
         connect(ceiHei_in_internal, cheCeiHei.ceiHeiIn);
        //---------------------------------------------------------------------------
        // Select total sky cover connector
        if totSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          totSkyCov_in_internal = totSkyCov;
        elseif totSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(totSkyCov_in, totSkyCov_in_internal);
        else
          connect(conTotSkyCov.u, datRea.y[13]) annotation (Line(
            points={{118,-30},{-59,-30}},
            color={0,0,127}));
          connect(conTotSkyCov.y, totSkyCov_in_internal);
        end if;
        connect(totSkyCov_in_internal, cheTotSkyCov.nIn);
        //---------------------------------------------------------------------------
        // Select opaque sky cover connector
        if opaSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          opaSkyCov_in_internal = opaSkyCov;
        elseif opaSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(opaSkyCov_in, opaSkyCov_in_internal);
        else
          connect(conOpaSkyCov.u, datRea.y[14]) annotation (Line(
            points={{118,-148},{30,-148},{30,-30},{-59,-30}},
            color={0,0,127}));
          connect(conOpaSkyCov.y, opaSkyCov_in_internal);
        end if;
        connect(opaSkyCov_in_internal, cheOpaSkyCov.nIn);
        //---------------------------------------------------------------------------
        // Select dew point temperature connector
        if TDewPoiSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          TDewPoi_in_internal = TDewPoi;
        elseif TDewPoiSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(TDewPoi_in, TDewPoi_in_internal);
        else
          connect(conTDewPoi.y, TDewPoi_in_internal);
        end if;
        connect(TDewPoi_in_internal, cheTemDewPoi.TIn);
        //---------------------------------------------------------------------------
        // Select dry bulb temperature connector
        if TDryBulSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          TDryBul_in_internal = TDryBul;
        elseif TDryBulSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(TDryBul_in, TDryBul_in_internal);
        else
          connect(conTDryBul.y, TDryBul_in_internal);
        end if;
        connect(TDryBul_in_internal, cheTemDryBul.TIn);
        //---------------------------------------------------------------------------
        // Select sky black body temperature connector
        if TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          TBlaSky_in_internal = TBlaSky;
        elseif TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(TBlaSky_in, TBlaSky_in_internal);
        else
          connect(TBlaSkyCom.TBlaSky, TBlaSky_in_internal);
        end if;
        connect(TBlaSky_in_internal, cheTemBlaSky.TIn);
        //---------------------------------------------------------------------------
        // Select relative humidity connector
        if relHumSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          relHum_in_internal = relHum;
        elseif relHumSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(relHum_in, relHum_in_internal);
        else
          connect(conRelHum.relHumOut, relHum_in_internal);
        end if;
        connect(relHum_in_internal, cheRelHum.relHumIn);
        //---------------------------------------------------------------------------
        // Select wind speed connector
        if winSpeSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          winSpe_in_internal = winSpe;
        elseif winSpeSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(winSpe_in, winSpe_in_internal);
        else
          connect(datRea.y[12], winSpe_in_internal);
        end if;
        connect(winSpe_in_internal, cheWinSpe.winSpeIn);
        //---------------------------------------------------------------------------
        // Select wind direction connector
        if winDirSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          winDir_in_internal = winDir;
        elseif winDirSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(winDir_in, winDir_in_internal);
        else
          connect(conWinDir.y, winDir_in_internal);
        end if;
        connect(winDir_in_internal, cheWinDir.nIn);
        //---------------------------------------------------------------------------
        // Select global horizontal radiation connector
        if HSou ==  IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor then
          connect(HGloHor_in, HGloHor_in_internal)
            "Get HGloHor using user input file";
        elseif HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
           HDirNor_in_internal*cos(zenAng.zen)+HDifHor_in_internal = HGloHor_in_internal
            "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
        else
          connect(conGloHorRad.HOut, HGloHor_in_internal)
            "Get HGloHor using weather data file";
        end if;
        connect(HGloHor_in_internal, cheGloHorRad.HIn);
        //---------------------------------------------------------------------------
        // Select diffuse horizontal radiation connector
        if HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
           connect(HDifHor_in, HDifHor_in_internal)
            "Get HDifHor using user input file";
        elseif  HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor then
            HGloHor_in_internal - HDirNor_in_internal*cos(zenAng.zen) = HDifHor_in_internal
            "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
        else
          connect(conDifHorRad.HOut, HDifHor_in_internal)
            "Get HDifHor using weather data file";
        end if;
        connect(HDifHor_in_internal, cheDifHorRad.HIn);
        //---------------------------------------------------------------------------
        // Select direct normal radiation connector
        if HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
           connect(HDirNor_in, HDirNor_in_internal)
            "Get HDirNor using user input file";
        elseif  HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor then
            IDEAS.Utilities.Math.Functions.smoothMin(
              solCon,
              (HGloHor_in_internal -HDifHor_in_internal)*
                IDEAS.Utilities.Math.Functions.spliceFunction(
                  x=cos(zenAng.zen),
                  pos=IDEAS.Utilities.Math.Functions.inverseXRegularized(cos(zenAng.zen),epsCos),
                  neg=0,
                  deltax=epsCos),
              0.1)
              = HDirNor_in_internal
            "Calculate the HDirNor using HGloHor and HDifHor according to (A.4.14) and (A.4.15)";
        else
          connect(conDirNorRad.HOut, HDirNor_in_internal)
            "Get HDirNor using weather data file";
        end if;
        connect(HDirNor_in_internal, cheDirNorRad.HIn);
        //---------------------------------------------------------------------------
        // Select infrared radiation connector
        if HInfHorSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          HInfHor_in_internal = HInfHor;
        elseif HInfHorSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(HInfHor_in, HInfHor_in_internal);
        else
          connect(conHorRad.HOut, HInfHor_in_internal);
        end if;
        connect(HInfHor_in_internal, cheHorRad.HIn);
        connect(chePre.POut, weaBus.pAtm) annotation (Line(
            points={{181,70},{220,70},{220,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTotSkyCov.nOut, weaBus.nTot) annotation (Line(
            points={{181,-30},{220,-30},{220,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheOpaSkyCov.nOut, weaBus.nOpa) annotation (Line(
            points={{181,-150},{220,-150},{220,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheGloHorRad.HOut, weaBus.HGloHor) annotation (Line(
            points={{181,190},{220,190},{220,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheDifHorRad.HOut, weaBus.HDifHor) annotation (Line(
            points={{181,150},{220,150},{220,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheDirNorRad.HOut, weaBus.HDirNor) annotation (Line(
            points={{181,230},{220,230},{220,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheCeiHei.ceiHeiOut, weaBus.celHei) annotation (Line(
            points={{181,-110},{220,-110},{220,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheWinSpe.winSpeOut, weaBus.winSpe) annotation (Line(
            points={{181,-70},{220,-70},{220,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheHorRad.HOut, weaBus.HHorIR) annotation (Line(
            points={{181,110},{220,110},{220,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheWinDir.nOut, weaBus.winDir) annotation (Line(
            points={{181,-270},{280,-270},{280,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheOpaSkyCov.nOut, TBlaSkyCom.nOpa) annotation (Line(
            points={{181,-150},{220,-150},{220,-213},{238,-213}},
            color={0,0,127}));
        connect(cheHorRad.HOut, TBlaSkyCom.HHorIR) annotation (Line(
            points={{181,110},{220,110},{220,-218},{238,-218}},
            color={0,0,127}));
        connect(modTim.y, weaBus.cloTim) annotation (Line(
            points={{-159,6.10623e-16},{34.75,6.10623e-16},{34.75,0},{124.5,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(modTim.y, add.u2) annotation (Line(
            points={{-159,0},{-150,0},{-150,184},{-142,184}},
            color={0,0,127}));
        connect(con30mins.y, add.u1) annotation (Line(
            points={{-159,222},{-150,222},{-150,196},{-142,196}},
            color={0,0,127}));
        connect(add.y, conTim1.modTim) annotation (Line(
            points={{-119,190},{-112,190}},
            color={0,0,127}));
        connect(conTim1.calTim, datRea1.u) annotation (Line(
            points={{-89,190},{-82,190}},
            color={0,0,127}));
        connect(modTim.y, locTim.cloTim) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-150},{-122,-150}},
            color={0,0,127}));
        connect(modTim.y, conTim.modTim) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-30},{-122,-30}},
            color={0,0,127}));
        connect(conTim.calTim, datRea.u) annotation (Line(
            points={{-99,-30},{-82,-30}},
            color={0,0,127}));
        connect(modTim.y, eqnTim.nDay) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-110},{-122,-110}},
            color={0,0,127}));
        connect(eqnTim.eqnTim, solTim.equTim) annotation (Line(
            points={{-99,-110},{-88,-110},{-88,-124},{-82,-124}},
            color={0,0,127}));
        connect(locTim.locTim, solTim.locTim) annotation (Line(
            points={{-99,-150},{-88,-150},{-88,-135.4},{-82,-135.4}},
            color={0,0,127}));
        connect(solTim.solTim, weaBus.solTim) annotation (Line(
            points={{-59,-130},{-20,-130},{-20,0},{284,0},{284,0},{300,
                0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(datRea.y[11], conWinDir.u) annotation (Line(
            points={{-59,-30},{20,-30},{20,-270},{118,-270}},
            color={0,0,127}));
        connect(cheTemDryBul.TOut, TBlaSkyCom.TDryBul) annotation (Line(
            points={{181,-190},{220,-190},{220,-202},{238,-202}},
            color={0,0,127}));
        connect(datRea.y[1], conTDryBul.u) annotation (Line(
            points={{-59,-30},{20,-30},{20,-190},{118,-190}},
            color={0,0,127}));
        connect(datRea.y[2], conTDewPoi.u) annotation (Line(
            points={{-59,-30},{20,-30},{20,-230},{118,-230}},
            color={0,0,127}));
        connect(cheTemDewPoi.TOut, weaBus.TDewPoi) annotation (Line(
            points={{181,-230},{280,-230},{280,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(TBlaSkyCom.TDewPoi, cheTemDewPoi.TOut) annotation (Line(
            points={{238,-207},{220,-207},{220,-230},{181,-230}},
            color={0,0,127}));
        connect(datRea1.y[2], conDirNorRad.HIn) annotation (Line(
            points={{-59,190},{20,190},{20,230},{118,230}},
            color={0,0,127}));
        connect(datRea1.y[1], conGloHorRad.HIn) annotation (Line(
            points={{-59,190},{-40,190},{20,190},{118,190}},
            color={0,0,127}));
        connect(datRea1.y[3], conDifHorRad.HIn) annotation (Line(
            points={{-59,190},{20,190},{20,150},{118,150}},
            color={0,0,127}));
        connect(conRelHum.relHumIn, datRea.y[3]) annotation (Line(
            points={{118,30},{20,30},{20,-30},{-59,-30}},
            color={0,0,127}));
        connect(cheRelHum.relHumOut, weaBus.relHum) annotation (Line(
            points={{181,30},{280,30},{280,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTemDryBul.TOut, weaBus.TDryBul) annotation (Line(
            points={{181,-190},{280,-190},{280,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(decAng.decAng, zenAng.decAng)
                                        annotation (Line(
            points={{-119,-210},{-82,-210},{-82,-210.6}},
            color={0,0,127}));
        connect(solHouAng.solHouAng, zenAng.solHouAng)  annotation (Line(
            points={{-119,-240},{-100,-240},{-100,-220.8},{-82,-220.8}},
            color={0,0,127}));
        connect(solHouAng.solTim, solTim.solTim) annotation (Line(
            points={{-142,-240},{-154,-240},{-154,-172},{-20,-172},{-20,-130},{-59,-130}},
            color={0,0,127}));
        connect(decAng.nDay, modTim.y) annotation (Line(
            points={{-142,-210},{-150,-210},{-150,-180},{0,-180},{0,6.10623e-16},{
                -159,6.10623e-16}},
            color={0,0,127}));
        connect(zenAng.zen, altAng.zen) annotation (Line(
            points={{-59,-216},{-40,-216},{-40,-270},{-32,-270}},
            color={0,0,127}));
        // Connectors for wet bulb temperature.
        // These are removed if computeWetBulbTemperature = false
        connect(chePre.POut, tWetBul_TDryBulXi.p) annotation (Line(
            points={{181,70},{220,70},{220,-64},{243,-64}},
            color={0,0,127}));
        connect(tWetBul_TDryBulXi.TWetBul, weaBus.TWetBul) annotation (Line(
            points={{265,-56},{280,-56},{280,0},{292,0},{300,0}},
            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTemDryBul.TOut, tWetBul_TDryBulXi.TDryBul) annotation (Line(
            points={{181,-190},{220,-190},{220,-48},{243,-48}},
            color={0,0,127}));
        connect(cheRelHum.relHumOut, tWetBul_TDryBulXi.phi) annotation (Line(
            points={{181,30},{208,30},{208,-56},{243,-56}},
            color={0,0,127}));
        connect(altAng.alt, weaBus.solAlt) annotation (Line(
            points={{-9,-270},{8,-270},{8,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(zenAng.zen, weaBus.solZen) annotation (Line(
            points={{-59,-216},{-40,-216},{-40,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(decAng.decAng, weaBus.solDec) annotation (Line(
            points={{-119,-210},{-110,-210},{-110,-208},{-100,-208},{-100,-290},{290,
                -290},{290,0},{300,0}},
            color={0,0,127}));
        connect(solHouAng.solHouAng, weaBus.solHouAng) annotation (Line(
            points={{-119,-240},{-108,-240},{-108,-238},{-100,-238},{-100,-290},{290,
                -290},{290,0},{300,0}},
            color={0,0,127}));
        connect(longitude.y, weaBus.lon) annotation (Line(
            points={{-119,-270},{-100,-270},{-100,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(latitude.y, weaBus.lat) annotation (Line(
            points={{-159,-270},{-150,-270},{-150,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(cheTemBlaSky.TOut, weaBus.TBlaSky) annotation (Line(points={{261,-250},
                {261,-250},{280,-250},{280,0},{300,0}}, color={0,0,127}));
        connect(datRea.y[26], conHorRad.HIn) annotation (Line(points={{-59,-30},{20,
                -30},{20,110},{118,110}}, color={0,0,127}));
        annotation (
          defaultComponentName="weaDat",
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-200,-200},{200,200}},
              initialScale=0.05), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={124,142,255},
                fillColor={124,142,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-162,270},{138,230}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                visible=(pAtmSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,216},{-164,184}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                visible=(TDryBulSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-194,162},{-118,118}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                visible=(relHumSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,92},{-104,66}},
                lineColor={0,0,127},
                textString="relHum"),
              Text(
              visible=(winSpeSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-196,44},{-110,2}},
                lineColor={0,0,127},
                textString="winSpe"),
              Text(
                visible=(winDirSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-192,-18},{-106,-60}},
                lineColor={0,0,127},
                textString="winDir"),
              Text(
              visible=(HSou ==  IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor),
              extent={{-202,-88},{-112,-108}},
                lineColor={0,0,127},
                textString="HGloHor"),
              Text(visible=(HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-202,-142},{-116,-164}},
                lineColor={0,0,127},
                textString="HDifHor"),
              Text(
              visible=(HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-200,-186},{-126,-214}},
                lineColor={0,0,127},
                textString="HDirNor"),
              Ellipse(
                extent={{-146,154},{28,-20}},
                lineColor={255,220,220},
                lineThickness=1,
                fillPattern=FillPattern.Sphere,
                fillColor={255,255,0}),
              Polygon(
                points={{104,76},{87.9727,12.9844},{88,12},{120,22},{148,20},{174,8},
                    {192,-58},{148,-132},{20,-140},{-130,-136},{-156,-60},{-140,-6},{
                    -92,-4},{-68.2109,-21.8418},{-68,-22},{-82,40},{-48,90},{44,110},
                    {104,76}},
                lineColor={220,220,220},
                lineThickness=0.1,
                fillPattern=FillPattern.Sphere,
                smooth=Smooth.Bezier,
                fillColor={230,230,230})}),
          Documentation(info="<html>
<p>
This component reads TMY3 weather data (Wilcox and Marion, 2008) or user specified weather data.
The weather data format is the Typical Meteorological Year (TMY3)
as obtained from the EnergyPlus web site at
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>. These
data, which are in the EnergyPlus format, need to be converted as described
in the next paragraph.
</p>
<!-- ============================================== -->
<h4>Output to weaBus</h4>
<p>
The following variables serve as output and are accessible via <code>weaBus</code>:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Name
  </th>
  <th>Unit
  </th>
  <th>Description
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal diffuse solar radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifNor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Direct normal radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HGloHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal global radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HHorIR</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal infrared irradiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TBlaSky</code>
  </td>
  <td>
    K
  </td>
  <td>
    Output temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDewPoi</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dew point temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDryBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dry bulb temperature at ground level.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TWetBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Wet bulb temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>celHei</code>
  </td>
  <td>
    m
  </td>
  <td>
    Ceiling height.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>cloTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    One-based day number in seconds.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lat</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Latitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lon</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Longitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nOpa</code>
  </td>
  <td>
    1
  </td>
  <td>
  Opaque sky cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nTot</code>
  </td>
  <td>
    1
  </td>
  <td>
   Total sky Cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>pAtm</code>
  </td>
  <td>
    Pa
  </td>
  <td>
    Atmospheric pressure.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>relHum</code>
  </td>
  <td>
    1
  </td>
  <td>
    Relative humidity.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solAlt</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Altitude angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solDec</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Declination angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solHouAng</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Solar hour angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    Solar time.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solZen</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Zenith angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winDir</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Wind direction.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winSpe</code>
  </td>
  <td>
    m/s
  </td>
  <td>
    Wind speed.
  </td>
</tr>
</table>
<!-- ============================================== -->
<h4>Adding new weather data</h4>
<p>
To add new weather data, proceed as follows:
</p>
<ol>
<li>
Download the weather data file with the <code>epw</code> extension from
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>.
</li>
<li>
Add the file to <code>IDEAS/Resources/weatherdata</code> (or to any directory
for which you have write permission).
</li>
<li>
On a console window, type<pre>
  cd IDEAS/Resources/weatherdata
  java -jar ../bin/ConvertWeatherData.jar inputFile.epw
</pre>
This will generate the weather data file <code>inputFile.mos</code>, which can be read
by the model
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.ReaderTMY3\">
IDEAS.BoundaryConditions.WeatherData.ReaderTMY3</a>.
</li>
</ol>
<!-- ============================================== -->
<h4>Location data that are read automatically from the weather data file</h4>
<p>
The following location data are automatically read from the weather file:
</p>
<ul>
<li>
The latitude of the weather station, <code>lat</code>,
</li>
<li>
the longitude of the weather station, <code>lon</code>, and
</li>
<li>
the time zone relative to Greenwich Mean Time, <code>timZone</code>.
</li>
</ul>
<!-- ============================================== -->
<h4>Wet bulb temperature</h4>
<p>
By default, the data bus contains the wet bulb temperature.
This introduces a nonlinear equation.
However, we have not observed an increase in computing time because
of this equation.
To disable the computation of the wet bulb temperature, set
<code>computeWetBulbTemperature=false</code>.
</p>
<!-- ============================================== -->
<h4>Using constant or user-defined input signals for weather data</h4>
<p>
This model has the option of using a constant value, using the data from the weather file,
or using data from an input connector for the following variables:
</p>
<ul>
<li>
The atmospheric pressure,
</li>
<li>
the ceiling height,
</li>
<li>
the total sky cover,
</li>
<li>
the opaque sky cover,
</li>
<li>
the dry bulb temperature,
</li>
<li>
the dew point temperature,
</li>
<li>
the sky black body temperature,
</li>
<li>
the relative humidity,
</li>
<li>
the wind direction,
</li>
<li>
the wind speed,
</li>
<li>
the global horizontal radiation, direct normal and diffuse horizontal radiation,
and
</li>
<li>
the infrared horizontal radiation.
</li>
</ul>
<p>
By default, all data are obtained from the weather data file,
except for the atmospheric pressure, which is set to the
parameter <code>pAtm=101325</code> Pascals.
</p>
<p>
The parameter <code>*Sou</code> configures the source of the data.
For the atmospheric pressure, temperatures, relative humidity, wind speed and wind direction,
the enumeration
<a href=\"modelica://IDEAS.BoundaryConditions.Types.DataSource\">
IDEAS.BoundaryConditions.Types.DataSource</a>
is used as follows:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>*Sou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Parameter
  </td>
  <td>
    Use value specified by the parameter.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input
  </td>
  <td>
    Use value from the input connector.
  </td>
</tr>
</table>
<p>
Because global, diffuse and direct radiation are related to each other, the parameter
<code>HSou</code> is treated differently.
It is set to a value of the enumeration
<a href=\"modelica://IDEAS.BoundaryConditions.Types.RadiationDataSource\">
IDEAS.BoundaryConditions.Types.RadiationDataSource</a>,
and allows the following configurations:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>HSou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input_HGloHor_HDifHor
  </td>
  <td>
    Use global horizontal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HDifHor
  </td>
  <td>
    Use direct normal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HGloHor
  </td>
  <td>
    Use direct normal and global horizontal radiation from input connector.
  </td>
</tr>
</table>
<p>
<b>Notes</b>
</p>
<ol>
<li>
<p>
In HVAC systems, when the fan is off, changes in atmospheric pressure can cause small air flow rates
in the duct system due to change in pressure and hence in the mass of air that is stored
in air volumes (such as in fluid junctions or in the room model).
This may increase computing time. Therefore, the default value for the atmospheric pressure is set to a constant.
Furthermore, if the initial pressure of air volumes are different
from the atmospheric pressure, then fast pressure transients can happen in the first few seconds of the simulation.
This can cause numerical problems for the solver. To avoid this problem, set the atmospheric pressure to the
same value as the medium default pressure, which is typically set to the parameter <code>Medium.p_default</code>.
For medium models for moist air and dry air, the default is
<code>Medium.p_default=101325</code> Pascals.
</p>
</li>
<li>
<p>
Different units apply depending on whether data are obtained from a file, or
from a parameter or an input connector:
</p>
<ul>
<li>
When using TMY3 data from a file (e.g. <code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos</code>), the units must be the same as the original TMY3 file used by EnergyPlus (e.g.
<code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.epw</code>).
The TMY3 data used by EnergyPlus are in both SI units and non-SI units.
If <code>Resources/bin/ConvertWeatherData.jar</code> is used to convert the <code>.epw</code> file to an <code>.mos</code> file, the units of the TMY3 data are preserved and the file can be directly
used by this data reader.
The data reader will automatically convert units to the SI units used by Modelica.
For example, the dry bulb temperature <code>TDryBul</code> in TMY3 is in degree Celsius.
The data reader will automatically convert the data to Kelvin.
The wind direction <code>winDir</code> in TMY3 is degrees and will be automatically converted to radians.
</li>
<li>
When using data from a parameter or from an input connector,
the data must be in the SI units used by Modelica.
For instance, the unit must be
<code>Pa</code> for pressure,
<code>K</code> for temperature,
<code>W/m2</code> for solar radiations and
<code>rad</code> for wind direction.
</li>
</ul>
</li>
<li>
The ReaderTMY3 should only be used with TMY3 data. It contains a time shift for solar radiation data
that is explained below. This time shift needs to be removed if the user may want to
use the ReaderTMY3 for other weather data types.
</li>
</ol>
<h4>Implementation</h4>
<h5>Start and end data for annual weather data files</h5>
<p>
The TMY3 weather data, as well as the EnergyPlus weather data, start at 1:00 AM
on January 1, and provide hourly data until midnight on December 31.
Thus, the first entry for temperatures, humidity, wind speed etc. are values
at 1:00 AM and not at midnight. Furthermore, the TMY3 weather data files can have
values at midnight of December 31 that may be significantly different from the values
at 1:00 AM on January 1.
Since annual simulations require weather data that start at 0:00 on January 1,
data need to be provided for this hour. Due to the possibly large change in
weatherdata between 1:00 AM on January 1 and midnight at December 31,
the weather data files in the IDEAS library do not use the data entry from
midnight at December 31 as the value for <i>t=0</i>. Rather, the
value from 1:00 AM on January 1 is duplicated and used for 0:00 on January 1.
To maintain a data record with <i>8760</i> hours, the weather data record from
midnight at December 31 is deleted.
These changes in the weather data file are done in the Java program that converts
EnergyPlus weather data file to Modelica weather data files, and which is described
below.
</p>
<h5>Time shift for solar radiation data</h5>
<p>
To read weather data from the TMY3 weather data file, there are
two data readers in this model. One data reader obtains all data
except solar radiation, and the other data reader reads only the
solar radiation data, shifted by <i>30</i> minutes.
The reason for this time shift is as follows:
The TMY3 weather data file contains for solar radiation the
\"...radiation received
on a horizontal surface during
the 60-minute period ending at
the timestamp.\"

Thus, as the figure below shows, a more accurate interpolation is obtained if
time is shifted by <i>30</i> minutes prior to reading the weather data.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/BoundaryConditions/WeatherData/RadiationTimeShift.png\"
border=\"1\" />
</p>
<h4>References</h4>
<ul>
<li>
Wilcox S. and W. Marion. <i>Users Manual for TMY3 Data Sets</i>.
Technical Report, NREL/TP-581-43156, revised May 2008.
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
September 20, 2018, by Michael Wetter:<br/>
Corrected documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1022\">#1022</a>.
</li>
<li>
December 4, 2017, by Michael Wetter:<br/>
Removed function call to <code>getAbsolutePath</code>, as this causes in Dymola 2018FD01
the error
\"A call of loadResource with a non-literal string remains in the generated code; it will not work for an URI.\"
when exporting <a href=\"modelica://IDEAS.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone\">
IDEAS.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone</a>
as an FMU. Instead, if the weather file is specified as a Modelica, URI, syntax such as
<code>Modelica.Utilities.Files.loadResource(\"modelica://IDEAS/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos\")</code>
should be used.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/867\">#867</a>.
</li>
<li>
February 18, 2017, by Filip Jorissen:<br/>
Infrared radiation on horizontal surface is now delayed by 30 minutes
such that the results in
<a href=\"modelica://IDEAS.BoundaryConditions.SkyTemperature.Examples.BlackBody\">TBlaSky</a>
are consistent.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/648\">#648</a>.
</li>
<li>
December 06, 2016, by Thierry S. Nouidui:<br/>
Constrained the direct normal radiation to not be bigger than the solar constant when using
global and diffuse solar radiation data provided via the inputs connectors.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/608\">#608</a>.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Introduced <code>absFilNam</code> to avoid multiple calls to
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed output <code>radHorIR</code> to <code>HHorIR</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
January 4, 2016, by Moritz Lauster:<br/>
Added a table in documentation with output variables accessible via <code>weaBus</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
December 15, 2015, by Michael Wetter:<br/>
Added the block <code>cheTemBlaSky</code>. This also allows to graphically
connect the black body sky temperature to the weather bus, which is required
in Dymola 2016 for the variable <code>weaBus.TBlaSky</code> to appear
in the graphical editor.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/377\">#377</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Removed redundant but consistent
<code>connect(TBlaSkyCom.TBlaSky, weaBus.TBlaSky)</code>
statement.
This avoids a warning if
<a href=\"modelica://IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness\">
IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness</a>
is translated in pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
March 26, 2015, by Michael Wetter:<br/>
Added option to obtain the black body sky temperature
from a parameter or an input signal.
This is required for
<a href=\"modelica://Buildings.Rooms.Validation.MixedAirInitialization\">
Buildings.Rooms.Validation.MixedAirInitialization</a>.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Corrected error that led the total and opaque sky cover to be ten times
too low if its value was obtained from the parameter or the input connector.
For the standard configuration in which the sky cover is obtained from
the weather data file, the model was correct. This error only affected
the other two possible configurations.
</li>
<li>
September 12, 2014, by Michael Wetter:<br/>
Removed redundant connection <code>connect(conHorRad.HOut, cheHorRad.HIn);</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
May 5, 2013, by Thierry S. Nouidui:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the ceiling height, the total sky cover, the opaque sky cover, the dew point temperature,
and the infrared horizontal radiation <code>HInfHor</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Improved the algorithm that determines the absolute path of the file.
Now weather files are searched in the path specified, and if not found, the urls
<code>file://</code>, <code>modelica://</code> and <code>modelica://IDEAS</code>
are added in this order to search for the weather file.
This allows using the data reader without having to specify an absolute path,
as long as the <code>IDEAS</code> library
is on the <code>MODELICAPATH</code>.
This change was implemented in
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
and improves this weather data reader.
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
October 16, 2012, by Michael Wetter:<br/>
Added computation of the wet bulb temperature.
Computing the wet bulb temperature introduces a nonlinear
equation. As we have not observed an increase in computing time
because of computing the wet bulb temperature, it is computed
by default. By setting the parameter
<code>computeWetBulbTemperature=false</code>, the computation of the
wet bulb temperature can be removed.
Revised documentation.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code> and
improved the optional inputs for radiation data.
</li>
<li>
July 24, 2012, by Wangda Zuo:<br/>
Corrected the notes of SI unit requirements for input files.
</li>
<li>
July 13, 2012, by Michael Wetter:<br/>
Removed assignment of <code>HGloHor_in</code> in its declaration,
because this gives an overdetermined system if the input connector
is used.
Removed non-required assignments of attribute <code>displayUnit</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Added subbus for solar position, which is needed by irradition and
shading model.
</li>
<li>
November 29, 2011, by Michael Wetter:<br/>
Fixed wrong display unit for <code>pAtm_in_internal</code> and
made propagation of parameter final.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
<ol>
<li>
Added optional connectors for dry bulb temperature, relative humidity, wind speed, wind direction, global horizontal radiation, diffuse horizontal radiation.<br/>
</li>
<li>
Separate the unit conversion for TMY3 data and data validity check.
</li>
</ol>
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Propagated value for sky temperature calculation to make it accessible as a parameter.
</li>
<li>
July 20, 2011, by Michael Wetter:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the atmospheric pressure.
</li><li>
March 15, 2011, by Wangda Zuo:<br/>
Delete the wet bulb temperature since it may cause numerical problem.
</li>
<li>
March 7, 2011, by Wangda Zuo:<br/>
Added wet bulb temperature. Changed reader to read only needed columns.
Added explanation for 30 minutes shift for radiation data.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
Changed implementation to obtain longitude and time zone directly
from weather file.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false,
           extent={{-200,-300},{300,300}})));
      end ReaderTMY3;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to read weather data. It also contains
the <code>expandable connector</code>
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.Bus\">
IDEAS.BoundaryConditions.WeatherData.Bus</a>
that is used in the library to provide weather data to the different models.
</html>"));
    end WeatherData;
  annotation (preferredView="info",
  Documentation(info="<html>
This package contains models to compute boundary conditions such as weather data.
For models that set boundary conditions for fluid flow systems,
see
<a href=\"modelica://IDEAS.Fluid.Sources\">
IDEAS.Fluid.Sources</a>.
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
        graphics={
          Ellipse(
          extent={{-76,80},{6,-2}},
          lineColor={255,255,255},
          lineThickness=1,
          fillPattern=FillPattern.Sphere,
          fillColor={255,255,255}),
        Line(
          points={{32,-24},{76,-82}},
          color={95, 95, 95}),
        Line(
          points={{4,-24},{48,-82}},
          color={95, 95, 95}),
        Line(
          points={{-26,-24},{18,-82}},
          color={95, 95, 95}),
        Line(
          points={{-56,-24},{-12,-82}},
          color={95, 95, 95}),
        Polygon(
          points={{64,6},{50,-2},{40,-18},{70,-24},{78,-52},{26,-52},{-6,-54},{
              -72,-52},{-72,-22},{-52,-10},{-42,10},{-78,34},{-44,52},{40,56},{76,
              40},{64,6}},
          lineColor={150,150,150},
          lineThickness=0.1,
          fillPattern=FillPattern.Sphere,
          smooth=Smooth.Bezier,
          fillColor={150,150,150})}));
  end BoundaryConditions;

  package Buildings "Transient building models and model components"
  extends Modelica.Icons.Package;

    package Components
    "Building components for high-order building models or component analysis"
    extends Modelica.Icons.Package;

      package BaseClasses
      extends Modelica.Icons.BasesPackage;

        package ConductiveHeatTransfer

          model MonoLayer "single material layer"

            parameter Modelica.SIunits.Area A "Layer surface area";
            parameter IDEAS.Buildings.Data.Interfaces.Material mat
              "Layer material properties";
            parameter Modelica.SIunits.Angle inc
              "Inclinination angle of the layer at port_a";
            parameter Modelica.SIunits.Emissivity epsLw_a
              "Longwave emissivity of material connected at port_a";
            parameter Modelica.SIunits.Emissivity epsLw_b
              "Longwave emissivity on material connected at port_b";

            parameter Boolean linIntCon=false
              "Linearise interior convection inside air layers / cavities in walls";
            parameter Modelica.Fluid.Types.Dynamics energyDynamics=if mat.glass then Modelica.Fluid.Types.Dynamics.SteadyState else Modelica.Fluid.Types.Dynamics.FixedInitial
              "Static (steady state) or transient (dynamic) thermal conduction model"
              annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
            parameter Modelica.SIunits.Temperature T_start=293.15
              "Start temperature for each of the states";
            final parameter Modelica.SIunits.ThermalInsulance R = mat.R
              "Total specific thermal resistance";
            final parameter Boolean isDynamic = dynamicLayer and realLayer and not airLayer;

            Modelica.SIunits.Energy E = E_internal;

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              "Port for connections between layers"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              "Port for connections between layers"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_gain
              "Port for heat gains in layers"
              annotation (Placement(transformation(extent={{-10,90},{10,110}})));
            IDEAS.Buildings.Components.BaseClasses.ConductiveHeatTransfer.MonoLayerDynamic
              monLayDyn(
              A=A,
              mat=mat,
              T_start=T_start,
              energyDynamics=energyDynamics) if isDynamic
              "Dynamic monolayer for solid"
              annotation (Placement(transformation(extent={{-10,-42},{10,-22}})));

            IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.MonoLayerAir
              monLayAir(
              A=A,
              inc=inc,
              d=mat.d,
              k=mat.k,
              epsLw_a=epsLw_a,
              epsLw_b=epsLw_b,
              linearise=linIntCon,
              dT_nominal=dT_nom_air) if
                                      realLayer and airLayer
              annotation (Placement(transformation(extent={{-20,30},{0,50}})));
            IDEAS.Buildings.Components.BaseClasses.ConductiveHeatTransfer.MonoLayerStatic
              monLaySta(R=R/A) if
                 realLayer and not dynamicLayer and not airLayer
              annotation (Placement(transformation(extent={{0,70},{20,90}})));

        protected
            Modelica.Blocks.Interfaces.RealInput E_internal;
            final parameter Boolean dynamicLayer= not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
              "True when modelling thermal dynamics"
              annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
            final parameter Boolean realLayer = mat.d > Modelica.Constants.small
              "True when the layer has a non-zero thickness";

            final parameter Boolean airLayer = mat.gas
              "True when a convection + radiation equation should be used to model the layer instead of conduction";

        public
            parameter SI.TemperatureDifference dT_nom_air=1
              "Nominal temperature difference for air layers, used for linearising Rayleigh number";
          equation
            connect(E_internal, monLayDyn.E);
            if not realLayer or airLayer or not dynamicLayer then
              E_internal=0;
            end if;

            // Connections for fictive layers
            if not realLayer then
              connect(port_a, port_b) annotation (Line(
                points={{-100,0},{100,0}},
                color={191,0,0},
                smooth=Smooth.None));
            end if;

            // Connections for dynamic layers
            connect(port_a, monLayDyn.port_a) annotation (Line(
                points={{-100,0},{-100,-32},{-10,-32}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(monLayDyn.port_b, port_b) annotation (Line(
                points={{10,-32},{100,-32},{100,0}},
                color={191,0,0},
                smooth=Smooth.None));

            // Connections for air layers
            connect(monLayAir.port_a, port_a) annotation (Line(points={{-20,40},{-100,40},
                    {-100,0}},         color={191,0,0}));
            connect(monLayAir.port_b, port_b) annotation (Line(points={{0,40},{100,40},{100,
                    0}},            color={191,0,0}));

            // Connections for static layers
            connect(port_a, monLaySta.port_a) annotation (Line(points={{-100,0},{-100,0},{
                    -100,78},{-100,80},{0,80}},   color={191,0,0}));
            connect(monLaySta.port_b, port_b) annotation (Line(points={{20,80},{20,80},{100,
                    80},{100,0}}, color={191,0,0}));

            // For static monolayers or air monolayer, connect port_gain in the middle of the layer.
            connect(monLayAir.port_emb, port_gain)
              annotation (Line(points={{-10,50},{-10,50},{-10,100},{0,100}},
                                               color={191,0,0}));
            connect(port_gain, monLaySta.port_gain)
              annotation (Line(points={{0,100},{8,100},{10,100},{10,90}},
                                                        color={191,0,0}));
            // For dynamic monolayers or fictive monolayers, connect port_gain at port_b of the layer.
            if not realLayer or realLayer and dynamicLayer and not airLayer then
              connect(port_a, port_gain) annotation (Line(points={{-100,0},{-100,0},{-100,
                      100},{0,100}},
                              color={191,0,0}));
            end if;

            annotation (
              Diagram(graphics,
                      coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})),
              Icon(graphics={Rectangle(
                    extent={{-90,80},{90,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),Text(
                    extent={{-150,113},{150,73}},
                    textString="%name",
                    lineColor={0,0,255}),Ellipse(
                    extent={{-40,-42},{40,38}},
                    lineColor={127,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Text(
                    extent={{-39,40},{39,-40}},
                    lineColor={127,0,0},
                    fontName="Calibri",
                    origin={0,-1},
                    rotation=90,
                    textString="S")}),
              Documentation(info="<html>
</html>",           revisions="<html>
<ul>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
March 8, 2016, by Filip Jorissen:<br/>
Fixed bug in connection of internal gains. 
Now connecting to port_a instead of port_b.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: now only one MonoLayer component exists.
</li>
</ul>
</html>"));
          end MonoLayer;

          model MonoLayerDynamic "Dynamic layer for uniform solid."

            parameter Modelica.SIunits.Area A "Layer area";
            parameter IDEAS.Buildings.Data.Interfaces.Material mat "Layer material";
            parameter Modelica.SIunits.Temperature T_start=293.15
              "Start temperature for each of the states";
            parameter Integer nStaMin(min=1) = 2 "Minimum number of states";

            parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial
              "Static (steady state) or transient (dynamic) thermal conduction model"
              annotation (Evaluate=true, Dialog(tab="Dynamics", group="Equations"));
            final parameter Boolean present=mat.d > Modelica.Constants.small;
            final parameter Integer nSta=max(nStaMin, mat.nSta) "Number of states";
            final parameter Real R=mat.R "Total specific thermal resistance";
            final parameter Modelica.SIunits.HeatCapacity Ctot=A*mat.rho*mat.c*mat.d
              "Total heat capacity";
            // This option is for solving problems when connecting a
            // fixed temperature boundary to a state when linearising a model.
            parameter Boolean addRes_b=false
              "Set to true to add a resistor at port b.";
            Modelica.Blocks.Interfaces.RealOutput E(unit="J") = sum(T .* C);

        protected
            final parameter Integer nRes=if addRes_b then nSta
                 else max(nSta - 1, 1) "Number of thermal resistances";
            final parameter Modelica.SIunits.ThermalConductance[nRes] G=fill(nRes*A/R,
                nRes);
            final parameter Modelica.SIunits.HeatCapacity[nSta] C=Ctot*(if nSta <= 2 or
                addRes_b then ones(nSta)/nSta else cat(
                1,
                {0.5},
                ones(nSta - 2),
                {0.5})/(nSta - 1));
            final parameter Real[nSta] Cinv(unit="K/J") = ones(nSta) ./ C
              "Dummy parameter for efficiently handling check for division by zero";
            Modelica.SIunits.Temperature[nSta] T(each start=T_start) "Temperature at the states";
            Modelica.SIunits.HeatFlowRate[nRes] Q_flow
              "Heat flow rate from state i to i-1";

        public
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));

          initial equation
            // We define initial conditions only for the inner states to avoid
            // redundant initial equations.
            // Initial equations for the outer states are defined at the MultiLayer level.
            if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
              if addRes_b then
                T[nSta]=T_start;
              end if;
              for i in 2:nSta-1 loop
                T[i] = T_start;
              end for;
            elseif energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
              if addRes_b then
                der(T[nSta])=0;
              end if;
              for i in 2:nSta-1 loop
                der(T[i]) = 0;
              end for;
            end if;
            assert(nSta >= 1, "Number of states needs to be higher than zero.");
            assert(abs(sum(C) - A*mat.rho*mat.c*mat.d) < 1e-6, "Verification error in MonLayerDynamic");
            assert(abs(sum(ones(size(G, 1)) ./ G) - R/A) < 1e-6, "Verification error in MonLayerDynamic");
            assert(not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState, "MonoLayerDynamic is configured to steady state, which is not the scope of this model!");
          equation
            port_a.T = T[1];

            if nSta > 1 then
              der(T[1]) = (port_a.Q_flow - Q_flow[1])*Cinv[1];
              // Q_flow[i] is heat flowing from (i-1) to (i)
              for i in 1:nSta - 1 loop
                (T[i] - T[i + 1])*G[i] = Q_flow[i];
              end for;
              for i in 2:nRes loop
                der(T[i]) = (Q_flow[i - 1] - Q_flow[i])*Cinv[i];
              end for;

              if not addRes_b then
                der(T[nSta]) = (Q_flow[nSta - 1] + port_b.Q_flow)*Cinv[nSta];
                port_b.T = T[nSta];
              else
                (T[end] - port_b.T)*G[end] = Q_flow[end];
                port_b.Q_flow = -Q_flow[end];
              end if;
            else
              der(port_a.T) = (port_a.Q_flow + port_b.Q_flow)*Cinv[1];
              Q_flow[1] = -port_b.Q_flow;
              Q_flow[1] = (port_a.T - port_b.T)*G[1];
            end if;

            annotation (
              Diagram(graphics),
              Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{90,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-150,113},{150,73}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Ellipse(
                    extent={{-40,-42},{40,38}},
                    lineColor={127,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-39,40},{39,-40}},
                    lineColor={127,0,0},
                    fontName="Calibri",
                    origin={0,-1},
                    rotation=90,
                    textString="S")}),
              Documentation(info="<html>
<p>For the purpose of dynamic building simulation, the partial differential equation of the continuous 
time and space model of heat transport through a solid is most often simplified into ordinary differential 
equations with a finite number of parameters representing only one-dimensional heat transport through a construction layer. 
Within this context, the wall is modeled with lumped elements, i.e. a model where temperatures and heat 
fluxes are determined from a system composed of a sequence of discrete resistances and capacitances R_{n+1}, C_{n}. 
The number of capacitive elements $n$ used in modeling the transient thermal response of the wall denotes the order of the lumped capacitance model.
</p>
<p align=\"center\"><img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-pqp0E04K.png\"/></p>
<p>where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-I7KXJhSH.png\"/> is the added energy to the lumped capacity, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-B0HPmGTu.png\"/> is the temperature of the lumped capacity, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-t7aqbnLB.png\"/> is the thermal capacity of the lumped capacity equal to
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-JieDs0oi.png\"/> for which rho denotes the density and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-ml5CM4zK.png\"/> is the specific heat capacity of the material and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-hOGNA6h5.png\"/> the equivalent thickness of the lumped element, where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-1pDREAb7.png\"/> the heat flux through the lumped resistance and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-XYf3O3hw.png\"/> is the total thermal resistance of the lumped resistance and where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-dgS5sGAN.png\"/> are internal thermal source.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
January 25, 2018, by Filip Jorissen:<br/>
Propagated <code>T_start</code> in the declaration of <code>T</code>.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/692>#692</a>.
</li>
<li>
December 8, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation of placeCapacityAtSurf_b, which has been renamed to addRes_b.
This is for solving problems when linearising a model.
See issue 591.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation.
</li>
</ul>
</html>"));
          end MonoLayerDynamic;

          model MonoLayerStatic "Static layer for uniform solid."
            parameter Modelica.SIunits.ThermalResistance R
              "Total specific thermal resistance";
            Modelica.Thermal.HeatTransfer.Components.ThermalConductor theCon_a(G=G2)
              "Static monolayer for solid"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
             Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_gain
              "port for gains by embedded active layers"
              annotation (Placement(transformation(extent={{-10,90},{10,110}})));
            Modelica.Thermal.HeatTransfer.Components.ThermalConductor theCon_b(G=G2)
              "Static monolayer for solid"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        protected
            final parameter Modelica.SIunits.ThermalConductance G2 = 2/R;
          equation
            connect(theCon_a.port_b, theCon_b.port_a)
              annotation (Line(points={{-40,0},{40,0}}, color={191,0,0}));
            connect(port_gain, theCon_b.port_a) annotation (Line(points={{0,100},{0,100},{
                    0,16},{0,0},{40,0}}, color={191,0,0}));
            connect(theCon_a.port_a, port_a)
              annotation (Line(points={{-60,0},{-100,0}}, color={191,0,0}));
            connect(theCon_b.port_b, port_b)
              annotation (Line(points={{60,0},{100,0}}, color={191,0,0}));
            annotation (Diagram(graphics,
                                coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}})), Icon(graphics={
                  Rectangle(
                    extent={{-86,80},{24,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-150,-69},{150,-109}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{24,80},{44,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Forward,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{44,80},{84,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{24,80},{24,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{44,80},{44,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Ellipse(
                    extent={{-36,-42},{44,38}},
                    lineColor={127,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-39,40},{39,-40}},
                    lineColor={127,0,0},
                    fontName="Calibri",
                    origin={4,-1},
                    rotation=90,
                    textString="S")}),
              Documentation(revisions="<html>
<ul>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
          end MonoLayerStatic;

          model MultiLayer "multiple material layers in series"

            parameter Modelica.SIunits.Area A "total multilayer area";
            parameter Modelica.SIunits.Angle inc
              "Inclinination angle of the multilayer at port_a";
            parameter Integer nLay(min=1) "number of layers";
            parameter IDEAS.Buildings.Data.Interfaces.Material[nLay] mats
              "array of layer materials";
            parameter Integer nGain = 0 "Number of gains";
            parameter Boolean linIntCon=false
              "Linearise interior convection inside air layers / cavities in walls";
            final parameter Modelica.SIunits.ThermalInsulance R=sum(monLay.R)
              "total specific thermal resistance";
            final parameter Modelica.SIunits.HeatCapacity C = sum(mats.d.*mats.rho.*mats.c*A)
              "Total heat capacity of the layers"
              annotation(Evaluate=true);

            parameter Modelica.SIunits.Temperature T_start[nLay]=ones(nLay)*293.15
              "Start temperature from port_b to port_a"
              annotation(Evaluate=true, Dialog(group="Dynamics"));
            parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial
              "Static (steady state) or transient (dynamic) thermal conduction model"
              annotation(Evaluate=true, Dialog(group="Dynamics"));
            parameter Boolean disableInitPortA= false
              "Remove initial equation at port a"
              annotation(Evaluate=true, Dialog(group="Dynamics"));
            parameter Boolean disableInitPortB= false
              "Remove initial equation at port b"
              annotation(Evaluate=true, Dialog(group="Dynamics"));
            parameter SI.TemperatureDifference dT_nom_air=1
              "Nominal temperature difference for air layers, used for linearising Rayleigh number"
              annotation(Dialog(enable=linIntCon));

            Modelica.SIunits.Energy E = sum(monLay.E);

            IDEAS.Buildings.Components.BaseClasses.ConductiveHeatTransfer.MonoLayer[nLay]
              monLay(
              each final A=A,
              each final inc=inc,
              final T_start=T_start,
              final mat=mats,
              each linIntCon=linIntCon,
              epsLw_a=cat(
                  1,
                  mats[2:nLay].epsLw_b,
                  {0.85}),
              epsLw_b=cat(
                  1,
                  {0.85},
                  mats[1:nLay - 1].epsLw_a),
              each energyDynamics=energyDynamics,
              each dT_nom_air=dT_nom_air) "Individual layers"
              annotation (Placement(transformation(extent={{-10,10},{10,-10}})));

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_gain[nLay]
              "port for gains by embedded active layers"
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a(T(start=289.15))
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b(T(start=289.15))
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealOutput iEpsLw_b
              "output of the interior emissivity for radiative heat losses"
              annotation (Placement(transformation(extent={{90,70},{110,90}})));
            Modelica.Blocks.Interfaces.RealOutput iEpsSw_b
              "output of the interior emissivity for radiative heat losses"
              annotation (Placement(transformation(extent={{90,30},{110,50}})));
            Modelica.Blocks.Interfaces.RealOutput iEpsLw_a
              "output of the interior emissivity for radiative heat losses"
              annotation (Placement(transformation(extent={{-90,70},{-110,90}})));
            Modelica.Blocks.Interfaces.RealOutput iEpsSw_a
              "output of the interior emissivity for radiative heat losses"
              annotation (Placement(transformation(extent={{-90,30},{-110,50}})));
            Modelica.Blocks.Interfaces.RealOutput area=A
              "output of the interior emissivity for radiative heat losses" annotation (
                Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=-90,
                  origin={0,100})));
          initial equation
            // This code sets initial equations for the outer states of each monolayer.
            // These initial equations are not added at the monoLayer level
            // since then two adjacent monolayers may set an initial equation for the
            // same port, which causes warnings when the initial equations are consistent
            // and errors otherwise.
            // Moreover, multiple multiLayers may be connected to each other, such as in
            // the SlabOnGround model. For this case the parameter disableInitPortB is added.
            for i in 1:nLay loop
              if monLay[i].isDynamic then
                if i>1 or not disableInitPortB then
                  monLay[i].port_b.T=T_start[i];
                end if;
              end if;
              if monLay[i].isDynamic and (if i==nLay then not disableInitPortA else not monLay[i+1].isDynamic) then
                monLay[i].port_a.T=T_start[i];
              end if;
            end for;

          equation
            // Last layer of monLay is connected to port_a
            connect(port_a, monLay[nLay].port_a)
              annotation (Line(points={{-100,0},{-100,0},{-10,0}}, color={191,0,0}));
            for j in 1:nLay - 1 loop
              connect(monLay[nLay - j + 1].port_b, monLay[nLay - j].port_a);
            end for;
            connect(port_b, monLay[1].port_b)
              annotation (Line(points={{100,0},{10,0}}, color={191,0,0}));

            connect(monLay.port_gain, port_gain) annotation (Line(points={{0,-10},{0,-10},
                    {0,-60},{0,-100}}, color={191,0,0}));

            iEpsLw_a = mats[nLay].epsLw_a;
            iEpsSw_a = mats[nLay].epsSw_a;
            iEpsLw_b = mats[1].epsLw_b;
            iEpsSw_b = mats[1].epsSw_b;

            annotation (
              Diagram(graphics,
                      coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})),
              Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{20,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-150,113},{150,73}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{20,80},{40,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Forward,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{40,80},{80,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{20,80},{20,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{40,80},{40,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Ellipse(
                    extent={{-40,-42},{40,38}},
                    lineColor={127,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-39,40},{39,-40}},
                    lineColor={127,0,0},
                    fontName="Calibri",
                    origin={0,-1},
                    rotation=90,
                    textString="S")}),
              Documentation(info="<html>
</html>",           revisions="<html>
<ul>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
March 8, 2016, by Filip Jorissen:<br/>
Fixed bug in output of iEpsLw and iEpsSw for issue 464.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: now only one MultiLayer component exists.
</li>
</ul>
</html>"));
          end MultiLayer;
        end ConductiveHeatTransfer;

        package ConservationOfEnergy

          connector EnergyPort "Port for adding up energy"
            flow Modelica.SIunits.Energy E "Energy port";
            Modelica.SIunits.Energy Etot "Energy port";
            annotation (Documentation(info="<html>
<p>
This connector is used to add up all internal energy terms of the model in the SimInfoManager.
</p>
</html>",           revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
          end EnergyPort;

          model PrescribedEnergy "Prescribed energy component"
            Modelica.Blocks.Interfaces.RealInput E(unit="J") annotation (Placement(
                  transformation(
                  origin={-100,0},
                  extent={{20,-20},{-20,20}},
                  rotation=180)));
            IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.EnergyPort port
              annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=0)));
          equation
            port.E = -E;
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics={
                  Line(
                    points={{-60,-20},{40,-20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-60,20},{40,20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-80,0},{-60,-20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-80,0},{-60,20}},
                    color={191,0,0},
                    thickness=0.5),
                  Polygon(
                    points={{40,0},{40,40},{70,20},{40,0}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{40,-40},{40,0},{70,-20},{40,-40}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{70,40},{90,-40}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,100},{150,60}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
If parameter alpha is &lt;&gt; 0, the heat flow is multiplied by (1 + alpha*(port.T - T_ref))
in order to simulate temperature dependent losses (which are given with respect to reference temperature T_ref).
</p>
</html>",           revisions="<html>
<ul>
<li>
June 14, 2015, Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"),           Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},
                      {100,100}}), graphics={
                  Line(
                    points={{-60,-20},{68,-20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-60,20},{68,20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-80,0},{-60,-20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-80,0},{-60,20}},
                    color={191,0,0},
                    thickness=0.5),
                  Polygon(
                    points={{60,0},{60,40},{90,20},{60,0}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{60,-40},{60,0},{90,-20},{60,-40}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid)}));
          end PrescribedEnergy;
        end ConservationOfEnergy;

        package ConvectiveHeatTransfer

          model CavityAirflow "Model for air flow through a cavity"
            parameter Boolean linearise = false
              "=true, to linearise the relation between heat flow rate and temperature difference";
            parameter Real CD=0.65 "Discharge coefficient";
            parameter Modelica.SIunits.Length h = 2
              "Height of (rectangular) cavity in wall";
            parameter Modelica.SIunits.Length w = 1
              "Width of (rectangular) cavity in wall";
            parameter Modelica.SIunits.Acceleration g = Modelica.Constants.g_n
              "Gravity, for computation of buoyancy";
            parameter Modelica.SIunits.Pressure p = 101300
              "Absolute pressure for computation of buoyancy";
            parameter Modelica.SIunits.Density rho = p/r/T
              "Nominal density for computation of buoyancy mass flow rate";
            parameter Modelica.SIunits.SpecificHeatCapacity c_p = 1013
             "Nominal heat capacity for computation of buoyancy heat flow rate";
            parameter Modelica.SIunits.Temperature T = 293
             "Nominal temperature for linearising heat flow rate";
            parameter Modelica.SIunits.TemperatureDifference dT = 1
             "Nominal temperature difference when linearising heat flow rate"
             annotation(Dialog(enable=linearise));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              "Port for connections between layers"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              "Port for connections between layers"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        protected
            constant Real r = 287 "Gas constant";
            // Assuming the same entering and leaving flow rate
            // between .bottom and top half of the cavity
            // Assuming uniform flow through both parts.
            // dp= rho * g * h/4 * (1-T1/T2) - buoyancy: horizontal pressure differences
            // factor 4: distance between door center and center of top/bottom door half
            // v = sqrt(2 * dp/rho) - Bernoulli
            // dotm = v*h/2*w*rho*cp  - Mass flow rate
            // G = dotm * c_p
            final parameter Real coeff1 = CD*c_p*rho*w*h/2*sqrt(0.5*g*h) "Bernoulli-based thermal conductance";
            final parameter Real coeff2 = sqrt(abs(1-T/(T+dT)));
            Modelica.SIunits.ThermalConductance G=
              coeff1*(if linearise
                     then coeff2
           else
              sqrt(abs(1-port_a.T/port_b.T)));
              // We don't need a regularisation for the square root since this
              // equation should not end up in an algebraic loop
              // when used correctly in IDEAS.
              // However, laminar flow could be approximated better.
          equation
            port_a.Q_flow+port_b.Q_flow=0;
            port_a.Q_flow=(port_a.T-port_b.T)*G;
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                    extent={{-60,80},{60,-84}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={85,75,55},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-54,72},{56,-84}},
                    lineColor={0,0,0},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{56,72},{-36,66},{-36,-90},{56,-84},{56,72}},
                    lineColor={0,0,0},
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-30,-10},{-16,-8},{-16,-14},{-30,-16},{-30,-10}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid)}),                      Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
June 5, 2018 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",           info="<html>
<h4>Assumptions and limitations</h4>
<p>
The cavity model assumes that the temperature difference between both zones is constant
along the zone heights and that this causes a pressure difference between the zones
due to buoyancy. 
We assume that the pressure at the height of the center of the opening is 
equal in both zones.
Based on this pressure difference, the mass flow rate is computed using Bernoulli,
from which a heat flow rate is computed.
This model deals with stratification in a very simplified way. 
Very large openings can lead to small time constants, which can cause problems
for the time integrator.
Only thermal effects are modelled: there is no mass transport of air or moisture.
The influence of the cavity on the radiative heat exchange is not modelled.
</p>
</html>"));
          end CavityAirflow;

          model ExteriorConvection "exterior surface convection"
            parameter Modelica.SIunits.Area A "surface area";
            parameter Boolean linearise = false "Use constant convection coefficient"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.CoefficientOfHeatTransfer hConExtLin = 18.3
              "Fixed exterior convection coefficient used when linearising equations"
               annotation(Dialog(enable=linearize));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Blocks.Interfaces.RealInput Te(unit="K",displayUnit="degC")
              annotation (Placement(transformation(extent={{-120,-68},{-80,-28}})));
            Modelica.Blocks.Interfaces.RealInput hConExt(unit="W/(m2.K)")
              "Exterior convective heat transfer coefficient"
              annotation (Placement(transformation(extent={{-120,-110},{-80,-70}})));
          equation
            if linearise then
              port_a.Q_flow = A*hConExtLin *(port_a.T - Te);
            else
              port_a.Q_flow = A*hConExt*(port_a.T - Te);
            end if;
            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(points={{-60,20},{76,20}}, color={191,0,0}),
                  Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                  Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                  Line(points={{56,30},{76,20}}, color={191,0,0}),
                  Line(points={{56,10},{76,20}}, color={191,0,0}),
                  Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                  Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                  Line(points={{6,80},{6,-80}}, color={0,127,255}),
                  Line(points={{40,80},{40,-80}}, color={0,127,255}),
                  Line(points={{76,80},{76,-80}}, color={0,127,255}),
                  Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                  Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                  Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                  Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                  Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                  Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                  Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                  Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                  Text(
                    extent={{-150,-90},{150,-130}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5)}), Documentation(info="<html>
<p>
The exterior convective heat flow is computed as 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-dlroqBUD.png\"/>where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-pvb42RGk.png\"/> is the surface area, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-EFr6uClx.png\"/> is the dry-bulb exterior air temperature, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-9BU57cj4.png\"/> is the surface temperature and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-HvwkeunV.png\"/> is the wind speed in the undisturbed flow at 
10 meter above the ground and where the stated correlation is valid for a 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-HvwkeunV.png\"/> range of [0.15,7.5] meter per second 
<a href=\"IDEAS.Buildings.UsersGuide.References\">[Defraeye 2011]</a>.
 The <img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-HvwkeunV.png\"/>-dependent term denoting the exterior 
convective heat transfer coefficient <img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-W7Ft8vaa.png\"/> is 
determined as <img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-aZcbMNkz.png\"/> in order to take into 
account buoyancy effects at low wind speeds <a href=\"IDEAS.Buildings.UsersGuide.References\">[Jurges 1924]</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"),    Diagram(graphics,
                      coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})));
          end ExteriorConvection;

          model InteriorConvection "interior surface convection"
            parameter Modelica.SIunits.Area A "surface area";
            parameter Modelica.SIunits.Angle inc "inclination";
            parameter Boolean linearise = false
              "= true, if convective heat transfer should be linearised"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.TemperatureDifference dT_nominal = -2
              "Nominal temperature difference used for linearisation, negative temperatures indicate the solid is colder"
              annotation(Evaluate=true, enable = linearise);
            parameter Modelica.SIunits.Length hZone = 2.7
              "Zone height, for calculation of hydraulic diameter"
              annotation(Dialog(tab="Advanced"));
            parameter Modelica.SIunits.Length DhWall = 4*A/(2*A/hZone+2*hZone)
              "Hydraulic diameter for walls"
              annotation(Dialog(tab="Advanced"));
            parameter Modelica.SIunits.Length DhFloor = sqrt(A)
              "Hydraulic diameter for ceiling/floor"
              annotation(Dialog(tab="Advanced"));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        protected
            Modelica.SIunits.TemperatureDifference dT(start=0);
            final parameter Real coeffWall = A*1.823/DhWall^0.121
              "For avoiding calculation of power at every time step";
            final parameter Real coeffFloor = A*2.175/DhFloor^0.076
              "For avoiding calculations at every time step";
            final parameter Real coeffCeiling = A*0.704/DhFloor^0.601
              "For avoiding calculations at every time step";
            final parameter Boolean isCeiling=abs(sin(inc)) < 10E-5 and cos(inc) > 0
              "true if ceiling"
              annotation(Evaluate=true);
            final parameter Boolean isFloor=abs(sin(inc)) < 10E-5 and cos(inc) < 0
              "true if floor"
              annotation(Evaluate=true);
            final parameter Real ceilingSign = if isCeiling then 1 else -1
              "Coefficient for buoyancy direction"
              annotation(Evaluate=true);
          equation
              if isCeiling or isFloor then
                if linearise then
                  port_a.Q_flow = if ceilingSign*dT_nominal > 0 then
                        dT*coeffCeiling*abs(dT_nominal)^0.133
                        else
                        dT*coeffFloor*abs(dT_nominal)^0.308;
                else
                  port_a.Q_flow = IDEAS.Utilities.Math.Functions.spliceFunction(
                        x=ceilingSign*dT,
                        pos=sign(dT)*coeffCeiling*abs(dT)^1.133,
                        neg=sign(dT)*coeffFloor*abs(dT)^1.308,
                        deltax = 0.1);
                end if;
              else
                if linearise then
                  port_a.Q_flow = dT*coeffWall*abs(dT_nominal)^0.293;
                else
                  port_a.Q_flow = sign(dT)*coeffWall*abs(dT)^1.293;
                end if;
              end if;
            port_a.Q_flow + port_b.Q_flow = 0;
            dT = port_a.T - port_b.T;
            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(points={{-60,20},{76,20}}, color={191,0,0}),
                  Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                  Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                  Line(points={{56,30},{76,20}}, color={191,0,0}),
                  Line(points={{56,10},{76,20}}, color={191,0,0}),
                  Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                  Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                  Line(points={{6,80},{6,-80}}, color={0,127,255}),
                  Line(points={{40,80},{40,-80}}, color={0,127,255}),
                  Line(points={{76,80},{76,-80}}, color={0,127,255}),
                  Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                  Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                  Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                  Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                  Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                  Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                  Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                  Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                  Text(
                    extent={{-150,-90},{150,-130}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5)}), Documentation(info="<html>
<p>
The interior natural convective heat transfer coefficient 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-eZGZlJrg.png\"/> 
is computed for each interior surface as 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-KNBSKUDK.png\"/>where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-W5kvS3SS.png\"/> is the characteristic length of the surface, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-jhC1rqax.png\"/> is the indoor air temperature and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-sbXAgHuQ.png\"/> are correlation coefficients. These parameters {
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-nHmmePq5.png\"/>,
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-zJZmNUzp.png\"/>,
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-7nwXbcLp.png\"/>} are identical to {1.823,-0.121,0.293} for vertical surfaces [Awbi 1999], 
{2.175,-0.076,0.308} for horizontal surfaces wherefore the heat flux is in the same direction as the buoyancy force <a href=\"IDEAS.Buildings.UsersGuide.References\">[Khalifa 2001]</a>, 
and {2.72,-,0.13} for horizontal surfaces wherefore the heat flux is in the opposite direction as the buoyancy force <a href=\"IDEAS.Buildings.UsersGuide.References\">[Awbi 1999]</a>. 
The interior natural convective heat transfer coefficient is only described as function 
of the temperature difference. Similar to the thermal model for heat transfer through a wall, 
a thermal circuit formulation for the direct radiant exchange between surfaces can be derived 
<a href=\"IDEAS.Buildings.UsersGuide.References\">[ Buchberg 1955, Oppenheim 1956]</a>.
</p>
<p>
[Awbi 1999]: H.B. Awbi, A. Hatton, Natural convection from heated room surfaces, Energy and Buildings 30 (1999) 233&ndash;244.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 11, 2016 by Filip Jorissen:<br/>
Adjusted formulation of correlation such that the Jacobian computation of 
non-linear algebraic loops do not lead to negative exponents.
</li>
</ul>
</html>"));
          end InteriorConvection;

          model MonoLayerAir
            "Heat transfer correlations (convection and radiation) for air cavities"
            parameter Modelica.SIunits.Area A "Surface area";
            parameter Modelica.SIunits.Angle inc "Inclination of surface at port a";
            parameter Modelica.SIunits.Length d "Cavity width";
            parameter Modelica.SIunits.Emissivity epsLw_a
              "Longwave emissivity of material connected at port_a";
            parameter Modelica.SIunits.Emissivity epsLw_b
              "Longwave emissivity on material connected at port_b";
            parameter Modelica.SIunits.TemperatureDifference dT_nominal = 1
              "Nominal temperature difference, used for linearising Rayleigh number"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.ThermalConductivity k = 0.026
              "Thermal conductivity of medium, default for air, T=20C";
            parameter Modelica.Media.Interfaces.Types.IsobaricExpansionCoefficient beta = 3.43e-3
              "Thermal expansion coefficient of medium, default for air, T=20C"
              annotation(Dialog(group="Advanced"));
            parameter Modelica.SIunits.KinematicViscosity nu = 15e-6
              "Kinematic viscosity of medium, default for air, T=20C"
              annotation(Dialog(group="Advanced"));
            parameter Modelica.SIunits.ThermalDiffusivity alpha = 22e-6
              "Thermal diffusivity of medium, default for air, T=300K"
              annotation(Dialog(group="Advanced"));
            parameter Boolean linearise = true
              "Linearise Grashoff number around expected nominal temperature difference"
              annotation(Evaluate=true);
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.SIunits.ThermalConductance G=h*A + A*5.86*(1/((1/epsLw_a) + (1/epsLw_b) - 1));
            //when linearising we assume that Nu is the average Nu for positive and negative temperature differences
            //Eqn 5 from Hollands
            Real Nu=
              if ceiling or floor then
                (if linearise then
                  (1 + (1.44*(1-1708/Ra)+((Ra/5830)^(1/3)-1)))/2
                else
                  if ceiling then
                    IDEAS.Utilities.Math.Functions.spliceFunction(pos=1 + (1.44*max(1-1708/Ra,0)+max((Ra/5830)^(1/3)-1,0)), neg=1, x=sign(port_a.T-port_b.T)*Ra-500,  deltax=100)
                  else
                    IDEAS.Utilities.Math.Functions.spliceFunction(pos=1 + (1.44*max(1-1708/Ra,0)+max((Ra/5830)^(1/3)-1,0)), neg=1, x=sign(port_b.T-port_a.T)*Ra-500,  deltax=100))
              elseif vertical then
                (if Ra>5e4
                  then 0.0673838*Ra^(1/3)
                elseif Ra>1e4
                  then 0.028154*Ra^0.41399
                else 1+1.75967e-10*Ra^2.2984755)
              else 1 "Correlations from Hollands et al. and Wright et al.";
        protected
            final parameter Boolean ceiling=IDEAS.Utilities.Math.Functions.isAngle(inc,IDEAS.Types.Tilt.Ceiling)
              "true if ceiling"
              annotation(Evaluate=true);
            final parameter Boolean floor=IDEAS.Utilities.Math.Functions.isAngle(inc,IDEAS.Types.Tilt.Floor)
              "true if floor"
              annotation(Evaluate=true);
            final parameter Boolean vertical=IDEAS.Utilities.Math.Functions.isAngle(inc,IDEAS.Types.Tilt.Wall)
              annotation(Evaluate=true);
            final parameter Real coeffRa=Modelica.Constants.g_n*beta*d^3/nu/alpha "Coefficient for evaluating less operations at run time";
            Real Ra = max(1,(if linearise then abs(dT_nominal) else abs(port_a.T-port_b.T))*coeffRa);
            Modelica.SIunits.CoefficientOfHeatTransfer h = Nu*k/d;
        public
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_emb "Internal port"
              annotation (Placement(transformation(extent={{-10,90},{10,110}})));
          equation
            if not (ceiling or floor or vertical) then
              assert(false, "Could not find suitable correlation for air cavity! Please change the inclination to wall, ceiling or floor or remove the air layer.",
                   level=AssertionLevel.warning);
            end if;
            port_a.Q_flow + port_b.Q_flow + port_emb.Q_flow=0;
            port_a.Q_flow = G*(port_a.T - port_b.T);
            port_emb.T=(port_a.T+port_b.T)/2;
            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-70,80},{-100,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(points={{-70,20},{66,20}}, color={191,0,0}),
                  Line(points={{-50,80},{-50,-80}}, color={0,127,255}),
                  Line(points={{-70,-20},{66,-20}}, color={191,0,0}),
                  Line(points={{46,30},{66,20}}, color={191,0,0}),
                  Line(points={{46,10},{66,20}}, color={191,0,0}),
                  Line(points={{46,-10},{66,-20}}, color={191,0,0}),
                  Line(points={{46,-30},{66,-20}}, color={191,0,0}),
                  Line(points={{-20,80},{-20,-80}},
                                                color={0,127,255}),
                  Line(points={{20,80},{20,-80}}, color={0,127,255}),
                  Line(points={{50,80},{50,-80}}, color={0,127,255}),
                  Line(points={{-50,80},{-60,60}},   color={0,127,255}),
                  Line(points={{-50,80},{-40,60}},   color={0,127,255}),
                  Line(points={{-20,80},{-30,60}},color={0,127,255}),
                  Line(points={{-20,80},{-10,60}},color={0,127,255}),
                  Line(points={{20,-80},{10,-60}}, color={0,127,255}),
                  Line(points={{20,-80},{30,-60}}, color={0,127,255}),
                  Line(points={{50,-80},{40,-60}}, color={0,127,255}),
                  Line(points={{50,-80},{60,-60}}, color={0,127,255}),
                  Text(
                    extent={{-148,-88},{152,-128}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-70,80},{-70,-80}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(points={{-50,64},{-60,44}},   color={0,127,255}),
                  Line(points={{-50,64},{-40,44}},   color={0,127,255}),
                  Line(points={{50,-60},{60,-40}},color={0,127,255}),
                  Line(points={{50,-60},{40,-40}},color={0,127,255}),
                  Rectangle(
                    extent={{100,80},{70,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{70,80},{70,-80}},
                    color={0,0,0},
                    thickness=0.5)}), Documentation(info="<html>
<p>
Model for computing convective/radiative heat transfer inside air cavities.
</p>
<h4>Assumption and limitations</h4>
<p>
Only valid for horizontal or vertical surfaces.
</p>
<h4>References</h4>
<pre><span style=\"font-family: Courier New,courier;\">Horizontal:</span>
<span style=\"font-family: Courier New,courier;\">K.G.T. Hollands, G.D. Raithby, L. Konicek, Correlation equations for free convection heat transfer in horizontal layers of air and water, International Journal of Heat and Mass Transfer, Volume 18, Issues 7&ndash;8, July&ndash;August 1975, Pages 879-884, ISSN 0017-9310, http://dx.doi.org/10.1016/0017-9310(75)90179-9.</span>
<span style=\"font-family: Courier New,courier;\">(http://www.sciencedirect.com/science/article/pii/0017931075901799)</span>

<span style=\"font-family: Courier New,courier;\">Vertical:</span>
<span style=\"font-family: Courier New,courier;\">Wright, J. 1996. A correlation to quantify convective heat transfer between vertical window glazings, ASHRAE Transactions, 102(1): 940-946.</span></pre>
</html>",           revisions="<html>
<ul>
<li>
November 10, 2016, by Filip Jorissen:<br/>
Revised implementation for horizontal surfaces such that
less state events are generated.
</li>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation.
</li>
<li>
November 15, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
          end MonoLayerAir;
        end ConvectiveHeatTransfer;

        package RadiativeHeatTransfer

          model ExteriorHeatRadiation
            "longwave radiative heat exchange of an exterior surface with the environment"
            parameter Modelica.SIunits.Area A "Surface area of heat exchange surface";
            parameter Modelica.SIunits.Temperature Tenv_nom = 280
              "Nominal temperature of environment"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Boolean linearise=true "If true, linearise radiative heat transfer";
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Blocks.Interfaces.RealInput Tenv
              "Radiative temperature of the environment"
              annotation (Placement(transformation(extent={{-120,40},{-80,80}})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature preTem
              "Prescribed temperature block"
              annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            Modelica.Blocks.Interfaces.RealInput epsLw
              "Longwave emissivity of the surface"
              annotation (Placement(transformation(extent={{-120,14},{-80,54}})));
            IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.HeatRadiation
              heaRad(
              final R=R,
              final Tzone_nom=Tenv_nom,
              dT_nom=5,
              final linearise=linearise) "Component for computing radiative heat "
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        protected
            parameter Real R(fixed=false);
          initial equation
            R=1/(Modelica.Constants.sigma*A*epsLw);
          equation
            connect(preTem.port, heaRad.port_b)
              annotation (Line(points={{10,60},{10,0}}, color={191,0,0}));
            connect(heaRad.port_a, port_a)
              annotation (Line(points={{-10,0},{-100,0}}, color={191,0,0}));
            connect(preTem.T, Tenv)
              annotation (Line(points={{-12,60},{-56,60},{-100,60}}, color={0,0,127}));
            annotation (Icon(graphics={
                  Line(points={{-40,10},{40,10}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,16}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,4}}, color={191,0,0}),
                  Line(points={{-40,-10},{40,-10}}, color={191,0,0}),
                  Line(points={{30,-16},{40,-10}}, color={191,0,0}),
                  Line(points={{30,-4},{40,-10}}, color={191,0,0}),
                  Line(points={{-40,-30},{40,-30}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-24}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-36}}, color={191,0,0}),
                  Line(points={{-40,30},{40,30}}, color={191,0,0}),
                  Line(points={{30,24},{40,30}}, color={191,0,0}),
                  Line(points={{30,36},{40,30}}, color={191,0,0}),
                  Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5),
                  Rectangle(
                    extent={{90,80},{60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{60,80},{60,-80}},
                    color={0,0,0},
                    thickness=0.5)}), Documentation(info="<html>
<p>
Longwave radiation between the surface and environment 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-AMjoTx5S.png\"/> is determined as
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-nt0agyic.png\"/>as derived from the Stefan-Boltzmann law wherefore 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-C6ZFvd5P.png\"/> the Stefan-Boltzmann constant 
<a href=\"IDEAS.Buildings.UsersGuide.References\">[Mohr 2008]</a>, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-sLNH0zgx.png\"/> the longwave emissivity of the exterior surface, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-Q5X4Yht9.png\"/> the radiant-interchange configuration factor between the surface and sky 
<a href=\"IDEAS.Buildings.UsersGuide.References\">[Hamilton 1952]</a>, and the surface and the environment respectively and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-k2V39u5g.png\"/> and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-GuSnzLxW.png\"/> are the exterior surface and sky temperature respectively. 
Shortwave solar irradiation absorbed by the exterior surface is determined as 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-cISf3Itz.png\"/>where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-IKuIUMef.png\"/> is the shortwave absorption of the surface and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-Vuo4fgcb.png\"/> the total irradiation on the depicted surface.
</p>
</html>"),    Diagram(graphics,
                      coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                      100,100}})));
          end ExteriorHeatRadiation;

          model ExteriorSolarAbsorption
            "Shortwave radiation absorption on an exterior surface"
            parameter Modelica.SIunits.Area A "Surface area";

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              "Port for heat exchange"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Blocks.Interfaces.RealInput solDir(unit="W/m2")
              "Direct solar irradiation on surface"
              annotation (Placement(transformation(extent={{120,40},{80,80}})));
            Modelica.Blocks.Interfaces.RealInput solDif(unit="W/m2")
              "Diffuse solar irradiation on surface"
              annotation (Placement(transformation(extent={{120,0},{80,40}})));
            Modelica.Blocks.Interfaces.RealInput epsSw
              "Shortwave emissivity of the surface"
              annotation (Placement(transformation(extent={{-120,40},{-80,80}})));

        protected
            parameter Modelica.SIunits.Area ASw(fixed=false)
              "Dummy for converting continuous variable into parameter";

          initial equation
            ASw=-A*epsSw;

          equation
            port_a.Q_flow = ASw*(solDir + solDif);

            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(points={{-40,10},{40,10}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,16}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,4}}, color={191,0,0}),
                  Line(points={{-40,-10},{40,-10}}, color={191,0,0}),
                  Line(points={{-40,-30},{40,-30}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-24}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-36}}, color={191,0,0}),
                  Line(points={{-40,30},{40,30}}, color={191,0,0}),
                  Line(points={{-40,30},{-30,36}}, color={191,0,0}),
                  Line(points={{-40,30},{-30,24}},color={191,0,0}),
                  Line(points={{-40,-10},{-30,-4}},color={191,0,0}),
                  Line(points={{-40,-10},{-30,-16}}, color={191,0,0})}), Documentation(
                  info="<html>
<p>Transmitted shortwave solar radiation is distributed over all surfaces in the zone in a prescribed scale. This scale is an input value which may be dependent on the shape of the zone and the location of the windows, but literature <a href=\"IDEAS.Buildings.UsersGuide.References\">[Liesen 1997]</a> shows that the overall model is not significantly sensitive to this assumption.</p>
</html>",           revisions="<html>
<ul>
<li>
October 29, 2018 by Filip Jorissen:<br/>
Improved documentation for
<a href=\"https://github.com/open-ideas/IDEAS/issues/950\">#950</a>.
</li>
<li>
Refactored solar absorption to include parameter for A.
</li>
</ul>
</html>"),    Diagram(graphics,
                      coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})));
          end ExteriorSolarAbsorption;

          model HeatRadiation "radiative heat exchange between two temperatures"
            parameter Real R(unit="K4/W")
              "Heat resistance for longwave radiative heat exchange";
            parameter Boolean linearise = true
              "If true, linearise radiative heat transfer"
              annotation(Evaluate=true, Dialog(group="Linearisation"));
            parameter Modelica.SIunits.Temperature Tzone_nom = 295.15
              "Nominal temperature of environment, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Modelica.SIunits.TemperatureDifference dT_nom = -2
              "Nominal temperature difference between solid and air, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        protected
            parameter Modelica.SIunits.ThermalConductance coeffLin = 1/R*(2*Tzone_nom+dT_nom)*(Tzone_nom^2+(Tzone_nom+dT_nom)^2)
              "Coefficient allowing less overhead for evaluation functions. This implementation is an approximation of the real linearization f(u)_lin = df/du|(u=u_bar) * (u-u_bar) + f|u_bar. The accuracy of it has been checked.";
            parameter Real coeffNonLin(unit="W/K4") = 1/R
              "Coefficient allowing less overhead for evaluation functions.";
          equation
            port_a.Q_flow+port_b.Q_flow=0;
            if linearise then
              port_a.Q_flow = coeffLin*(port_a.T - port_b.T);
            else
              port_a.Q_flow = coeffNonLin*(port_a.T^4 - port_b.T^4);
            end if;
            annotation (Icon(graphics={Line(points={{-40,10},{40,10}}, color={191,0,0}),
                    Line(points={{-40,10},{-30,16}}, color={191,0,0}),Line(points={{-40,
                    10},{-30,4}}, color={191,0,0}),Line(points={{-40,-10},{40,-10}},
                    color={191,0,0}),Line(points={{30,-16},{40,-10}}, color={191,0,0}),
                    Line(points={{30,-4},{40,-10}}, color={191,0,0}),Line(points={{-40,-30},
                    {40,-30}}, color={191,0,0}),Line(points={{-40,-30},{-30,-24}}, color=
                    {191,0,0}),Line(points={{-40,-30},{-30,-36}}, color={191,0,0}),Line(
                    points={{-40,30},{40,30}}, color={191,0,0}),Line(points={{30,24},{40,
                    30}}, color={191,0,0}),Line(points={{30,36},{40,30}}, color={191,0,0}),
                    Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5),Rectangle(
                    extent={{90,80},{60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),Line(
                    points={{60,80},{60,-80}},
                    color={0,0,0},
                    thickness=0.5)}), Documentation(info="<html>
<p>
Basic implementation of Stefan Boltzmanns law for radiation.
Heat exchange is linearised by default.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 12, 2016 by Filip Jorissen:<br/>
Changed implementation to be more intuitive.
Added units to variables.
</li>
</ul>
</html>"));
          end HeatRadiation;

          model SwWindowResponse "shortwave window respones"
            parameter Integer nLay(min=1) "number of layers of the wall";
            parameter Real[:, nLay + 1] SwAbs
              "absorbed solar radiation for each layer for look-up table as function of angle of incidence";
            parameter Real[:, 2] SwTrans
              "transmitted solar radiation for look-up table as function of angle of incidence";
            parameter Real[nLay] SwAbsDif
              "absorbed solar radiation for each layer for look-up table as function of angle of incidence";
            parameter Real SwTransDif
              "transmitted solar radiation for look-up table as function of angle of incidence";
            final parameter Integer[nLay] columns=if (nLay == 1) then {2} else integer(
                linspace(
                2,
                nLay + 1,
                nLay));
            Modelica.Blocks.Interfaces.RealInput solDir
              "direct solar illuminance on surface se"
              annotation (Placement(transformation(extent={{-120,40},{-80,80}})));
            Modelica.Blocks.Interfaces.RealInput solDif
              "diffuse solar illuminance on surface s"
              annotation (Placement(transformation(extent={{-120,0},{-80,40}})));
            Modelica.Blocks.Interfaces.RealInput angInc "angle of incidence"
              annotation (Placement(transformation(extent={{-120,-60},{-80,-20}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nLay] iSolAbs
              "solar absorptance in the panes"
              annotation (Placement(transformation(extent={{-10,90},{10,110}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDir
              "transmitted direct solar radiation"
              annotation (Placement(transformation(extent={{-30,-110},{-10,-90}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDif
              "transmitted difuse solar radiation"
              annotation (Placement(transformation(extent={{10,-110},{30,-90}})));
            Modelica.Blocks.Math.Gain radToDeg(final k=180/Modelica.Constants.pi)
              "Conversion of radians to degrees"
              annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
            Modelica.Blocks.Tables.CombiTable1Ds SwAbsDir(
              final table=SwAbs,
              final smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
              final columns=columns) "lookup table for AOI dependent absorptance"
              annotation (Placement(transformation(
                  extent={{-9,-9},{9,9}},
                  rotation=90,
                  origin={-29,-11})));
            Modelica.Blocks.Tables.CombiTable1Ds SwTransDir(
              final table=SwTrans,
              final smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
              final columns={2}) "lookup table for AOI dependent transmittance"
              annotation (Placement(transformation(
                  extent={{-9,-9},{9,9}},
                  rotation=90,
                  origin={-3,-11})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow[nLay] Abs_flow
              "solar absorptance in the panes source" annotation (Placement(
                  transformation(
                  extent={{-8,-8},{8,8}},
                  rotation=90,
                  origin={-8.88178e-016,78})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow Dir_flow
              "transmitted direct solar radiation source" annotation (Placement(
                  transformation(
                  extent={{-8,-8},{8,8}},
                  rotation=-90,
                  origin={-20,-78})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow Dif_flow
              "transmitted difuse solar radiation source" annotation (Placement(
                  transformation(
                  extent={{-8,-8},{8,8}},
                  rotation=-90,
                  origin={20,-78})));
            Modelica.Blocks.Math.Product[nLay] SwAbsDirProd annotation (Placement(
                  transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=90,
                  origin={-33,19})));
            Modelica.Blocks.Math.Product SwTransDirProd annotation (Placement(
                  transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=90,
                  origin={-7,19})));
            Modelica.Blocks.Math.Add[nLay] add annotation (Placement(transformation(
                  extent={{8,-8},{-8,8}},
                  rotation=-90,
                  origin={-32,48})));
            Modelica.Blocks.Math.Gain[   nLay] SwAbsDifProd(k=SwAbsDif)  annotation (Placement(
                  transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=90,
                  origin={25,21})));
            Modelica.Blocks.Math.Gain    SwTransDifProd(k=SwTransDif)  annotation (Placement(
                  transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=90,
                  origin={51,21})));
          equation
            connect(Abs_flow.port, iSolAbs) annotation (Line(
                points={{4.89859e-016,86},{0,86},{0,100}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(Dir_flow.port, iSolDir) annotation (Line(
                points={{-20,-86},{-20,-100}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(Dif_flow.port, iSolDif) annotation (Line(
                points={{20,-86},{20,-100}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(solDir, SwTransDirProd.u1) annotation (Line(
                points={{-100,60},{-60,60},{-60,4},{-11.2,4},{-11.2,10.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(SwAbsDir.y, SwAbsDirProd.u2) annotation (Line(
                points={{-29,-1.1},{-29,13.45},{-28.8,13.45},{-28.8,10.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(SwTransDir.y[1], SwTransDirProd.u2) annotation (Line(
                points={{-3,-1.1},{-3,13.45},{-2.8,13.45},{-2.8,10.6}},
                color={0,0,127},
                smooth=Smooth.None));
            for i in 1:nLay loop
              connect(solDir, SwAbsDirProd[i].u1) annotation (Line(
                  points={{-100,60},{-60,60},{-60,4},{-37.2,4},{-37.2,10.6}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(SwAbsDifProd[i].u, solDif) annotation (Line(points={{25,12.6},{25,2},{
                    -64,2},{-64,20},{-100,20}}, color={0,0,127}));
            end for;
            connect(SwTransDirProd.y, Dir_flow.Q_flow) annotation (Line(
                points={{-7,26.7},{-7,50},{80,50},{80,-54},{-20,-54},{-20,-70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(SwAbsDirProd.y, add.u2) annotation (Line(
                points={{-33,26.7},{-33,31.35},{-36.8,31.35},{-36.8,38.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(add.y, Abs_flow.Q_flow) annotation (Line(
                points={{-32,56.8},{-32,62},{-4.89859e-016,62},{-4.89859e-016,70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(radToDeg.u, angInc) annotation (Line(points={{-62,-40},{-76,-40},{
                    -100,-40}},           color={0,0,127}));
            connect(radToDeg.y, SwAbsDir.u) annotation (Line(points={{-39,-40},{-29,-40},
                    {-29,-21.8}}, color={0,0,127}));
            connect(radToDeg.y, SwTransDir.u) annotation (Line(points={{-39,-40},{-3,-40},
                    {-3,-21.8}},      color={0,0,127}));
            connect(SwAbsDifProd.y, add.u1) annotation (Line(points={{25,28.7},{25,34},{-27.2,
                    34},{-27.2,38.4}}, color={0,0,127}));
            connect(SwTransDifProd.y, Dif_flow.Q_flow) annotation (Line(points={{51,28.7},
                    {51,34},{38,34},{38,-60},{20,-60},{20,-70}}, color={0,0,127}));
             connect(SwTransDifProd.u, solDif) annotation (Line(points={{51,12.6},{51,2},{-64,
                    2},{-64,20},{-100,20}}, color={0,0,127}));
            annotation (
              Diagram(graphics,
                      coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})),
              Icon(graphics={
                  Rectangle(
                    extent={{-80,90},{80,70}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{-80,70},{80,70}},
                    pattern=LinePattern.None,
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{44,40},{44,-50}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{44,40},{38,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{44,40},{50,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{14,40},{14,-50}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{14,40},{8,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{14,40},{20,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-16,40},{-16,-50}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-16,40},{-22,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-16,40},{-10,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-46,40},{-46,-50}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-46,40},{-52,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-46,40},{-40,30}},
                    smooth=Smooth.None,
                    color={127,0,0})}),
              Documentation(info="<html>
<p>The properties for absorption by and transmission through the glazingare taken into account depending on the angle of incidence of solar irradiation and are based on the output of the <a href=\"IDEAS.Buildings.UsersGuide.References\">[WINDOW 6.3]</a> software, i.e. the shortwave properties itselves based on the layers in the window are not calculated in the model but are input parameters. </p>
</html>"));
          end SwWindowResponse;

          function viewFactorRectRectPar
            "View factor between two equal coaxial parallel rectangular surfaces."
            extends Modelica.Icons.Function;
            input Real A "Area of surface";
            input Real d "Distance between surfaces";
            input Real l "Length of surface";
            output Real vieFac "View factor between surfaces";
        protected
            Real x = l/d;
            Real y = A/l/d;
            Real x1 = sqrt(1+x^2);
            Real y1 = sqrt(1+y^2);
          algorithm
          vieFac := 1/Modelica.Constants.pi/x/y*(log(x1^2*y1^2/(x1^2+y1^2-1)) +
                                                 2*x*(y1*atan(x/y1)-atan(x)) +
                                                 2*y*(x1*atan(y/x1)-atan(y)));
            annotation (Documentation(info="<html>
<p>source: http://webserver.dmt.upm.es/~isidoro/tc3/Radiation%20View%20factors.pdf</p>
</html>"));
          end viewFactorRectRectPar;

          function viewFactorRectRectPerp
            "View factor between two adjacent, perpendicular rectangular surfaces with one common dimension."
            extends Modelica.Icons.Function;
            input Real W1 "Width of surface 1";
            input Real W2 "Width of surface 2";
            input Real lCommon "Common surface edge length";
            output Real vieFac "View factor between surfaces";
        protected
            Real h = W1/lCommon;
            Real w = W2/lCommon;
            Real a = (1+h^2)*(1+w^2)/(1+w^2 + h^2);
            Real b = w^2*(1+h^2+w^2)/(1+w^2)/(h^2+w^2);
            Real c = h^2*(1+h^2+w^2)/(1+h^2)/(h^2+w^2);
            Real subExp = sqrt(h*h+w*w);
          algorithm
            vieFac :=1/w/Modelica.Constants.pi*(h*atan(1/h)+w*atan(1/w) - subExp*atan(1/subExp) + 1/4*log(a*b^(w^2)*c^(h^2)));
          end viewFactorRectRectPerp;

          model ZoneLwDistribution "internal longwave radiative heat exchange"
            parameter Integer nSurf(min=1) "Number of surfaces connected to the zone";
            parameter Boolean simVieFac = false "Simplify view factor computation";
            parameter Boolean linearise=true "Linearise radiative heat exchange";
            parameter Modelica.SIunits.Temperature Tzone_nom = 295.15
              "Nominal temperature of environment, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Modelica.SIunits.TemperatureDifference dT_nom = -2
              "Nominal temperature difference between solid and air, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSurf] port_a
              "Port for radiative heat exchange"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] A(
               each final quantity="Area", each final unit="m2")
              "Surface areas of connected surfaces" annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={40,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] epsLw(
               each final quantity="Emissivity", each final unit="1")
              "Longwave surface emissivities of connected surfaces" annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,100})));
        protected
            parameter Boolean computeCarroll(fixed=false) "if false, then a simplified model is used";
            parameter Real FMax=5 "Upper bound for F";
            parameter Real[nSurf] F1(
               each final fixed=false,
               each final min=0,
               each final max=FMax,
               each start=0.1)
              "View factor estimate by Carroll";
            parameter Real[nSurf] F2(
               each final fixed=false,
               each final min=1e-6,
               each final max=1,
               each start=1)
              "Simplified view factor estimate";
            parameter Real[nSurf] R(
               each final fixed=false,
               each final unit="K4/W")
              "Thermal resistance for longwave radiative heat exchange";
            IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.HeatRadiation[nSurf] radRes(
              R=R,
              each linearise=linearise,
              each dT_nom=dT_nom,
              each Tzone_nom=Tzone_nom)
              "Component that computes radiative heat exchange";
          initial equation
            // see Eqns 29-30 in Liesen, R. J., & Pedersen, C. O. (1997). An Evaluation of Inside Surface Heat Balance Models for Cooling Load Calculations. ASHRAE Transactions, 3(103), 485–502.
            // or Eqns 4 and 10 in Carroll, J.A. 1980. An "MRT method" of computing radiant energy exchange in rooms. Proceedings of the 2nd Sys- tems Simulation and Economics Analysis Conference, January 23-25
            // The additional min(,) and max(,) function cause the Newton solver to find a (wrong) solution instead of crashing.
            // If max(A)<sum(A)/2 is not satisfied, then the non-linear
            // algebraic loop will not converge and therefore we do not compute
            // view factors according to Carroll.
            computeCarroll = not simVieFac and max(A)<sum(A)/2;
            F1= if computeCarroll then {max(0,min(FMax,1/(1 - A[i] .* F1[i]/(A*F1)))) for i in 1:nSurf} else zeros(nSurf);
            F2= A ./ (ones(nSurf)*sum(A) - A);
            // If Carroll's model converged to a solution for F1
            // that does not equal the variable bounds
            // (i.e. the solution converged using the real model equations),
            // then use this model otherwise use a more simplified model
            // since a solution was found, but not for the real model equations.
            // This should only occur for non-physical geometries where
            // it is difficult to argue whether or not this simplification is correct.
            R= if computeCarroll and max(F1)<FMax*0.9 then
                  ((ones(nSurf) - epsLw) ./ epsLw + ones(nSurf)./F1) ./ A/ Modelica.Constants.sigma
                else
                  ((ones(nSurf) - epsLw) ./ (A .* epsLw) + (ones(nSurf) - F2) ./ A)/Modelica.Constants.sigma;
            // Throw a warning when the simplified approach is used.
            assert(max(F1)<FMax*0.9 and computeCarroll or simVieFac,
                    "WARNING: The view factor computed in ZoneLwDistribution could not properly converge. 
          A simplified method is used. 
          This may be caused by trying to model a non-physical geometry.\n",
                    AssertionLevel.warning);
          equation
            for i in 1:nSurf loop
              connect(radRes[i].port_b, port_a[i]);
            end for;
            for i in 1:nSurf - 1 loop
              connect(radRes[i].port_a, radRes[i + 1].port_a);
            end for;
            annotation (
              Diagram(graphics),
              Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{90,-80}},
                    pattern=LinePattern.None,
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Backward,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{68,60},{-68,-60}},
                    pattern=LinePattern.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Line(points={{6,0},{64,0}},     color={191,0,0}),
                  Line(points={{6,0},{16,6}},      color={191,0,0}),
                  Line(points={{6,0},{16,-6}},    color={191,0,0}),
                  Line(points={{0,56},{0,12}},      color={191,0,0}),
                  Line(points={{-62,0},{-8,0}},   color={191,0,0}),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={-13,-3},
                    rotation=180),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={-13,3},
                    rotation=180),
                  Line(
                    points={{-68,60},{68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{68,60},{68,-60},{-68,-60},{-68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={-3,17},
                    rotation=270),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={3,17},
                    rotation=270),
                  Line(points={{0,-10},{0,-54}},    color={191,0,0}),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={-3,-49},
                    rotation=270),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={3,-49},
                    rotation=270),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={-3,-15},
                    rotation=270),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={3,-15},
                    rotation=270),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={3,51},
                    rotation=270),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={-3,51},
                    rotation=270),
                  Line(points={{-62,0},{-52,-6}}, color={191,0,0}),
                  Line(points={{-62,0},{-52,6}},   color={191,0,0}),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={59,3},
                    rotation=180),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={59,-3},
                    rotation=180)}),
              Documentation(info="<html>
<p>
The Mean Radiant Temperature Network (MRTnet) approach from 
Carroll (1980) is used to compute the radiative heat transfer.
This is a computationally efficient approach that does not require exact view factors to be known.
Each surface exchanges heat with a fictive radiant surface,
leading to a star resistance network.
</p>
<h4>Parameters</h4>
<p>
Parameter <code>simVieFac</code> may be set to false to simplify the 
view factor calculation. This leads to a less accurate computation
of view factors, but this approach is more robust.
It may be used when the initial equation that computes the view factors does not converge.
</p>
<h4>References</h4>
<p>
Liesen, R. J., &amp; Pedersen, C. O. (1997). An Evaluation of Inside Surface Heat Balance Models for Cooling Load Calculations. ASHRAE Transactions, 3(103), 485-502.<br/>
Carroll, J.A. 1980. An \"MRT method\" of computing radiant energy exchange in rooms. Proceedings of the 2nd Sys- tems Simulation and Economics Analysis Conference, January 23-25
</p>
</html>",           revisions="<html>
<ul>
<li>
February 1, 2017 by Filip Jorissen:<br/>
Added option for disabling new view factor computation.
See issue 
<a href=https://github.com/open-ideas/IDEAS/issues/663>#663</a>.
</li>
<li>
January 20, 2017 by Filip Jorissen:<br/>
Changed view factor implementation.
See issue 
<a href=https://github.com/open-ideas/IDEAS/issues/643>#643</a>.
</li>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Updated icon for issue
<a href=https://github.com/open-ideas/IDEAS/issues/641>#641
</a>.
</li>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Propagated parameters for linearisation.
</li>
<li>
July 12, 2016 by Filip Jorissen:<br/>
Changed implementation to be more intuitive.
Added units to variables.
</li>
</ul>
</html>"));
          end ZoneLwDistribution;

          model ZoneLwDistributionViewFactor
            "Internal longwave radiative heat exchange using view factors"
            parameter Integer nSurf(min=1) "number of surfaces in contact with the zone";
            parameter Modelica.SIunits.Angle incCeiling = IDEAS.Types.Tilt.Ceiling;
            parameter Modelica.SIunits.Angle incFloor = IDEAS.Types.Tilt.Floor;
            parameter Modelica.SIunits.Angle incWall = IDEAS.Types.Tilt.Wall;
            parameter Modelica.SIunits.Angle aziSouth = IDEAS.Types.Azimuth.S;
            final parameter Integer numAzi = 4;
            parameter Modelica.SIunits.Length hZone "Distance between floor and ceiling";
            parameter Boolean linearise = true "Linearise radiative heat exchange"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.Temperature Tzone_nom = 295.15
              "Nominal temperature of environment, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Modelica.SIunits.TemperatureDifference dT_nom = -2
              "Nominal temperature difference between solid and air, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Real[nSurf,nSurf] vieFac(each fixed=false)
              "Emissivity weighted viewfactor from surface to surface"
              annotation(Dialog(tab="Advanced"));
            final parameter Real[nSurf,nSurf] Umat(each fixed=false);
            Modelica.Blocks.Interfaces.RealInput[nSurf] inc "Surface inclination angles"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={-100,40})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] azi "Surface azimuth angles"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={-100,-40})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSurf] port_a
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] A "surface areas" annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={40,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] epsLw
              "longwave surface emissivities" annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,100})));
            Modelica.Blocks.Interfaces.RealOutput[nSurf] floorArea
              "Amount of floor area for each surface" annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={-60,-104})));
        protected
            parameter Modelica.SIunits.ThermalConductance coeffLin = 1*(2*Tzone_nom+dT_nom)*(Tzone_nom^2+(Tzone_nom+dT_nom)^2)
              "Coefficient allowing less overhead for evaluation functions. This implementation is an approximation of the real linearization f(u)_lin = df/du|(u=u_bar) * (u-u_bar) + f|u_bar. The accuracy of it has been checked.";
            parameter Real[2+numAzi] Atot(each fixed=false)
              "Total surface area per orientation";
            parameter Real[2+numAzi,2+numAzi] vieFacTot(each fixed=false)
              "Emissivity weighted viewfactor from total of surfaces to each other"
              annotation(Dialog(tab="Advanced"));
            parameter Real lWall(fixed = false);
            parameter Integer index1(fixed=false);
            parameter Integer index2(fixed=false);
            parameter Modelica.SIunits.Area[nSurf] Afloor(each fixed = false);
          initial algorithm
            //initialise surface area to zero
            Atot :=zeros(2 + numAzi);
            // calculate total area for each direction + ceiling/floor
            for i in 1:nSurf loop
              if IDEAS.Utilities.Math.Functions.isAngle(inc[i], incCeiling) then
                // ceiling area: index 1
                Atot[1]:=Atot[1] + A[i];
              elseif IDEAS.Utilities.Math.Functions.isAngle(inc[i], incFloor) then
                // floor area: index 2
                Atot[2]:=Atot[2] + A[i];
              elseif IDEAS.Utilities.Math.Functions.isAngle(inc[i], incWall) or IDEAS.Utilities.Math.Functions.isAngle(inc[i], incWall+Modelica.Constants.pi) then
                  for j in (0:numAzi-1) loop
                    // numAzi wall areas: indices 3 through 6
                    if IDEAS.Utilities.Math.Functions.isAngle(azi[i], aziSouth + j*Modelica.Constants.pi*2/numAzi) then
                      Atot[3+j] :=Atot[3 + j] + A[i];
                      //Modelica.Utilities.Streams.print(String(azi[i]) + " to " + String(j));
                      break;
                    end if;
                  end for;
              else
                Modelica.Utilities.Streams.error("Could not find matching orientation for surface with index " + String(i) +
                    ". Avoid this error by disabling explicit view factor calculation in the zone model");
              end if;
            end for;
            assert(Atot[1]>0, "Zone contains no ceiling surfaces. This needs to be fixed or explicit view factor calculation should be disabled.");
            assert(Atot[2]>0, "Zone contains no floor surfaces. This needs to be fixed or explicit view factor calculation should be disabled.");
            //view factor from ceiling/floor to floor/ceiling
            vieFacTot[1,1] :=0;
            vieFacTot[2,2] :=0;
            vieFacTot[1,2] :=
              IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPar(
              A=(Atot[1] + Atot[2])/2,
              d=hZone,
              l=(A[3] + A[5])/hZone/2);
            vieFacTot[2,1] := vieFacTot[1,2]*Atot[1]/Atot[2];
            for i in 3:numAzi+2 loop
              //estimate for total wall length
              lWall :=Atot[i]/hZone;
              //view factor for walls to ceiling and floor
              if lWall == 0 then
                for j in 1:numAzi+2 loop
                  vieFacTot[j,i]:=0;
                  vieFacTot[i,j]:=0;
                end for;
              else
              vieFacTot[1,i]:=
                  IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPerp(
                  lCommon=lWall,
                  W1=hZone,
                  W2=Atot[1]/lWall);
              vieFacTot[i,1]:=vieFacTot[1,i]*Atot[1]/Atot[i];
              vieFacTot[2,i]:=
                  IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPerp(
                  lCommon=lWall,
                  W1=hZone,
                  W2=Atot[2]/lWall);
              vieFacTot[i,2]:=vieFacTot[2,i]*Atot[2]/Atot[i];
              // walls to walls
                  for j in i:numAzi+2 loop
                    if i==j then
                      //a wall does not interchange radiant heat with itself
                       vieFacTot[i,i] := 0;
                    elseif Atot[i]==0 or Atot[j]==0 then
                      vieFacTot[i,j] := 0;
                      vieFacTot[j,i] := 0;
                    elseif abs(i-j)==1 or abs(i-j)==3 then
                      //surfaces are perpendicular
                      vieFacTot[i,j] :=
                      IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPerp(
                      lCommon=hZone,
                      W1=Atot[j]/hZone,
                      W2=Atot[i]/hZone);
                      vieFacTot[j,i]:=vieFacTot[i,j]*Atot[i]/Atot[j];
                    elseif abs(i-j) == 2 then
                      //surfaces are parallel
                      vieFacTot[i,j] :=
                      IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPar(
                      A=(Atot[i] + Atot[j])/2,
                      d=Atot[integer((i + j)/2)]/hZone,
                      l=hZone);
                      vieFacTot[j,i]:=vieFacTot[i,j]*Atot[i]/Atot[j];
                    else
                      //fixme warning
                    end if;
                  end for;
              end if;
            end for;
            //view factors for real surfaces are calculated from the total surfaces
            for i in 1:nSurf loop
                //set floor area
                Afloor[i]:=0;
                 //determine orientation of first plane
                if IDEAS.Utilities.Math.Functions.isAngle(inc[i], incCeiling) then
                   index1:=1;
                elseif IDEAS.Utilities.Math.Functions.isAngle(inc[i], incFloor) then
                   index1:=2;
                   Afloor[i]:=A[i];
                elseif IDEAS.Utilities.Math.Functions.isAngle(inc[i], incWall) then
                   for k in 0:numAzi-1 loop
                     if IDEAS.Utilities.Math.Functions.isAngle(azi[i], aziSouth + k*Modelica.Constants.pi*2/numAzi) then
                       index1:=2+k+1;
                     break;
                     end if;
                     //warning
                   end for;
                end if;
                  for j in i:nSurf loop
                    if i==j then
                      vieFac[i,j]:=0;
                    else
                        //determine orientation of second plane
                    if IDEAS.Utilities.Math.Functions.isAngle(inc[j], incCeiling) then
                      index2:=1;
                    elseif IDEAS.Utilities.Math.Functions.isAngle(inc[j], incFloor) then
                      index2:=2;
                    elseif IDEAS.Utilities.Math.Functions.isAngle(inc[j], incWall) then
                      for k in 0:numAzi-1 loop
                        if IDEAS.Utilities.Math.Functions.isAngle(azi[j], aziSouth + k*Modelica.Constants.pi*2/numAzi) then
                          index2:=2+k+1;
                          break;
                        end if;
                        //warning
                      end for;
                    end if;
                    Umat[i,j] := if vieFacTot[index1, index2]  < Modelica.Constants.small then 0 else (if linearise then coeffLin else 1) * Modelica.Constants.sigma/(1/A[i]/(vieFacTot[index1, index2]*A[j]/Atot[index2])+(1-epsLw[i])/A[i]/epsLw[i]+(1-epsLw[j])/A[j]/epsLw[j]);
                    Umat[j,i] := if vieFacTot[index2, index1]  < Modelica.Constants.small then 0 else (if linearise then coeffLin else 1) * Modelica.Constants.sigma/(1/A[j]/(vieFacTot[index2, index1]*A[i]/Atot[index1])+(1-epsLw[i])/A[i]/epsLw[i]+(1-epsLw[j])/A[j]/epsLw[j]);
                    end if;
                  end for;
          end for;
                Umat := Umat-identity(nSurf).*(Umat*ones(nSurf,nSurf));
          equation
            if linearise then
              port_a.Q_flow=-Umat*port_a.T;
            else
              port_a.Q_flow=-Umat*port_a.T.^4;
            end if;
            floorArea=Afloor;
            annotation (
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}}),
                      graphics),
              Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{90,-80}},
                    pattern=LinePattern.None,
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Backward,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{68,60},{-68,-60}},
                    pattern=LinePattern.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Line(points={{-42,0},{40,0}},     color={191,0,0}),
                  Line(points={{30,-6},{40,0}},    color={191,0,0}),
                  Line(points={{30,6},{40,0}},    color={191,0,0}),
                  Line(points={{-58,6},{-14,50}}, color={191,0,0}),
                  Line(points={{-14,38},{-14,50}},
                                                 color={191,0,0}),
                  Line(points={{-26,50},{-14,50}},
                                                 color={191,0,0}),
                  Line(
                    points={{-68,60},{68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{68,60},{68,-60},{-68,-60},{-68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(points={{-32,6},{-42,0}},  color={191,0,0}),
                  Line(points={{-32,-6},{-42,0}},  color={191,0,0}),
                  Line(points={{-58,18},{-58,6}},color={191,0,0}),
                  Line(points={{-46,6},{-58,6}}, color={191,0,0}),
                  Line(points={{14,-52},{58,-8}}, color={191,0,0}),
                  Line(points={{26,-52},{14,-52}},
                                                 color={191,0,0}),
                  Line(points={{14,-40},{14,-52}},
                                                 color={191,0,0}),
                  Line(points={{46,-8},{58,-8}}, color={191,0,0}),
                  Line(points={{58,-20},{58,-8}},color={191,0,0}),
                  Line(points={{-22,-22},{22,22}},color={191,0,0},
                    origin={36,28},
                    rotation=90),
                  Line(points={{14,50},{26,50}}, color={191,0,0}),
                  Line(points={{14,38},{14,50}}, color={191,0,0}),
                  Line(points={{46,6},{58,6}},   color={191,0,0}),
                  Line(points={{58,6},{58,18}},  color={191,0,0}),
                  Line(points={{-14,-52},{-14,-40}},
                                                 color={191,0,0}),
                  Line(points={{-22,-22},{22,22}},color={191,0,0},
                    origin={-36,-30},
                    rotation=90),
                  Line(points={{-58,-20},{-58,-8}},
                                                 color={191,0,0}),
                  Line(points={{-58,-8},{-46,-8}},
                                                 color={191,0,0}),
                  Line(points={{-26,-52},{-14,-52}},
                                                 color={191,0,0}),
                  Line(points={{-41,0},{41,0}},     color={191,0,0},
                    origin={-1,0},
                    rotation=90),
                  Line(points={{-5,3},{5,-3}},    color={191,0,0},
                    origin={-5,35},
                    rotation=90),
                  Line(points={{-5,-3},{5,3}},     color={191,0,0},
                    origin={3,35},
                    rotation=90),
                  Line(points={{-5,-3},{5,3}},     color={191,0,0},
                    origin={-5,-35},
                    rotation=90),
                  Line(points={{-5,3},{5,-3}},    color={191,0,0},
                    origin={3,-35},
                    rotation=90)}),
              Documentation(info="<html>
<p>
Computation of longwave radiative heat exchange based on view factors. 
</p>
<h4>Assumption and limitations</h4>
<p>
This implementation is only valid for rectangular geometries.
</p>
<h4>Verification</h4>
<p>
Verification test in IDEAS.Buildings.Validation.Tests.ViewFactorVerification.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Updated icon for issue
<a href=https://github.com/open-ideas/IDEAS/issues/641>#641
</a>.
</li>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Added options for properly linearising heat exchange.
</li>
<li>
December 8, 2016 by Filip Jorissen:<br/>
Fixed indexing bug in algorithm.
</li>
</ul>
</html>",           revisions="<html>
<ul>
<li>
December 8, 2016 by Filip Jorissen:<br/>
Fixed indexing bug in algorithm.
</li>
</ul>
</html>"));
          end ZoneLwDistributionViewFactor;

          model ZoneLwGainDistribution
            "Distribution of radiative internal gains"

            parameter Integer nSurf(min=1) "number of surfaces in contact with the zone";
            parameter Boolean lineariseJModelica = false
              "=true, to introduce radiative temperature node"
              annotation(Dialog(tab="Advanced"));
            parameter Modelica.SIunits.Time tau = 120
              "Time constant for radiative node"
               annotation(Dialog(enable=lineariseJModelica, tab="Advanced"));
            parameter Modelica.SIunits.Temperature T_start=296.15
              "Start value of radiative temperature node"
              annotation(Dialog(tab = "Advanced", enable=lineariseJModelica));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDir
              "Direct solar radiation gains received through windows"
              annotation (Placement(transformation(extent={{-110,30},{-90,50}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDif
              "Diffuse solar radiation gains received through windows"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a radGain
              "External long wave internal gains, e.g. from radiator"
              annotation (Placement(transformation(extent={{-110,-48},{-90,-28}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[nSurf] radSurfTot
              "Port for connecting to surfaces"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealOutput TRad(start=T_start)
              "Radiative zone temperature, computed as weighted sum of surface temperatures."
              annotation (Placement(transformation(
                  extent={{20,-20},{-20,20}},
                  rotation=90,
                  origin={0,-100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] epsLw(
               each final unit="1")
              "Long wave surface emissivities of connected surfaces" annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] epsSw(
               each final unit="1")
              "Short wave surface emissivities of connected surfaces" annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={-40,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] area(
               each final unit="m2")
              "Surface areas of connected surfaces" annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={-80,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] inc "Surface inclination angles"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={40,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] azi "Surface azimuth angles"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={80,100})));

        protected
            final parameter Real[nSurf] weightFactorDir(each final fixed=false)
              "Distribution factor for incident direct solar irradiation";
            final parameter Real[nSurf] weightFactorDif(each final fixed=false)
              "Distribution factor for incident diffuse solar irradiation";
            final parameter Real[nSurf] weightFactorGain(each final fixed=false)
              "Distribution factor for other radiative heat gains irradiation";
            final parameter Real[nSurf] weightFactorTRad(each final fixed=false)
              "Weight factor for radiative temperature computation";
            final parameter Modelica.SIunits.Area AfloorTot(fixed=false)
              "Total floor surface area";
            final parameter Real ASWotherSurface(fixed=false)
              "Total absorption surface area on surfaces other than the floor";
            final parameter Real fraTotAbsFloor(fixed=false)
              "Fraction of the direct solar irradiation that is absorbed by the floor";

            Modelica.SIunits.Temperature TRad_internal = radSurfTot.T * weightFactorTRad
              "To avoid duplicate operations";

          initial equation
            weightFactorDir = {if IDEAS.Utilities.Math.Functions.isAngle(inc[i], IDEAS.Types.Tilt.Floor)
                               then area[i]*epsSw[i]/AfloorTot
                               else (1-fraTotAbsFloor)*area[i]*epsSw[i]/ASWotherSurface for i in 1:nSurf};
            weightFactorDif = area .* epsSw / sum(area .* epsSw);
            weightFactorGain = area .* epsLw / sum(area .* epsLw);
            // minimum of Modelica.Constants.small to guard against division by zero
            AfloorTot = max(Modelica.Constants.small,sum({if IDEAS.Utilities.Math.Functions.isAngle(inc[i], IDEAS.Types.Tilt.Floor) then area[i] else 0 for i in 1:nSurf}));
            fraTotAbsFloor = sum({if IDEAS.Utilities.Math.Functions.isAngle(inc[i], IDEAS.Types.Tilt.Floor) then area[i]*epsSw[i] else 0 for i in 1:nSurf})/AfloorTot;
            ASWotherSurface = sum({if IDEAS.Utilities.Math.Functions.isAngle(inc[i], IDEAS.Types.Tilt.Floor) then 0 else area[i]*epsSw[i] for i in 1:nSurf});
            weightFactorTRad = weightFactorDif;

            assert(AfloorTot>2*Modelica.Constants.small, "WARNING: Zone does not contain a floor surface so incoming beam radiation is spread over all other surfaces! Is this intended? \n", AssertionLevel.warning);
            assert(AfloorTot<0.9*sum(area), "More than 90% of zone surface area is floor, this is not allowed.");
            assert(abs(1-sum(weightFactorTRad))<1e-4, "Error in computation of weightFactorTRad, please submit a bug report");
            assert(abs(1-sum(weightFactorDir))<1e-4, "Error in computation of weightFactorDir, please submit a bug report");
            assert(abs(1-sum(weightFactorDif))<1e-4, "Error in computation of weightFactorDif, please submit a bug report");
            assert(abs(1-sum(weightFactorGain))<1e-4, "Error in computation of weightFactorGain, please submit a bug report");

            if lineariseJModelica then
              TRad=T_start;
            end if;
          equation
            for k in 1:nSurf loop
              radSurfTot[k].Q_flow =
                -weightFactorDif[k]*iSolDif.Q_flow
                -weightFactorDir[k]*iSolDir.Q_flow
                -weightFactorGain[k]*radGain.Q_flow;
            end for;

            if lineariseJModelica then // this introduces a state for the radiative temperature, which is useful when linearising
              der(TRad) = (TRad_internal - TRad)/tau;
            else
              TRad = TRad_internal;
            end if;

            iSolDir.T = TRad_internal;
            iSolDif.T = TRad_internal;
            radGain.T = TRad_internal;

            annotation (
              Icon(graphics={
                  Line(points={{-40,10},{40,10}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,16}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,4}}, color={191,0,0}),
                  Line(points={{-40,-10},{40,-10}}, color={191,0,0}),
                  Line(points={{30,-16},{40,-10}}, color={191,0,0}),
                  Line(points={{30,-4},{40,-10}}, color={191,0,0}),
                  Line(points={{-40,-30},{40,-30}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-24}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-36}}, color={191,0,0}),
                  Line(points={{-40,30},{40,30}}, color={191,0,0}),
                  Line(points={{30,24},{40,30}}, color={191,0,0}),
                  Line(points={{30,36},{40,30}}, color={191,0,0}),
                  Rectangle(
                    extent={{-15,80},{15,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None,
                    origin={9,66},
                    rotation=90),
                  Rectangle(
                    extent={{90,80},{60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{-70,50},{60,50},{60,-80}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None)}),
              Documentation(info="<html>
<p>
This model computes how radiative gains are redistributed among all surfaces.
We consider 1) diffuse solar gains, 
2) beam solar gains and 
3) other, long wave, internal gains, e.g. from occupants.
</p>
<p>
Diffuse solar gains are redistributed by computing a weighting factor equal to the surface area multiplied with the
shortwave emissivity of the surface.
This factor is used to redistribute the diffuse solar gains among all surfaces.
</p>
<p>
Internal gains from occupants are redistributed in the same way, but using
the long wave emissivity instead of the short wave emissivity.
</p>
<p>
Direct/beam solar gains are redistributed by assuming that a fixed fraction of the beam solar
gains are absorbed by the floor. 
This fraction equals the short wave emissivity of the floor. 
If there are multiple floors (based on the inclination angle) 
then their area and emissivity are used to compute a weight factor for the floors.
The remaining radiation is redistributed over all other surfaces, again using the shortwave emissivity
and surface area to determine the relative fractions.
If there is no floor then the beam radiation is spread over all surfaces and a warning is generated.
</p>
</html>",           revisions="<html>
<ul>
<li>
November 5, 2018 by Filip Jorissen:<br/>
Added initial equation for <code>TRad</code>.
</li>
<li>
October 7, 2018 by Filip Jorissen:<br/>
Improved documentation.
</li>
<li>
March 28, 2018 by Filip Jorissen:<br/>
Added option for introducing state for
radiative temperature.
</li>
<li>
December 22, 2016 by Filip Jorissen:<br/>
Fixed bug in absorption model where
<code>TRad</code> was computed using coefficients for
<code>iSolDir</code> instead of <code>iSolDif</code>.
Added asserts for checking the sum of all 
weight factors.
This closes #605.
</li>
<li>
September 8, 2016 by Filip Jorissen:<br/>
Added warning for when there are no floors and guarded against division by zero.
</li>
<li>
July 15, 2016 by Filip Jorissen:<br/>
New absorption model for beam radiation.
</li>
<li>
July 12, 2016 by Filip Jorissen:<br/>
Simplified implementation by removing intermediate variables.
</li>
</ul>
</html>"));
          end ZoneLwGainDistribution;
        end RadiativeHeatTransfer;

        package Varia

          model EnergyFlowMultiplicator "Component to scale the energy flow of a energyPort"
            parameter Real k = 1 "Multiplication factor for heat flow";
            ConservationOfEnergy.EnergyPort E_a
              "Unscaled port"
              annotation (Placement(transformation(extent={{-108,-10},{-88,10}})));
            ConservationOfEnergy.EnergyPort E_b
              "Scaled port"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          equation
            E_a.E  * k = - E_b.E;
            E_a.Etot = E_b.Etot;
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Polygon(
                    points={{-100,100},{100,-2},{-100,-100},{-100,100}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid), Text(
                    extent={{-50,28},{50,-34}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="E x n"),
                  Text(
                    extent={{-150,-138},{150,-98}},
                    lineColor={0,0,0},
                    textString="k=%k"),
                  Text(
                    extent={{-150,142},{150,102}},
                    textString="%name",
                    lineColor={0,0,255})}),                                Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
          end EnergyFlowMultiplicator;

          model HeatFlowMultiplicator "Component to scale the energy flow of a energyPort"
            parameter Real k = 1 "Multiplication factor for heat flow rate";
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              "Port with unscaled heat flow rate"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              "Port with scaled heat flow rate"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          equation
            port_a.Q_flow * k = - port_b.Q_flow;
            port_a.T = port_b.T;
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Polygon(
                    points={{-100,100},{100,-2},{-100,-100},{-100,100}},
                    lineColor={255,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid), Text(
                    extent={{-78,36},{50,-34}},
                    lineColor={255,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="Q_flow x n"),
                  Text(
                    extent={{-150,-138},{150,-98}},
                    lineColor={0,0,0},
                    textString="k=%k"),
                  Text(
                    extent={{-150,142},{150,102}},
                    textString="%name",
                    lineColor={0,0,255})}),                                Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(info="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
          end HeatFlowMultiplicator;
        end Varia;
      end BaseClasses;

      model BoundaryWall "Opaque wall with optional prescribed heat flow rate or temperature boundary conditions"
        extends IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface(
           final nWin=1,
           QTra_design=U_value*A*(273.15 + 21 - TRef_a),
           dT_nominal_a=-1,
          layMul(disableInitPortB=use_T_in or use_T_fixed, monLay(monLayDyn(each addRes_b=(sim.lineariseDymola and (use_T_in or use_T_fixed))))));

        parameter Boolean use_T_fixed = false
          "Get the boundary temperature from the input connector"
          annotation(Dialog(group="Boundary conditions"));
        parameter Modelica.SIunits.Temperature T_fixed = 294.15
          "Fixed boundary temperature"
          annotation(Dialog(group="Boundary conditions",enable=use_T_fixed));
        parameter Boolean use_T_in = false
          "Get the boundary temperature from the input connector"
          annotation(Dialog(group="Boundary conditions"));
        parameter Boolean use_Q_in = false
          "Get the boundary heat flux from the input connector"
          annotation(Dialog(group="Boundary conditions"));

        Modelica.Blocks.Interfaces.RealInput T if use_T_in
          "Input for boundary temperature"                 annotation (Placement(
              transformation(extent={{-120,10},{-100,30}}),iconTransformation(extent={{-120,10},
                  {-100,30}})));
        Modelica.Blocks.Interfaces.RealInput Q_flow if use_Q_in
          "Input for boundary heat flow rate entering the wall" annotation (Placement(
              transformation(extent={{-120,-30},{-100,-10}}),
                                                          iconTransformation(extent={{-120,
                  -30},{-100,-10}})));
        Modelica.Blocks.Math.Product proPreT if  use_T_in or use_T_fixed "Product for linearisation"
          annotation (Placement(transformation(extent={{-86,26},{-74,14}})));
        Modelica.Blocks.Math.Product proPreQ if use_Q_in "Product for linearisation"
          annotation (Placement(transformation(extent={{-86,-14},{-74,-26}})));
        Modelica.Blocks.Sources.Constant TConst(k=T_fixed) if use_T_fixed
          "Constant block for temperature"
          annotation (Placement(transformation(extent={{-110,32},{-100,42}})));

    protected
        final parameter Real U_value=1/(1/8 + sum(constructionType.mats.R) + 1/8)
          "Wall U-value";
        Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preFlo(final alpha=0) if
                             use_Q_in "Prescribed heat flow rate"
          annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
        Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature preTem if
                                   use_T_in or use_T_fixed "Prescribed temperature"
          annotation (Placement(transformation(extent={{-60,10},{-40,30}})));

      equation
        assert(not (use_T_in and use_Q_in or use_T_in and use_T_fixed or use_Q_in and use_T_fixed),
          "In "+getInstanceName()+": Only one of the following options can be used simultaneously: use_T_in, use_Q_in, use_T_fixed");
        connect(Q_flow, proPreQ.u1)
          annotation (Line(points={{-110,-20},{-100,-20},{-100,-23.6},{-87.2,-23.6}},
                                                          color={0,0,127}));
        connect(proPreQ.y, preFlo.Q_flow)
          annotation (Line(points={{-73.4,-20},{-60,-20}}, color={0,0,127}));
        connect(proPreQ.u2, propsBusInt.weaBus.dummy) annotation (Line(points={{-87.2,
                  -16.4},{-92,-16.4},{-92,40},{56.09,40},{56.09,19.91}},
                                                                  color={0,0,127}),
            Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(proPreT.y, preTem.T)
            annotation (Line(points={{-73.4,20},{-62,20}}, color={0,0,127}));
        connect(proPreT.u2, propsBusInt.weaBus.dummy) annotation (Line(points={{-87.2,
                  23.6},{-92,23.6},{-92,40},{56.09,40},{56.09,19.91}},
                                                            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(T, proPreT.u1)
          annotation (Line(points={{-110,20},{-100,20},{-100,16.4},{-87.2,16.4}},
                                                                 color={0,0,127}));
        connect(layMul.port_b, preFlo.port) annotation (Line(points={{-10,0},{-10,0},{
                -20,0},{-20,-20},{-40,-20}}, color={191,0,0}));
        connect(preTem.port, layMul.port_b) annotation (Line(points={{-40,20},{-20,20},
                {-20,0},{-10,0}}, color={191,0,0}));
        connect(TConst.y, proPreT.u1) annotation (Line(points={{-99.5,37},{-96,37},{-96,
                16.4},{-87.2,16.4}},
                               color={0,0,127}));
        annotation (
          Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                  100}})),
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-50,-90},{50,-70}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-50,80},{50,100}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-50,80},{50,80}},
                color={175,175,175}),
              Line(
                points={{-50,-70},{50,-70}},
                color={175,175,175}),
              Line(
                points={{-50,-90},{50,-90}},
                color={175,175,175}),
              Line(
                points={{-50,100},{50,100}},
                color={175,175,175}),
              Rectangle(
                extent={{-10,80},{10,-70}},
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None),
              Line(
                points={{-10,80},{-10,-70}},
                smooth=Smooth.None,
                color={175,175,175}),
              Line(
                points={{10,80},{10,-70}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5)}),
          Documentation(info="<html>
<p>
This is a wall model that should be used
to simulate a wall between a zone and a prescribed temperature or prescribed heat flow rate boundary condition.
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces.
</p>
<h4>Main equations</h4>
<p>
Specific to this model is that the model does not contain a convection or radiative heat exchange model at the outside of the wall.
Instead a prescribed temperature or heat flow rate may be set.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameters <code>use_T_in</code> and <code>use_Q_in</code> may be used
to enable an input for a prescribed boundary condition temperature or heat flow rate.
Alternatively, parameters <code>use_T_fixed</code> and <code>T_fixed</code> can be used
to specify a fixed boundary condition temperature.
It is not allowed to enabled multiple of these three options. 
If all are disabled then an adiabatic boundary (<code>Q_flow=0</code>) is used.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
December 2, 2018 by Filip Jorissen:<br/>
Added option for setting fixed boundary condition temperature.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/961\">
#961</a>. 
</li>
<li>
August 10, 2018 by Damien Picard:<br/>
Set nWin final to 1 as this should only be used for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. 
</li>
<li>
March 22, 2017, by Filip Jorissen:<br/>
Changes for JModelica compatibility.
</li>
<li>
January 2, 2017, by Filip Jorissen:<br/>
Updated icon layer.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
December 7, 2016, by Damien Picard:<br/>
Set placeCapacityAtSurf_b to false for last layer of layMul when T_in is used and the sim.lineariseDymola is true.
Having a capacity connected directly to the prescribed temperature would require to have the derivative of T_in
when linearized.
The dynamics of the last layer is further set to dynamicFreeInitial when T_in is used to avoid an initialization problem.
</li>
<li>
March 8, 2016, by Filip Jorissen:<br/>
Fixed energyDynamics when using fixed temperature boundary condition input.
This is discussed in issue 462.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
</ul>
</html>"));
      end BoundaryWall;

      package Comfort "Package for computing thermal comfort "
      extends Modelica.Icons.Package;

        package BaseClasses
          extends Modelica.Icons.BasesPackage;

          partial model PartialComfort "Partial for comfort models"
            extends Modelica.Blocks.Icons.Block;
            parameter Boolean use_phi_in=true
              "Get the relative humidity from the input connector"
              annotation(Evaluate=true);
            parameter Real phi(min=0,max=1)=0.4
              "Default value of relative humidity"
              annotation(Dialog(enable=not use_phi_in));
            parameter IDEAS.Buildings.Components.OccupancyType.OfficeWork
              occupancyType
              annotation (Placement(transformation(extent={{-60,80},{-40,100}})));
            Modelica.Blocks.Interfaces.RealInput phi_in(min=0, max=1) if use_phi_in "Relative humidity"
              annotation (
                Placement(transformation(extent={{-120,10},{-100,30}}),
                  iconTransformation(extent={{-120,10},{-100,30}})));
            Modelica.Blocks.Interfaces.RealInput TRad(final quantity="ThermodynamicTemperature",
                                                    final unit = "K", displayUnit = "degC")
              "Radiation temperature"
              annotation (
                Placement(transformation(extent={{-120,50},{-100,70}}),
                  iconTransformation(extent={{-120,50},{-100,70}})));
            Modelica.Blocks.Interfaces.RealInput TAir(final quantity="ThermodynamicTemperature",
                                                    final unit = "K", displayUnit = "degC")
              "Air temperature"
              annotation (Placement(
                  transformation(extent={{-120,90},{-100,110}})));

        protected
            Modelica.Blocks.Interfaces.RealInput phi_in_internal
              "Needed to connect to conditional connector";
          equation
            connect(phi_in, phi_in_internal);
            if not use_phi_in then
              phi_in_internal = phi;
            end if;
            annotation (Icon(graphics,
                             coordinateSystem(preserveAspectRatio=false)), Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
April 11, 2019 by Filip Jorissen:<br/>
Revised implementation such that default value of relative humidity is
used when using a dry air medium.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1011\">#1011</a>.
</li>
<li>
January 26, 2018 by Filip Jorissen:<br/>
Changed replaceable record into parameter such that 
<code>IDEAS.Buildings.Components.OccupancyType.BaseClasses.PartialOccupancyType</code> 
can be a partial record.
This is for <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
          end PartialComfort;
        end BaseClasses;

        model None "No comfort is computed"
          extends BaseClasses.PartialComfort;
          annotation (Documentation(revisions="<html>
<ul>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",         info="<html>
<p>
Use this if you do not need to know the thermal comfort of the occupants.
</p>
</html>"));
        end None;
      end Comfort;

      package Interfaces "Building component interfaces"
      extends Modelica.Icons.InterfacesPackage;

        type BoundaryType = enumeration(
          BoundaryWall   "Boundary wall",
          InternalWall   "Internal wall",
          OuterWall   "Outer wall",
          SlabOnGround   "Slab on ground",
          External   "External connection using propsbus",
          None   "No wall for this orientation") "Type of zone boundary conditions that should be considered";

        partial model PartialOpaqueSurface
          "Partial component for the opaque surfaces of the building envelope"
          replaceable parameter IDEAS.Buildings.Data.Interfaces.Construction constructionType
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Building component material structure" annotation (
            __Dymola_choicesAllMatching=true,
            Placement(transformation(extent={{-34,78},{-30,82}})),
            Dialog(group="Construction details"));
          extends IDEAS.Buildings.Components.Interfaces.PartialSurface(
            E(y=if sim.computeConservationOfEnergy then layMul.E else 0),
            Qgai(y=layMul.port_b.Q_flow + (if sim.openSystemConservationOfEnergy or not sim.computeConservationOfEnergy
                 then 0 else sum(port_emb.Q_flow))),
            layMul(
              final nLay=constructionType.nLay,
              final mats=constructionType.mats,
              T_start=ones(constructionType.nLay)*T_start,
              nGain=constructionType.nGain));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_emb[constructionType.nGain]
            "Port for gains by embedded active layers"
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
      protected
          Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow iSolDir(final Q_flow=0);
          Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow iSolDif(final Q_flow=0);
        initial equation
          assert(not energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState,
            "In " + getInstanceName() + ": Using SteadyState energyDynamics for a wall
    is not allowed since this causes large algebraic loops, which significantly affects computation time.");
          assert(IDEAS.Utilities.Math.Functions.isAngle(constructionType.incLastLay, IDEAS.Types.Tilt.Other) or
            constructionType.incLastLay >= inc - Modelica.Constants.pi/3 - Modelica.Constants.eps and
            constructionType.incLastLay <= inc + Modelica.Constants.pi/3 + Modelica.Constants.eps,
            "The inclination of a wall, a floor or a ceiling does not correspond to its record.");
        equation
          connect(iSolDif.port, propsBus_a.iSolDif);
          connect(iSolDir.port, propsBus_a.iSolDir);
          for i in 1:constructionType.nGain loop
            connect(layMul.port_gain[constructionType.locGain[i]], port_emb[i])
            annotation (Line(points={{0,-10},{0,-10},{0,-100}}, color={191,0,0}));
          end for;
            annotation (
            Diagram(graphics,
                    coordinateSystem(preserveAspectRatio=false, extent={{-60,-100},{60,100}})),
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-50,-100},{50,100}}),
                graphics),
            Documentation(revisions="<html>
<ul>
<li>
June 27, 2018, by Filip Jorissen:<br/>
Added check to avoid <code>energyDynamics=SteadyState</code>. 
See issue <a href=https://github.com/open-ideas/IDEAS/issues/856>#856</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed conservation of energy implementation for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Removed
<code>AWall</code>  and declared <code>A</code> in 
<a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialSurface>
IDEAS.Buildings.Components.Interfaces.PartialSurface</a>.
This is for 
<a href=https://github.com/open-ideas/IDEAS/issues/609>#609</a>.
</li>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
February 6, 2016 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
This model extends 
<a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialSurface>IDEAS.Buildings.Components.Interfaces.PartialSurface</a>
with parameters that are typical for opaque surfaces, i.e. all surfaces except windows.
</p>
</html>"));
        end PartialOpaqueSurface;

        partial model PartialSurface "Partial model for building envelope component"
          outer IDEAS.BoundaryConditions.SimInfoManager sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{30,-100},{50,-80}})));
          parameter Modelica.SIunits.Angle inc
            "Inclination (tilt) angle of the wall, see IDEAS.Types.Tilt";
          parameter Modelica.SIunits.Angle azi
            "Azimuth angle of the wall, i.e. see IDEAS.Types.Azimuth, set IDEAS.Types.Azimuth.S for horizontal ceilings and floors";
          parameter Modelica.SIunits.Area A
            "Component surface area";
          parameter Real nWin = 1 "Use this factor to scale the component to nWin identical components";
          parameter Modelica.SIunits.Power QTra_design
            "Design heat losses at reference temperature of the boundary space"
            annotation (Dialog(group="Design power",tab="Advanced"));
          parameter Modelica.SIunits.Temperature T_start=293.15
            "Start temperature for each of the layers"
            annotation(Dialog(tab="Dynamics", group="Initial condition"));
          parameter Modelica.SIunits.Temperature TRef_a=291.15
            "Reference temperature of zone on side of propsBus_a, for calculation of design heat loss"
            annotation (Dialog(group="Design power",tab="Advanced"));
          parameter Boolean linIntCon_a=sim.linIntCon
            "= true, if convective heat transfer should be linearised"
            annotation (Dialog(tab="Convection"));
          parameter Modelica.SIunits.TemperatureDifference dT_nominal_a=1
            "Nominal temperature difference used for linearisation, negative temperatures indicate the solid is colder"
            annotation (Dialog(tab="Convection"));
          parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial
            "Static (steady state) or transient (dynamic) thermal conduction model"
            annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
          IDEAS.Buildings.Components.Interfaces.ZoneBus propsBus_a(
            numIncAndAziInBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
                                                     "If inc = Floor, then propsbus_a should be connected to the zone above this floor.
    If inc = ceiling, then propsbus_a should be connected to the zone below this ceiling.
    If component is an outerWall, porpsBus_a should be connect to the zone."
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={100,20}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,20})));
          IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.InteriorConvection intCon_a(
            linearise=linIntCon_a or sim.linearise,
            dT_nominal=dT_nominal_a,
            final inc=inc,
            A=A)
            "Convective heat transfer correlation for port_a"
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
          IDEAS.Buildings.Components.BaseClasses.ConductiveHeatTransfer.MultiLayer
            layMul(final inc=inc, energyDynamics=energyDynamics,
            linIntCon=linIntCon_a or sim.linearise,
            A=A)
            "Multilayer component for simulating walls, windows and other surfaces"
            annotation (Placement(transformation(extent={{10,-10},{-10,10}})));
      protected
          Modelica.Blocks.Sources.RealExpression QDesign(y=QTra_design);
          Modelica.Blocks.Sources.RealExpression aziExp(y=azi)
            "Azimuth angle expression";
          Modelica.Blocks.Sources.RealExpression incExp(y=inc)
            "Inclination angle expression";
          Modelica.Blocks.Sources.RealExpression E
            "Model internal energy";
          IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.PrescribedEnergy prescribedHeatFlowE
            "Component for computing conservation of energy";
          Modelica.Blocks.Sources.RealExpression Qgai
            "Heat gains across model boundary";
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prescribedHeatFlowQgai
            "Component for computing conservation of energy";
          IDEAS.Buildings.Components.Interfaces.ZoneBusVarMultiplicator gain(k=nWin)
            "Gain for all propsBus variable to represent nWin surfaces instead of 1"
            annotation (Placement(transformation(extent={{70,6},{88,36}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus propsBusInt(
            numIncAndAziInBus=sim.numIncAndAziInBus,
            outputAngles=sim.outputAngles)
            annotation (Placement(transformation(
                extent={{-18,-18},{18,18}},
                rotation=-90,
                origin={56,20}),  iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,20})));
        equation
          connect(prescribedHeatFlowE.port, propsBusInt.E);
          connect(Qgai.y,prescribedHeatFlowQgai. Q_flow);
          connect(prescribedHeatFlowQgai.port, propsBusInt.Qgai);
          connect(E.y,prescribedHeatFlowE. E);
          connect(QDesign.y, propsBusInt.QTra_design);
          connect(propsBusInt.surfCon, intCon_a.port_b) annotation (Line(
              points={{56.09,19.91},{46,19.91},{46,0},{40,0}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(layMul.port_a, propsBusInt.surfRad) annotation (Line(
              points={{10,0},{16,0},{16,19.91},{56.09,19.91}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(layMul.port_a, intCon_a.port_a) annotation (Line(
              points={{10,0},{20,0}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(layMul.iEpsSw_a, propsBusInt.epsSw) annotation (Line(
              points={{10,4},{20,4},{20,19.91},{56.09,19.91}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(layMul.iEpsLw_a, propsBusInt.epsLw) annotation (Line(
              points={{10,8},{18,8},{18,19.91},{56.09,19.91}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(layMul.area, propsBusInt.area) annotation (Line(
              points={{0,10},{0,19.91},{56.09,19.91}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(incExp.y, propsBusInt.inc);
          connect(aziExp.y, propsBusInt.azi);
          connect(propsBus_a, gain.propsBus_b) annotation (Line(
              points={{100,20},{94,20},{94,20.2105},{88,20.2105}},
              color={255,204,51},
              thickness=0.5));
          connect(gain.propsBus_a, propsBusInt) annotation (Line(
              points={{70,20.2105},{60,20.2105},{60,20},{56,20}},
              color={255,204,51},
              thickness=0.5));
          annotation (
            Diagram(graphics,
                    coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                    100,100}})),
            Icon(graphics,
                 coordinateSystem(preserveAspectRatio=false, extent={{-50,-100},{50,100}})),
            Documentation(revisions="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
Add scaling to propsBus_a to allow simulation of nWin windows instead of 1
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. This factor is not useful for wall and it is set final to 1 
for them.
</li>
<li>
January 26, 2018, by Filip Jorissen:<br/>
Extended documentation.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed bus declarations for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Declared parameter <code>A</code> instead of using
<code>AWall</code> in 
<a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>
IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a>.
This is for 
<a href=https://github.com/open-ideas/IDEAS/issues/609>#609</a>.
</li>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
March 8, 2016, by Filip Jorissen:<br/>
Added energyDynamics parameter.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
February 6, 2016 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Partial model for all surfaces and windows that contains common building blocks such as material layers and parameters.
</p>
<h4>Main equations</h4>
<p>
Submodel <code>layMul</code> contains equations
for simulating conductive (and sometimes radiative) heat transfer
inside material layers.
</p>
<h4>Assumption and limitations</h4>
<p>
This model assumes 1D heat transfer, i.e. edge effects are neglected.
Mass exchange (moisture) is not modelled.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameters <code>inc</code> and <code>azi</code> may be
used to specify the inclination and azimuth/tilt angle of the surface.
Variables in <a href=modelica://IDEAS.Types.Azimuth>IDEAS.Types.Azimuth</a>
and <a href=modelica://IDEAS.Types.Tilt>IDEAS.Types.Tilt</a>
may be used for this purpose or custom variables may be defined.
Numerical values can be used directly. 
Azimuth angles should be in radians relative to the south orientation, clockwise.
Tilt angles should be in radians where an angle of 0 is the ceiling (upward) orientation
and an angle of Pi is the floor (downward) orientation.
Preferably the azimuth angle is set to zero for horizontal tilt angles, 
since this leads to more efficient code, 
although the model results will not change.
</p>
<p>
The parameter <code>nWin</code> is used in the window model to scale
the window to <code>nWin</code> identical window using the single window
model.
</p>
<h4>Options</h4>
<p>
Convection equations may be simplified (linearised) by setting <code>linIntCon_a = true</code>.
</p>
<h4>Dynamics</h4>
<p>
This model contains multiple state variables for describing the temperature state of the component.
</p>
</html>"));
        end PartialSurface;

        model PartialZone "Building zone model"
          extends IDEAS.Buildings.Components.Interfaces.ZoneInterface(
            Qgai(y=(if not sim.computeConservationOfEnergy then 0 elseif sim.openSystemConservationOfEnergy
                   then airModel.QGai else gainCon.Q_flow + gainRad.Q_flow + airModel.QGai)),
            Eexpr(y=if sim.computeConservationOfEnergy then E else 0),
            useOccNumInput=occNum.useInput,
            useLigCtrInput=ligCtr.useCtrInput);

            replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choicesAllMatching = true);

          parameter Modelica.SIunits.Length hZone = 2.8
            "Zone height: distance between floor and ceiling"
            annotation(Dialog(group="Building physics"));
          parameter Modelica.SIunits.Area A = V/hZone "Total conditioned floor area"
            annotation(Dialog(group="Building physics"));
          parameter Real n50(min=0.01)= 0.4
            "n50 value cfr airtightness, i.e. the ACH at a pressure diffence of 50 Pa"
            annotation(Dialog(group="Building physics"));
          parameter Boolean allowFlowReversal=true
            "= true to allow flow reversal in zone, false restricts to design direction (port_a -> port_b)."
            annotation(Dialog(tab="Advanced", group="Air model"));
          parameter Real n50toAch=20 "Conversion fractor from n50 to Air Change Rate"
           annotation(Dialog(tab="Advanced", group="Air model"));
          parameter Modelica.Fluid.Types.Dynamics energyDynamicsAir=Modelica.Fluid.Types.Dynamics.FixedInitial
            "Type of energy balance for air model: dynamic (3 initialization options) or steady state";
          parameter Real mSenFac = 5 "Correction factor for thermal capacity of zone air."
            annotation(Dialog(tab="Advanced",group="Air model"));

          parameter Boolean linIntRad=sim.linIntRad
            "Linearized computation of long wave radiation"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));
          parameter Boolean calculateViewFactor = false
            "Explicit calculation of view factors: works well only for rectangular zones!"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));
          final parameter Modelica.SIunits.Power QInf_design=1012*1.204*V/3600*n50/n50toAch*(273.15
               + 21 - sim.Tdes)
            "Design heat losses from infiltration at reference outdoor temperature";
          final parameter Modelica.SIunits.Power QRH_design=A*fRH
            "Additional power required to compensate for the effects of intermittent heating";
          final parameter Modelica.SIunits.Power Q_design(fixed=false)
            "Total design heat losses for the zone";
          parameter Medium.Temperature T_start=Medium.T_default
            "Start value of temperature"
            annotation(Dialog(tab = "Initialization"));
          parameter Real fRH=11
            "Reheat factor for calculation of design heat load, (EN 12831, table D.10 Annex D)" annotation(Dialog(tab="Advanced",group="Design heat load"));
          parameter Modelica.SIunits.Temperature Tzone_nom = 295.15
            "Nominal zone temperature, used for linearising radiative heat exchange"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange", enable=linIntRad));
          parameter Modelica.SIunits.TemperatureDifference dT_nom = -2
            "Nominal temperature difference between zone walls, used for linearising radiative heat exchange"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange", enable=linIntRad));
          parameter Boolean simVieFac=false "Simplify view factor computation"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));

          replaceable ZoneAirModels.WellMixedAir airModel(
            redeclare package Medium = Medium,
            nSurf=nSurf,
            Vtot=V,
            energyDynamics=energyDynamicsAir,
            allowFlowReversal=allowFlowReversal)
          constrainedby
          IDEAS.Buildings.Components.ZoneAirModels.BaseClasses.PartialAirModel(
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            nSurf=nSurf,
            Vtot=V,
            final T_start=T_start,
            allowFlowReversal=allowFlowReversal,
            energyDynamics=energyDynamicsAir,
            massDynamics=if interzonalAirFlow.prescribesPressure
                         then Modelica.Fluid.Types.Dynamics.SteadyState
                         else energyDynamicsAir,
            nPorts=interzonalAirFlow.nPorts,
            m_flow_nominal=m_flow_nominal)
            "Zone air model"
            annotation (choicesAllMatching=true,
            Placement(transformation(extent={{-40,20},{-20,40}})),
            Dialog(tab="Advanced",group="Air model"));
          replaceable IDEAS.Buildings.Components.InterzonalAirFlow.n50Tight interzonalAirFlow
          constrainedby
          IDEAS.Buildings.Components.InterzonalAirFlow.BaseClasses.PartialInterzonalAirFlow(
              redeclare package Medium = Medium,
              V=V,
              n50=n50,
              n50toAch=n50toAch,
              m_flow_nominal_vent=m_flow_nominal)
              "Interzonal air flow model"
            annotation (choicesAllMatching = true,Dialog(tab="Advanced", group="Air model"),
              Placement(transformation(extent={{-40,60},{-20,80}})),
            choicesAllMatching=true,
            Dialog(group="Building physics"));
          replaceable IDEAS.Buildings.Components.Occupants.Fixed occNum
            constrainedby Occupants.BaseClasses.PartialOccupants(
              final A=A,
              final linearise = sim.lineariseDymola)
            "Number of occupants that are present" annotation (
            choicesAllMatching=true,
            Dialog(group="Occupants (optional)"),
            Placement(transformation(extent={{80,22},{60,42}})));

          replaceable parameter IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp
            constrainedby
          IDEAS.Buildings.Components.OccupancyType.BaseClasses.PartialOccupancyType
            "Occupancy type, only used for evaluating occupancy model and comfort model"
            annotation (
            choicesAllMatching=true,
            Dialog(group="Occupants (optional)"),
            Placement(transformation(extent={{80,82},{100,102}})));
          replaceable parameter IDEAS.Buildings.Components.RoomType.Generic rooTyp
            constrainedby
          IDEAS.Buildings.Components.RoomType.BaseClasses.PartialRoomType
            "Room type or function, currently only determines the desired lighting intensity"
            annotation (choicesAllMatching=true,
            Dialog(group="Lighting (optional)"),
            Placement(transformation(extent={{32,82},{52,102}})));
          replaceable parameter IDEAS.Buildings.Components.LightingType.None ligTyp
            constrainedby
          IDEAS.Buildings.Components.LightingType.BaseClasses.PartialLighting
            "Lighting type, determines the lighting efficacy/efficiency" annotation (
            choicesAllMatching=true,
            Dialog(group="Lighting (optional)"),
            Placement(transformation(extent={{56,82},{76,102}})));
          replaceable IDEAS.Buildings.Components.Comfort.None comfort
            constrainedby
          IDEAS.Buildings.Components.Comfort.BaseClasses.PartialComfort(
              occupancyType=occTyp,
              use_phi_in=Medium.nX > 1) "Comfort model" annotation (
            choicesAllMatching=true,
            Dialog(group="Occupants (optional)"),
            Placement(transformation(extent={{20,-20},{40,0}})));
          replaceable IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ZoneLwGainDistribution
            radDistr(nSurf=nSurf, lineariseJModelica=sim.lineariseJModelica,
            T_start=T_start)
            "Distribution of radiative internal gains"
            annotation (choicesAllMatching=true,Dialog(tab="Advanced",group="Building physics"),Placement(transformation(
                extent={{10,10},{-10,-10}},
                rotation=-90,
                origin={-50,-50})));
          replaceable IDEAS.Buildings.Components.InternalGains.Occupants intGaiOcc
            constrainedby
          IDEAS.Buildings.Components.InternalGains.BaseClasses.PartialOccupancyGains(
              occupancyType=occTyp,
              redeclare final package Medium = Medium)
            "Internal gains model" annotation (
            choicesAllMatching=true,
            Dialog(tab="Advanced", group="Occupants"),
            Placement(transformation(extent={{40,22},{20,42}})));

          replaceable IDEAS.Buildings.Components.InternalGains.Lighting intGaiLig
            constrainedby
          IDEAS.Buildings.Components.InternalGains.BaseClasses.PartialLightingGains(
              A=A,
              ligTyp=ligTyp,
              rooTyp=rooTyp) "Lighting model" annotation (
            choicesAllMatching=true,
            Dialog(tab="Advanced", group="Lighting"),
            Placement(transformation(extent={{40,52},{20,72}})));

          Modelica.SIunits.Power QTra_design=sum(propsBusInt.QTra_design)
            "Total design transmission heat losses for the zone";
          Modelica.Blocks.Interfaces.RealOutput TAir(unit="K") = airModel.TAir;
          Modelica.Blocks.Interfaces.RealOutput TRad(unit="K") = radDistr.TRad;
          Modelica.SIunits.Energy E = airModel.E;

          replaceable IDEAS.Buildings.Components.LightingControl.Fixed ligCtr
            constrainedby
          IDEAS.Buildings.Components.LightingControl.BaseClasses.PartialLightingControl(
              final linearise = sim.lineariseDymola)
            "Lighting control type" annotation (
            choicesAllMatching=true,
            Dialog(group="Lighting (optional)"),
            Placement(transformation(extent={{80,52},{60,72}})));



      protected
          IDEAS.Buildings.Components.Interfaces.ZoneBus[nSurf] propsBusInt(
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles)
            "Dummy propsbus for partial" annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-80,40}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-80,40})));

          IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ZoneLwDistribution
            radDistrLw(nSurf=nSurf, final linearise=linIntRad or sim.linearise,
            Tzone_nom=Tzone_nom,
            dT_nom=dT_nom,
            final simVieFac=simVieFac) if                not calculateViewFactor
            "internal longwave radiative heat exchange" annotation (Placement(
                transformation(
                extent={{10,-10},{-10,10}},
                rotation=90,
                origin={-50,-10})));
          Modelica.Blocks.Math.Sum add(nin=2, k={0.5,0.5}) "Operative temperature"
            annotation (Placement(transformation(extent={{84,14},{96,26}})));

          IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ZoneLwDistributionViewFactor
            zoneLwDistributionViewFactor(
              nSurf=nSurf,
              final hZone=hZone,
            linearise=linIntRad or sim.linearise,
            Tzone_nom=Tzone_nom,
            dT_nom=dT_nom) if       calculateViewFactor annotation (Placement(
                transformation(
                extent={{-10,10},{10,-10}},
                rotation=270,
                origin={-30,-10})));



        initial equation
          Q_design=QInf_design+QRH_design+QTra_design; //Total design load for zone (additional ventilation losses are calculated in the ventilation system)

        equation
          if interzonalAirFlow.verifyBothPortsConnected then
            assert(cardinality(port_a)>1 and cardinality(port_b)>1 or cardinality(port_a) == 1 and cardinality(port_b) == 1,
              "WARNING: Only one of the FluidPorts of " + getInstanceName() + " is 
      connected and an 'open' interzonalAirFlow model is used, 
      which means that all injected/extracted air will flow
      through the zone to/from the surroundings, at ambient temperature. 
      This may be unintended.",         AssertionLevel.warning);
          end if;
          for i in 1:nSurf loop
            connect(sim.weaBus, propsBusInt[i].weaBus) annotation (Line(
                points={{-81,93},{-81,92},{-80,92},{-80,66},{-80.1,66},{-80.1,39.9}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(dummy1, propsBusInt[i].Qgai);
            connect(dummy2, propsBusInt[i].E);
        end for;
          connect(radDistr.radGain, gainRad) annotation (Line(
              points={{-46.2,-60},{100,-60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(radDistr.TRad, add.u[1]) annotation (Line(
              points={{-40,-50},{-6,-50},{-6,19.4},{82.8,19.4}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(propsBusInt[1:nSurf].area, radDistr.area[1:nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-58},{-60,-58}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].area, radDistrLw.A[1:nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-14},{-60,-14}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].epsLw, radDistrLw.epsLw[1:nSurf]) annotation (
              Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-10},{-60,-10}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].epsLw, zoneLwDistributionViewFactor.epsLw[1:
            nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-10},{-40,-10}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].area, zoneLwDistributionViewFactor.A[1:nSurf])
            annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-14},{-40,-14}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].epsLw, radDistr.epsLw[1:nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-50},{-60,-50}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].epsSw, radDistr.epsSw[1:nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-54},{-60,-54}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          for i in 1:nSurf loop
            connect(radDistr.iSolDir, propsBusInt[i].iSolDir) annotation (Line(
                points={{-54,-60},{-80.1,-60},{-80.1,39.9}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(radDistr.iSolDif, propsBusInt[i].iSolDif) annotation (Line(
                points={{-50,-60},{-50,-64},{-80.1,-64},{-80.1,39.9}},
                color={191,0,0},
                smooth=Smooth.None));
          end for;
          connect(radDistr.radSurfTot, radDistrLw.port_a) annotation (Line(
              points={{-50,-40},{-50,-20}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(zoneLwDistributionViewFactor.inc[1:nSurf], propsBusInt[1:nSurf].inc)
            annotation (Line(
              points={{-34,-1.77636e-15},{-34,4},{-80,4},{-80,39.9},{-80.1,39.9}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(zoneLwDistributionViewFactor.azi[1:nSurf], propsBusInt[1:nSurf].azi)
            annotation (Line(
              points={{-26,-1.77636e-15},{-26,8},{-80,8},{-80,39.9},{-80.1,39.9}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(zoneLwDistributionViewFactor.port_a, radDistr.radSurfTot) annotation (
             Line(
              points={{-30,-20},{-30,-30},{-50,-30},{-50,-40}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(add.y, TSensor) annotation (Line(points={{96.6,20},{110,20}},
                           color={0,0,127}));
          connect(radDistr.radSurfTot[1:nSurf], propsBusInt[1:nSurf].surfRad)
            annotation (Line(points={{-50,-40},{-50,-30},{-80,-30},{-80,39.9},{-80.1,
                  39.9}}, color={191,0,0}));
          connect(airModel.ports_surf[1:nSurf], propsBusInt[1:nSurf].surfCon)
            annotation (Line(points={{-40,30},{-80,30},{-80,40},{-80.1,40},{-80.1,39.9}},
                color={191,0,0}));
          connect(airModel.inc[1:nSurf], propsBusInt[1:nSurf].inc) annotation (Line(
                points={{-40.8,38},{-80,38},{-80,40},{-82,40},{-80.1,40},{-80.1,39.9}},
                color={0,0,127}));
          connect(airModel.azi[1:nSurf], propsBusInt[1:nSurf].azi) annotation (Line(
                points={{-40.8,34},{-80,34},{-80,40},{-80.1,40},{-80.1,39.9}}, color={0,
                  0,127}));
          connect(airModel.A[1:nSurf], propsBusInt[1:nSurf].area) annotation (Line(
                points={{-40.6,24},{-80,24},{-80,40},{-80.1,40},{-80.1,39.9}}, color={0,
                  0,127}));
          connect(airModel.ports_air[1], gainCon) annotation (Line(points={{-20,30},{2,30},
                  {2,-30},{100,-30}}, color={191,0,0}));
          connect(airModel.TAir, add.u[2]) annotation (Line(points={{-19,24},{-10,24},{-10,
                  20.6},{82.8,20.6}},  color={0,0,127}));
          connect(radDistr.azi[1:nSurf], propsBusInt[1:nSurf].azi) annotation (Line(
                points={{-60,-42},{-70,-42},{-80,-42},{-80,39.9},{-80.1,39.9}}, color={
                  0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(radDistr.inc[1:nSurf], propsBusInt[1:nSurf].inc) annotation (Line(
                points={{-60,-46},{-80,-46},{-80,39.9},{-80.1,39.9}}, color={0,0,127}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(intGaiOcc.portCon, airModel.ports_air[1])
            annotation (Line(points={{20,30},{-20,30}}, color={191,0,0}));
          connect(intGaiOcc.portRad, radDistr.radGain) annotation (Line(points={{20,26},
                  {4,26},{4,-60},{-46.2,-60}}, color={191,0,0}));
          connect(intGaiOcc.mWat_flow, airModel.mWat_flow)
            annotation (Line(points={{19.4,38},{-19.2,38}}, color={0,0,127}));
          connect(intGaiOcc.C_flow, airModel.C_flow)
            annotation (Line(points={{19.4,34},{-19.2,34}}, color={0,0,127}));
          connect(comfort.TAir, airModel.TAir) annotation (Line(points={{19,0},{-10,0},{
                  -10,24},{-19,24}},   color={0,0,127}));
          connect(comfort.TRad, radDistr.TRad) annotation (Line(points={{19,-4},{-6,-4},
                  {-6,-50},{-40,-50}}, color={0,0,127}));
          connect(comfort.phi_in, airModel.phi) annotation (Line(points={{19,-8},{-12,-8},{
                  -12,26},{-19,26}},   color={0,0,127}));
          connect(occNum.nOcc, intGaiOcc.nOcc)
            annotation (Line(points={{58,32},{41,32}}, color={0,0,127}));
          connect(yOcc, occNum.yOcc) annotation (Line(points={{120,40},{96,40},{96,32},{
                  82,32}}, color={0,0,127}));
          connect(uLig, ligCtr.ligCtr) annotation (Line(points={{120,70},{96,70},{96,60},
                  {82,60}},color={0,0,127}));
          connect(occNum.nOcc, ligCtr.nOcc) annotation (Line(points={{58,32},{96,32},{96,
                  64},{82,64}},
                           color={0,0,127}));
          connect(airModel.port_b, interzonalAirFlow.port_a_interior)
            annotation (Line(points={{-36,40},{-36,60}}, color={0,127,255}));
          connect(airModel.port_a, interzonalAirFlow.port_b_interior)
            annotation (Line(points={{-24,40},{-24,60}}, color={0,127,255}));
          connect(interzonalAirFlow.ports, airModel.ports) annotation (Line(points={{
                  -29.8,60},{-30,60},{-30,40}}, color={0,127,255}));
          connect(interzonalAirFlow.port_b_exterior, port_b) annotation (Line(points={{
                  -32,80},{-32,92},{-20,92},{-20,100}}, color={0,127,255}));
          connect(interzonalAirFlow.port_a_exterior, port_a) annotation (Line(points={{
                  -28,80},{-28,84},{20,84},{20,100}}, color={0,127,255}));
          connect(ppm, airModel.ppm) annotation (Line(points={{110,0},{52,0},{52,16},{-8,
                  16},{-8,28},{-19,28}}, color={0,0,127}));
          connect(intGaiLig.portRad, gainRad) annotation (Line(points={{20,60},{4,60},{4,
                  -60},{100,-60}}, color={191,0,0}));
          connect(intGaiLig.portCon, gainCon) annotation (Line(points={{20,64},{2,64},{2,
                  -30},{100,-30}}, color={191,0,0}));
          connect(ligCtr.ctrl, intGaiLig.ctrl)
            annotation (Line(points={{58,62},{41,62}}, color={0,0,127}));
         annotation (Placement(transformation(extent={{
                    140,48},{100,88}})),
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                 graphics),
            Documentation(info="<html>
<p>See extending models.</p>
</html>",         revisions="<html>
<ul>
<li>
April 26, 2019 by Filip Jorissen:<br/>
Set <code>massDynamics=if interzonalAirFlow.prescribesPressure then Modelica.Fluid.Types.Dynamics.SteadyState</code>
such that the state is removed when the pressure is prescribed.
See <a href=https://github.com/open-ideas/IDEAS/issues/1021>#1021</a>.
</li>
<li>
April 11, 2019 by Filip Jorissen:<br/>
Revised implementation such that default value of relative humidity is
used when using a dry air medium.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1011\">#1011</a>.
</li>
<li>
January 25, 2019 by Filip Jorissen:<br/>
Avoided redundant consistent initial equation for pressure in <code>airModel</code>.
See <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
November 5, 2018 by Filip Jorissen:<br/>
Propagated <code>T_start</code> into <code>radDistr</code>.
</li>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
Implementation of the lighting model
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
<li>
September 24, 2018 by Filip Jorissen:<br/>
Fixed duplicate declaration of <code>V</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/917\">#917</a>.
</li>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added output for the CO2 concentration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
July 11, 2018, Filip Jorissen:<br/>
Propagated <code>m_flow_nominal</code> for setting nominal values 
of <code>h_outflow</code> and <code>m_flow</code>
in <code>FluidPorts</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/859\">#859</a>.
</li>
<li>
May 29, 2018, Filip Jorissen:<br/>
Removed conditional fluid ports for JModelica compatibility.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/834\">#834</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
Modified interfaces for supporting new interzonal air flow models.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
<li>
April 12, 2018 by Filip Jorissen:<br/>
Propagated <code>energyDynamicsAir</code>.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/800>#800</a>.
</li>
<li>
March 29, 2018 by Filip Jorissen:<br/>
Propagated <code>mSenFac</code> to <code>airModel</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/792\">#792</a>.
</li>
<li>
March 28, 2018 by Filip Jorissen:<br/>
Added option for introducing state for
radiative temperature.
</li>
<li>
July 26, 2018 by Filip Jorissen:<br/>
Added replaceable block that allows to define
the number of occupants.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed linearisation and conservation of energy implementations for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
February 1, 2017 by Filip Jorissen:<br/>
Added option for disabling new view factor computation.
See issue
<a href=https://github.com/open-ideas/IDEAS/issues/663>#663</a>.
</li>
<li>
January 24, 2017 by Filip Jorissen:<br/>
Made <code>radDistr</code> replaceable
such that it can be redeclared in experimental models.
</li>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Propagated linearisation parameters for interior radiative heat exchange.
</li>
<li>
August 26, 2016 by Filip Jorissen:<br/>
Added support for conservation of energy of air model.
</li>
<li>
April 30, 2016, by Filip Jorissen:<br/>
Added replaceable air model implementation.
</li>
<li>
March, 2015, by Filip Jorissen:<br/>
Added view factor implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Partial model that defines the main variables and connectors of a zone model.
</p>
</html>"));
        end PartialZone;

        connector RealConnector =
                            Real "Real connector without input/output specifier"
          annotation (Icon(graphics,
                           coordinateSystem(preserveAspectRatio=false)), Diagram(graphics,
                coordinateSystem(preserveAspectRatio=false)));

        partial model RectangularZoneTemplateInterface
          "Rectangular zone including walls, floor and ceiling"
          extends IDEAS.Buildings.Components.Interfaces.PartialZone(
            calculateViewFactor=false,
            final nSurf=indWinCei+nSurfExt,
            final V=A*h,
            final A=AZone,
            final hZone=h,
            final fRH=11);

          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypA
            "Modelled boundary for face A of the zone"
            annotation(Dialog(tab="Face A", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypB
            "Modelled boundary for face B of the zone"
            annotation(Dialog(tab="Face B", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypC
            "Modelled boundary for face C of the zone"
            annotation(Dialog(tab="Face C", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypD
            "Modelled boundary for face D of the zone"
            annotation(Dialog(tab="Face D", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypFlo
            "Modelled boundary for the zone floor"
            annotation(Dialog(tab="Floor", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypCei
            "Modelled boundary for the zone ceiling"
            annotation(Dialog(tab="Ceiling", group="Construction details"));
          parameter Integer nExtA(min=0) = 1 "Number of external surfaces connected to face A"
            annotation(Dialog(tab="Face A", group="Construction details",
                       enable=bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtB(min=0) = 1 "Number of external surfaces connected to face B"
            annotation(Dialog(tab="Face B", group="Construction details",
                       enable=bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtC(min=0) = 1 "Number of external surfaces connected to face C"
            annotation(Dialog(tab="Face C", group="Construction details",
                       enable=bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtD(min=0) = 1 "Number of external surfaces connected to face D"
            annotation(Dialog(tab="Face D", group="Construction details",
                       enable=bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtFlo(min=0) = 1 "Number of external surfaces connected to floor"
            annotation(Dialog(tab="Floor", group="Construction details",
                       enable=bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtCei(min=0) = 1 "Number of external surfaces connected to ceiling"
            annotation(Dialog(tab="Ceiling", group="Construction details",
                       enable=bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));

          parameter Boolean hasWinA = false
            "Modelling window for face A if true"
            annotation(Dialog(tab="Face A", group="Window details", enable=not (bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasWinB = false
            "Modelling window for face B if true"
            annotation(Dialog(tab="Face B", group="Window details", enable=not (bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasWinC = false
            "Modelling window for face C if true"
            annotation(Dialog(tab="Face C", group="Window details", enable=not (bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasWinD = false
            "Modelling window for face D if true"
            annotation(Dialog(tab="Face D", group="Window details", enable=not (bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasWinCei = false
            "Modelling window for ceiling if true"
            annotation(Dialog(tab="Ceiling", group="Window details", enable=not (bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasInt = false
            "If true, the zone contains an internal wall with both faces connected to the zone"
            annotation(Dialog(tab="Internal wall"));
          parameter Integer nSurfExt = 0
            "Number of additional connected external surfaces";
          parameter Modelica.SIunits.Angle aziA
            "Azimuth angle of face A";
          parameter Modelica.SIunits.Length l
            "Horizontal length of faces A and C. This parameter can be overwritten per surface";
          parameter Modelica.SIunits.Length w
            "Horizontal length of faces B and D. This parameter can be overwritten per surface";
          parameter Modelica.SIunits.Length lA = l
            "Horizontal length of face A" annotation(Dialog(tab="Face A", group="Overwrite"));
          parameter Modelica.SIunits.Length lB = w
            "Horizontal length of face B" annotation(Dialog(tab="Face B", group="Overwrite"));
          parameter Modelica.SIunits.Length lC = l
            "Horizontal length of face C" annotation(Dialog(tab="Face C", group="Overwrite"));
          parameter Modelica.SIunits.Length lD = w
            "Horizontal length of face D" annotation(Dialog(tab="Face D", group="Overwrite"));
          parameter Modelica.SIunits.Length lInt = lA
            "Horizontal length of internal wall contained within the zone" annotation(Dialog(tab="Internal wall", group="Construction details", enable=hasInt));
          parameter Modelica.SIunits.Area AZone = w*l
            "Parameter to overwrite the zone surface area"
                                          annotation(Dialog(tab="Advanced", group="Overwrite"));
          parameter Modelica.SIunits.Area ACei = w*l "Surface of roof or ceiling (including potential windows)"
            annotation(Dialog(tab="Ceiling", group="Overwrite"));

          parameter Modelica.SIunits.Length h
            "Height between top of floor and bottom of ceiling";
          parameter Modelica.SIunits.Area A_winA=0
            "Surface area of window of face A"
            annotation(Dialog(tab="Face A", group="Window details",
            enable=hasWinA));
          parameter Modelica.SIunits.Area A_winB=0
            "Surface area of window of face B"
            annotation(Dialog(tab="Face B", group="Window details",
            enable=hasWinB));
          parameter Modelica.SIunits.Area A_winC=0
            "Surface area of window of face C"
            annotation(Dialog(tab="Face C", group="Window details",
            enable=hasWinC));
          parameter Modelica.SIunits.Area A_winD=0
            "Surface area of window of face D"
            annotation(Dialog(tab="Face D", group="Window details",
            enable=hasWinD));
          parameter Modelica.SIunits.Area A_winCei=0
            "Surface area of window of ceiling"
            annotation(Dialog(tab="Ceiling", group="Window details",
            enable=hasWinCei));

          parameter Real fracA=0.15
            "Area fraction of the window frame of face A"
            annotation(Dialog(tab="Face A", group="Window details",
            enable=hasWinA));
          parameter Real fracB=0.15
            "Area fraction of the window frame of face B"
            annotation(Dialog(tab="Face B", group="Window details",
            enable=hasWinB));
          parameter Real fracC=0.15
            "Area fraction of the window frame of face C"
            annotation(Dialog(tab="Face C", group="Window details",
            enable=hasWinC));
          parameter Real fracD=0.15
            "Area fraction of the window frame of face D"
            annotation(Dialog(tab="Face D", group="Window details",
            enable=hasWinD));
          parameter Real fracCei=0.15
            "Area fraction of the window frame of the ceiling"
            annotation(Dialog(tab="Ceiling", group="Window details",
            enable=hasWinCei));
          parameter Real nWinA=1
            "Scaling factor to model nWinA identical windows in facade A"
            annotation(Dialog(tab="Face A", group="Window details",
            enable=hasWinA));
          parameter Real nWinB=1
            "Scaling factor to model nWinB identical windows in facade B"
            annotation(Dialog(tab="Face B", group="Window details",
            enable=hasWinB));
          parameter Real nWinC=1
            "Scaling factor to model nWinC identical windows in facade C"
            annotation(Dialog(tab="Face C", group="Window details",
            enable=hasWinC));
          parameter Real nWinD=1
            "Scaling factor to model nWinD identical windows in facade D"
            annotation(Dialog(tab="Face D", group="Window details",
            enable=hasWinD));
          parameter Real nWinCei=1
            "Scaling factor to model nWinCei identical windows in the ceiling"
            annotation(Dialog(tab="Ceiling", group="Window details",
            enable=hasWinCei));

          parameter Boolean linIntCon=sim.linIntCon
            "= true, if convective heat transfer should be linearised"
            annotation(Dialog(tab="Advanced", group="Convective heat exchange"));
          parameter Interfaces.WindowDynamicsType windowDynamicsType=IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Two
            "Type of dynamics for glazings and frames: using zero, one combined or two states"
            annotation(Dialog(group="Windows", tab="Advanced"));
          parameter SI.TemperatureDifference dT_nominal_win=-3
            "Nominal temperature difference used for linearisation, negative temperatures indicate the solid is colder"
            annotation(Dialog(group="Convective heat transfer", tab="Advanced"));
          parameter Boolean linExtCon=sim.linExtCon
            "= true, if exterior convective heat transfer should be linearised (uses average wind speed)"
            annotation(Dialog(tab="Advanced", group="Convective heat exchange"));
          parameter Boolean linExtRad=sim.linExtRad
            "= true, if exterior radiative heat transfer for walls should be linearised"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));
          parameter Boolean linExtRadWin=sim.linExtRadWin
            "= true, if exterior radiative heat transfer for windows should be linearised"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));

          parameter Real mSenFac(min=0.1)=5
            "Factor for scaling the sensible thermal mass of the zone air"
            annotation(Dialog(tab="Advanced",group="Air model"));
          parameter SI.TemperatureDifference dT_nominal_bou=-1
            "Nominal temperature difference for boundary walls, used for linearisation, negative temperatures indicate the solid is colder"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          parameter SI.TemperatureDifference dT_nominal_out=-3
            "Nominal temperature difference for outer walls, used for linearisation, negative temperatures indicate the solid is colder"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          parameter SI.TemperatureDifference dT_nominal_sla=-3
            "Nominal temperature difference of slab on ground, used for linearisation, negative temperatures indicate the solid is colder"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          parameter SI.Temperature TeAvg=273.15 + 10.8
            "Annual average outdoor temperature"
            annotation(Dialog(tab="Floor", group="Slab on ground", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          parameter SI.Temperature TiAvg=273.15 + 22
            "Annual average indoor temperature"
            annotation(Dialog(tab="Floor", group="Slab on ground", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          parameter SI.TemperatureDifference dTeAvg=4
            "Amplitude of variation of monthly average outdoor temperature"
            annotation(Dialog(tab="Floor", group="Slab on ground", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          parameter SI.TemperatureDifference dTiAvg=2
            "Amplitude of variation of monthly average indoor temperature"
            annotation(Dialog(tab="Floor", group="Slab on ground", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          parameter SI.TemperatureDifference dT_nominal_intA=1
            "Nominal temperature difference between zone air and interior walls, used for linearisation"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          parameter SI.TemperatureDifference dT_nominal_intB=1
            "Nominal temperature difference between interior walls exterior connection, used for linearisation"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypA
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of face A" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,8},{-224,12}})),
            Dialog(tab="Face A",group="Construction details",
                   enable=not (bouTypA==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypA==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypB
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of face B" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-12},{-224,-8}})),
            Dialog(tab="Face B",group="Construction details",
                   enable=not (bouTypB==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypB==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypC
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of face C" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-32},{-224,-28}})),
            Dialog(tab="Face C",group="Construction details",
                   enable=not (bouTypC==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypC==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypD
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of face D" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-52},{-224,-48}})),
            Dialog(tab="Face D",group="Construction details",
                   enable=not (bouTypD==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypD==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypCei
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of ceiling" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-92},{-224,-88}})),
            Dialog(tab="Ceiling",group="Construction details",
                   enable=not (bouTypCei==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypCei==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypFlo
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of floor" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-72},{-224,-68}})),
            Dialog(tab="Floor",group="Construction details",
                   enable=not (bouTypFlo==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypFlo==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypInt
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of internal wall" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-72},{-224,-68}})),
            Dialog(tab="Internal wall",group="Construction details", enable=hasInt));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingA
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of face A"
            annotation (choicesAllMatching=true,
            Dialog(tab="Face A", group="Window details",
                   enable = hasWinA));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingB
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of face B"
            annotation (choicesAllMatching=true,
            Dialog(tab="Face B", group="Window details",
                   enable = hasWinB));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingC
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of face C"
            annotation (choicesAllMatching=true,
            Dialog(tab="Face C", group="Window details",
                   enable = hasWinC));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingD
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of face D"
            annotation (choicesAllMatching=true,
            Dialog(tab="Face D", group="Window details",
                   enable = hasWinD));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingCei
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of ceiling"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Ceiling", group="Window details",
                   enable = hasWinCei));

          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypA
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of face A"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Face A", group="Window details",
                   enable = hasWinA));
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypB
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of face B"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Face B", group="Window details",
                   enable = hasWinB));
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypC
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of face C"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Face C", group="Window details",
                   enable = hasWinC));
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypD
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of face D"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Face D", group="Window details",
                   enable = hasWinD));
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypCei
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of ceiling"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Ceiling", group="Window details",
                   enable = hasWinCei));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypA
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface A"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Face A", group="Window details", enable=hasWinA));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypB
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface B"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Face B", group="Window details", enable=hasWinB));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypC
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface C"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Face C", group="Window details", enable=hasWinC));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypD
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface D"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Face D", group="Window details", enable=hasWinD));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypCei
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface Cei"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Ceiling", group="Window details", enable=hasWinCei));

          // open door modelling
          parameter Boolean hasCavityA = false
            "=true, to model open door or cavity in internal wall"
            annotation(Dialog(tab="Face A", group="Cavity or open door", enable=(bouTypeA==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall)));
          parameter Modelica.SIunits.Length hA(min=0) = 2
            "Height of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityA,tab="Face A", group="Cavity or open door"));
          parameter Modelica.SIunits.Length wA(min=0) = 1
            "Width of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityA,tab="Face A", group="Cavity or open door"));
          parameter Boolean hasCavityB = false
            "=true, to model open door or cavity in internal wall"
            annotation(Dialog(tab="Face B", group="Cavity or open door", enable=(bouTypeB==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall)));
          parameter Modelica.SIunits.Length hB(min=0) = 2
            "Height of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityB,tab="Face B", group="Cavity or open door"));
          parameter Modelica.SIunits.Length wB(min=0) = 1
            "Width of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityB,tab="Face B", group="Cavity or open door"));
          parameter Boolean hasCavityC = false
            "=true, to model open door or cavity in internal wall"
            annotation(Dialog(tab="Face C", group="Cavity or open door", enable=(bouTypeC==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall)));
          parameter Modelica.SIunits.Length hC(min=0) = 2
            "Height of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityC,tab="Face C", group="Cavity or open door"));
          parameter Modelica.SIunits.Length wC(min=0) = 1
            "Width of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityC,tab="Face C", group="Cavity or open door"));
          parameter Boolean hasCavityD = false
            "=true, to model open door or cavity in internal wall"
            annotation(Dialog(tab="Face D", group="Cavity or open door", enable=(bouTypeD==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall)));
          parameter Modelica.SIunits.Length hD(min=0) = 2
            "Height of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityD,tab="Face D", group="Cavity or open door"));
          parameter Modelica.SIunits.Length wD(min=0) = 1
            "Width of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityD,tab="Face D", group="Cavity or open door"));
          parameter Modelica.SIunits.Acceleration g = Modelica.Constants.g_n
            "Gravity, for computation of buoyancy"
            annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.Pressure p = 101300
            "Absolute pressure for computation of buoyancy"
            annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.Density rho = p/r/T
            "Nominal density for computation of buoyancy mass flow rate"
            annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.SpecificHeatCapacity c_p = 1013
           "Nominal heat capacity for computation of buoyancy heat flow rate"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.Temperature T = 293.15
           "Nominal temperature for linearising heat flow rate"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.TemperatureDifference dT = 1
           "Nominal temperature difference when linearising heat flow rate"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));

          parameter Boolean hasBuildingShadeA=false
            "=true, to enable computation of shade cast by opposite building or object on OuterWall"
            annotation(Dialog(tab="Face A", group="Building shade", enable=(bouTypA==IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall)));
          parameter SI.Length LShaA=0
            "Distance between shading object and wall, perpendicular to wall"
            annotation(Dialog(enable=hasBuildingShadeA,tab="Face A", group="Building shade"));
          parameter SI.Length dhShaA=0
            "Height difference between top of shading object and top of wall A"
            annotation(Dialog(enable=hasBuildingShadeA,tab="Face A", group="Building shade"));
          parameter Boolean hasBuildingShadeB=false
            "=true, to enable computation of shade cast by opposite building or object on OuterWall"
            annotation(Dialog(tab="Face B", group="Building shade", enable=(bouTypB==IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall)));
          parameter SI.Length LShaB=0
            "Distance between shading object and wall, perpendicular to wall"
            annotation(Dialog(enable=hasBuildingShadeB,tab="Face B", group="Building shade"));
          parameter SI.Length dhShaB=0
            "Height difference between top of shading object and top of wall B"
            annotation(Dialog(enable=hasBuildingShadeB,tab="Face B", group="Building shade"));
          parameter Boolean hasBuildingShadeC=false
            "=true, to enable computation of shade cast by opposite building or object on OuterWall"
            annotation(Dialog(tab="Face C", group="Building shade", enable=(bouTypC==IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall)));
          parameter SI.Length LShaC=0
            "Distance between shading object and wall, perpendicular to wall"
            annotation(Dialog(enable=hasBuildingShadeC,tab="Face C", group="Building shade"));
          parameter SI.Length dhShaC=0
            "Height difference between top of shading object and top of wall C"
            annotation(Dialog(enable=hasBuildingShadeC,tab="Face C", group="Building shade"));
          parameter Boolean hasBuildingShadeD=false
            "=true, to enable computation of shade cast by opposite building or object on OuterWall"
            annotation(Dialog(tab="Face D", group="Building shade", enable=(bouTypD==IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall)));
          parameter SI.Length LShaD=0
            "Distance between shading object and wall, perpendicular to wall"
            annotation(Dialog(enable=hasBuildingShadeD,tab="Face D", group="Building shade"));
          parameter SI.Length dhShaD=0
            "Height difference between top of shading object and top of wall D"
            annotation(Dialog(enable=hasBuildingShadeD,tab="Face D", group="Building shade"));
          parameter SI.Length PWall = (if hasOutA then lA else 0) + (if hasOutB then lB else 0) + (if hasOutC then lC else 0) + (if hasOutD then lD else 0)
            "Total floor slab perimeter length" annotation(Dialog(tab="Advanced", group="SlabOnGround", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));

          parameter Boolean hasEmb = false
            "Set to true if floor is equipped with floor heating or concrete core activation"
          annotation(Dialog(tab="Floor", group="Floor heating / CCA",
                    enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
                            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall or
                            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          final parameter Modelica.SIunits.Angle aziB = aziA + Modelica.Constants.pi/2
            "Azimuth angle of face B";
          final parameter Modelica.SIunits.Angle aziC = aziA + Modelica.Constants.pi
            "Azimuth angle of face C";
          final parameter Modelica.SIunits.Angle aziD = aziA + 3*Modelica.Constants.pi/2
            "Azimuth angle of face D";

          IDEAS.Buildings.Components.Interfaces.ZoneBus[nSurfExt] proBusExt(
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if nSurfExt>0
            "Propsbus for connecting additional external surfaces" annotation (
              Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-210,50}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=180,
                origin={-120,100})));

      protected
          constant Real r = 287 "Gas constant";
        final parameter Integer nGainEmb = conTypFlo.nGain "Number of planes in which CCA or FH pipes are located"
            annotation(Dialog(tab="Floor", group="Floor heating / CCA"));
          IDEAS.Buildings.Components.BoundaryWall bouA(azi=aziA, inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypA.locGain,
              incLastLay=conTypA.incLastLay,
              mats=conTypA.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=AWallANet) if
               hasBouA
            "Boundary wall for face A of this zone"
            annotation (Placement(transformation(extent={{-120,0},{-110,20}})));
          IDEAS.Buildings.Components.BoundaryWall bouB(
                   inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypB.locGain,
              incLastLay=conTypB.incLastLay,
              mats=conTypB.mats),
            azi=aziB,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=AWallBNet) if
               hasBouB
            "Boundary wall for face A of this zone"
            annotation (Placement(transformation(extent={{-120,-20},{-110,0}})));
          IDEAS.Buildings.Components.BoundaryWall bouC(inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypC.locGain,
              incLastLay=conTypC.incLastLay,
              mats=conTypC.mats),
            azi=aziC,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=AWallCNet) if
               hasBouC
            "Boundary wall for face C of this zone"
            annotation (Placement(transformation(extent={{-120,-40},{-110,-20}})));
          IDEAS.Buildings.Components.BoundaryWall bouD(inc=IDEAS.Types.Tilt.Wall, azi=aziD,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypD.locGain,
              incLastLay=conTypD.incLastLay,
              mats=conTypD.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=AWallDNet) if
               hasBouD
            "Boundary wall for face D of this zone"
            annotation (Placement(transformation(extent={{-120,-60},{-110,-40}})));
          IDEAS.Buildings.Components.BoundaryWall bouFlo(inc=IDEAS.Types.Tilt.Floor, azi=aziA,
            A=A,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypFlo.locGain,
              incLastLay=conTypFlo.incLastLay,
              mats=conTypFlo.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou) if
               hasBouFlo
            "Boundary wall for zone floor"
            annotation (Placement(transformation(extent={{-120,-80},{-110,-60}})));
          IDEAS.Buildings.Components.BoundaryWall bouCei(inc=IDEAS.Types.Tilt.Ceiling, azi=aziA,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypCei.locGain,
              incLastLay=conTypCei.incLastLay,
              mats=conTypCei.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=ACeiNet) if
               hasBouCei
            "Boundary wall for zone ceiling"
            annotation (Placement(transformation(extent={{-120,-100},{-110,-80}})));
          IDEAS.Buildings.Components.OuterWall outA(azi=aziA, inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypA.locGain,
              incLastLay=conTypA.incLastLay,
              mats=conTypA.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,AWallANet),
            final hWal=h,
            final hasBuildingShade=hasBuildingShadeA,
            final L=LShaA,
            final dh=dhShaA) if
               hasOutA
            "Outer wall for face A of this zone"
            annotation (Placement(transformation(extent={{-140,0},{-130,20}})));
          IDEAS.Buildings.Components.OuterWall outB(
              inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypB.locGain,
              incLastLay=conTypB.incLastLay,
              mats=conTypB.mats),
            azi=aziB,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,AWallBNet),
            final hasBuildingShade=hasBuildingShadeB,
            final L=LShaB,
            final dh=dhShaB,
            final hWal=h) if
               hasOutB
            "Outer wall for face B of this zone"
            annotation (Placement(transformation(extent={{-140,-20},{-130,0}})));
          IDEAS.Buildings.Components.OuterWall outC(inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypC.locGain,
              incLastLay=conTypC.incLastLay,
              mats=conTypC.mats),
            azi=aziC,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,AWallCNet),
            final hasBuildingShade=hasBuildingShadeC,
            final L=LShaC,
            final dh=dhShaC,
            final hWal=h) if
               hasOutC
            "Outer wall for face C of this zone"
            annotation (Placement(transformation(extent={{-140,-40},{-130,-20}})));
          IDEAS.Buildings.Components.OuterWall outD(inc=IDEAS.Types.Tilt.Wall, azi=aziD,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypD.locGain,
              incLastLay=conTypD.incLastLay,
              mats=conTypD.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,AWallDNet),
            final hasBuildingShade=hasBuildingShadeD,
            final L=LShaD,
            final dh=dhShaD,
            final hWal=h) if
               hasOutD
            "Outer wall for face D of this zone"
            annotation (Placement(transformation(extent={{-140,-60},{-130,-40}})));
          IDEAS.Buildings.Components.OuterWall outCei(
            inc=IDEAS.Types.Tilt.Ceiling,
            azi=aziA,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypCei.locGain,
              incLastLay=conTypCei.incLastLay,
              mats=conTypCei.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,ACeiNet)) if
               hasOutCei
            "Outer wall for zone ceiling"
            annotation (Placement(transformation(extent={{-140,-100},{-130,-80}})));
          IDEAS.Buildings.Components.SlabOnGround slaOnGro(
            inc=IDEAS.Types.Tilt.Floor,
            azi=aziA,
            A=A,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypFlo.locGain,
              incLastLay=conTypFlo.incLastLay,
              mats=conTypFlo.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            TeAvg=TeAvg,
            TiAvg=TiAvg,
            dTeAvg=dTeAvg,
            dTiAvg=dTiAvg,
            dT_nominal_a=dT_nominal_sla,
            PWall=PWall) if
             bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround
            "Slab on ground model for zone floor."
            annotation (Placement(transformation(extent={{-160,-80},{-150,-60}})));
          IDEAS.Buildings.Components.InternalWall intA(azi=aziA, inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypA.locGain,
              mats=conTypA.mats,
              incLastLay=conTypA.incLastLay),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB,
            hasCavity=hasCavityA,
            h=hA,
            w=wA,
            g=g,
            p=p,
            rho=rho,
            c_p=c_p,
            T=T,
            dT=dT,
            A=lA*h - (if hasCavityA then hA*wA else 0)) if
            hasIntA
            "Internal wall for face A of this zone"
            annotation (Placement(transformation(extent={{-176,0},{-164,20}})));
          IDEAS.Buildings.Components.InternalWall intB(
                   inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypB.locGain,
              incLastLay=conTypB.incLastLay,
              mats=conTypB.mats),
            azi=aziB,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB,
            g=g,
            p=p,
            rho=rho,
            c_p=c_p,
            T=T,
            dT=dT,
            hasCavity=hasCavityB,
            h=hB,
            w=wB,
            A=lB*h - (if hasCavityB then hB*wB else 0)) if
            hasIntB
            "Internal wall for face B of this zone"
            annotation (Placement(transformation(extent={{-176,-20},{-164,0}})));
          IDEAS.Buildings.Components.InternalWall intC(inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypC.locGain,
              incLastLay=conTypC.incLastLay,
              mats=conTypC.mats),
            azi=aziC,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB,
            g=g,
            p=p,
            rho=rho,
            c_p=c_p,
            T=T,
            dT=dT,
            hasCavity=hasCavityC,
            h=hC,
            w=wC,
            A=lC*h - (if hasCavityC then hC*wC else 0)) if
            hasIntC
            "Internal wall for face C of this zone"
            annotation (Placement(transformation(extent={{-176,-40},{-164,-20}})));
          IDEAS.Buildings.Components.InternalWall intD(inc=IDEAS.Types.Tilt.Wall, azi=aziD,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypD.locGain,
              incLastLay=conTypD.incLastLay,
              mats=conTypD.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB,
            g=g,
            p=p,
            rho=rho,
            c_p=c_p,
            T=T,
            dT=dT,
            hasCavity=hasCavityD,
            h=hD,
            w=wD,
            A=lD*h - (if hasCavityD then hD*wD else 0)) if
            hasIntD
            "Internal wall for face D of this zone"
            annotation (Placement(transformation(extent={{-176,-60},{-164,-40}})));
          IDEAS.Buildings.Components.InternalWall intFlo(
            inc=IDEAS.Types.Tilt.Floor,
            azi=aziA,
            A=A,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypFlo.locGain,
              incLastLay=conTypFlo.incLastLay,
              mats=conTypFlo.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB) if
            hasIntFlo
            "Internal wall for zone floor"
            annotation (Placement(transformation(extent={{-176,-80},{-164,-60}})));

          IDEAS.Buildings.Components.InternalWall int(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypInt.locGain,
              mats=conTypInt.mats,
              incLastLay=conTypInt.incLastLay),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intA,
            azi=0,
            A=lInt*h,
            final hasCavity=false) if
            hasInt "Internal wall contained within the zone"
            annotation (Placement(transformation(extent={{-176,20},{-164,40}})));
      public
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusA[nExtA](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of face A"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,10}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=180,
                origin={-60,90})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusB[nExtB](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of face B"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-10}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=90,
                origin={90,60})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusC[nExtC](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of face C"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-30}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=0,
                origin={68,-98})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusD[nExtD](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of face D"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-50}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-96,-70})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusFlo[nExtFlo](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of floor"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-70}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=180,
                origin={0,-60})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusCei[nExtCei](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface of ceiling: internal walls should be modelled as the floor of the zone above"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-90}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=180,
                origin={-2,60})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b gainEmb[nGainEmb] if
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall or
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround
            "Floor node for embedded heat gain if case of floor heating or CCA."
            annotation (Placement(transformation(extent={{90,-100},{110,-80}})));
      protected
          final parameter Boolean hasBouA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouFlo=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouCei=
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasOutA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasOutB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasOutC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasOutD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasOutCei=
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasIntA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasIntB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasIntC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasIntD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasIntFlo=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasExtA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtFlo=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtCei=
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasNoA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoFlo=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoCei=
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;

          parameter Modelica.SIunits.Area AWallANet(fixed=false);
          parameter Modelica.SIunits.Area AWallBNet(fixed=false);
          parameter Modelica.SIunits.Area AWallCNet(fixed=false);
          parameter Modelica.SIunits.Area AWallDNet(fixed=false);
          parameter Modelica.SIunits.Area ACeiNet(fixed=false);

          final parameter Integer indWalA = if hasNoA then 0 else 1;
          final parameter Integer indWalA_end = indWalA + (if bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtA - 1  else 0);
          final parameter Integer indWalB = indWalA_end + (if hasNoB then 0 else 1);
          final parameter Integer indWalB_end = indWalB+ (if bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtB - 1  else 0);
          final parameter Integer indWalC = indWalB_end  + (if hasNoC then 0 else 1);
          final parameter Integer indWalC_end = indWalC + (if bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtC - 1  else 0);
          final parameter Integer indWalD = indWalC_end  + (if hasNoD then 0 else 1);
          final parameter Integer indWalD_end = indWalD + (if bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtD - 1  else 0);
          final parameter Integer indFlo = indWalD_end + (if hasNoFlo then 0 else 1);
          final parameter Integer indFlo_end = indFlo + (if bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtFlo - 1  else 0);
          final parameter Integer indCei = indFlo_end  + (if hasNoCei then 0 else 1);
          final parameter Integer indCei_end = indCei + (if bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtCei - 1  else 0);
          final parameter Integer indIntZone_a = indCei_end + (if hasInt then 1 else 0);
          final parameter Integer indIntZone_b = indIntZone_a + (if hasInt then 1 else 0);
          final parameter Integer indWinA = indIntZone_b + (if hasWinA then 1 else 0);
          final parameter Integer indWinB = indWinA + (if hasWinB then 1 else 0);
          final parameter Integer indWinC = indWinB + (if hasWinC then 1 else 0);
          final parameter Integer indWinD = indWinC + (if hasWinD then 1 else 0);
          final parameter Integer indWinCei = indWinD + (if hasWinCei then 1 else 0);

        initial equation
          assert(not bouTypA==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypA is not supported");
          assert(not bouTypB==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypB is not supported");
          assert(not bouTypC==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypC is not supported");
          assert(not bouTypD==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypD is not supported");
          assert(not bouTypCei==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypCei is not supported");
          assert(not (bouTypCei==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
                      "Using internal walls for the ceiling is not allowed because it is considered bad practice. 
              Use instead the 'External'  connection to connect the the floor of the surface above, 
              or use this option to connect and internal wall externally.");
          assert(not (hasWinA and bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");
          assert(not (hasWinB and bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");
          assert(not (hasWinC and bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");
          assert(not (hasWinD and bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");
          assert(not (hasWinCei and bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");

          //assert that the cavity is not larger than the wall
          assert(not hasCavityA or (hA <= h and wA <=lA),
            "In " + getInstanceName() + ": The cavity dimensions of surface A exceed the zone dimensions. This is non-physical");
          assert(not hasCavityB or (hB <= h and wB <=lB),
            "In " + getInstanceName() + ": The cavity dimensions of surface B exceed the zone dimensions. This is non-physical");
          assert(not hasCavityC or (hC <= h and wC <=lC),
            "In " + getInstanceName() + ": The cavity dimensions of surface C exceed the zone dimensions. This is non-physical");
          assert(not hasCavityD or (hD <= h and wD <=lD),
            "In " + getInstanceName() + ": The cavity dimensions of surface D exceed the zone dimensions. This is non-physical");

          AWallANet = lA*h - (if hasWinA then  propsBusInt[indWinA].area else 0);
          AWallBNet = lB*h - (if hasWinB then  propsBusInt[indWinB].area else 0);
          AWallCNet = lC*h - (if hasWinC then  propsBusInt[indWinC].area else 0);
          AWallDNet = lD*h - (if hasWinD then  propsBusInt[indWinD].area else 0);
          ACeiNet = ACei - (if hasWinCei then  propsBusInt[indWinCei].area else 0);

          // assert that the windows are not bigger than the wall
          assert(AWallANet >= 0, "The net surface area of wall A is negative. This is not allowed.");
          assert(AWallBNet >= 0, "The net surface area of wall B is negative. This is not allowed.");
          assert(AWallDNet >= 0, "The net surface area of wall C is negative. This is not allowed.");
          assert(AWallDNet >= 0, "The net surface area of wall D is negative. This is not allowed.");
          assert(ACeiNet >= 0, "The net surface area of the ceiling is negative. This is not allowed.");

          if hasIntA then
            assert(nExtA == 1, "The parameter nExtA should be = 1 when internalWall type is chosen for surface A");
          end if;
          if hasIntB then
            assert(nExtB == 1, "The parameter nExtB should be = 1 when internalWall type is chosen for surface B");
          end if;
          if hasIntC then
            assert(nExtC == 1, "The parameter nExtC should be = 1 when internalWall type is chosen for surface C");
          end if;
          if hasIntD then
            assert(nExtD == 1, "The parameter nExtD should be = 1 when internalWall type is chosen for surface D");
          end if;
          if hasIntFlo then
            assert(nExtFlo == 1, "The parameter nExtFlo should be = 1 when internalWall type is chosen for Floor");
          end if;

          if hasWinCei then
            // note that w*l is the default value of ACei
            assert(abs(ACei-w*l) < 1e-6, "The overwrite parameter ACei should not be used when the roof has a window
                                  since then the window surface area cannot be factored in correctly.");
          end if;
        equation
          connect(intA.propsBus_a, propsBusInt[indWalA]) annotation (Line(
              points={{-165,12},{-152,12},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intB.propsBus_a, propsBusInt[indWalB]) annotation (Line(
              points={{-165,-8},{-152,-8},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intC.propsBus_a, propsBusInt[indWalC]) annotation (Line(
              points={{-165,-28},{-152,-28},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intD.propsBus_a, propsBusInt[indWalD]) annotation (Line(
              points={{-165,-48},{-152,-48},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intFlo.propsBus_a, propsBusInt[indFlo]) annotation (Line(
              points={{-165,-68},{-152,-68},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(int.propsBus_a, propsBusInt[indIntZone_a]) annotation (Line(
              points={{-165,32},{-80,32},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(int.propsBus_b, propsBusInt[indIntZone_b]) annotation (Line(
              points={{-175,32},{-180,32},{-180,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outA.propsBus_a, propsBusInt[indWalA]) annotation (Line(
              points={{-130.833,12},{-130.833,12},{-124,12},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outB.propsBus_a, propsBusInt[indWalB]) annotation (Line(
              points={{-130.833,-8},{-124,-8},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outC.propsBus_a, propsBusInt[indWalC]) annotation (Line(
              points={{-130.833,-28},{-124,-28},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outD.propsBus_a, propsBusInt[indWalD]) annotation (Line(
              points={{-130.833,-48},{-124,-48},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(slaOnGro.propsBus_a, propsBusInt[indFlo]) annotation (Line(
              points={{-150.833,-68},{-150.833,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outCei.propsBus_a, propsBusInt[indCei]) annotation (Line(
              points={{-130.833,-88},{-124,-88},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouA.propsBus_a, propsBusInt[indWalA]) annotation (Line(
              points={{-110.833,12},{-110.833,12},{-106,12},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouB.propsBus_a, propsBusInt[indWalB]) annotation (Line(
              points={{-110.833,-8},{-106,-8},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouC.propsBus_a, propsBusInt[indWalC]) annotation (Line(
              points={{-110.833,-28},{-106,-28},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouD.propsBus_a, propsBusInt[indWalD]) annotation (Line(
              points={{-110.833,-48},{-106,-48},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouFlo.propsBus_a, propsBusInt[indFlo]) annotation (Line(
              points={{-110.833,-68},{-106,-68},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouCei.propsBus_a, propsBusInt[indCei]) annotation (Line(
              points={{-110.833,-88},{-106,-88},{-106,-76},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intA.propsBus_b, proBusA[1]) annotation (Line(
              points={{-175,12},{-188,12},{-188,10}},
              color={255,204,51},
              thickness=0.5));
          connect(intB.propsBus_b, proBusB[1]) annotation (Line(
              points={{-175,-8},{-188,-8},{-188,-10}},
              color={255,204,51},
              thickness=0.5));
          connect(intC.propsBus_b, proBusC[1]) annotation (Line(
              points={{-175,-28},{-188,-28},{-188,-30}},
              color={255,204,51},
              thickness=0.5));
          connect(intD.propsBus_b, proBusD[1]) annotation (Line(
              points={{-175,-48},{-188,-48},{-188,-50}},
              color={255,204,51},
              thickness=0.5));
          connect(intFlo.propsBus_b, proBusFlo[1]) annotation (Line(
              points={{-175,-68},{-188,-68},{-188,-70}},
              color={255,204,51},
              thickness=0.5));
          if hasExtA then
            for i in indWalA:indWalA_end loop
            connect(proBusA[i-indWalA+1], propsBusInt[i]) annotation (Line(
              points={{-188,10},{-188,10},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtB then
            for i in indWalB:indWalB_end loop
            connect(proBusB[i-indWalB+1], propsBusInt[i]) annotation (Line(
              points={{-188,-10},{-188,-10},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtC then
            for i in indWalC:indWalC_end loop
            connect(proBusC[i-indWalC+1], propsBusInt[i]) annotation (Line(
              points={{-188,-30},{-188,-30},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtD then
            for i in indWalD:indWalD_end loop
            connect(proBusD[i-indWalD+1], propsBusInt[i]) annotation (Line(
              points={{-188,-50},{-188,-50},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtFlo then
            for i in indFlo:indFlo_end loop
            connect(proBusFlo[i-indFlo+1], propsBusInt[i]) annotation (Line(
              points={{-188,-70},{-188,-70},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtCei then
            for i in indCei:indCei_end loop
            connect(proBusCei[i-indCei+1], propsBusInt[i]) annotation (Line(
              points={{-188,-90},{-188,-90},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;

          connect(propsBusInt[(indWinCei+1):(indWinCei+nSurfExt)], proBusExt[1:nSurfExt]) annotation (Line(
              points={{-80,40},{-82,40},{-82,54},{-82,50},{-210,50}},
              color={255,204,51},
              thickness=0.5));
          connect(intFlo.port_emb, gainEmb) annotation (Line(points={{-170,-80},{-170,-104},
                  {100,-104},{100,-90}}, color={191,0,0}));
          connect(bouFlo.port_emb, gainEmb) annotation (Line(points={{-115,-80},{-88,-80},
                  {-88,-104},{100,-104},{100,-90}}, color={191,0,0}));
          connect(slaOnGro.port_emb, gainEmb) annotation (Line(points={{-155,-80},{-156,
                  -80},{-156,-104},{100,-104},{100,-90}}, color={191,0,0}));
            annotation(Dialog(tab="Floor", group="Floor heating / CCA", enable=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall),
                          Icon(coordinateSystem(preserveAspectRatio=false, initialScale=0.1),
                graphics={
                Text(
                  extent={{-60,-72},{-30,-38}},
                  lineColor={28,108,200},
                  textString="Flo"),
                Text(
                  extent={{120,-14},{140,20}},
                  lineColor={28,108,200},
                  textString="B"),
                Text(
                  extent={{-10,-122},{10,-94}},
                  lineColor={28,108,200},
                  textString="C"),
                Text(
                  extent={{-122,-14},{-102,20}},
                  lineColor={28,108,200},
                  textString="D"),
                Text(
                  extent={{18,44},{46,80}},
                  lineColor={28,108,200},
                  textString="Cei"),
                Text(
                  extent={{-10,114},{10,148}},
                  lineColor={28,108,200},
                  textString="A")}),                                     Diagram(
                coordinateSystem(preserveAspectRatio=false, extent={{-220,-100},{100,100}}),
                            graphics={
                Text(
                  extent={{-220,-60},{-200,-80}},
                  lineColor={28,108,200},
                  textString="Floor"),
                Text(
                  extent={{-220,-80},{-200,-100}},
                  lineColor={28,108,200},
                  textString="Ceiling"),
                Text(
                  extent={{-220,-40},{-200,-60}},
                  lineColor={28,108,200},
                  textString="D"),
                Text(
                  extent={{-220,-20},{-200,-40}},
                  lineColor={28,108,200},
                  textString="C"),
                Text(
                  extent={{-220,0},{-200,-20}},
                  lineColor={28,108,200},
                  textString="B"),
                Text(
                  extent={{-220,20},{-200,0}},
                  lineColor={28,108,200},
                  textString="A")}),
            Documentation(info="<html>
<p>
This model can be used to set up
zones with a rectangular geometry more quickly.
This template consists of a zone, four walls, a horizontal roof and a floor
and five optional windows.
Additional surfaces may also be connected through external bus connector.
For the documentation of the zone parameters, see the documentation of 
<a href=\"modelica://IDEAS.Buildings.Components.Zone\">Zone</a>.
</p>
<h4>Main equations</h4>
<p>
This model incorporates IDEAS components such as
<a href=modelica://IDEAS.Buildings.Components.OuterWall>
IDEAS.Buildings.Components.OuterWall</a> and reproduces
the same results as a model that would be constructed without 
the use of this template.
</p>
<h4>Assumption and limitations</h4>
<p>
This model assumes that the zone has a rectangular
geometry with width <code>w</code>, length <code>l</code>
and height <code>h</code>.
All walls are vertical and perpendicular to each other and both the roof and
the floor are horizontal.
</p>
<p>
The surface area of each wall is calculated by default using
the parameters <code>h, w</code> and <code>l</code>. If you want to split a wall
and add external walls using the external bus connector, use the overwrite
length parameters <code>lA, lB, lC, lD</code> from the <code>Face</code> tabs
such that the surface area of the wall is correct. Also the ceiling or roof
surface area can be overwritten using the parameter <code>ACei</code>
from the <code>Ceiling</code> tab.
This way the user can overwrite the default ceiling surface area, 
e.g. to better approximate an inclinated roof.
Be also aware that the model
<code>slabOnGround</code> has a parameter <code>PWall</code> which specifies the
perimeter of slab on ground. The model cannot detect external walls connected
using the external bus connector. When splitting outer walls by using the external bus connector
you should update this parameter
manually using the parameter <code>PWall</code> from the <code>Advanced</code> tab.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameters width <code>w</code>, length <code>l</code>
and height <code>h</code> need to be defined
and are used to compute the dimensions of each of the surfaces.
Parameter <code>aziA</code> represents the azimuth angle
of surface A (see icon). Other surfaces are rotated (clockwise) by multiples
of ninety degrees with respect to <code>aziA</code>.
Parameter <code>nSurfExt</code> may be used
to connect additional surfaces to the template. 
When doing this, you may need to change the surface areas of
the surfaces in the template as these are not updated automatically.
</p>
<p>
Seven parameter tabs allow to specify further parameters
that are specific for each of the seven surfaces: six surfaces 
for the walls, floor and ceiling and one for an internal wall 
contained within the zone.
For each surface the surface type may be specified
using parameters <code>bouTyp*</code>.
The construction type should be defined
using <code>conTyp*</code>.
Parameter <code>hasWin*</code> may be used
for all orientations except for the floor to add
a window.
In this case the window surface area, shading and glazing 
types need to be provided.
For non-default shading a record needs to be created that specifies
the shading properties.
The surface area of the window is deducted from the surface area
of the wall such that the total surface areas add up.
</p>
<p>
The zone template also has a heat port for embedded heat gains
in the floor. This can be used when the floor has a floor heating
system or a concrete core activation system. Set then 
<code>hasEmb</code> from the tab Floor to <code>true</code> 
to get the <code>gaiEmb</code> heat port on the zone template.
Notice that the zone template does not have a heat port for embedded
gains in the ceiling. To model concrete core activation in the ceiling,
use an external surface.
</p>
<h4>Options</h4>
<p>
Advanced options are found under the <code>Advanced</code> 
parameter tab. 
The model may also be adapted further by
overriding the default parameter assignments in the template.
</p>
<p>
You can also use this model for non-rectangular zones by, for example,
using the <code>None</code> type for a wall and by adding additional walls
corresponding to a different geometry through
the external bus connector. 
This model however then does not guarantee that all parameters are consistent.
Therefore, some internal parameters of this model will need to be
updated manually.
</p>
<p>
In the parameter group <code>Windows</code>, you can redeclare the window. 
This is useful when using a window model that has a pre-configured surface area,
glazing type, frame fraction and shading. 
The parameters 
<code>azi=aziA</code>,
<code>inc=IDEAS.Types.Tilt.Wall</code>,
<code>T_start=T_start</code>,
<code>linIntCon_a=linIntCon</code>,
<code>dT_nominal_a=dT_nominal_win</code>,
<code>linExtCon=linExtCon</code>,
<code>windowDynamicsType=windowDynamicsType</code>,
<code>linExtRad=linExtRadWin</code>,
<code>nWin=nWinA</code>,
are still computed from the zone model parameters but, the
other windows parameters are those configured in the
used window model, including the window surface area.
</p>
<h4>Dynamics</h4>
<p>
This model contains wall dynamics
and a state for the zone air temperature.
The zone temperature may be set to steady state using
parameter <code>energyDynamicsAir</code>, which should
in general not be done.
The mass dynamics of the air volume
may be set to steady state by overriding the default parameter
assignment in the <code>airModel</code> submodel.
This removes small time constants
when the zone model is connected to an air flow circuit. 
</p>
<h4>Shading</h4>
<p>
In order to choose the shading of the glazing,
instead of selecting one shading type from the
dropdown menu, click on the
button right of the dropdown menu (edit). 
A menu will appear where the type of 
shading and corresponding parameters
have to be defined.
Alternatively, the shading template can be extended.
</p>
<h4>Validation</h4>
<p>
This implementation is compared with a manual implementation
in <a href=modelica://IDEAS.Buildings.Validation.Tests.ZoneTemplateVerification2>
IDEAS.Buildings.Validation.Tests.ZoneTemplateVerification2</a>.
This gives identical results.
</p>
<h4>Example</h4>
<p>
An example of how this template may be used
can be found in 
<a href=modelica://IDEAS.Examples.PPD12>IDEAS.Examples.PPD12</a>.
</p>
<h4>Implementation</h4>
<p>
Shading types need to be declared using a record instead of
by redeclaring the shading components.
This is a workaround because redeclared 
components cannot be propagated.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 10, 2019, by Filip Jorissen:<br/>
Removed obsolete redeclaration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1009\">#1009</a>.
</li>
<li>
August 29, 2018, by Damien Picard:<br/>
Add embedded heat port for floor heating or CCA.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/903\">#903</a>.
</li>
<li>
August 28, 2018, by Damien Picard:<br/>
Changes to allow multiple external surfaces connection per faces.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/901\">#901</a>.
</li>
<li>
August 26, 2018, by Damien Picard:<br/>
Move all equations except windows equations of
RectangularZoneTemplate to this interface model.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/891\">#891</a>.
</li>
<li>
August 16, 2018, by Damien Picard:<br/>
Make windows replaceable.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/891\">#891</a>.
And correct wall surface computation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/890\">#890</a>. 
</li>
<li>
August 10, 2018, by Damien Picard:<br/>
Added parameters for scaling factors for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">#888</a>.
</li>
<li>
Adapted model to make it possible to remove walls from the template.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/880\">#880</a>.
</li>
<li>
June 13, 2018, by Filip Jorissen:<br/>
Added parameters for shade cast by external building.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/576\">#576</a>.
</li>
<li>
May 21, 2018, by Filip Jorissen:<br/>
Added parameters for air flow through cavity.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/822\">#822</a>.
</li>
<li>
April 30, 2018 by Iago Cupeiro:<br/>
Propagated boolean input connections for controlled shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/809\">#809</a>.
Shading documentation added.
</li>
<li>
July 26, 2017 by Filip Jorissen:<br/>
Added replaceable block that allows to define
the number of occupants.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
April 26, 2017, by Filip Jorissen:<br/>
Added asserts that check for illegal combinations of internal wall with exterior window.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/714>#714</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed bus parameters for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
Also removed obsolete each.
</li>
<li>
January 20, 2017 by Filip Jorissen:<br/>
Removed propagation of <code>nLay</code> and <code>nGain</code>
since this lead to warnings.
</li>
<li>
January 11, 2017 by Filip Jorissen:<br/>
Added documentation
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Added <code>linExtRadWin</code> for windows.
</li>
<li>
November 14, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
        end RectangularZoneTemplateInterface;

        connector SolBus
          "Bus containing solar radiation for various incidence angles"
          extends Modelica.Icons.SignalBus;
          parameter Boolean outputAngles = true "Set to false when linearising in Dymola only";
          IDEAS.Buildings.Components.Interfaces.RealConnector HDirTil(unit="W/(m2)",start=100) annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector HSkyDifTil(unit="W/(m2)",start=100) annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector HGroDifTil(unit="W/(m2)",start=100) annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector angInc(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg",
            start=1) if outputAngles;
          IDEAS.Buildings.Components.Interfaces.RealConnector angZen(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg",
            start=1) if outputAngles;
          IDEAS.Buildings.Components.Interfaces.RealConnector angAzi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg",
            start=1) if outputAngles;
          IDEAS.Buildings.Components.Interfaces.RealConnector Tenv(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 0.0,
            start = 293.15,
            nominal = 300,
            displayUnit="degC") "Equivalent radiant temperature" annotation ();
          annotation (Documentation(info="<html>
<p>
Connector that contains all solar irridiation information for one inclination and tilt angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2018, by Damien Picard:<br/>
Add start value for linearisation.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed Reals into connectors for JModelica compatibility.
Other compatibility changes. 
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end SolBus;

        connector WeaBus "Data bus that stores weather data"
          extends Modelica.Icons.SignalBus;
          parameter Integer numSolBus;
          parameter Boolean outputAngles = true "Set to false when linearising in Dymola only";
          IDEAS.Buildings.Components.Interfaces.RealConnector solTim(
            final unit="s",
            final quantity="Time",
            start=1) "Solar time";
          IDEAS.Buildings.Components.Interfaces.SolBus[numSolBus] solBus(each outputAngles=outputAngles) annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector Te(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 0.0,
            start = 293.15,
            nominal = 300,
            displayUnit="degC") "Ambient sensible temperature" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector Tdes(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 0.0,
            start = -8 + 273.15,
            nominal = 300,
            displayUnit="degC") "Design temperature?" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector TGroundDes(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 0.0,
            start = 283.15,
            nominal = 300,
            displayUnit="degC")
            "Design ground temperature" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector hConExt(unit="W/(m2.K)", start = 18.3) "Exterior convective heat transfer coefficient" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector X_wEnv(start=0.01) "Environment air water mass fraction"
                                        annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector CEnv(start=1e-6) "Environment air trace substance mass fraction"
                                        annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector dummy(start=1)
            "Dummy variable of value 1 to include constant term in linearization (see SlabOnGround)"
            annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector TskyPow4(start=273^4),TePow4(start=273^4), solGloHor(start=100), solDifHor(start=100), F1(start=0.1), F2(start=-0.1), angZen(start=1), angHou(start=1), angDec(start=1), solDirPer(start=1), phi(start=1);
          annotation (
            defaultComponentName="weaBus",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-20,2},{22,-2}},
                  lineColor={255,204,51},
                  lineThickness=0.5)}),
            Diagram(graphics,
                    coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}})),
            Documentation(info="<html>
<p>
Connector that contains all environment information for many inclinations and tilt angles.
</p>
</html>",  revisions="<html>
<ul>
<li>
March 27, 2018, by Filip Jorissen:<br/>
Added relative humidity to weather bus.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/780>#780</a>
</li>
<li>
January 25, 2018 by Filip Jorissen:<br/>
Added <code>solTim</code> connections for revised azimuth computations.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed Reals into connectors for JModelica compatibility.
Other compatibility changes. 
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end WeaBus;

        connector WindowBus
          "Bus containing inputs/outputs for linear window model"
          extends Modelica.Icons.SignalBus;
          parameter Integer nLay = 3 "Number of window layers";
          RealConnector[nLay] AbsQFlow(start=fill(100,nLay)) annotation ();
          RealConnector iSolDir(start=100) annotation ();
          RealConnector iSolDif(start=100) annotation ();
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
March, 2015 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",         info="<html>
<p>
Specialized connector
</p>
</html>"));
        end WindowBus;

        type WindowDynamicsType = enumeration(
          Two   "One state for the glazing and one for the frame",
          Normal   "States in each glass sheet and one state for the frame") "Type of dynamics that are used for window models" annotation (
            Documentation(revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>",         info="<html>
<p>
Type variable for defining how many states should be used to represent the window dynamics.
Zero, one or two states may be used to represent the dynamics of the frame and glazing of a window.
Fewer states are used than for opaque surfaces since the time constants of glazing are relatively fast,
which may slow down simulations. 
Therefore the dynamics are lumped into one or two states.
</p>
</html>"));

        connector ZoneBus
          extends Modelica.Icons.SignalBus;
          parameter Integer numIncAndAziInBus
            "Number of calculated azimuth angles, set to sim.numIncAndAziInBus";
          parameter Boolean outputAngles = true "Set to false when linearising in Dymola only";
          IDEAS.Buildings.Components.Interfaces.RealConnector QTra_design(
            final quantity="Power",
            final unit="W") annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector area(
            final quantity="Area",
            final unit="m2") annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector epsLw(
            final quantity="Emissivity",
            final unit="1") annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector epsSw(
            final quantity="Emissivity",
            final unit="1") annotation ();
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a surfCon annotation ();
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b surfRad annotation ();
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDir annotation ();
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b iSolDif annotation ();
          IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(numSolBus=numIncAndAziInBus, outputAngles=outputAngles)
            annotation(HideResult=true);
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b Qgai
            "Heat gains in model" annotation ();
          IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.EnergyPort E
            "Internal energy in model" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector inc(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector azi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") annotation ();
          annotation (Documentation(info="<html>
<p>
Connector that contains a weather bus and further
contains variables and connectors for exchanging 
heat and information between a zone and a surface.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed Reals into connectors for JModelica compatibility.
Other compatibility changes. 
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end ZoneBus;

        model ZoneBusVarMultiplicator "Component to scale all flows from the zone propsBus. This can be used to scale the surface to n identical surfaces"
          parameter Real k = 1 "Scaling factor";
          ZoneBus propsBus_a(
            numIncAndAziInBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
            "Unscaled port"                                                         annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-100,0})));
          ZoneBus propsBus_b(
            numIncAndAziInBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
            "Scaled port"                                                           annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={100,0})));
          outer BoundaryConditions.SimInfoManager       sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{72,122},{92,142}})));
      protected
          Modelica.Blocks.Math.Gain QTra_desgin(k=k) "Design heat flow rate"
            annotation (Placement(transformation(extent={{-10,178},{10,198}})));
          Modelica.Blocks.Math.Gain area(k=k) "Heat exchange surface area"
            annotation (Placement(transformation(extent={{-10,150},{10,170}})));
          BaseClasses.Varia.HeatFlowMultiplicator surfCon(k=k)
            "Block for scaling convective heat transfer"
            annotation (Placement(transformation(extent={{-10,62},{10,82}})));
          BaseClasses.Varia.HeatFlowMultiplicator surfRad(k=k)
            "Block for scaling radiative heat transfer"
            annotation (Placement(transformation(extent={{-10,34},{10,54}})));
          BaseClasses.Varia.HeatFlowMultiplicator iSolDir(k=k)
            "Block for scaling direct solar irradiation"
            annotation (Placement(transformation(extent={{-10,2},{10,22}})));
          BaseClasses.Varia.HeatFlowMultiplicator iSolDif(k=k)
            "Black for scaling diffuse solar irradiation"
            annotation (Placement(transformation(extent={{-10,-26},{10,-6}})));
          BaseClasses.Varia.HeatFlowMultiplicator QGai(k=k)
            "Block for scaling internal gains"
            annotation (Placement(transformation(extent={{-10,-86},{10,-66}})));
          BaseClasses.Varia.EnergyFlowMultiplicator E(k=k)
            "Block for scaling internal energy"
            annotation (Placement(transformation(extent={{-10,-116},{10,-96}})));
          WeaBus weaBus(numSolBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-48})));
          Modelica.Blocks.Routing.RealPassThrough inc "Inclination angle"
            annotation (Placement(transformation(extent={{-10,-148},{10,-128}})));
          Modelica.Blocks.Routing.RealPassThrough azi "Azimuth angle"
            annotation (Placement(transformation(extent={{-10,-178},{10,-158}})));
          Modelica.Blocks.Routing.RealPassThrough epsLw "Longwave emissivity"
            annotation (Placement(transformation(extent={{-10,118},{10,138}})));
          Modelica.Blocks.Routing.RealPassThrough epsSw "Shortwave emissivity"
            annotation (Placement(transformation(extent={{-10,88},{10,108}})));
        equation
          connect(QTra_desgin.u, propsBus_a.QTra_design) annotation (Line(points={{-12,188},
                  {-100.1,188},{-100.1,0.1}},         color={0,0,127}));
          connect(QTra_desgin.y, propsBus_b.QTra_design) annotation (Line(points={{11,188},
                  {100.1,188},{100.1,-0.1}},color={0,0,127}));
          connect(area.u, propsBus_a.area) annotation (Line(points={{-12,160},{-100.1,
                  160},{-100.1,0.1}},color={0,0,127}));
          connect(area.y, propsBus_b.area) annotation (Line(points={{11,160},{100.1,160},
                  {100.1,-0.1}},     color={0,0,127}));
          connect(surfCon.port_a, propsBus_a.surfCon) annotation (Line(points={{-10,72},
                  {-100.1,72},{-100.1,0.1}},          color={191,0,0}));
          connect(surfRad.port_a, propsBus_a.surfRad) annotation (Line(points={{-10,44},
                  {-100.1,44},{-100.1,0.1}},          color={191,0,0}));
          connect(iSolDif.port_a, propsBus_a.iSolDif) annotation (Line(points={{-10,-16},
                  {-100.1,-16},{-100.1,0.1}},
                                           color={191,0,0}));
          connect(iSolDir.port_a, propsBus_a.iSolDir) annotation (Line(points={{-10,12},
                  {-100.1,12},{-100.1,0.1}},          color={191,0,0}));
          connect(weaBus, propsBus_a.weaBus) annotation (Line(
              points={{0,-48},{-100.1,-48},{-100.1,0.1}},
              color={255,204,51},
              thickness=0.5));
          connect(weaBus, propsBus_b.weaBus) annotation (Line(
              points={{0,-48},{100.1,-48},{100.1,-0.1}},
              color={255,204,51},
              thickness=0.5));
          connect(surfCon.port_b, propsBus_b.surfCon) annotation (Line(points={{10,72},
                  {100.1,72},{100.1,-0.1}},        color={191,0,0}));
          connect(surfRad.port_b, propsBus_b.surfRad) annotation (Line(points={{10,44},
                  {100.1,44},{100.1,-0.1}},        color={191,0,0}));
          connect(iSolDir.port_b, propsBus_b.iSolDir) annotation (Line(points={{10,12},
                  {100.1,12},{100.1,-0.1}},        color={191,0,0}));
          connect(iSolDif.port_b, propsBus_b.iSolDif)
            annotation (Line(points={{10,-16},{100.1,-16},{100.1,-0.1}},
                                                                     color={191,0,0}));
          connect(QGai.port_b, propsBus_b.Qgai) annotation (Line(points={{10,-76},{
                  100.1,-76},{100.1,-0.1}},
                                      color={191,0,0}));
          connect(E.E_b, propsBus_b.E) annotation (Line(points={{10,-106},{100.1,-106},
                  {100.1,-0.1}},
                          color={0,0,0}));
          connect(inc.y, propsBus_b.inc) annotation (Line(points={{11,-138},{100.1,-138},
                  {100.1,-0.1}}, color={0,0,127}));
          connect(azi.y, propsBus_b.azi) annotation (Line(points={{11,-168},{100.1,-168},
                  {100.1,-0.1}}, color={0,0,127}));
          connect(azi.u, propsBus_a.azi) annotation (Line(points={{-12,-168},{-100.1,
                  -168},{-100.1,0.1}},
                                 color={0,0,127}));
          connect(inc.u, propsBus_a.inc) annotation (Line(points={{-12,-138},{-100.1,
                  -138},{-100.1,0.1}},
                                 color={0,0,127}));
          connect(E.E_a, propsBus_a.E) annotation (Line(points={{-9.8,-106},{-100.1,
                  -106},{-100.1,0.1}},
                                 color={0,0,0}));
          connect(QGai.port_a, propsBus_a.Qgai) annotation (Line(points={{-10,-76},{
                  -100.1,-76},{-100.1,0.1}},       color={191,0,0}));
          connect(epsLw.u, propsBus_a.epsLw) annotation (Line(points={{-12,128},{-100.1,
                  128},{-100.1,0.1}}, color={0,0,127}));
          connect(epsSw.u, propsBus_a.epsSw) annotation (Line(points={{-12,98},{-100.1,
                  98},{-100.1,0.1}},         color={0,0,127}));
          connect(epsLw.y, propsBus_b.epsLw) annotation (Line(points={{11,128},{100.1,
                  128},{100.1,-0.1}},        color={0,0,127}));
          connect(epsSw.y, propsBus_b.epsSw) annotation (Line(points={{11,98},{100.1,98},
                  {100.1,-0.1}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-180},
                    {100,200}}), graphics={
                Polygon(
                  points={{-100,120},{102,-2},{-100,-120},{-100,120}},
                  lineColor={255,215,136},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Text(
                  extent={{-76,-110},{72,-160}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="k = %k"),
                Text(
                  extent={{-100,158},{100,98}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="%name")}),                                 Diagram(graphics,
                coordinateSystem(preserveAspectRatio=false, extent={{-100,-180},{100,200}})),
            Documentation(revisions="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ZoneBusVarMultiplicator;

        partial model ZoneInterface "Partial model for thermal building zones"
          replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choicesAllMatching = true);
          outer IDEAS.BoundaryConditions.SimInfoManager sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));

          parameter Integer nSurf(min=2)
            "Number of surfaces adjacent to and heat exchangeing with the zone";
          parameter Modelica.SIunits.Volume V "Total zone air volume"
            annotation(Dialog(group="Building physics"));
          parameter Modelica.SIunits.Length hZone = 2.8
            "Zone height: distance between floor and ceiling"
            annotation(Dialog(group="Building physics"));
          parameter Modelica.SIunits.Area A = V/hZone "Total conditioned floor area"
            annotation(Dialog(group="Building physics"));
          parameter Boolean useOccNumInput
            "=false, to remove icon of nOcc"
            annotation(Dialog(tab="Advanced",group="Occupants"));
          parameter Boolean useLigCtrInput
            "=false, to remove icon of lightCtrl"
            annotation(Dialog(tab="Advanced",group="Lighting"));
          //default ACH=2 for ventilation
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal = V * 1.2*2/3600
            "Nominal flow rate of the air flow system fluid ports"
            annotation(Dialog(tab="Advanced",group="Air model"));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b gainRad
            "Internal zone node for radiative heat gains"
            annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a gainCon
            "Internal zone node for convective heat gains"
            annotation (Placement(transformation(extent={{90,-40},{110,-20}})));
          Modelica.Blocks.Interfaces.RealOutput TSensor(unit="K", displayUnit="degC")
            "Sensor temperature of the zone, i.e. operative temeprature" annotation (
              Placement(transformation(extent={{100,10},{120,30}}), iconTransformation(
                  extent={{100,10},{120,30}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b(
            redeclare package Medium = Medium,
            m_flow(nominal=m_flow_nominal),
            h_outflow(nominal=Medium.h_default))
            annotation (Placement(transformation(extent={{-30,90},{-10,110}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_a(
            redeclare package Medium = Medium,
            m_flow(nominal=m_flow_nominal),
            h_outflow(nominal=Medium.h_default))
            annotation (Placement(transformation(extent={{10,90},{30,110}})));
          Modelica.Blocks.Interfaces.RealInput yOcc if useOccNumInput
            "Control input for number of occupants, used by Occupants.Input and Occupants.AreaWeightedInput"
            annotation (Placement(transformation(extent={{140,20},{100,60}})));
          Modelica.Blocks.Interfaces.RealInput uLig if useLigCtrInput
            "Lighting control input (1 corresponds to 100%), only used when using LightingControl.Input"
            annotation (Placement(transformation(extent={{140,50},{100,90}})));
          Modelica.Blocks.Interfaces.RealOutput ppm(unit="1")
            "CO2 concentration in the zone" annotation (Placement(transformation(extent={{100,-10},
                    {120,10}}),           iconTransformation(extent={{100,-10},{120,10}})));
      protected
          Modelica.Blocks.Sources.RealExpression Eexpr "Internal energy model";
          BaseClasses.ConservationOfEnergy.PrescribedEnergy prescribedHeatFlowE
            "Dummy that allows computing total internal energy";
          Modelica.Blocks.Sources.RealExpression Qgai(
            y=(if sim.openSystemConservationOfEnergy or not sim.computeConservationOfEnergy
               then 0
            else gainCon.Q_flow + gainRad.Q_flow)) "Heat gains in model";
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prescribedHeatFlowQgai
            "Component for computing conservation of energy";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a dummy1
            "Dummy heat port for avoiding error by dymola translator";
          IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.EnergyPort dummy2
            "Dummy emergy port for avoiding error by dymola translator";
        initial equation
          assert(nSurf>1, "In " + getInstanceName() +
            ": A minimum of 2 surfaces must be connected to the zone.");

        equation
          connect(sim.Qgai, dummy1);
          connect(sim.E, dummy2);
          connect(Eexpr.y,prescribedHeatFlowE.E);
          connect(prescribedHeatFlowE.port, sim.E);
          connect(Qgai.y,prescribedHeatFlowQgai. Q_flow);
          connect(prescribedHeatFlowQgai.port, sim.Qgai);

          annotation (Diagram(graphics,
                              coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),           Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-90,90},{90,-90}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Backward,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{68,70},{-68,-70}},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-68,70},{68,70}},
                  color={0,0,0},
                  thickness=0.5,
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-40,-70},{40,-90}},
                  lineThickness=0.5,
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-40,-90},{68,22},{68,-42},{40,-70},{40,-90},{-40,-90},{-40,-90}},
                  lineThickness=0.5,
                  smooth=Smooth.None,
                  fillColor={255,255,170},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{-68,70},{-68,-70},{-40,-70},{-40,-80},{40,-80},{40,-70},{68,
                      -70},{68,70}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Text(
                  extent={{-39,40},{39,-40}},
                  lineColor={0,0,0},
                  fontName="Calibri",
                  origin={-2,3},
                  rotation=0,
                  textString="%name")}),
            Documentation(revisions="<html>
<ul>
<li>
May 2, 2019 by Filip Jorissen:<br/>
Moved location of <code>ppm</code> in the icon layer such that it
does not overlap with <code>TSensor</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1026\">#1026</a>.
</li>
<li>
March 28, 2019 by Filip Jorissen:<br/>
Renamed <code>nOcc</code> to <code>yOcc</code>
See <a href=\"https://github.com/open-ideas/IDEAS/issues/998\">#998</a>.
</li>
<li>
September 5, 2018 by Iago Cupeiro:<br/>
Added uLig input for controlling lighting
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added output for the CO2 concentration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
July 11, 2018, Filip Jorissen:<br/>
Added nominal values for <code>h_outflow</code> and <code>m_flow</code>
in <code>FluidPorts</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/859\">#859</a>.
</li>
<li>
May 29, 2018, Filip Jorissen:<br/>
Removed conditional fluid ports for JModelica compatibility.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/834\">#834</a>.
</li>
<li>
April 28, 2016, Filip Jorissen:<br/>
Added assert for checking nSurf larger than 1.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
        end ZoneInterface;
      end Interfaces;

      package InternalGains "Package for occupant models"

        package BaseClasses
          extends Modelica.Icons.BasesPackage;

          partial model PartialLightingGains "Partial model for lighting internal gains"
            extends Modelica.Blocks.Icons.Block;
            outer IDEAS.BoundaryConditions.SimInfoManager sim
              "Simulation information manager";
            parameter IDEAS.Buildings.Components.LightingType.None ligTyp
              annotation (Placement(transformation(extent={{-60,80},{-40,100}})));
            parameter IDEAS.Buildings.Components.RoomType.Generic rooTyp
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            parameter  Modelica.SIunits.Area A "Area of the zone";
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portCon
              "Port for convective sensible heat transfer due to occupants"
              annotation (Placement(transformation(extent={{90,10},{110,30}})));
            Modelica.Blocks.Interfaces.RealInput ctrl
              "Number of occupants"
              annotation (Placement(transformation(extent={{-130,-20},{-90,20}})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFlo(
              final alpha=0) if sim.computeConservationOfEnergy
              "Prescribed energy heat flow for conservation of energy check";
            Modelica.Blocks.Sources.RealExpression Qgai(y=-portCon.Q_flow-portRad.Q_flow) if
                 sim.computeConservationOfEnergy;
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portRad
              "Port for radiative sensible heat transfer due to occupants"
              annotation (Placement(transformation(extent={{90,-30},{110,-10}})));
          equation
            connect(preHeaFlo.port, sim.Qgai);
            connect(Qgai.y, preHeaFlo.Q_flow);
            annotation (Icon(graphics,
                             coordinateSystem(preserveAspectRatio=false)), Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>"));
          end PartialLightingGains;

          partial model PartialOccupancyGains "Partial model for occupant internal gains"
            import IDEAS;
            extends Modelica.Blocks.Icons.Block;
            outer IDEAS.BoundaryConditions.SimInfoManager sim "Simulation information manager";
            replaceable package Medium =
              Modelica.Media.Interfaces.PartialMedium "Medium in the component"
                annotation (choicesAllMatching = true, Documentation(revisions="<html>
<ul>
<li>
January 26, 2018 by Filip Jorissen:<br/>
Changed replaceable record into parameter such that 
<code>IDEAS.Buildings.Components.OccupancyType.BaseClasses.PartialOccupancyType</code> 
can be a partial record.
This is for <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
</ul>
</html>"));
            parameter IDEAS.Buildings.Components.OccupancyType.OfficeWork occupancyType
              annotation (Placement(transformation(extent={{-60,80},{-40,100}})));
            Modelica.Blocks.Interfaces.RealOutput mWat_flow
              "Water vapor mass flow rate due to occupants"
              annotation (Placement(transformation(extent={{96,50},{116,70}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portCon
              "Port for convective sensible heat transfer due to occupants"
              annotation (Placement(transformation(extent={{90,-30},{110,-10}})));
            Modelica.Blocks.Interfaces.RealOutput C_flow[max(Medium.nC,1)]
              "Trace substance mass flow rate due to occupants"
              annotation (Placement(transformation(extent={{96,10},{116,30}})));
            Modelica.Blocks.Interfaces.RealInput nOcc "Number of occupants"
              annotation (Placement(transformation(extent={{-130,-20},{-90,20}})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFlo(final
                alpha=0) if sim.computeConservationOfEnergy
              "Prescribed energy heat flow for conservation of energy check";
            Modelica.Blocks.Sources.RealExpression Qgai(y=-portCon.Q_flow-portRad.Q_flow) if sim.computeConservationOfEnergy;
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portRad
              "Port for radiative sensible heat transfer due to occupants"
              annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
          equation
            connect(preHeaFlo.port, sim.Qgai);
            connect(Qgai.y, preHeaFlo.Q_flow);
            annotation (Icon(graphics,
                             coordinateSystem(preserveAspectRatio=false)), Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
July 26, 2018 by Filip Jorissen:<br/>
Revised implementation to add support for
<a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
          end PartialOccupancyGains;
        end BaseClasses;

        model Lighting
          "Computes heat gains due to lighting requirements"
          extends
          IDEAS.Buildings.Components.InternalGains.BaseClasses.PartialLightingGains;
          Modelica.Blocks.Math.Gain gaiHea(final k=PNom)
            "Gain for computing heat lighting gains based on zone lighting requirements"
            annotation (Placement(transformation(extent={{-52,-10},{-32,10}})));
      protected
          final parameter Modelica.SIunits.Power PNom = rooTyp.Ev*A/ligTyp.K
            "Nominal power, avoids parameter division";
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloCon(final
              alpha=0) "Prescribed heat flow rate for convective sensible heat"
            annotation (Placement(transformation(extent={{40,10},{60,30}})));
          Modelica.Blocks.Math.Gain gainRad(final k=ligTyp.radFra) "Radiative fraction"
            annotation (Placement(transformation(extent={{-8,-30},{12,-10}})));
          Modelica.Blocks.Math.Gain gainCon(final k=1 - ligTyp.radFra)
            "Convective fraction"
            annotation (Placement(transformation(extent={{-8,10},{12,30}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloRad(
            final alpha=0) "Prescribed heat flow rate for radiative sensible heat"
            annotation (Placement(transformation(extent={{40,-30},{60,-10}})));
        equation
          connect(preHeaFloCon.port, portCon)
            annotation (Line(points={{60,20},{100,20}},            color={191,0,0}));
          connect(preHeaFloRad.port, portRad)
            annotation (Line(points={{60,-20},{100,-20}},           color={191,0,0}));
          connect(gainRad.y, preHeaFloRad.Q_flow)
            annotation (Line(points={{13,-20},{40,-20}}, color={0,0,127}));
          connect(gainCon.y, preHeaFloCon.Q_flow) annotation (Line(points={{13,20},{40,20}},
                                           color={0,0,127}));
          connect(gainCon.u, gaiHea.y)
            annotation (Line(points={{-10,20},{-20,20},{-20,0},{-31,0}},
                                                                     color={0,0,127}));
          connect(gainRad.u, gaiHea.y) annotation (Line(points={{-10,-20},{-20,-20},{-20,
                  0},{-31,0}}, color={0,0,127}));
          connect(ctrl, gaiHea.u) annotation (Line(points=
                 {{-110,0},{-54,0}}, color={0,0,127}));
          annotation (Documentation(info="<html>
<p>
This lighting model uses a light control input signal, 
which should have a value between 0 and 1,
which is multiplied by the lighting requirements of the zone (<i>lx=lm/m<sup>2</sup></i>), 
the floor area (<i>m<sup>2</sup></i>) and the inverse of the luminous efficacy (<i>lm/W</i>). 
The total lighting gains are then split into a radiative and a convective part. 
</p>
</html>",       revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>"));
        end Lighting;

        model Occupants "Constant sensible, latent and CO2 heat production per person"
          extends BaseClasses.PartialOccupancyGains;
          parameter Modelica.SIunits.Power QlatPp = occupancyType.QlatPp
            "Latent heat production per person, default from Ashrae Fundamentals: 'Seated, very light work'";
          parameter Modelica.SIunits.Power QsenPp = occupancyType.QsenPp
            "Sensible heat production per person, default from Ashrae Fundamentals: 'Seated, very light work'";
          parameter Real radFra(min=0,max=1) = occupancyType.radFra
            "Radiant fraction of sensible heat exchange, default based on Ashrae fundamentals chap 18.4 for low air velocity";
      protected
          constant Modelica.SIunits.SpecificEnthalpy lambdaWater = 2418000
            "Latent heat of evaporation of water at 35 degrees Celsius";
          constant Modelica.SIunits.SpecificEnthalpy E_glu = 16e6
            "Calorific value of glucose";
          constant Real MM_glu = 180
            "Molar mass of glucose";
          constant Real MM_CO2 = 44
            "Molar mass of CO2";
          parameter Real m_flow_co2_pp = (QlatPp+QsenPp)/(E_glu*MM_glu/6/MM_CO2)
            "CO2 production per person, based on oxidation of suger with calorific value of 16 kJ/g";
          final parameter Modelica.SIunits.MassFlowRate m_flow_h2o_pp = QlatPp/lambdaWater
            "Vapor production per person";
          final parameter Real s_co2[max(Medium.nC,1)] = {if Modelica.Utilities.Strings.isEqual(string1=if Medium.nC>0 then Medium.extraPropertiesNames[i] else "",
                                                     string2="CO2",
                                                     caseSensitive=false)
                                                     then 1 else 0 for i in 1:max(Medium.nC,1)};
          Modelica.Blocks.Math.Gain gaiHea(k=QsenPp)
                        "Gain for computing heat flow rate"
            annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
          Modelica.Blocks.Math.Gain[max(Medium.nC,1)] gaiCO2(k=m_flow_co2_pp*s_co2)
            "Gain for computing CO2 mass flow rate"
            annotation (Placement(transformation(extent={{-8,10},{12,30}})));
          Modelica.Blocks.Math.Gain gaiWat(k=m_flow_h2o_pp)
            "Gain for computing water mass flow rate"
            annotation (Placement(transformation(extent={{-8,50},{12,70}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloCon(final
              alpha=0) "Prescribed heat flow rate for convective sensible heat"
            annotation (Placement(transformation(extent={{40,-30},{60,-10}})));
      public
          Modelica.Blocks.Math.Gain gain(final k=radFra)
            annotation (Placement(transformation(extent={{-8,-70},{12,-50}})));
          Modelica.Blocks.Math.Gain gainCon(final k=1 - radFra)
            annotation (Placement(transformation(extent={{-8,-30},{12,-10}})));
      protected
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloRad(final
              alpha=0) "Prescribed heat flow rate for radiative sensible heat"
            annotation (Placement(transformation(extent={{40,-70},{60,-50}})));
        equation
          connect(gaiWat.y, mWat_flow)
            annotation (Line(points={{13,60},{106,60},{106,60}}, color={0,0,127}));
          connect(gaiCO2.y, C_flow)
            annotation (Line(points={{13,20},{60,20},{106,20}}, color={0,0,127}));
          connect(preHeaFloCon.port, portCon)
            annotation (Line(points={{60,-20},{82,-20},{100,-20}}, color={191,0,0}));
          connect(gaiHea.u, nOcc)
            annotation (Line(points={{-62,-40},{-110,-40},{-110,0}}, color={0,0,127}));
          for i in 1:max(Medium.nC,1) loop
            connect(gaiCO2[i].u, nOcc)
              annotation (Line(points={{-10,20},{-60,20},{-60,0},{-110,0}},
                                                          color={0,0,127}));
          end for;
          connect(gaiWat.u, nOcc)
            annotation (Line(points={{-10,60},{-110,60},{-110,0}}, color={0,0,127}));
          connect(preHeaFloRad.port, portRad)
            annotation (Line(points={{60,-60},{100,-60},{100,-60}}, color={191,0,0}));
          connect(gain.y, preHeaFloRad.Q_flow)
            annotation (Line(points={{13,-60},{40,-60}},          color={0,0,127}));
          connect(gainCon.y, preHeaFloCon.Q_flow) annotation (Line(points={{13,-20},{26,
                  -20},{40,-20}},          color={0,0,127}));
          connect(gainCon.u, gaiHea.y)
            annotation (Line(points={{-10,-20},{-39,-20},{-39,-40}}, color={0,0,127}));
          connect(gain.u, gaiHea.y)
            annotation (Line(points={{-10,-60},{-39,-60},{-39,-40}}, color={0,0,127}));
          annotation (Documentation(info="<html>
<p>
This occupancy model assumes a constant latent and sensible load per person. 
We assume this heat gain is caused by the metabolic combustion of suger, 
resulting into a corresponding CO2 production. 
The CO2 mass flow rate is added only if the Medium contains CO2. 
Latent heat is only added if the Medium is a moist air medium. 
Sensible heat is emitted both as convective and radiant heat using a fixed weighing factor.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 26, 2018 by Filip Jorissen:<br/>
Revised implementation to add support for
<a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
January 18, 2017 by Filip Jorissen:<br/>
Changed latent heat of evaporation of water.
This is for issue
<a href=https://github.com/open-ideas/IDEAS/issues/635>#635</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
        end Occupants;
      end InternalGains;

      model InternalWall "interior opaque wall between two zones"
        extends IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface(
          final nWin=1,
           dT_nominal_a=1,
        E(y= if sim.computeConservationOfEnergy then layMul.E else 0),
        Qgai(y=(if sim.openSystemConservationOfEnergy or not sim.computeConservationOfEnergy
               then 0 else sum(port_emb.Q_flow))),
        final QTra_design=U_value*A    *(TRef_a - TRef_b),
          intCon_a);
        parameter Boolean linIntCon_b=sim.linIntCon
          "= true, if convective heat transfer should be linearised"
          annotation(Dialog(tab="Convection"));
        parameter Modelica.SIunits.TemperatureDifference dT_nominal_b=1
          "Nominal temperature difference used for linearisation, negative temperatures indicate the solid is colder"
          annotation(Dialog(tab="Convection"));
        parameter Modelica.SIunits.Temperature TRef_b=291.15
          "Reference temperature of zone on side of propsBus_b, for calculation of design heat loss"
           annotation (Dialog(group="Design power",tab="Advanced"));
        // open door modelling
        parameter Boolean hasCavity = false
          "=true, to model open door or cavity in wall"
          annotation(Dialog(group="Cavity or open door"));
        parameter Modelica.SIunits.Length h = 2
          "Height of (rectangular) cavity in wall"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door"));
        parameter Modelica.SIunits.Length w = 1
          "Width of (rectangular) cavity in wall"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door"));
        parameter Modelica.SIunits.Acceleration g = Modelica.Constants.g_n
          "Gravity, for computation of buoyancy"
          annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.Pressure p = 101300
          "Absolute pressure for computation of buoyancy"
          annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.Density rho = p/r/T
          "Nominal density for computation of buoyancy mass flow rate"
          annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.SpecificHeatCapacity c_p = 1013
         "Nominal heat capacity for computation of buoyancy heat flow rate"
         annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.Temperature T = 293
         "Nominal temperature for linearising heat flow rate"
         annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.TemperatureDifference dT = 1
         "Nominal temperature difference when linearising heat flow rate"
         annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_emb[constructionType.nGain]
          "port for gains by embedded active layers"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
        IDEAS.Buildings.Components.Interfaces.ZoneBus propsBus_b(
          numIncAndAziInBus=sim.numIncAndAziInBus,
          outputAngles=sim.outputAngles) "If inc = Floor, then propsbus_b should be connected to the zone below this floor.
    If inc = Ceiling, then propsbus_b should be connected to the zone above this ceiling."
              annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-100,20}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-50,20})));
    protected
        final parameter Real U_value=1/(1/8 + sum(constructionType.mats.R) + 1/8)
          "Wall U-value";
        constant Real r = 287 "Gas constant";
        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.InteriorConvection
          intCon_b(
          linearise=linIntCon_b or sim.linearise,
          dT_nominal=dT_nominal_b,
          final inc=inc + Modelica.Constants.pi,
          final A=A)
          "convective surface heat transimission on the interior side of the wall"
          annotation (Placement(transformation(extent={{-22,-10},{-42,10}})));
        Modelica.Blocks.Sources.RealExpression QDesign_b(y=-QTra_design);
        //Negative, because of its losses from zone side b to zone side a, oposite of calculation of QTra_design
        Modelica.Blocks.Sources.RealExpression incExp1(y=inc + Modelica.Constants.pi)
          "Inclination angle";
        Modelica.Blocks.Sources.RealExpression aziExp1(y=azi + Modelica.Constants.pi)
          "Azimuth angle expression";
        Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow iSolDif1(final Q_flow=0);
        Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow iSolDir1(final Q_flow=0);
        Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow Qgai_b(final Q_flow=0);
        IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.PrescribedEnergy
          E_b;
        Modelica.Blocks.Sources.Constant E0(final k=0)
          "All internal energy is assigned to right side";
        BaseClasses.ConvectiveHeatTransfer.CavityAirflow
                                              theConDoor(
          linearise=sim.linearise or linIntCon_a or linIntCon_b,
          h=h,
          w=w,
          g=g,
          p=p,
          rho=rho,
          c_p=c_p,
          T=T,
          dT=dT) if                                         hasCavity
          "Model for air flow through open door or cavity"
          annotation (Placement(transformation(extent={{-10,40},{10,60}})));
      equation
        assert(hasCavity == false or IDEAS.Utilities.Math.Functions.isAngle(inc, IDEAS.Types.Tilt.Wall),
          "In " + getInstanceName() + ": Cavities are only supported for vertical walls, but inc=" + String(inc));
        connect(layMul.port_b, propsBus_b.surfRad) annotation (Line(
            points={{-10,0},{-18,0},{-18,20.1},{-100.1,20.1}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(propsBus_b.surfCon, intCon_b.port_b) annotation (Line(
            points={{-100.1,20.1},{-48,20.1},{-48,0},{-42,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layMul.port_b, intCon_b.port_a) annotation (Line(
            points={{-10,0},{-22,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layMul.iEpsSw_b, propsBus_b.epsSw) annotation (Line(
            points={{-10,4},{-22,4},{-22,20.1},{-100.1,20.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(layMul.iEpsLw_b, propsBus_b.epsLw) annotation (Line(
            points={{-10,8},{-20,8},{-20,20.1},{-100.1,20.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(layMul.area, propsBus_b.area) annotation (Line(
            points={{0,10},{0,20.1},{-100.1,20.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(iSolDif1.port, propsBus_b.iSolDif);
        connect(iSolDir1.port, propsBus_b.iSolDir);
        connect(QDesign_b.y, propsBus_b.QTra_design);
        connect(incExp1.y, propsBus_b.inc);
        connect(aziExp1.y, propsBus_b.azi);
        connect(Qgai_b.port, propsBus_b.Qgai);
        connect(E_b.port, propsBus_b.E);
        connect(E_b.E, E0.y);
        connect(theConDoor.port_a, propsBus_b.surfCon) annotation (Line(points={{-10,50},
                {-48,50},{-48,20.1},{-100.1,20.1}}, color={191,0,0}));
        connect(theConDoor.port_b, propsBusInt.surfCon) annotation (Line(points={{10,50},
                {46,50},{46,19.91},{56.09,19.91}},
                                                 color={191,0,0}));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-52,-90},{48,-70}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-50,80},{50,100}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-10,80},{10,-70}},
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None),
              Line(points={{-50,80},{50,80}}, color={175,175,175}),
              Line(points={{-50,-70},{50,-70}}, color={175,175,175}),
              Line(points={{-50,-90},{50,-90}}, color={175,175,175}),
              Line(points={{-50,100},{50,100}}, color={175,175,175}),
              Line(
                points={{-10,80},{-10,-70}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{10,80},{10,-70}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5)}),
          Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false,extent={{-60,-100},{60,
                  100}})),
          Documentation(info="<html>
<p>
This is a wall model that should be used
to simulate a wall or floor between two zones.
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces.
</p>
<h4>Typical use and important parameters</h4>
<p>
Each propsbus needs to be connected to a zone, which may be the same zone.
</p>
<p>
Note that this model is not symmetric: the convection equations depend on the inclination <code>inc</code>,
which is turned 180 degrees between both side. The value of <code>inc</code> is applied to the right side of the model.
</p>
<p>
Parameter <code>hasCavity</code> can be set to <code>true</code> to simulate heat transfer
through a cavity such as an open door in a simplified way.
The cavity height <code>h</code> and width <code>w</code> then have to be specified.
We assume that the value of <code>A</code> excludes the surface area of the cavity.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
Set nWin final to 1 as this should only be used for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. 
</li>
<li>
May 21, 2018, by Filip Jorissen:<br/>
Added model for air flow through cavity.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/822\">#822</a>.
</li>
<li>
January 2, 2017, by Filip Jorissen:<br/>
Updated icon layer.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
</ul>
</html>"));
      end InternalWall;

      package InterzonalAirFlow "Package for interzonal air flow models"
      extends Modelica.Icons.Package;

        package BaseClasses "Base classes"
          extends Modelica.Icons.BasesPackage;

          partial model PartialInterzonalAirFlow "Partial for interzonal air flow"
            replaceable package Medium = IDEAS.Media.Air "Air medium";
            parameter Integer nPorts "Number of ports for connection to zone air volume";
            parameter Modelica.SIunits.Volume V "Zone air volume for n50 computation";
            parameter Real n50 "n50 value";
            parameter Real n50toAch = 20
              "Conversion fractor from n50 to Air Change Rate"
              annotation(Dialog(tab="Advanced"));
            constant Boolean prescribesPressure = false
              "Indication whether this model prescribes the air zone pressure or not";
            // = true to enable check in zone that verifies whether both FluidPorts
            //  or none of the are connected, to avoid incorrect use.
            parameter Boolean verifyBothPortsConnected = false
              "=true, to verify fluid port connections";
            parameter Modelica.SIunits.MassFlowRate m_flow_nominal_vent
              "Nominal mass flow rate of ventilation system"
              annotation(Dialog(tab="Advanced"));
            Modelica.Fluid.Interfaces.FluidPort_b port_b_interior(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal_vent),
              h_outflow(nominal=Medium.h_default))
              "Port a connection to zone air model ports"
              annotation (Placement(transformation(extent={{50,-110},{70,-90}})));
            Modelica.Fluid.Interfaces.FluidPort_a port_a_interior(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal_vent),
              h_outflow(nominal=Medium.h_default))
              "Port b connection to zone air model ports"
              annotation (Placement(transformation(extent={{-70,-110},{-50,-90}})));
            Modelica.Fluid.Interfaces.FluidPort_a port_a_exterior(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal_vent),
              h_outflow(nominal=Medium.h_default))
              "Port a connection to model exterior ports"
              annotation (Placement(transformation(extent={{10,90},{30,110}})));
            Modelica.Fluid.Interfaces.FluidPort_b port_b_exterior(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal_vent),
              h_outflow(nominal=Medium.h_default))
              "Port b connection to model exterior ports"
              annotation (Placement(transformation(extent={{-30,90},{-10,110}})));
            Modelica.Fluid.Interfaces.FluidPorts_a[nPorts] ports(
              redeclare each package Medium = Medium,
              each m_flow(nominal=m_flow_nominal_vent),
              each h_outflow(nominal=Medium.h_default))
              "Ports connector for multiple ports" annotation (Placement(
                  transformation(
                  extent={{-10,40},{10,-40}},
                  rotation=90,
                  origin={2,-100})));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                    extent={{-15,80},{15,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None,
                    origin={-19,86},
                    rotation=90),
                  Rectangle(
                    extent={{-70,100},{-100,40}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{57.5,0},{-11,-0.5}},
                    color={0,128,255},
                    visible=not allowFlowReversal,
                    origin={-20.5,31},
                    rotation=90),
                  Line(
                    points={{57.5,0},{-13,-0.5}},
                    color={0,128,255},
                    visible=not allowFlowReversal,
                    origin={19.5,33},
                    rotation=90),
                  Rectangle(
                    extent={{-70,0},{-100,-60}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{-11,10},{20,0},{-11,-10},{-11,10}},
                    lineColor={0,128,255},
                    fillColor={0,128,255},
                    fillPattern=FillPattern.Solid,
                    visible=not allowFlowReversal,
                    origin={20,41},
                    rotation=270),
                  Line(
                    points={{60,70},{-70,70},{-70,-60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Polygon(
                    points={{-11,10},{20,0},{-11,-10},{-11,10}},
                    lineColor={0,128,255},
                    fillColor={0,128,255},
                    fillPattern=FillPattern.Solid,
                    visible=not allowFlowReversal,
                    origin={-20,69},
                    rotation=90)}),                                        Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
January 25, 2019, Filip Jorissen:<br/>
Added constant <code>prescribesPressure</code> that indicates
whether this model prescribes the zone air pressure or not.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/971\">#971</a>.
</li>
<li>
July 11, 2018, Filip Jorissen:<br/>
Added <code>m_flow_nominal_vent</code> and set 
<code>h_outflow</code> and <code>m_flow</code>
in <code>FluidPorts</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/859\">#859</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
First version.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
</ul>
</html>"));
          end PartialInterzonalAirFlow;

          partial model PartialInterzonalAirFlowBoundary
            "Partial interzonal air flow model that includes a boundary"
            extends
            IDEAS.Buildings.Components.InterzonalAirFlow.BaseClasses.PartialInterzonalAirFlow;
            outer BoundaryConditions.SimInfoManager sim "Simulation information manager"
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
        protected
            final parameter Real s_co2[max(Medium.nC,1)] = {if Modelica.Utilities.Strings.isEqual(string1=if Medium.nC>0 then Medium.extraPropertiesNames[i] else "",
                                                       string2="CO2",
                                                       caseSensitive=false)
                                                       then 1 else 0 for i in 1:max(Medium.nC,1)};
            IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(numSolBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
              annotation (Placement(transformation(extent={{-78,80},{-58,100}})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFlo(final
                alpha=0) if                                                                 sim.computeConservationOfEnergy
              "Prescribed heat flow rate for conservation of energy check" annotation (
                Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=270,
                  origin={-90,66})));
            Modelica.Blocks.Sources.RealExpression QGai(y=-actualStream(bou.ports.h_outflow)
                  *bou.ports.m_flow) "Net heat gain through n50 air leakage "
              annotation (Placement(transformation(extent={{-22,30},{-82,50}})));
            Fluid.Sources.Boundary_pT bou(
              redeclare package Medium = Medium,
              use_T_in=true,
              use_p_in=false,
              use_C_in=Medium.nC > 0,
              use_Xi_in=Medium.nX == 2) annotation (Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=90,
                  origin={0,10})));
            Modelica.Blocks.Sources.RealExpression Te(y=weaBus.Te)
                                                                "Ambient temperature"
              annotation (Placement(transformation(extent={{-44,52},{-26,68}})));
            Modelica.Blocks.Sources.RealExpression Xi(y=weaBus.X_wEnv)
              annotation (Placement(transformation(extent={{-44,64},{-26,80}})));
            Modelica.Blocks.Sources.RealExpression CEnv[max(Medium.nC,1)](y=weaBus.CEnv*s_co2)
              annotation (Placement(transformation(extent={{-44,74},{-26,90}})));
          equation
            connect( sim.weaBus,weaBus);
            connect(port_a_interior, port_b_exterior) annotation (Line(points={{-60,-100},
                    {-60,0},{-20,0},{-20,100}}, color={0,127,255}));
            connect(port_a_exterior, port_b_interior) annotation (Line(points={{20,100},{20,
                    0},{60,0},{60,-100}}, color={0,127,255}));
            connect(preHeaFlo.port, sim.Qgai)
              annotation (Line(points={{-90,76},{-90,80}}, color={191,0,0}));
            connect(QGai.y, preHeaFlo.Q_flow)
              annotation (Line(points={{-85,40},{-90,40},{-90,56}}, color={0,0,127}));
            if Medium.nX == 2 then
              connect(bou.Xi_in[1], Xi.y) annotation (Line(points={{4,22},{4,72},{-25.1,
                      72}},            color={0,0,127}));
            end if;
            if Medium.nC > 0 then
              connect(CEnv.y, bou.C_in)
                annotation (Line(points={{-25.1,82},{8,82},{8,22}}, color={0,0,127}));
            end if;
            connect(bou.T_in, Te.y) annotation (Line(points={{-4,22},{-4,60},{-25.1,60}},
                             color={0,0,127}));
            annotation (Documentation(revisions="<html>
<ul>
<li>
September 24, 2018 by Filip Jorissen:<br/>
Fix for supporting multiple trace substances.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/920\">#920</a>.
</li>
<li>
August 24, 2018 by Damien Picard:<br/>
Use weaDatBus.Te instead of sim.Te such that the variable is correctly 
used when linearizing with LIDEAS.
</li>
<li>
June 11, 2018 by Filip Jorissen:<br/>
Using <code>Xi_in</code> instead of <code>X_in</code> since this
requires fewer inputs and it avoids an input variable consistency check.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
First version.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
</ul>
</html>"));
          end PartialInterzonalAirFlowBoundary;

          partial model PartialInterzonalAirFlown50
            "Model representing idealised n50 air leakage"
            extends
            IDEAS.Buildings.Components.InterzonalAirFlow.BaseClasses.PartialInterzonalAirFlowBoundary(
                nPorts=2, bou(nPorts=2));
            parameter Modelica.SIunits.MassFlowRate m_flow_nominal_airLea=
              V*rho_default/3600*n50/n50toAch
              "Nominal mass flow of air leakage"
              annotation(Dialog(tab="Advanced"));
            Modelica.Blocks.Sources.RealExpression reaExpMflo(y=m_flow_nominal_airLea)
              annotation (Placement(transformation(extent={{-52,-54},{-30,-34}})));
            Fluid.Interfaces.IdealSource airInfiltration(
              redeclare package Medium = Medium,
              control_m_flow=true,
              allowFlowReversal=false,
              control_dp=false) "Fixed air infiltration rate" annotation (Placement(
                  transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=90,
                  origin={-10,-50})));
        protected
            final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
                T=Medium.T_default,
                p=Medium.p_default,
                X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
            final parameter Modelica.SIunits.Density rho_default = Medium.density(
              state=state_default) "Medium default density";
          equation
            connect(reaExpMflo.y, airInfiltration.m_flow_in) annotation (Line(points={{-28.9,
                    -44},{-18,-44}},                 color={0,0,127}));
            connect(airInfiltration.port_a, bou.ports[1]) annotation (Line(points={{-10,-40},
                    {-10,0},{-2,0}},                                          color={0,127,
                    255}));
            connect(airInfiltration.port_b, ports[1]) annotation (Line(points={{-10,-60},{
                    -10,-100},{-18,-100}},          color={0,127,255}));
            annotation (Documentation(revisions="<html>
<ul>
<li>
April 27, 2018 by Filip Jorissen:<br/>
First version.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
</ul>
</html>"),           Icon(graphics={Text(
                    extent={{18,-38},{66,-60}},
                    lineColor={28,108,200},
                    textString="n50")}));
          end PartialInterzonalAirFlown50;
        end BaseClasses;

        model n50Tight
          "n50Tight: n50 air leakage into and from airtight zone"
          extends
          IDEAS.Buildings.Components.InterzonalAirFlow.BaseClasses.PartialInterzonalAirFlown50
          ( prescribesPressure=false);
          Fluid.Interfaces.IdealSource airExfiltration(
            redeclare package Medium = Medium,
            control_m_flow=true,
            allowFlowReversal=false,
            control_dp=false) "Fixed air exfiltration rate" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={10,-50})));
        equation
          connect(airExfiltration.m_flow_in, airInfiltration.m_flow_in)
            annotation (Line(points={{2,-56},{-18,-56},{-18,-44}},  color={0,0,127}));
          connect(airExfiltration.port_b, bou.ports[2])
            annotation (Line(points={{10,-40},{10,0},{2,0}},  color={0,127,255}));
          connect(airExfiltration.port_a, ports[2]) annotation (Line(points={{10,-60},{10,
                  -100},{22,-100},{22,-100}},
                                            color={0,127,255}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
January 25, 2019, Filip Jorissen:<br/>
Added constant <code>prescribesPressure</code> that indicates
whether this model prescribes the zone air pressure or not.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/971\">#971</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
First version.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents an air tight zone.  
A fixed mass flow rate, 
corresponding to air infiltration, is injected into and extracted from the zone.
The mass flow rate is computed from the zone <code>n50</code> value.
No other air leakage is modelled.
</p>
</html>"),         Icon(graphics={
                Rectangle(
                  extent={{-70,40},{-100,0}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward,
                  pattern=LinePattern.None)}));
        end n50Tight;
      end InterzonalAirFlow;

      package LightingControl
      "Models for defining the lighting control that is present"
      extends Modelica.Icons.Package;

        package BaseClasses "Base classes"
        extends Modelica.Icons.BasesPackage;

          partial block PartialLightingControl
            "Partial for defining the lighting control"
            extends Modelica.Blocks.Icons.Block;
            parameter Boolean useCtrInput= false
              "=true to use external control input";
            parameter Boolean useOccInput= false
              "=true to use occupancy input";
            parameter Boolean linearise
              "For linearisation checks";
            Modelica.Blocks.Interfaces.RealOutput ctrl "Lighting control signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));
            Modelica.Blocks.Interfaces.RealInput ligCtr if useCtrInput
              "External lighting control input"
              annotation (Placement(transformation(extent={{-140,-40},{-100,0}})));
            Modelica.Blocks.Interfaces.RealInput nOcc if   useOccInput
              "Number of occupants"
              annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
            annotation (Icon(graphics,
                             coordinateSystem(preserveAspectRatio=false)), Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
August 28, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",           info="<html>
<p>
Partial for defining the lighting control.
</p>
</html>"));
          end PartialLightingControl;
        end BaseClasses;

        block Fixed "Fixed lighting"
          extends BaseClasses.PartialLightingControl(
            final useCtrInput=false,
            final useOccInput=false);
          parameter Real ctrFix(min=0)=0
            "Fixed control signal";
          outer BoundaryConditions.SimInfoManager       sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          Modelica.Blocks.Math.Product product "For LIDEAS"
            annotation (Placement(transformation(extent={{40,10},{60,-10}})));
          Modelica.Blocks.Sources.Constant constCtrl(final k=ctrFix)
            "Constant block for lighting control"
            annotation (Placement(transformation(extent={{
                    -12,-10},{8,10}})));
      protected
          IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(
            final numSolBus=sim.numIncAndAziInBus,
            final outputAngles=sim.outputAngles)
            annotation (Placement(transformation(extent={{-74,82},{-54,102}})));
        equation
          connect(product.u2,weaBus. dummy) annotation (Line(points={{38,6},{24,6},{24,
                  92.05},{-63.95,92.05}},
                                   color={0,0,127}));
          connect(sim.weaBus,weaBus)  annotation (Line(
              points={{-81,93},{-74,93},{-74,92},{-64,92}},
              color={255,204,51},
              thickness=0.5));
          connect(constCtrl.y, product.u1)
            annotation (Line(points={{9,0},{20,0},{20,-6},{38,-6}}, color={0,0,127}));
          connect(product.y, ctrl)
            annotation (Line(points={{61,0},{120,0}}, color={0,0,127}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
August 28, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",         info="<html>
<p>
This block implements a fixed lighting control signal.
</p>
</html>"));
        end Fixed;
      annotation (Documentation(revisions="<html>
<ul>
<li>
August 28, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>"));
      end LightingControl;

      package LightingType
      "Records for defining the properties of the lighting"

        package BaseClasses "Base classes"
        extends Modelica.Icons.BasesPackage;

          partial record PartialLighting
            "Record for defining the lighting type"
            extends Modelica.Icons.Record;
            parameter Real radFra(min=0,max=1)
              "Radiant fraction of lighting heat exchange";
            parameter Modelica.SIunits.LuminousEfficacy K
              "Luminous efficacy, specifies the lm/W (lumen per watt) of the installed lighting";
        protected
            parameter Real conFra(min=0, max=1) = 1-radFra
              "Convective fraction of lighting heat exchange";
            annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",           info="<html>
<p>This record may be used to describe the relevant parameters of the lighting installation of a determined zone, i.e. the luminous efficacy (in<i> lm/W</i>) and the fraction between the convective and radiative heat gains.</p>
</html>"));
          end PartialLighting;
        end BaseClasses;

        record None "No lighting installed in the zone"
          extends Modelica.Icons.Record;
          extends
          IDEAS.Buildings.Components.LightingType.BaseClasses.PartialLighting(
              K = Modelica.Constants.inf,
              radFra = 0);                   //infinite to force 0 lighting gains in the lighting model
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",         info="<html>
<p>
Model in case no lighting heat gains should be modelled.
</p>
</html>"));
        end None;
      end LightingType;

      package OccupancyType
      "Records for defining the properties of the zone occupants"

        package BaseClasses "Base classes"
        extends Modelica.Icons.BasesPackage;

          partial record PartialOccupancyType
            "Record for defining the type (i.e. properties) of the occupants, used in InternalGains and Comfort models"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.Power QlatPp(min=0)
              "Sensible heat production per person";
            parameter Modelica.SIunits.Power QsenPp(min=0)
              "Latent heat production per person";
            parameter Real radFra(min=0,max=1) = 0.6
              "Radiant fraction of sensible heat exchange, default based on Ashrae fundamentals chap 18.4 for low air velocity, used for computing radiative and convective sensible heat flow rate fractions";
            parameter Real ICl(min=0) = 0.7
              "Fixed value for clothing insulation in units of clo (summer=0.5; winter=0.9), used to compute thermal comfort";
            annotation (Documentation(revisions="<html>
<ul>
<li>
January 26, 2018 by Filip Jorissen:<br/>
Revised default values. 
Record is now partial.
This is for <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",           info="<html>
<p>
This record may be used to describe the thermally relevant characteristics of the occupants. 
Following tables may be used as a guide to choose the numeric values.
Some tables and part of this documentation was copied from Buildings.Utilities.Comfort.Fanger.
</p>

<h4>Latent/sensible heat load fraction</h4>
<p>
Human heat production is dissipated through a latent (sweat secretion) and 
sensible heat load, respectively QlatPp and QsenPp in this record.
The table below provides some typical values (W per person) from ASHRAE (2009) page 18.4.
The table also provides typical values for radFra for low and high air velocities.
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Activity</th><th>QsenPp</th><th>QlatPp</th><th>radFra low</th><th>radFra high</th></tr>
<tr><td>Seated at theatre</td><td>66</td><td>31</td><td>0.6</td><td>0.27</td></tr>
<tr><td>Seated, very light work</td><td>72</td><td>45</td><td>0.6</td><td>0.27</td></tr>
<tr><td>Moderately active office work</td><td>73</td><td>59</td><td>0.58</td><td>0.38</td></tr>
<tr><td>Standing, light work, walking</td><td>73</td><td>59</td><td>0.58</td><td>0.38</td></tr>
<tr><td>Walking, standing</td><td>73</td><td>73</td><td>0.58</td><td>0.38</td></tr>
<tr><td>Light bench work (factory)</td><td>81</td><td>140</td><td>0.49</td><td>0.35</td></tr>
</table>
<br/>

<h4>Insulation for clothing ensembles</h4>
<p>
Clothing (parameter ICl) is defined in terms of clo units.  Clo is a unit used to express the thermal insulation provided by garments and clothing ensembles,
where <i>1</i> clo = <i>0.155</i> (m^2*K/W) (ASHRAE 55-92).
</p>
<p>
The following table is obtained from ASHRAE page 8.8
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Clothing ensemble</th><th>clo</th></tr>
<tr><td>ASHRAE Standard 55 Winter</td><td>0.90</td></tr>
<tr><td>ASHRAE Standard 55 Summer</td><td>0.50</td></tr>
<tr><td>Walking shorts, short-sleeve shirt</td><td>  0.36</td></tr>
<tr><td>Trousers, long-sleeve shirt</td><td> 0.61</td></tr>
<tr><td>Trousers, long-sleeve shirt, suit jacket</td><td> 0.96</td></tr>
<tr><td>Trousers, long-sleeve shirt, suit jacket, T-shirt</td><td> 1.14</td></tr>
<tr><td>Trousers, long-sleeve shirt, long-sleeve sweater, T-shirt</td><td> 1.01</td></tr>
<tr><td>Same as above + suit jacket, long underwear bottoms</td><td> 1.30</td></tr>
<tr><td>Sweat pants, sweat shirt</td><td> 0.74</td></tr>
<tr><td>Knee-length skirt, short-sleeve shirt, panty hose, sandals</td><td> 0.54</td></tr>
<tr><td>Knee-length skirt, long-sleeve shirt, full slip, panty hose</td><td> 0.67</td></tr>
<tr><td>Knee-length skirt, long-sleeve shirt, half slip, panty hose, long sleeve sweater</td><td> 1.10</td></tr>
<tr><td>Long-sleeve coveralls, T-shirt</td><td>   0.72</td></tr>
<tr><td>Insulated coveralls, long-sleeve, thermal underwear, long underwear bottoms</td><td> 1.37</td></tr>
</table>
<br/>

<h4> Metabolic rates</h4>
<p>
One met is defined as <i>58.2</i> Watts per square meter which is equal to the energy produced
per unit surface area of a seated person at rest.</p>
<p>The following table is obtained from ASHRAE (1997) page 8.6.</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Activity</th><th>W/m2 body surface area</th></tr>
<tr><td>ASHRAE Standard 55</td><td>58.2</td></tr>
<tr><td> reclining  </td><td>45</td></tr>
<tr><td> seated and quiet </td><td>60</td></tr>
<tr><td> sedentary activity (reading, writing) </td><td>60</td></tr>
<tr><td> standing, relaxed </td><td>70</td></tr>
<tr><td> office (filling while standing)</td><td>80</td></tr>
<tr><td> office (walking)</td><td>100</td></tr>
<tr><td>Sleeping</td><td>         40     </td></tr>
<tr><td>Seated quiet</td><td>   60 </td></tr>
<tr><td>Standing Relaxed</td><td>  70  </td></tr>
<tr><td>Walking 3.2 - 6.4km/h</td><td> 115-220   </td></tr>
<tr><td>Reading</td><td> 55</td></tr>
<tr><td>Writing</td><td> 60</td></tr>
<tr><td>Typing</td><td> 65</td></tr>
<tr><td>Lifting/packing</td><td>  120</td></tr>
<tr><td>Driving Car</td><td> 60-115</td></tr>
<tr><td>Driving Heavy vehicle</td><td> 185</td></tr>
<tr><td>Cooking</td><td> 95-115</td></tr>
<tr><td>Housecleaning</td><td> 115-200</td></tr>
<tr><td>Machine work</td><td> 105-235</td></tr>
<tr><td>Pick and shovel work</td><td> 235-280</td></tr>
<tr><td>Dancing-Social</td><td> 140-225</td></tr>
<tr><td>Calisthenics</td><td>  175-235</td></tr>
<tr><td>Basketball</td><td>  290-440</td></tr>
<tr><td>Wrestling</td><td>  410-505</td></tr>
</table>
<br/>
<h4>References</h4>

<ul><li>
ASHRAE Handbook, Fundamentals (SI Edition).
 American Society of Heating, Refrigerating and Air-Conditioning Engineers,
Chapter 8, Thermal Comfort; pages 8.1-8.26; Atlanta, USA, 1997.
</li>
<li>
ASHRAE Handbook, Fundamentals.
 American Society of Heating, Refrigerating and Air-Conditioning Engineers,
Chapter 18, Internal Heat Gains; pages 18.4; Atlanta, USA, 2009.
</li>
<li>
International Standards Organization (ISO).
Moderate Thermal Environments: Determination of the PMV and PPD Indices
and Specification of the Conditions for Thermal Comfort (ISO 7730).
Geneva, Switzerland: ISO. 1994.
</li>
<li>
Charles, K.E. Fanger Thermal Comfort and Draught Models. Institute for Research in Construction
National Research Council of Canada, Ottawa, K1A 0R6, Canada.
IRC Research Report RR-162. October 2003.
<a href=\"http://irc.nrc-cnrc.gc.ca/ircpubs\">http://irc.nrc-cnrc.gc.ca/ircpubs</a>.
</li>
<li>
Data, References and Links at: Thermal Comfort; Dr. Sam C M Hui
Department of Mechanical Engineering
The University of Hong Kong MEBS6006 Environmental Services I;
<a href=\"http://me.hku.hk/msc-courses/MEBS6006/index.html\">
http://me.hku.hk/msc-courses/MEBS6006/index.html</a>
</li>
</ul>

</html>"));
          end PartialOccupancyType;
        end BaseClasses;

        record OfficeWork
          "Properties for typical office work."
          extends
          IDEAS.Buildings.Components.OccupancyType.BaseClasses.PartialOccupancyType(
            QlatPp=45,
            QsenPp=73,
            radFra=0.6,
            ICl=0.7);
          annotation (Documentation(revisions="<html>
<ul>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",         info="<html>
<p>
See documentation in IDEAS.Buildings.Components.OccupancyType.PartialOccupancyType.
This model is based on Fanger and Ashrae Fundamentals (2009).
</p>
<h4>References</h4>
<ul>
<li>
ASHRAE Handbook, Fundamentals.
 American Society of Heating, Refrigerating and Air-Conditioning Engineers,
Chapter 18, Internal Heat Gains; pages 18.4; Atlanta, USA, 2009.
</li>
</ul>
</html>"));
        end OfficeWork;
      end OccupancyType;

      package Occupants
      "Models for defining the number of occupants that are present"
      extends Modelica.Icons.Package;

        package BaseClasses "Base classes"
        extends Modelica.Icons.BasesPackage;

          partial block PartialOccupants "Partial for defining the number of occupants"
            extends Modelica.Blocks.Icons.Block;
            parameter Boolean useInput= false
              "=true to use external input";
            parameter Boolean linearise
              "For linearisation checks";
            parameter Modelica.SIunits.Area A
              "Zone surface area";
            Modelica.Blocks.Interfaces.RealOutput nOcc "Number of occupants"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));
            Modelica.Blocks.Interfaces.RealInput yOcc if   useInput
              "Input for number of occupants"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            annotation (Icon(graphics,
                             coordinateSystem(preserveAspectRatio=false)), Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
March 28, 2019 by Filip Jorissen:<br/>
Added parameter <code>A</code> 
for <a href=\"https://github.com/open-ideas/IDEAS/issues/998\">#998</a>.
</li>
<li>
July 26, 2018 by Filip Jorissen:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
</ul>
</html>"));
          end PartialOccupants;
        end BaseClasses;

        block Fixed "Fixed number of occupants"
          extends BaseClasses.PartialOccupants(final useInput=false);
          outer BoundaryConditions.SimInfoManager       sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          parameter Real nOccFix(min=0)=0
            "Fixed number of occupants";
          Modelica.Blocks.Sources.Constant constOcc(final k=nOccFix)
            "Constant block for number of occupants"
            annotation (Placement(transformation(extent={{-10,-16},{10,4}})));
          Modelica.Blocks.Math.Product product "For LIDEAS"
            annotation (Placement(transformation(extent={{40,10},{60,-10}})));
      protected
          Interfaces.WeaBus weaBus(numSolBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
            annotation (Placement(transformation(extent={{-74,82},{-54,102}})));
        equation
          connect(sim.weaBus, weaBus) annotation (Line(
              points={{-81,93},{-74,93},{-74,92},{-64,92}},
              color={255,204,51},
              thickness=0.5));
          connect(product.u1, constOcc.y)
            annotation (Line(points={{38,-6},{11,-6}},color={0,0,127}));
          connect(product.y, nOcc)
            annotation (Line(points={{61,0},{120,0}}, color={0,0,127}));
          connect(product.u2, weaBus.dummy) annotation (Line(points={{38,6},{24,6},{24,
                  92.05},{-63.95,92.05}},
                                   color={0,0,127}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
August 21, 2018 by Damien Picard: <br/> 
Multiplied the occupant number with the dummy variable to 
avoid the suppression of it while linearizing in LIDEAS.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/812\">#812</a>.
</li>
<li>
July 26, 2018 by Filip Jorissen:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
</ul>
</html>"));
        end Fixed;
      end Occupants;

      model OuterWall "Opaque building envelope construction"
         extends IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface(
           final nWin=1,
           dT_nominal_a=-3,
           QTra_design(fixed=false));
        parameter Boolean linExtCon=sim.linExtCon
          "= true, if exterior convective heat transfer should be linearised (uses average wind speed)"
          annotation(Dialog(tab="Convection"));
        parameter Boolean linExtRad=sim.linExtRad
          "= true, if exterior radiative heat transfer should be linearised"
          annotation(Dialog(tab="Radiation"));
        parameter Boolean hasBuildingShade = false
          "=true, to enable computation of shade cast by opposite building or object"
          annotation(Dialog(group="Building shade"));
        parameter Modelica.SIunits.Length L(min=0)=0
          "Distance between object and wall, perpendicular to wall"
          annotation(Dialog(group="Building shade",enable=hasBuildingShade));
        parameter Modelica.SIunits.Length dh(min=-hWal)=0
          "Height difference between top of object and top of wall"
          annotation(Dialog(group="Building shade",enable=hasBuildingShade));
        parameter Modelica.SIunits.Length hWal(min=0)=0 "Wall height"
          annotation(Dialog(group="Building shade",enable=hasBuildingShade));
        final parameter Real U_value=1/(1/8 + sum(constructionType.mats.R) + 1/25)
          "Wall U-value";
        replaceable IDEAS.Buildings.Components.Shading.BuildingShade shaType(
          final L=L,
          final dh=dh,
          final hWin=hWal) if hasBuildingShade
        constrainedby
        IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
          final azi=azi)
          "Building shade model"
          annotation (Placement(transformation(extent={{-72,-8},{-62,12}})),
            __Dymola_choicesAllMatching=true,
            Dialog(tab="Advanced",group="Shading"));
    protected
        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.ExteriorConvection
          extCon(               linearise=linExtCon or sim.linearise, final A=A)
          "convective surface heat transimission on the exterior side of the wall"
          annotation (Placement(transformation(extent={{-22,-28},{-42,-8}})));
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorSolarAbsorption
          solAbs(A=A)
          "determination of absorbed solar radiation by wall based on incident radiation"
          annotation (Placement(transformation(extent={{-22,-8},{-42,12}})));
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorHeatRadiation
          extRad(               linearise=linExtRad or sim.linearise, final A=A)
          "determination of radiant heat exchange with the environment and sky"
          annotation (Placement(transformation(extent={{-22,12},{-42,32}})));
        BoundaryConditions.SolarIrradiation.RadSolData radSolData(
          inc=inc,
          azi=azi,
          lat=sim.lat,
          final outputAngles=sim.outputAngles,
          incAndAziInBus=sim.incAndAziInBus,
          numIncAndAziInBus=sim.numIncAndAziInBus,
          useLinearisation=sim.lineariseDymola)
          annotation (Placement(transformation(extent={{-100,-6},{-80,14}})));
        Modelica.Blocks.Routing.RealPassThrough Tdes "Design temperature passthrough";
        Modelica.Blocks.Math.Add solDif(final k1=1, final k2=1)
          "Sum of ground and sky diffuse solar irradiation"
          annotation (Placement(transformation(extent={{-54,0},{-46,8}})));
      initial equation
        QTra_design =U_value*A*(273.15 + 21 - Tdes.y);
      equation
        if hasBuildingShade then
          assert(L>0, "Shading is enabled in " + getInstanceName() +
          ": Provide a value for L, the distance to the shading object, that is larger than 0.");
          assert(not sim.lineariseDymola, "Shading is enabled in " + getInstanceName() +
          " but this is not supported when linearising a model.");
          assert(hWal>0, "Shading is enabled in " + getInstanceName() +
          ": Provide a value for hWal, the wall height, that is larger than 0.");
        end if;
        connect(extCon.port_a, layMul.port_b) annotation (Line(
            points={{-22,-18},{-18,-18},{-18,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(solAbs.port_a, layMul.port_b) annotation (Line(
            points={{-22,2},{-12,2},{-12,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(extRad.port_a, layMul.port_b) annotation (Line(
            points={{-22,22},{-18,22},{-18,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layMul.iEpsSw_b,solAbs. epsSw) annotation (Line(
            points={{-10,4},{-16,4},{-16,8},{-22,8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(layMul.iEpsLw_b,extRad. epsLw) annotation (Line(
            points={{-10,8},{-16,8},{-16,25.4},{-22,25.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.weaBus, propsBusInt.weaBus) annotation (Line(
            points={{-80,12},{-80,19.91},{56.09,19.91}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(radSolData.Tenv,extRad. Tenv) annotation (Line(
            points={{-79.4,2},{-70,2},{-70,38},{-22,38},{-22,28}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(extCon.Te, propsBusInt.weaBus.Te) annotation (Line(
            points={{-22,-22.8},{56.09,-22.8},{56.09,19.91}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(extCon.hConExt, propsBusInt.weaBus.hConExt) annotation (Line(
            points={{-22,-27},{56.09,-27},{56.09,19.91}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(Tdes.u, propsBusInt.weaBus.Tdes);
        connect(solDif.y, solAbs.solDif) annotation (Line(points={{-45.6,4},{-42,4}},
                                     color={0,0,127}));
        connect(radSolData.angInc, shaType.angInc) annotation (Line(
            points={{-79.4,0},{-76,0},{-76,-2},{-72,-2}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.angAzi, shaType.angAzi) annotation (Line(
            points={{-79.4,-4},{-78,-4},{-78,-6},{-72,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.angZen, shaType.angZen) annotation (Line(
            points={{-79.4,-2},{-76,-2},{-76,-4},{-72,-4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.HDirTil, shaType.HDirTil) annotation (Line(points={{-79.4,8},
                {-72,8}},                            color={0,0,127}));
        connect(radSolData.HSkyDifTil, shaType.HSkyDifTil) annotation (Line(points={{-79.4,6},
                {-72,6}},                                  color={0,0,127}));
        connect(radSolData.HGroDifTil, shaType.HGroDifTil) annotation (Line(points={{-79.4,4},
                {-72,4}},                                  color={0,0,127}));
        if not hasBuildingShade then
          connect(solDif.u1, radSolData.HSkyDifTil) annotation (Line(points={{-54.8,
                  6.4},{-55.3,6.4},{-55.3,6},{-79.4,6}},
                                                  color={0,0,127}));
          connect(solDif.u2, radSolData.HGroDifTil) annotation (Line(points={{-54.8,
                  1.6},{-55.3,1.6},{-55.3,4},{-79.4,4}},
                                                  color={0,0,127}));
          connect(solAbs.solDir, radSolData.HDirTil)
            annotation (Line(points={{-42,8},{-79.4,8}}, color={0,0,127}));
        end if;
        connect(shaType.HShaDirTil, solAbs.solDir)
          annotation (Line(points={{-62,8},{-42,8}},           color={0,0,127}));
        connect(shaType.HShaSkyDifTil, solDif.u1) annotation (Line(points={{-62,6},{
                -54.8,6},{-54.8,6.4}},   color={0,0,127}));
        connect(shaType.HShaGroDifTil, solDif.u2) annotation (Line(points={{-62,4},{
                -56,4},{-56,1.6},{-54.8,1.6}},   color={0,0,127}));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-50,-90},{50,80}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-50,60},{-30,60},{-30,80},{50,80},{50,100},{-50,100},{-50,60}},
                pattern=LinePattern.None,
                lineThickness=0.5,
                smooth=Smooth.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward),
              Rectangle(
                extent={{-30,-70},{-50,-20}},
                lineThickness=0.5,
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None),
              Line(
                points={{-50,60},{-50,66},{-50,100},{50,100}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,60},{-30,60},{-30,80},{50,80}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,-20},{-30,-20},{-30,-70},{-30,-70},{52,-70}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,-20},{-50,-90},{50,-90}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-44,60},{-30,60},{-30,80},{-28,80},{50,80}},
                pattern=LinePattern.None,
                thickness=0.5,
                smooth=Smooth.None),
              Line(
                points={{-44,-20},{-30,-20},{-30,-70}},
                pattern=LinePattern.None,
                thickness=0.5,
                smooth=Smooth.None),
              Line(
                points={{-44,60},{-44,-20}},
                smooth=Smooth.None,
                color={175,175,175}),
              Line(
                points={{-44,-20},{-30,-20},{-30,-70}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-44,60},{-30,60},{-30,80},{50,80}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5)}),
          Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                  100}})),
          Documentation(info="<html>
<p>
This is the main wall model that should be used to
simulate a wall or roof between a zone and the outside environment.
</p>
<h4>Typical use and important parameters</h4>
<p>
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>
IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces.
</p>
<p>
In addition to these parameters, this model computes the shade cast by an outside
object such as a building using 
<a href=\"IDEAS.Buildings.Components.Shading.BuildingShade\">IDEAS.Buildings.Components.Shading.BuildingShade</a>
if parameter <code>hasBuildingShade=true</code>.
Values for parameters <code>L</code>, <code>dh</code> and <code>hWal</code> then have to be specified.
</p>
<h4>Options</h4>
<p>
The model <a href=\"IDEAS.Buildings.Components.Shading.BuildingShade\">IDEAS.Buildings.Components.Shading.BuildingShade</a> 
is implemented by default but it can be redeclared in the advanced tab. 
In this case the user still has to provide values for <code>L</code>, <code>dh</code> and <code>hWal</code>
to avoid failing an assert that verifies the parameter consistency. The values are however not used in this case.
The correct shading parameter values should then be passed through the redeclaration.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
Set nWin final to 1 as this should only be used for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. 
</li>
<li>
May 29, 2018 by Filip Jorissen:<br/>
Added building shade implementation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/576\">
#576</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
January 2, 2017, by Filip Jorissen:<br/>
Updated icon layer.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
      end OuterWall;

      model RectangularZoneTemplate
        "Rectangular zone including walls, floor and ceiling"
        extends
        IDEAS.Buildings.Components.Interfaces.RectangularZoneTemplateInterface;

        Modelica.Blocks.Interfaces.RealInput ctrlA if
                                                     shaTypA.controlled
          "Control input for windows in face A, if controlled"
          annotation (Placement(transformation(extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-171,-111}), iconTransformation(
              extent={{-11,-11},{11,11}},
              rotation=-90,
              origin={84,112})));
        Modelica.Blocks.Interfaces.RealInput ctrlB if
                                                     shaTypB.controlled
          "Control input for windows in face B, if controlled" annotation (Placement(
              transformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-155,-111}), iconTransformation(extent={{123,-99},{101,-77}},
                rotation=0)));
        Modelica.Blocks.Interfaces.RealInput ctrlC if
                                                     shaTypC.controlled
          "Control input for windows in face C, if controlled" annotation (Placement(
              transformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-139,-111}), iconTransformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-88,-112})));
        Modelica.Blocks.Interfaces.RealInput ctrlD if
                                                     shaTypD.controlled
          "Control input for windows in face D, if controlled" annotation (Placement(
              transformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-123,-111}), iconTransformation(
              extent={{11,-11},{-11,11}},
              rotation=180,
              origin={-112,72})));
        Modelica.Blocks.Interfaces.RealInput ctrlCei if
                                                     shaTypCei.controlled
          "Control input for windows in ceiling, if controlled" annotation (Placement(
              transformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-107,-111}), iconTransformation(
              extent={{-11,-11},{11,11}},
              rotation=-90,
              origin={50,82})));


      replaceable
        IDEAS.Buildings.Components.Window winA(azi=aziA, inc=IDEAS.Types.Tilt.Wall,
          glazing(
            nLay=glazingA.nLay,
            mats=glazingA.mats,
            SwAbs=glazingA.SwAbs,
            SwTrans=glazingA.SwTrans,
            SwAbsDif=glazingA.SwAbsDif,
            SwTransDif=glazingA.SwTransDif,
            U_value=glazingA.U_value,
            g_value=glazingA.g_value),
          A=A_winA,
          frac=fracA,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
        controlled=shaTypA.controlled,
        shaType=shaTypA.shaType,
        hWin=shaTypA.hWin,
        wWin=shaTypA.wWin,
        wLeft=shaTypA.wLeft,
        wRight=shaTypA.wRight,
        ovDep=shaTypA.ovDep,
        ovGap=shaTypA.ovGap,
        hFin=shaTypA.hFin,
        finDep=shaTypA.finDep,
        finGap=shaTypA.finGap,
        L=shaTypA.L,
        dh=shaTypA.dh,
        shaCorr=shaTypA.shaCorr)),
          fraType(present=fraTypA.present,
                  U_value=fraTypA.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinA) if
             hasWinA constrainedby Window(
             azi=aziA,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinA)
          "Window for face A of this zone"
          annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinA,
            choicesAllMatching=true,
            Placement(transformation(extent={{-100,0},{-90,20}})));
        replaceable
        IDEAS.Buildings.Components.Window winB(
            inc=IDEAS.Types.Tilt.Wall,
          glazing(
            nLay=glazingB.nLay,
            mats=glazingB.mats,
            SwAbs=glazingB.SwAbs,
            SwTrans=glazingB.SwTrans,
            SwAbsDif=glazingB.SwAbsDif,
            SwTransDif=glazingB.SwTransDif,
            U_value=glazingB.U_value,
            g_value=glazingB.g_value),
          A=A_winB,
          frac=fracB,
          azi=aziA + Modelica.Constants.pi/2,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
        controlled=shaTypB.controlled,
        shaType=shaTypB.shaType,
        hWin=shaTypB.hWin,
        wWin=shaTypB.wWin,
        wLeft=shaTypB.wLeft,
        wRight=shaTypB.wRight,
        ovDep=shaTypB.ovDep,
        ovGap=shaTypB.ovGap,
        hFin=shaTypB.hFin,
        finDep=shaTypB.finDep,
        finGap=shaTypB.finGap,
        L=shaTypB.L,
        dh=shaTypB.dh,
        shaCorr=shaTypB.shaCorr)),
          fraType(present=fraTypB.present, U_value=fraTypB.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinB) if
             hasWinB constrainedby Window(
             azi=aziB,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinB)
          "Window for face B of this zone" annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinB,
            choicesAllMatching=true,
            Placement(
              transformation(
              extent={{-5,-10},{5,10}},
              rotation=0,
              origin={-95,-10})));
        replaceable
        IDEAS.Buildings.Components.Window winC(inc=IDEAS.Types.Tilt.Wall,
          glazing(
            nLay=glazingC.nLay,
            mats=glazingC.mats,
            SwAbs=glazingC.SwAbs,
            SwTrans=glazingC.SwTrans,
            SwAbsDif=glazingC.SwAbsDif,
            SwTransDif=glazingC.SwTransDif,
            U_value=glazingC.U_value,
            g_value=glazingC.g_value),
          A=A_winC,
          frac=fracC,
          azi=aziA + Modelica.Constants.pi,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
        controlled=shaTypC.controlled,
        shaType=shaTypC.shaType,
        hWin=shaTypC.hWin,
        wWin=shaTypC.wWin,
        wLeft=shaTypC.wLeft,
        wRight=shaTypC.wRight,
        ovDep=shaTypC.ovDep,
        ovGap=shaTypC.ovGap,
        hFin=shaTypC.hFin,
        finDep=shaTypC.finDep,
        finGap=shaTypC.finGap,
        L=shaTypC.L,
        dh=shaTypC.dh,
        shaCorr=shaTypC.shaCorr)),
          fraType(present=fraTypC.present, U_value=fraTypC.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinC) if
             hasWinC constrainedby Window(
             azi=aziC,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinC)
          "Window for face C of this zone" annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinC,
            choicesAllMatching=true,
            Placement(
              transformation(
              extent={{-5,-10},{5,10}},
              rotation=0,
              origin={-95,-30})));
        replaceable
        IDEAS.Buildings.Components.Window winD(inc=IDEAS.Types.Tilt.Wall, azi=aziA +
              Modelica.Constants.pi/2*3,
          glazing(
            nLay=glazingD.nLay,
            mats=glazingD.mats,
            SwAbs=glazingD.SwAbs,
            SwTrans=glazingD.SwTrans,
            SwAbsDif=glazingD.SwAbsDif,
            SwTransDif=glazingD.SwTransDif,
            U_value=glazingD.U_value,
            g_value=glazingD.g_value),
          A=A_winD,
          frac=fracD,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
            controlled=shaTypD.controlled,
        shaType=shaTypD.shaType,
        hWin=shaTypD.hWin,
        wWin=shaTypD.wWin,
        wLeft=shaTypD.wLeft,
        wRight=shaTypD.wRight,
        ovDep=shaTypD.ovDep,
        ovGap=shaTypD.ovGap,
        hFin=shaTypD.hFin,
        finDep=shaTypD.finDep,
        finGap=shaTypD.finGap,
        L=shaTypD.L,
        dh=shaTypD.dh,
        shaCorr=shaTypD.shaCorr)),
          fraType(present=fraTypD.present, U_value=fraTypD.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinD) if
             hasWinD constrainedby Window(
             azi=aziD,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinD)
          "Window for face D of this zone" annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinD,
            choicesAllMatching=true,
            Placement(
              transformation(
              extent={{-5,-10},{5,10}},
              rotation=0,
              origin={-95,-50})));
        replaceable
        IDEAS.Buildings.Components.Window winCei(inc=IDEAS.Types.Tilt.Ceiling, azi=aziA,
          glazing(
            nLay=glazingCei.nLay,
            mats=glazingCei.mats,
            SwAbs=glazingCei.SwAbs,
            SwTrans=glazingCei.SwTrans,
            SwAbsDif=glazingCei.SwAbsDif,
            SwTransDif=glazingCei.SwTransDif,
            U_value=glazingCei.U_value,
            g_value=glazingCei.g_value),
          A=A_winCei,
          frac=fracCei,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
            controlled=shaTypCei.controlled,
        shaType=shaTypCei.shaType,
        hWin=shaTypCei.hWin,
        wWin=shaTypCei.wWin,
        wLeft=shaTypCei.wLeft,
        wRight=shaTypCei.wRight,
        ovDep=shaTypCei.ovDep,
        ovGap=shaTypCei.ovGap,
        hFin=shaTypCei.hFin,
        finDep=shaTypCei.finDep,
        finGap=shaTypCei.finGap,
        L=shaTypCei.L,
        dh=shaTypCei.dh,
        shaCorr=shaTypCei.shaCorr)),
          fraType(present=fraTypCei.present, U_value=fraTypCei.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinCei) if
             hasWinCei constrainedby Window(
             azi=aziA,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinCei)
          "Window for ceiling of this zone" annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinCei,
            choicesAllMatching=true,
            Placement(
              transformation(
              extent={{-5,-10},{5,10}},
              rotation=0,
              origin={-95,-90})));
      equation
        connect(winA.propsBus_a, propsBusInt[indWinA]) annotation (Line(
            points={{-90.8333,12},{-88,12},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));
        connect(winB.propsBus_a, propsBusInt[indWinB]) annotation (Line(
            points={{-90.8333,-8},{-88,-8},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));
        connect(winC.propsBus_a, propsBusInt[indWinC]) annotation (Line(
            points={{-90.8333,-28},{-88,-28},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));
        connect(winD.propsBus_a, propsBusInt[indWinD]) annotation (Line(
            points={{-90.8333,-48},{-88,-48},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));
        connect(winCei.propsBus_a, propsBusInt[indWinCei]) annotation (Line(
            points={{-90.8333,-88},{-88,-88},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));

        connect(ctrlCei, winCei.Ctrl) annotation (Line(points={{-107,-111},{-106.5,
                -111},{-106.5,-100},{-98.3333,-100}},
                                                color={0,0,127}));
        connect(ctrlD, winD.Ctrl) annotation (Line(points={{-123,-111},{-123,-106},{
                -124,-106},{-124,-100},{-98.3333,-100},{-98.3333,-60}},
                                                                   color={0,0,127}));
        connect(ctrlC, winC.Ctrl) annotation (Line(points={{-139,-111},{-139,-104},{
                -140,-104},{-140,-100},{-98,-100},{-98,-40},{-98.3333,-40}},
                                                                        color={0,0,127}));
        connect(ctrlB, winB.Ctrl) annotation (Line(points={{-155,-111},{-155,-100},{
                -156,-100},{-98,-100},{-98,-20},{-98.3333,-20}},        color={0,0,127}));
        connect(ctrlA, winA.Ctrl) annotation (Line(points={{-171,-111},{-171,-106},{
                -172,-106},{-172,-100},{-98.3333,-100},{-98.3333,0}},
                                                                 color={0,0,127}));



          annotation (Icon(coordinateSystem(preserveAspectRatio=false, initialScale=0.1),
              graphics={
              Text(
                extent={{-60,-72},{-30,-38}},
                lineColor={28,108,200},
                textString="Flo"),
              Text(
                extent={{120,-14},{140,20}},
                lineColor={28,108,200},
                textString="B"),
              Text(
                extent={{-10,-122},{10,-94}},
                lineColor={28,108,200},
                textString="C"),
              Text(
                extent={{-122,-14},{-102,20}},
                lineColor={28,108,200},
                textString="D"),
              Text(
                extent={{18,44},{46,80}},
                lineColor={28,108,200},
                textString="Cei"),
              Text(
                extent={{-10,114},{10,148}},
                lineColor={28,108,200},
                textString="A")}),                                     Diagram(
              coordinateSystem(preserveAspectRatio=false, extent={{-220,-100},{100,100}}),
                          graphics={
              Text(
                extent={{-220,-60},{-200,-80}},
                lineColor={28,108,200},
                textString="Floor"),
              Text(
                extent={{-220,-80},{-200,-100}},
                lineColor={28,108,200},
                textString="Ceiling"),
              Text(
                extent={{-220,-40},{-200,-60}},
                lineColor={28,108,200},
                textString="D"),
              Text(
                extent={{-220,-20},{-200,-40}},
                lineColor={28,108,200},
                textString="C"),
              Text(
                extent={{-220,0},{-200,-20}},
                lineColor={28,108,200},
                textString="B"),
              Text(
                extent={{-220,20},{-200,0}},
                lineColor={28,108,200},
                textString="A")}),
          Documentation(info="<html>
<p>
This model can be used to set up
zones with a rectangular geometry more quickly.
This template consists of a zone, four walls, a horizontal roof and a floor
and five optional windows.
Additional surfaces may also be connected through external bus connector.
For the documentation of the regular zone parameters, see the documentation of 
<a href=\"modelica://IDEAS.Buildings.Components.Zone\">IDEAS.Buildings.Components.Zone</a>.
</p>
<h4>Main equations</h4>
<p>
This model incorporates IDEAS components such as
<a href=modelica://IDEAS.Buildings.Components.OuterWall>
IDEAS.Buildings.Components.OuterWall</a> and reproduces
the same results as a model that would be constructed without 
the use of this template.
</p>
<h4>Assumption and limitations</h4>
<p>
This model assumes that the zone has a rectangular
geometry with width <code>w</code>, length <code>l</code>
and height <code>h</code>.
All walls are vertical and perpendicular to each other and both the roof and
the floor are horizontal.
</p>
<p>
The surface area of each wall is calculated by default using
the parameters <code>w</code> and <code>l</code>. If you want to split a wall
and add external walls using the external bus connector, use the overwrite
length parameters <code>lA, lB, lC, lD</code> from the <code>Face</code> tabs
such that the surface area of the wall is correct. 
Be also aware that the model
<code>slabOnGround</code> has a parameter <code>PWall</code> which specifies the
perimeter of slab on ground. The model cannot detect external walls connected
using the external bus connector. When splitting outer walls by using the external bus connector
you should update this parameter
manually using the parameter <code>PWall</code> from the <code>Advanced</code> tab.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameters width <code>w</code>, length <code>l</code>
and height <code>h</code> need to be defined
and are used to compute the dimensions of each of the surfaces.
Parameter <code>aziA</code> represents the azimuth angle
of surface A (see icon). Other surfaces are rotated (clockwise) by multiples
of ninety degrees with respect to <code>aziA</code>.
Parameter <code>nSurfExt</code> may be used
to connect additional surfaces to the template. 
When doing this, you may need to change the surface areas of
the surfaces in the template as these are not updated automatically.
</p>
<p>
Seven parameter tabs allow to specify further parameters
that are specific for each of the seven surfaces: six surfaces 
for the walls, floor and ceiling and one for an internal wall 
contained within the zone.
For each surface the surface type may be specified
using parameters <code>bouTyp*</code>.
The construction type should be defined
using <code>conTyp*</code>.
Parameter <code>hasWin*</code> may be used
for all orientations except for the floor to add
a window.
In this case the window surface area, shading and glazing 
types need to be provided.
For non-default shading a record needs to be created that specifies
the shading properties.
The surface area of the window is deducted from the surface area
of the wall such that the total surface areas add up.
</p>
<h4>Options</h4>
<p>
Advanced options are found under the <code>Advanced</code> 
parameter tab. 
The model may also be adapted further by
overriding the default parameter assignments in the template.
</p>
<p>
You can also use this model for non-rectangular zones by, for example,
using the <code>None</code> type for a wall and by adding additional walls
corresponding to a different geometry through
the external bus connector. 
This model however then does not guarantee that all parameters are consistent.
Therefore, some internal parameters of this model will need to be
updated manually.
</p>
<p>
In the parameter group <code>Windows</code>, you can redeclare the window. 
This is useful when using a window model that has a pre-configured surface area,
glazing type, frame fraction and shading. 
The parameters 
<code>azi=aziA</code>,
<code>inc=IDEAS.Types.Tilt.Wall</code>,
<code>T_start=T_start</code>,
<code>linIntCon_a=linIntCon</code>,
<code>dT_nominal_a=dT_nominal_win</code>,
<code>linExtCon=linExtCon</code>,
<code>windowDynamicsType=windowDynamicsType</code>,
<code>linExtRad=linExtRadWin</code>,
<code>nWin=nWinA</code>,
are still computed from the zone model parameters but, the
other windows parameters are those configured in the
used window model, including the window surface area.
</p>
<h4>Dynamics</h4>
<p>
This model contains wall dynamics
and a state for the zone air temperature.
The zone temperature may be set to steady state using
parameter <code>energyDynamicsAir</code>, which should
in general not be done.
The mass dynamics of the air volume
may be set to steady state by overriding the default parameter
assignment in the <code>airModel</code> submodel.
This removes small time constants
when the zone model is connected to an air flow circuit. 
</p>
<h4>Shading</h4>
<p>
In order to choose the shading of the glazing,
instead of selecting one shading type from the
dropdown menu, click on the
button right of the dropdown menu (edit). 
A menu will appear where the type of 
shading and corresponding parameters
have to be defined.
Alternatively, the shading template can be extended.
</p>
<h4>Validation</h4>
<p>
This implementation is compared with a manual implementation
in <a href=modelica://IDEAS.Buildings.Validation.Tests.ZoneTemplateVerification2>
IDEAS.Buildings.Validation.Tests.ZoneTemplateVerification2</a>.
This gives identical results.
</p>
<h4>Example</h4>
<p>
An example of how this template may be used
can be found in 
<a href=modelica://IDEAS.Examples.PPD12>IDEAS.Examples.PPD12</a>.
</p>
<h4>Implementation</h4>
<p>
Shading types need to be declared using a record instead of
by redeclaring the shading components.
This is a workaround because redeclared 
components cannot be propagated.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 5, 2019, by Damien Picard:<br/>
Correct typo in winB declaration (fraB should be fracB). 
</li>
<li>
October 26, 2018, by Filip Jorissen:<br/>
Removed use of non-existent parameter <code>aziCei</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/946\">#946</a>. 
</li>
<li>
August 26, 2018, by Damien Picard:<br/>
Move all equations except those of windows to 
<code>RectangularZoneTemplateInterface</code>
for LIDEAS.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/891\">#891</a>.
</li>
<li>
August 16, 2018, by Damien Picard:<br/>
Make windows replaceable.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/891\">#891</a>.
And correct wall surface computation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/890\">#890</a>. 
</li>
<li>
August 10, 2018, by Damien Picard:<br/>
Added parameters for scaling factors for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">#888</a>.
</li>
<li>
Adapted model to make it possible to remove walls from the template.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/880\">#880</a>.
</li>
<li>
June 13, 2018, by Filip Jorissen:<br/>
Added parameters for shade cast by external building.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/576\">#576</a>.
</li>
<li>
May 21, 2018, by Filip Jorissen:<br/>
Added parameters for air flow through cavity.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/822\">#822</a>.
</li>
<li>
April 30, 2018 by Iago Cupeiro:<br/>
Propagated boolean input connections for controlled shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/809\">#809</a>.
Shading documentation added.
</li>
<li>
July 26, 2017 by Filip Jorissen:<br/>
Added replaceable block that allows to define
the number of occupants.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
April 26, 2017, by Filip Jorissen:<br/>
Added asserts that check for illegal combinations of internal wall with exterior window.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/714>#714</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed bus parameters for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
Also removed obsolete each.
</li>
<li>
January 20, 2017 by Filip Jorissen:<br/>
Removed propagation of <code>nLay</code> and <code>nGain</code>
since this lead to warnings.
</li>
<li>
January 11, 2017 by Filip Jorissen:<br/>
Added documentation
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Added <code>linExtRadWin</code> for windows.
</li>
<li>
November 14, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
      end RectangularZoneTemplate;

      package RoomType "package for room type specifications"
      extends Modelica.Icons.Package;

        package BaseClasses
        extends Modelica.Icons.BasesPackage;

          partial record PartialRoomType
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.Illuminance Ev
              "Illuminance requirement of the zone";
            annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",           info="<html>
<p>
This record describes the function of the zone.
</p>
<p>
At this point, this record only contains the illuminance requirements of the zone.
In the future, other functionality may be added.
</p>
</html>"));
          end PartialRoomType;
        end BaseClasses;

        record Generic "Generic room type"
          extends
          IDEAS.Buildings.Components.RoomType.BaseClasses.PartialRoomType(
            Ev = 300);
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",         info="<html>
<p>Record for lighting requirements for a generic zone.
Based on standard EN 12464-1, Table 5.31 (5.31.1)</p>
</html>"));
        end Generic;
      end RoomType;

      package Shading "Shadeing devices for windows"
      extends Modelica.Icons.Package;

        model Box "Both side fins and overhang"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=false);
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length ovDep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length ovGap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length hFin(min=0)
            "Height of side fin above window"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length finDep(min=0)
            "Side fin depth perpendicular to the wall plane"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length finGap(min=0)
            "Vertical distance between side fin and window"
            annotation(Dialog(group="Side fin properties"));
          Real fraSunDir(
            final min=0,
            final max=1,
            final unit="1")
            "Fraction of window area exposed to the sun";
          Real fraSunDifSky(
            final min=0,
            final max=1,
            final unit="1")
            "Fraction of window area exposed to diffuse sun light";
          IDEAS.Buildings.Components.Shading.Overhang overhang(
            final azi=azi,
            final hWin=hWin,
            final wWin=wWin,
            final wLeft=wLeft,
            final wRight=wRight,
            final dep=ovDep,
            final gap=ovGap)
            annotation (Placement(transformation(extent={{-2,60},{8,80}})));
          IDEAS.Buildings.Components.Shading.SideFins sideFins(
            final azi=azi,
            final hWin=hWin,
            final wWin=wWin,
            final hFin=hFin,
            final dep=finDep,
            final gap=finGap)
            annotation (Placement(transformation(extent={{-4,20},{6,40}})));
      protected
            final parameter Modelica.SIunits.Area aWin = hWin*wWin "Window area";
        initial equation
            assert(ovDep > 0, "The depth of the overhang must be larger than zero. If this is not the case, just use Shading.SideFins");
            assert(finDep > 0, "The depth of the side fins must be larger than zero. If this is not the case, just use Shading.Overhang");
        equation
          fraSunDir = overhang.fraSunDir*sideFins.fraSunDir;
          fraSunDifSky = overhang.fraSunDifSky*sideFins.fraSunDif;
          HShaDirTil = HDirTil * fraSunDir;
          HShaSkyDifTil = HSkyDifTil * fraSunDifSky;
          HShaGroDifTil = HGroDifTil * sideFins.fraSunDif;
          connect(angInc, iAngInc) annotation (Line(
              points={{-60,-50},{-16,-50},{-16,-50},{40,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(overhang.angZen, angZen) annotation (Line(
              points={{-2,64},{-30,64},{-30,-70},{-60,-70}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sideFins.angInc, angInc) annotation (Line(
              points={{-4,26},{-32,26},{-32,-50},{-60,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sideFins.angZen, angZen) annotation (Line(
              points={{-4,24},{-30,24},{-30,-70},{-60,-70}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sideFins.angAzi, angAzi) annotation (Line(
              points={{-4,22},{-28,22},{-28,-90},{-60,-90}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(overhang.angAzi, angAzi) annotation (Line(
              points={{-2,62},{-28,62},{-28,-90},{-60,-90}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(overhang.angInc, angInc) annotation (Line(
              points={{-2,66},{-32,66},{-32,-50},{-60,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirTil, overhang.HDirTil) annotation (Line(points={{-60,50},{-40,50},
                  {-40,76},{-2,76}}, color={0,0,127}));
          connect(HDirTil, sideFins.HDirTil) annotation (Line(points={{-60,50},{-40,50},
                  {-40,36},{-4,36}}, color={0,0,127}));
          connect(HSkyDifTil, overhang.HSkyDifTil) annotation (Line(points={{-60,30},{-38,
                  30},{-38,74},{-2,74}}, color={0,0,127}));
          connect(HSkyDifTil, sideFins.HSkyDifTil) annotation (Line(points={{-60,30},{-38,
                  30},{-38,34},{-4,34}}, color={0,0,127}));
          connect(HGroDifTil, overhang.HGroDifTil) annotation (Line(points={{-60,10},{-36,
                  10},{-36,72},{-2,72}}, color={0,0,127}));
          connect(HGroDifTil, sideFins.HGroDifTil) annotation (Line(points={{-60,10},{-36,
                  10},{-36,32},{-4,32}}, color={0,0,127}));
          annotation (Diagram(graphics,
                              coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),  Documentation(info="<html>
<p>
Shading model that simulates a combination of both side fins and a overhang. 
The implementation is a combination of both IDEAS.Buildings.Components.Shading.Overhang 
and IDEAS.Buildings.Components.Shading.SideFins.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end Box;

        model BoxAndScreen "Box and screen shading"
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length ovDep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length ovGap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length hFin(min=0)
            "Height of side fin above window"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length finDep(min=0)
            "Side fin depth perpendicular to the wall plane"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length finGap(min=0)
            "Vertical distance between side fin and window"
            annotation(Dialog(group="Side fin properties"));
          parameter Real shaCorr=0.24 "Shortwave transmittance of shortwave radiation";
          extends IDEAS.Buildings.Components.Shading.Interfaces.DoubleShading(
              redeclare IDEAS.Buildings.Components.Shading.Screen stateShading1(
                azi=azi,
                shaCorr=shaCorr),
              redeclare IDEAS.Buildings.Components.Shading.Box stateShading2(
                azi=azi,
                hWin=hWin,
                wWin=wWin,
                wLeft=wLeft,
                wRight=wRight,
                ovDep=ovDep,
                ovGap=ovGap,
                hFin=hFin,
                finDep=finDep,
                finGap=finGap));
        initial equation
            assert(ovDep > 0, "The depth of the overhang must be larger than zero, if this is not the case: just use Shading.Screen.");
            assert(finDep > 0, "The depth of the side fins must be larger than zero, if this is not the case: just use Shading.OverhangAndScreen.");
          annotation (Diagram(graphics,
                              coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),  Documentation(info="<html>
<p>This model describes the transient behaviour of solar irradiance on a window below a non-fixed horizontal or vertical overhang combined with a controllable screen.</p>
</html>",         revisions="<html>
<ul>
<li>
July 2015, by Filip Jorissenr:<br/>
Now extending from IDEAS.Buildings.Components.Interfaces.DoubleShading.
</li>
<li>
December 2014, by Filip Jorissenr:<br/>
First implementation.
</li>
</ul>
</html>"));
        end BoxAndScreen;

        model BuildingShade
          "Component for modeling shade cast by distant objects such as buildings and treelines"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
            final controlled=false);

          parameter Modelica.SIunits.Length L(min=0)
            "Distance to object perpendicular to window"
            annotation(Dialog(group="Dimensions (see illustration in documentation)"));
          parameter Modelica.SIunits.Length dh
            "Height difference between top of object and top of window glazing"
            annotation(Dialog(group="Dimensions (see illustration in documentation)"));
          parameter Modelica.SIunits.Length hWin(min=0) = 1
            "Window height: distance between top and bottom of window glazing"
            annotation(Dialog(group="Dimensions (see illustration in documentation)"));
          parameter Real fraSha(min=0,max=1) = 1
            "Fraction of the light that is shaded, e.g. smaller than 1 for shading cast by tree lines.";
          final parameter Real fraSunDifSky(final min=0,final max=1, final unit="1") = 1-vieAngObj/(Modelica.Constants.pi/2)
            "Fraction of window area exposed to diffuse sun light";

          Real fraSunDir(final min=0,final max=1, final unit="1")
            "Fraction of window area exposed to direct sun light";

          // Computation assumes that window base is at ground level.
          // Viewing angle computed from center of glazing.
      protected
          parameter Modelica.SIunits.Angle vieAngObj = atan((hWin/2+dh)/L) "Viewing angle of opposite object";
          final parameter Modelica.SIunits.Angle rot = 0
            "Rotation angle of opposite building. Zero when parallel, positive when rotated clockwise"
            annotation(Evaluate=true);
          final parameter Real coeff = 1-fraSha "More efficient implementation";
          final parameter Real hWinInv = 1/hWin "More efficient implementation";
          Real tanZen = tan(min(angZen, Modelica.Constants.pi/2.01));
          Modelica.SIunits.Length L1 "Horizontal distance to object when following vertical plane through sun ray";
          Modelica.SIunits.Length L2 "Distance to object, taking into account sun position";
          Modelica.SIunits.Angle alt = (Modelica.Constants.pi/2) - angZen;
          Modelica.SIunits.Angle verAzi
            "Angle between downward projection of sun's rays and normal to vertical surface";

        equation
          verAzi = Modelica.Math.acos(cos(angInc)/cos(alt));
          L1 = max(0,L/cos(verAzi));
          L2 = L1*tan(alt);
          if noEvent(L2<dh) then
            fraSunDir=coeff;
          elseif noEvent(L2<dh+hWin) then
            fraSunDir=coeff + (L2-dh)*fraSha*hWinInv;
          else
            fraSunDir=1;
          end if;

          HShaDirTil=fraSunDir*HDirTil;
          HShaSkyDifTil = fraSunDifSky*HSkyDifTil;
          connect(angInc, iAngInc) annotation (Line(points={{-60,-50},{-14,-50},{-14,-50},
                  {40,-50}}, color={0,0,127}));

          connect(HGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-60,10},{40,10},{40,10}}, color={0,0,127}));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-50,-100},{50,100}}),
                graphics),
            Documentation(info="<html>
<p>
This model computes the shading cast by a building (or other object) at 
distance <code>L</code> and relative height <code>dh</code> 
on a window (or wall) with height <code>hWin</code>.
For a window this height corresponds to the window glazing height,
excluding the window frame.
Diffuse sky solar radiation is reduced
by computing a simplified view factor of the building,
which blocks the sky view.
Diffuse ground solar radiation is unaffected by this model. 
</p>
<p><img alt=\"illustration\" src=\"modelica://IDEAS/Resources/Images/Buildings/Components/Shading/BuildingShade.png\"/></p>
<h4>Assumption and limitations</h4>
<p>
This model assumes that the obstructing object is very wide (infinite) 
compared to the window/wall
and that it is parallel to the window. 
This model is inaccurate when this is not the case.
</p>
<p>
We assume that the opposite building is shaded or that its reflectivity is zero,
such that it does not reflect solar irradiation towards
the window.
Partial shading, e.g. when modelling treelines, 
can be modelled by changing the value of parameter <code>fraSha</code> accordingly.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 10, 2019 by Filip Jorissen:<br/>
Revised computation of <code>fraSunDifSky</code> to avoid
negative shading fractions.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1007\">
#1007</a>.
</li>
<li>
February 21, 2019 by Filip Jorissen:<br/>
Added parameter <code>shaFra</code> for lowering shading
fraction of the model.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/912\">
#912</a>.
</li>
<li>
September 25, 2018 by Filip Jorissen:<br/>
Clarified meaning of <code>hWin</code>
and grouped parameters with reference to documentation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/909\">
#909</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Added computation of diffuse solar shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
May 25, 2017, by Filip Jorissen:<br/>
Fixed implementation for non-south oriented windows.
</li>
<li>
December 9, 2016, by Filip Jorissen:<br/>
Fixed implementation for non-circular type building.
</li>
<li>
July 14, 2015, by Filip Jorissen:<br/>
Added documentation.
</li>
<li>
June 12, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end BuildingShade;

        model HorizontalFins "Horizontal fin shading with 2 control input options"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(final controlled=use_betaInput or use_displacementInput);

          parameter Modelica.SIunits.Length s(min=0)
            "Vertical spacing between fins";
          parameter Modelica.SIunits.Length w(min=0)
            "Fin width";
          parameter Modelica.SIunits.Length t(min=0)
            "Fin thickness";
          parameter Boolean use_displacementInput = false
            "=true, to use input for controlling the horizontal fin displacement"
            annotation(Evaluate=true);
          parameter Boolean use_betaInput = false
            "=true, to use input for fin inclination angle"
            annotation(Evaluate=true);
          parameter Modelica.SIunits.Angle beta(min=0)=0
            "Fin inclination angle: 0 for horizontal inclination, see documentation"
            annotation(Dialog(enable=not use_betaInput));

          Real shaFrac "Shaded fraction of the glazing";


      protected
          Modelica.SIunits.Length dy1 = s-sin(beta_internal)*w-cos(beta_internal)*t;
          Modelica.SIunits.Length dx = cos(beta_internal)*w-sin(beta_internal)*t;
          Modelica.SIunits.Length dz = dx/cos(angInc) "Horizontal ray displacement along the ray direction";
          Modelica.SIunits.Length dy3 = max(0,min(dz*tan(angAlt),s));

          Real dispLim=min(1,max(0,disp_internal));

          Modelica.Blocks.Interfaces.RealInput beta_internal
            "Internal variable for inclination angle";
          Modelica.Blocks.Interfaces.RealInput disp_internal
            "Internal variable for displacement fraction";
          Modelica.SIunits.Angle angAlt = Modelica.Constants.pi/2 - angZen
            "Altitude angle";

        initial equation
          if not use_betaInput then
            assert(beta >= 0 and beta < acos(t/s), "In " + getInstanceName() + ": Beta must be within the feasible range.");
          end if;
          assert(s > 0 and w > 0 and t >= 0,
           "The fin spacing, width and thickness should be positive");
          assert(not use_betaInput or not use_displacementInput,
            "In " + getInstanceName() + ": Either use_betaInput or use_displacementInput should be false.");

        equation

          if not use_betaInput then
            beta_internal = beta;
          else
            connect(beta_internal,Ctrl);
          end if;
          if not use_displacementInput then
            disp_internal=1;
          else
            connect(disp_internal,Ctrl);
          end if;

          if dy3 > dy1 then
            shaFrac = dispLim;
          else
            // The shaded part equals 100% minus the unshaded part due to displacement (1-dispLim),
            // minus the shaded fraction (disp) that is unshaded by the fins (dy1-min(dy1,dy3))/s.
            // i.e. 1 - (1-dispLim) - dispLim*(dy1-min(dy1,dy3))/s
            // after collecting terms this results in:
            shaFrac = dispLim*(1 - (dy1-min(dy1,dy3))/s);
          end if;

          HShaDirTil = (1-shaFrac)*HDirTil;
          angInc = iAngInc;
          connect(HSkyDifTil, HShaSkyDifTil);
          connect(HGroDifTil, HShaGroDifTil);

            annotation (
            Icon(graphics,
                 coordinateSystem(preserveAspectRatio=true, extent={{-50,-100},{50,100}})),
            Documentation(info="<html>
<p>
Shading model for exterior horizontal fins in front of a window,
in function of the fin angle.
</p>
<h4>Assumption and limitations</h4>
<p>
We assume that the fins fully cover the window at all times.
The fin angle should be positive.
The diffuse solar irradiation is not modified, i.e. only the direct
solar irradiation is influenced.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameter <code>t</code> is the fin thickness,
<code>s</code> is the vertical spacing between the fins and
<code>w</code> is the fin width.
If <code>use_betaInput=true</code>, 
the input <code>Ctrl</code> is used to control the angle beta,
such that <code>beta</code> in the figure equals <code>Ctrl</code>.
Note that <code>beta</code> must have radians as a unit.
If <code>use_displacementInput=true</code>,
the input <code>0 &lt; Ctrl &lt; 1</code> is used to control the horizontal
displacement of the fins.
For <code>Ctrl=0</code>, the fins are moved away from the window, 
into the plane of the figure below,
such that no sun light is blocked.
Either <code>use_displacementInput</code> or <code>use_betaInput</code>
should be false.
See the figure below for an illustration.
</p>
<h4>Dynamics</h4>
<p>
This model has no dynamics.
</p>
<h4>Implementation</h4>
<p>
The implementation is illustrated using this figure: 
<br/><img alt=\"illustration\" src=\"modelica://IDEAS/Resources/Images/Buildings/Components/Shading/HorizontalFins.PNG\"/>
</p>
</html>",         revisions="<html>
<ul>
<li>
March 18, 2019 by Filip Jorissen:<br/>
Added control option for horizontal displacement.
Fixed bug in the implementation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/992\">#992</a>.
</li>
<li>
April, 2017 by Iago Cupeiro:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end HorizontalFins;

        package Interfaces
        extends Modelica.Icons.InterfacesPackage;

          model DoubleShading "Two shading components in series"
            extends PartialShading(
              final controlled=stateShading1.controlled or
                  stateShading2.controlled);
            replaceable PartialShading stateShading1 constrainedby
            PartialShading(                                                       azi=azi)
              "First shading device"
              annotation (Placement(transformation(extent={{-28,-18},{-18,2}})));
            replaceable PartialShading stateShading2 constrainedby
            PartialShading(                                                       azi=azi)
              "Second shading device"
              annotation (Placement(transformation(extent={{-4,-18},{6,2}})));
          equation
            connect(stateShading1.angInc, angInc) annotation (Line(points={{-28,-12},{-34,
                    -12},{-34,-50},{-60,-50}}, color={0,0,127}));
            connect(stateShading1.angAzi, angAzi) annotation (Line(points={{-28,-16},{-30,
                    -16},{-30,-90},{-60,-90}}, color={0,0,127}));
            connect(stateShading1.angZen, angZen) annotation (Line(points={{-28,-14},{-32,
                    -14},{-32,-16},{-32,-70},{-60,-70}}, color={0,0,127}));
            connect(Ctrl, stateShading1.Ctrl) annotation (Line(points={{-10,-110},{-10,-80},
                    {-23,-80},{-23,-18}}, color={0,0,127}));
            connect(Ctrl,stateShading2. Ctrl) annotation (Line(points={{-10,-110},{-10,-80},
                    {1,-80},{1,-18}}, color={0,0,127}));
            connect(stateShading1.angAzi, stateShading2.angAzi)
              annotation (Line(points={{-28,-16},{-4,-16}}, color={0,0,127}));
            connect(stateShading1.angZen, stateShading2.angZen)
              annotation (Line(points={{-28,-14},{-16,-14},{-4,-14}}, color={0,0,127}));
            connect(stateShading1.iAngInc, stateShading2.angInc)
              annotation (Line(points={{-18,-12},{-11,-12},{-4,-12}}, color={0,0,127}));
            connect(stateShading2.iAngInc, iAngInc) annotation (Line(points={{6,-12},{14,-12},
                    {14,-50},{40,-50}}, color={0,0,127}));
            connect(HSkyDifTil, stateShading1.HSkyDifTil) annotation (Line(points={{-60,
                    30},{-34,30},{-34,-4},{-28,-4}}, color={0,0,127}));
            connect(HGroDifTil, stateShading1.HGroDifTil) annotation (Line(points={{-60,
                    10},{-36,10},{-36,-6},{-28,-6}}, color={0,0,127}));
            connect(stateShading2.HShaGroDifTil, HShaGroDifTil) annotation (Line(points={
                    {6,-6},{16,-6},{16,10},{40,10}}, color={0,0,127}));
            connect(stateShading2.HShaDirTil, HShaDirTil) annotation (Line(points={{6,-2},
                    {12,-2},{12,0},{12,52},{12,50},{40,50}}, color={0,0,127}));
            connect(stateShading2.HShaSkyDifTil, HShaSkyDifTil) annotation (Line(points={
                    {6,-4},{14,-4},{14,30},{40,30}}, color={0,0,127}));
            connect(stateShading1.HShaDirTil, stateShading2.HDirTil)
              annotation (Line(points={{-18,-2},{-11,-2},{-4,-2}}, color={0,0,127}));
            connect(stateShading1.HShaSkyDifTil, stateShading2.HSkyDifTil)
              annotation (Line(points={{-18,-4},{-11,-4},{-4,-4}}, color={0,0,127}));
            connect(stateShading1.HShaGroDifTil, stateShading2.HGroDifTil)
              annotation (Line(points={{-18,-6},{-12,-6},{-4,-6}}, color={0,0,127}));
            connect(HDirTil, stateShading1.HDirTil) annotation (Line(points={{-60,50},{
                    -32,50},{-32,-2},{-28,-2}}, color={0,0,127}));
            annotation (Diagram(graphics,
                                coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}})), Documentation(revisions="<html>
<ul>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
<li>
December 2014, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>This model can be extended or used if two shading models need to be combined.</p>
</html>"));
          end DoubleShading;

          partial model PartialShading "Window shading partial"
            parameter Boolean controlled=true
              "if true, shading has a control input"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.Angle azi
              "Window azimuth angle"
              annotation(Dialog(group="Window properties"));
            Modelica.Blocks.Interfaces.RealInput HDirTil
              "Direct solar illuminance on surface" annotation (Placement(
                  transformation(extent={{-80,30},{-40,70}}), iconTransformation(extent={
                      {-60,50},{-40,70}})));
            Modelica.Blocks.Interfaces.RealInput HSkyDifTil
              "Diffuse sky solar illuminance on tilted surface" annotation (Placement(
                  transformation(extent={{-80,10},{-40,50}}),  iconTransformation(extent={{-60,30},
                      {-40,50}})));
            Modelica.Blocks.Interfaces.RealInput HGroDifTil
              "Diffuse ground solar illuminance on tilted surface" annotation (Placement(
                  transformation(extent={{-80,-10},{-40,30}}), iconTransformation(extent={{-60,10},
                      {-40,30}})));
            Modelica.Blocks.Interfaces.RealInput angZen
              "Angle of incidence" annotation (
                Placement(transformation(extent={{-80,-90},{-40,-50}}),
                  iconTransformation(extent={{-60,-70},{-40,-50}})));
            Modelica.Blocks.Interfaces.RealOutput HShaDirTil
              "Shaded direct solar illuminance on surface" annotation (Placement(
                  transformation(extent={{20,30},{60,70}}), iconTransformation(extent={{
                      40,50},{60,70}})));
            Modelica.Blocks.Interfaces.RealOutput HShaSkyDifTil
              "Shaded diffuse sky solar illuminance on tilted surface" annotation (Placement(
                  transformation(extent={{20,10},{60,50}}),  iconTransformation(extent={{40,30},
                      {60,50}})));
            Modelica.Blocks.Interfaces.RealOutput HShaGroDifTil
              "Shaded diffuse ground solar illuminance on tilted surface" annotation (Placement(
                  transformation(extent={{20,-10},{60,30}}), iconTransformation(extent={{40,10},
                      {60,30}})));
            Modelica.Blocks.Interfaces.RealOutput iAngInc
              "Angle of incidence after transmittance through (possible) shading"
              annotation (Placement(transformation(extent={{20,-70},{60,-30}}),
                  iconTransformation(extent={{40,-50},{60,-30}})));
            Modelica.Blocks.Interfaces.RealInput angInc "Inclination angle" annotation (
                Placement(transformation(extent={{-80,-70},{-40,-30}}),
                  iconTransformation(extent={{-60,-50},{-40,-30}})));
            Modelica.Blocks.Interfaces.RealInput angAzi "Azimuth angle" annotation (
                Placement(transformation(extent={{-80,-110},{-40,-70}}),
                  iconTransformation(extent={{-60,-90},{-40,-70}})));
            Modelica.Blocks.Interfaces.RealInput Ctrl(min=0, max=1) if controlled
              "Control signal between 0 and 1, i.e. 1 is fully closed" annotation (
                Placement(transformation(
                  extent={{20,-20},{-20,20}},
                  rotation=-90,
                  origin={-10,-110}), iconTransformation(
                  extent={{10,-10},{-10,10}},
                  rotation=-90,
                  origin={0,-100})));
            annotation (Diagram(graphics,
                                coordinateSystem(preserveAspectRatio=false,extent={{-100,
                      -100},{100,100}})),           Icon(coordinateSystem(
                    preserveAspectRatio=true, extent={{-50,-100},{50,100}}), graphics={
                  Polygon(
                    points={{-50,80},{0,60},{4,60},{4,-20},{-50,0},{-50,80}},
                    smooth=Smooth.None,
                    pattern=LinePattern.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{4,40},{50,20},{50,-32},{20,-20},{4,-20},{4,40}},
                    smooth=Smooth.None,
                    pattern=LinePattern.None,
                    fillColor={179,179,179},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Line(
                    points={{0,60},{20,60},{20,80},{50,80}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-20},{20,-20},{20,-70},{20,-70},{50,-70}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{0,60},{0,66},{0,100},{50,100}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-20},{0,-90},{50,-90}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{4,60},{4,-20}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None)}),
              Documentation(revisions="<html>
<ul>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>",           info="<html>
<p>Partial model for shading computations.</p>
</html>"));
          end PartialShading;

          record ShadingProperties
            "Default: no shading"
            extends Modelica.Icons.Record;
            parameter Boolean controlled = false
              "if true, shading has a control input"
              annotation(Evaluate=true,
                         Dialog(enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Screen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BoxAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingType shaType=
                IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.None
              "Window shading type";
            parameter Modelica.SIunits.Length hWin(min=0, start=0)=0.01 "Window height"
              annotation(Dialog(group="Window properties"));
            parameter Modelica.SIunits.Length wWin(min=0, start=0)=0.01 "Window width"
              annotation(Dialog(group="Window properties"));
            parameter Modelica.SIunits.Length wLeft(min=0, start=0)=0.01
              "Left overhang width measured from the window corner"
              annotation(Dialog(group="Overhang properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length wRight(min=0, start=0)=0.01
              "Right overhang width measured from the window corner"
              annotation(Dialog(group="Overhang properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length ovDep(min=0, start=0)=0.01
              "Overhang depth perpendicular to the wall plane"
              annotation(Dialog(group="Overhang properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length ovGap(min=0, start=0)=0.01
              "Distance between window upper edge and overhang lower edge"
              annotation(Dialog(group="Overhang properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length hFin(min=0, start=0)=0.01
              "Height of side fin above window"
              annotation(Dialog(group="Side fin properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.SideFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box)));
            parameter Modelica.SIunits.Length finDep(min=0, start=0)=0.01
              "Side fin depth perpendicular to the wall plane"
              annotation(Dialog(group="Side fin properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.SideFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box)));
            parameter Modelica.SIunits.Length finGap(min=0, start=0)=0.01
              "Vertical distance between side fin and window"
              annotation(Dialog(group="Side fin properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.SideFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box)));
            parameter Modelica.SIunits.Length L(min=0, start=0)=0.01
              "Horizontal distance to object"
              annotation(Dialog(group="Building shade",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BuildingShade)));
            parameter Modelica.SIunits.Length dh(min=0, start=0)=0.01
              "Height difference between top of object and top of window"
              annotation(Dialog(group="Building shade",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BuildingShade)));
            parameter Real shaCorr(min=0)=0.24
              "Shortwave transmittance of shortwave radiation"
              annotation(Dialog(group="Screen",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Screen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen)));
            parameter Modelica.SIunits.Length s(min=0)=0.1
              "Vertical spacing between fins"
              annotation(Dialog(group="Horizontal fins",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length w(min=0)=0.1
              "Fin width"
                  annotation(Dialog(group="Horizontal fins",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length t(min=0)=0.01
              "Fin thickness"
                  annotation(Dialog(group="Horizontal fins",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Boolean use_betaInput = controlled
              "=true, to use input for fin inclination angle"
                  annotation(Dialog(group="Horizontal fins",
                                Evaluate = true,
                                enable= false));
            parameter Modelica.SIunits.Angle beta(min=0) = 0.01
              "Fin inclination angle: 0 for horizontal inclination, see documentation"
              annotation(Dialog(group="Horizontal fins",
                                enable= not controlled and (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            annotation (Icon(graphics,
                             coordinateSystem(preserveAspectRatio=false)), Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
Aug 2 2018, by Iago Cupeiro:<br/>
Corrected initialization bug in assert
</li>
<li>
May 4 2018, by Iago Cupeiro:<br/>
Extended with HorizontalFins and OverhangAndHorizontalFins models.
</li>
</ul>
</html>"));
          end ShadingProperties;

          type ShadingType = enumeration(
            None "None",
            BuildingShade "Buildings shade",
            Overhang "Overhang",
            SideFins "Side fins",
            Box "Box: overhang and side fins",
            Screen "Screen",
            OverhangAndScreen "Overhang and screen",
            BoxAndScreen
                    "Box and screen",
            HorizontalFins
                    "Horizontal fins",
            OverhangAndHorizontalFins
                    "Overhang and horizontal fins",
            Shading "Shading") annotation (Documentation(revisions="<html>
<ul>
<li>
May 4 2018, by Iago Cupeiro:<br/>
Extended with HorizontalFins and OverhangAndHorizontalFins models.
</li>
</ul>
</html>"));
        end Interfaces;

        model None "No solar shading"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=false);
        equation
          connect(angInc, iAngInc) annotation (Line(
              points={{-60,-50},{-16,-50},{-16,-50},{40,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirTil, HShaDirTil)
            annotation (Line(points={{-60,50},{40,50},{40,50}}, color={0,0,127}));
          connect(HSkyDifTil, HShaSkyDifTil) annotation (Line(points={{-60,30},{-17,30},
                  {-17,30},{40,30}}, color={0,0,127}));
          connect(HGroDifTil, HShaGroDifTil) annotation (Line(points={{-60,10},{-14,10},
                  {-14,10},{40,10}}, color={0,0,127}));
          annotation (Diagram(graphics,
                              coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})), Documentation(revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>",         info="<html>
<p>Use this model if you want no solar shading to be computed.</p>
</html>"));
        end None;

        model Overhang "Roof overhangs"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=false);
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length dep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length gap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          final parameter Real fraSunDifSky(final min=0,final max=1, final unit="1") = 1-vieAngOverhang/(0.5*Modelica.Constants.pi)
            "Fraction of window area exposed to diffuse sun light";
          Real fraSunDir(final min=0,final max=1, final unit="1")
            "Fraction of window area exposed to direct sun light";
      protected
          final parameter Modelica.SIunits.Area AWin= hWin*wWin "Window area";
          parameter Modelica.SIunits.Length tmpH[4](fixed=false)
            "Height rectangular sections used for superposition";
          final parameter Modelica.SIunits.Angle vieAngOverhang = atan(dep/(gap+hWin/2)) "Viewing angle of overhang";
          Modelica.SIunits.Length w
            "Either wL or wR, depending on the sun relative to the wall azimuth";
          Modelica.SIunits.Length tmpW[4]
            "Width of rectangular sections used for superpositions";
          Modelica.SIunits.Length del_L = wWin/100
            "Fraction of window dimension over which min-max functions are smoothened";
          Modelica.SIunits.Length x1
            "Horizontal distance between window side edge and shadow corner";
          Modelica.SIunits.Length x2[4]
            "Horizontal distance between window side edge and point where shadow line and window lower edge intersects";
          Modelica.SIunits.Length y1
            "Vertical distance between overhang and shadow lower edge";
          Modelica.SIunits.Length y2[4]
            "Window height (vertical distance corresponding to x2)";
          Real shdwTrnglRtio "ratio of y1 and x1";
          Modelica.SIunits.Area area[4]
            "Shaded areas of the sections used in superposition";
          Modelica.SIunits.Area shdArea "Shaded area calculated from equations";
          Modelica.SIunits.Area crShdArea "Final value for shaded area";
          Modelica.SIunits.Area crShdArea1
            "Corrected for the sun behind the surface/wall";
          Modelica.SIunits.Area crShdArea2 "Corrected for the sun below horizon";
          Modelica.SIunits.Angle alt = (Modelica.Constants.pi/2) - angZen;
          Modelica.SIunits.Angle verAzi
            "Angle between projection of sun's rays and normal to vertical surface";
        initial equation
            assert(dep > 0, "The depth of the overhang must be larger than zero.");
        initial algorithm
          for i in 1:4 loop
            tmpH[i] := gap + mod((i - 1), 2)*hWin;
          end for;
        equation
          verAzi = Modelica.Math.acos(cos(angInc)/cos(alt));
          w = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=wLeft, neg=wRight, x=angAzi-azi, deltax=0.005);
          tmpW = {w+wWin,w,w,w+wWin};
          y1*Modelica.Math.cos(verAzi) = dep*Modelica.Math.tan(alt);
          x1 = dep*Modelica.Math.tan(verAzi);
          shdwTrnglRtio*x1 = y1;
          for i in 1:4 loop
            y2[i] = tmpH[i];
            x2[i]*y1 = x1*tmpH[i];
            area[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=y1,x2=y2[i],deltaX=del_L)*tmpW[i]
              -(IDEAS.Utilities.Math.Functions.smoothMin(y1,tmpH[i],del_L)*IDEAS.Utilities.Math.Functions.smoothMin(x1=x2[i],x2=y1,deltaX=del_L)/2)
              + IDEAS.Utilities.Math.Functions.smoothMax(x1=shdwTrnglRtio*(IDEAS.Utilities.Math.Functions.smoothMin(x1=x1,x2=x2[i],deltaX=del_L) - tmpW[i]),x2=0,deltaX=del_L)*IDEAS.Utilities.Math.Functions.smoothMax(x1=(IDEAS.Utilities.Math.Functions.smoothMin(x1=x1,x2=x2[i],deltaX=del_L) - tmpW[i]),x2=0,deltaX=del_L)/2;
          end for;
          shdArea = area[4] + area[3] - area[2] - area[1];
          // correction case: Sun not in front of the wall
          crShdArea1 = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=shdArea,neg=AWin,x=(Modelica.Constants.pi/2)-verAzi,deltax=0.01);
          // correction case: Sun not above horizon
          crShdArea2 = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=shdArea,neg=AWin,x=alt,deltax=0.01);
          crShdArea=IDEAS.Utilities.Math.Functions.smoothMax(x1=crShdArea1,x2=crShdArea2,deltaX=0.01);
          fraSunDir = IDEAS.Utilities.Math.Functions.smoothMin( x1=IDEAS.Utilities.Math.Functions.smoothMax(x1=1-crShdArea/AWin,x2=0,deltaX=0.01),x2=1.0,deltaX=0.01);
          HShaDirTil = fraSunDir*HDirTil;
          HShaSkyDifTil=fraSunDifSky*HSkyDifTil;
          connect(angInc, iAngInc) annotation (Line(
              points={{-60,-50},{-14,-50},{-14,-50},{40,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HGroDifTil, HShaGroDifTil) annotation (Line(points={{-60,10},{-14,10},
                  {-14,10},{40,10}}, color={0,0,127}));
          annotation (                   Documentation(info="<html>
<p>
Shading model of an overhang above a window where
hWin is the window height,
wWin is the window width,
gap is the vertical distance between the window upper edge and the overhang,
dep is the horizontal distance between the window glazing and the overhang
and wLeft and wRight are respectively the horizontal overhang widths.
</p>
<p><img alt=\"illustration\" src=\"modelica://IDEAS/Resources/Images/Buildings/Components/Shading/Overhang.png\"/></p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Added computation of diffuse solar shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end Overhang;

        model OverhangAndHorizontalFins "Roof overhang and horizontal fins"
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length dep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length gap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length s(min=0)
            "Vertical spacing between fins"
            annotation(Dialog(group="Horizontal fin properties"));
          parameter Modelica.SIunits.Length w(min=0)
            "Fin width"
            annotation(Dialog(group="Horizontal fin properties"));
          parameter Modelica.SIunits.Length t(min=0)
            "Fin thickness"
            annotation(Dialog(group="Horizontal fin properties"));
          parameter Boolean use_betaInput = false
            "=true, to use input for fin inclination angle"
            annotation(Evaluate=true,Dialog(group="Horizontal fin properties"));
          parameter Modelica.SIunits.Angle beta(min=0)=0
            "Fin inclination angle: 0 for horizontal inclination, see documentation"
            annotation(Dialog(enable=not use_betaInput,group="Horizontal fin properties"));
          extends IDEAS.Buildings.Components.Shading.Interfaces.DoubleShading(
              redeclare HorizontalFins stateShading1(
                azi=azi,
              s=s,
              w=w,
              t=t,
              use_betaInput=use_betaInput,
              beta=beta),
              redeclare IDEAS.Buildings.Components.Shading.Overhang stateShading2(
                azi=azi,
                hWin=hWin,
                wWin=wWin,
                wLeft=wLeft,
                wRight=wRight,
                dep=dep,
                gap=gap));
        initial equation
            assert(dep > 0, "The depth of the overhang must be larger than zero, if this is not the case: just use Shading.Screen.");
          annotation (Diagram(graphics,
                              coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),  Documentation(info="<html>
<p>
Shading model for a combination of overhang and horizontal fins.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 23 2018, by Filip Jorissenr:<br/>
First implementation.
</li>
</ul>
</html>"));
        end OverhangAndHorizontalFins;

        model OverhangAndScreen "Roof overhangs and screen shading"
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length dep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length gap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          parameter Real shaCorr=0.24 "Shortwave transmittance of shortwave radiation";
          extends IDEAS.Buildings.Components.Shading.Interfaces.DoubleShading(
              redeclare IDEAS.Buildings.Components.Shading.Screen stateShading1(
                azi=azi,
                shaCorr=shaCorr),
              redeclare IDEAS.Buildings.Components.Shading.Overhang stateShading2(
                azi=azi,
                hWin=hWin,
                wWin=wWin,
                wLeft=wLeft,
                wRight=wRight,
                dep=dep,
                gap=gap));
        initial equation
            assert(dep > 0, "The depth of the overhang must be larger than zero, if this is not the case: just use Shading.Screen.");
          annotation (Diagram(graphics,
                              coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),  Documentation(info="<html>
<p>This model describes the transient behaviour of solar irradiance on a window below a non-fixed horizontal or vertical overhang combined with a controllable screen.</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 2015, by Filip Jorissenr:<br/>
Now extending from IDEAS.Buildings.Components.Interfaces.DoubleShading.
</li>
<li>
December 2014, by Filip Jorissenr:<br/>
First implementation.
</li>
</ul>
</html>"));
        end OverhangAndScreen;

        model Screen "Controllable exterior screen"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=true);

          parameter Real shaCorr=0.24 "Shortwave transmittance of shortwave radiation";

      protected
          Modelica.Blocks.Nonlinear.Limiter limiter(
            uMax=1,
            uMin=0,
            limitsAtInit=true);

        equation
          HShaDirTil = HDirTil*(1 - limiter.y);
          HShaSkyDifTil = HSkyDifTil*(1 - limiter.y) + HSkyDifTil*limiter.y*shaCorr + HDirTil*limiter.y*shaCorr;
          HShaGroDifTil = HGroDifTil*(1 - limiter.y) + HGroDifTil*limiter.y*shaCorr;

          connect(limiter.u, Ctrl);
          connect(angInc, iAngInc) annotation (Line(points={{-60,-50},{-14,-50},{-14,
                  -50},{40,-50}}, color={0,0,127}));
          annotation (
            Icon(graphics,
                 coordinateSystem(preserveAspectRatio=true, extent={{-50,-100},{50,100}})),
            Documentation(info="<html>
<p>
Shading model of a controllable screen. 
The transmitted direct solar irradiance varies linearly between [0, 1] with the control input. 
A fraction <code>shaCorr</code> is converted into diffuse light that enters the building.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end Screen;

        model Shading
          "Model that allows to select any shading option based on record"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(controlled=shaPro.controlled);
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaPro
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading properties"
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
      protected
          IDEAS.Buildings.Components.Shading.Box box(
            azi=azi,
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            ovDep=shaPro.ovDep,
            ovGap=shaPro.ovGap,
            hFin=shaPro.hFin,
            finDep=shaPro.finDep,
            finGap=shaPro.finGap) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box
            "Box shading model"                                                           annotation (Placement(transformation(extent={{-16,80},{-6,100}})));
          IDEAS.Buildings.Components.Shading.BuildingShade buildingShade(
            L=shaPro.L,
            dh=shaPro.dh,
            hWin=shaPro.hWin,
            azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BuildingShade
            "Building shade model"
            annotation (Placement(transformation(extent={{-16,60},{-6,80}})));
          IDEAS.Buildings.Components.Shading.Overhang overhang(
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            dep=shaPro.ovDep,
            gap=shaPro.ovGap,
            azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang
            "Overhang model"
            annotation (Placement(transformation(extent={{-16,40},{-6,60}})));
          IDEAS.Buildings.Components.Shading.OverhangAndScreen overhangAndScreen(
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            dep=shaPro.ovDep,
            gap=shaPro.ovGap,
            shaCorr=shaPro.shaCorr,
            azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen
            "Overhang and screen model"
            annotation (Placement(transformation(extent={{-16,20},{-6,40}})));
          IDEAS.Buildings.Components.Shading.Screen screen(
            azi=azi,
            shaCorr=shaPro.shaCorr) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Screen
            "Screen model"                                 annotation (Placement(transformation(extent={{-16,0},{-6,20}})));
          IDEAS.Buildings.Components.Shading.SideFins sideFins(
            azi=azi,
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            hFin=shaPro.hFin,
            dep=shaPro.finDep,
            gap=shaPro.finGap) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.SideFins
            "Side fin model"
            annotation (Placement(transformation(extent={{-16,-20},{-6,0}})));
          IDEAS.Buildings.Components.Shading.None none(azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.None
            "No shading model"
            annotation (Placement(transformation(extent={{-16,-40},{-6,-20}})));
          IDEAS.Buildings.Components.Shading.BoxAndScreen boxAndScreen(
            azi=azi,
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            ovDep=shaPro.ovDep,
            ovGap=shaPro.ovGap,
            hFin=shaPro.hFin,
            finDep=shaPro.finDep,
            finGap=shaPro.finGap,
            shaCorr=shaPro.shaCorr) if shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BoxAndScreen "Box and screen model"
                annotation (Placement(transformation(extent={{-16,-62},{-6,-42}})));
          IDEAS.Buildings.Components.Shading.HorizontalFins horizontalFins(
            azi=azi,
            s=shaPro.s,
            w=shaPro.w,
            t=shaPro.t,
            beta = shaPro.beta,
            use_betaInput=shaPro.use_betaInput) if shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins "Horizontal fins model"
            annotation (Placement(transformation(extent={{-16,100},{-6,120}})));
          IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins overhangAndHorizontalFins(
            s=shaPro.s,
            w=shaPro.w,
            t=shaPro.t,
            beta = shaPro.beta,
            use_betaInput=shaPro.use_betaInput,
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            dep=shaPro.ovDep,
            gap=shaPro.ovGap,
            azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins
            "Overhang and horizontal fins model"
            annotation (Placement(transformation(extent={{-16,120},{-6,140}})));
        equation
          connect(screen.Ctrl, Ctrl) annotation (Line(
              points={{-11,0},{-10,0},{-10,-110}},
              color={0,0,127},
              visible=false));
          connect(Ctrl, overhangAndScreen.Ctrl) annotation (Line(
              points={{-10,-110},{-10,20},{-11,20}},
              color={0,0,127},
              visible=false));
          connect(box.HDirTil, HDirTil)
            annotation (Line(points={{-16,96},{-60,96},{-60,50}}, color={0,0,127}));
          connect(buildingShade.HDirTil, HDirTil)
            annotation (Line(points={{-16,76},{-60,76},{-60,50}}, color={0,0,127}));
          connect(overhang.HDirTil, HDirTil)
            annotation (Line(points={{-16,56},{-60,56},{-60,50}}, color={0,0,127}));
          connect(overhangAndScreen.HDirTil, HDirTil)
            annotation (Line(points={{-16,36},{-60,36},{-60,50}}, color={0,0,127}));
          connect(screen.HDirTil, HDirTil)
            annotation (Line(points={{-16,16},{-60,16},{-60,50}}, color={0,0,127}));
          connect(sideFins.HDirTil, HDirTil)
            annotation (Line(points={{-16,-4},{-60,-4},{-60,50}}, color={0,0,127}));
          connect(box.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,94},{-60,94},{-60,30}}, color={0,0,127}));
          connect(buildingShade.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,74},{-60,74},{-60,30}}, color={0,0,127}));
          connect(overhang.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,54},{-60,54},{-60,30}}, color={0,0,127}));
          connect(overhangAndScreen.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,34},{-60,34},{-60,30}}, color={0,0,127}));
          connect(screen.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,14},{-60,14},{-60,30}}, color={0,0,127}));
          connect(sideFins.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,-6},{-60,-6},{-60,30}}, color={0,0,127}));
          connect(box.angInc, angInc)
            annotation (Line(points={{-16,86},{-60,86},{-60,-50}}, color={0,0,127}));
          connect(buildingShade.angInc, angInc)
            annotation (Line(points={{-16,66},{-60,66},{-60,-50}}, color={0,0,127}));
          connect(overhang.angInc, angInc)
            annotation (Line(points={{-16,46},{-60,46},{-60,-50}}, color={0,0,127}));
          connect(overhangAndScreen.angInc, angInc)
            annotation (Line(points={{-16,26},{-60,26},{-60,-50}}, color={0,0,127}));
          connect(screen.angInc, angInc)
            annotation (Line(points={{-16,6},{-60,6},{-60,-50}}, color={0,0,127}));
          connect(sideFins.angInc, angInc)
            annotation (Line(points={{-16,-14},{-60,-14},{-60,-50}}, color={0,0,127}));
          connect(box.angZen, angZen) annotation (Line(points={{-16,84},{-24,84},{-60,84},
                  {-60,-70}},          color={0,0,127}));
          connect(buildingShade.angZen, angZen) annotation (Line(points={{-16,64},{-24,64},
                  {-60,64},{-60,-70}},          color={0,0,127}));
          connect(overhang.angZen, angZen) annotation (Line(points={{-16,44},{-26,44},{-60,
                  44},{-60,-70}},          color={0,0,127}));
          connect(overhangAndScreen.angZen, angZen)
            annotation (Line(points={{-16,24},{-60,24},{-60,-70}}, color={0,0,127}));
          connect(screen.angZen, angAzi) annotation (Line(points={{-16,4},{-24,4},{-60,4},
                  {-60,-90}},         color={0,0,127}));
          connect(sideFins.angZen, angZen) annotation (Line(points={{-16,-16},{-24,-16},
                  {-60,-16},{-60,-70}},           color={0,0,127}));
          connect(box.angAzi, angAzi)
            annotation (Line(points={{-16,82},{-60,82},{-60,-90}}, color={0,0,127}));
          connect(buildingShade.angAzi, angAzi)
            annotation (Line(points={{-16,62},{-60,62},{-60,-90}}, color={0,0,127}));
          connect(overhang.angAzi, angAzi)
            annotation (Line(points={{-16,42},{-60,42},{-60,-90}}, color={0,0,127}));
          connect(overhangAndScreen.angAzi, angAzi)
            annotation (Line(points={{-16,22},{-60,22},{-60,-90}}, color={0,0,127}));
          connect(screen.angAzi, angAzi)
            annotation (Line(points={{-16,2},{-60,2},{-60,-90}}, color={0,0,127}));
          connect(sideFins.angAzi, angAzi)
            annotation (Line(points={{-16,-18},{-60,-18},{-60,-90}}, color={0,0,127}));
          connect(box.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,96},{40,96},{40,50}}, color={0,0,127}));
          connect(buildingShade.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,76},{40,76},{40,50}}, color={0,0,127}));
          connect(overhang.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,56},{40,56},{40,50}}, color={0,0,127}));
          connect(overhangAndScreen.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,36},{40,36},{40,50}}, color={0,0,127}));
          connect(screen.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,16},{40,16},{40,50}}, color={0,0,127}));
          connect(sideFins.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,-4},{40,-4},{40,50}}, color={0,0,127}));
          connect(box.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,94},{40,94},{40,30}}, color={0,0,127}));
          connect(buildingShade.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,74},{40,74},{40,30}}, color={0,0,127}));
          connect(overhang.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,54},{40,54},{40,30}}, color={0,0,127}));
          connect(overhangAndScreen.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,34},{40,34},{40,30}}, color={0,0,127}));
          connect(screen.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,14},{40,14},{40,30}}, color={0,0,127}));
          connect(sideFins.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,-6},{40,-6},{40,30}}, color={0,0,127}));
          connect(sideFins.iAngInc, iAngInc)
            annotation (Line(points={{-6,-14},{40,-14},{40,-50}}, color={0,0,127}));
          connect(screen.iAngInc, iAngInc)
            annotation (Line(points={{-6,6},{40,6},{40,-50}}, color={0,0,127}));
          connect(overhangAndScreen.iAngInc, iAngInc)
            annotation (Line(points={{-6,26},{40,26},{40,-50}}, color={0,0,127}));
          connect(overhang.iAngInc, iAngInc)
            annotation (Line(points={{-6,46},{40,46},{40,-50}}, color={0,0,127}));
          connect(buildingShade.iAngInc, iAngInc)
            annotation (Line(points={{-6,66},{40,66},{40,-50}}, color={0,0,127}));
          connect(box.iAngInc, iAngInc)
            annotation (Line(points={{-6,86},{40,86},{40,-50}}, color={0,0,127}));
          connect(none.HDirTil, HDirTil)
            annotation (Line(points={{-16,-24},{-60,-24},{-60,50}}, color={0,0,127}));
          connect(none.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,-26},{-60,-26},{-60,30}}, color={0,0,127}));
          connect(none.angInc, angInc)
            annotation (Line(points={{-16,-34},{-60,-34},{-60,-50}}, color={0,0,127}));
          connect(none.angAzi, angAzi) annotation (Line(points={{-16,-38},{-24,-38},{-60,
                  -38},{-60,-90}}, color={0,0,127}));
          connect(none.angZen, angZen) annotation (Line(points={{-16,-36},{-28,-36},{-60,
                  -36},{-60,-70}}, color={0,0,127}));
          connect(none.iAngInc, iAngInc)
            annotation (Line(points={{-6,-34},{40,-34},{40,-50}}, color={0,0,127}));
          connect(none.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,-26},{40,-26},{40,30}}, color={0,0,127}));
          connect(none.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,-24},{40,-24},{40,50}}, color={0,0,127}));
          connect(boxAndScreen.HDirTil, HDirTil) annotation (Line(points={{-16,-46},{-36,-46},
                  {-36,50},{-60,50}}, color={0,0,127}));
          connect(boxAndScreen.HSkyDifTil, HSkyDifTil) annotation (Line(points={{-16,-48},
                  {-36,-48},{-36,30},{-60,30}},
                                      color={0,0,127}));
          connect(boxAndScreen.angInc, angInc) annotation (Line(points={{-16,-56},{-36,-56},
                  {-36,-50},{-60,-50}}, color={0,0,127}));
          connect(boxAndScreen.angZen, angZen) annotation (Line(points={{-16,-58},{-32,-58},
                  {-32,-70},{-60,-70}}, color={0,0,127}));
          connect(boxAndScreen.angAzi, angAzi) annotation (Line(points={{-16,-60},{-34,-60},
                  {-34,-90},{-60,-90}}, color={0,0,127}));
          connect(boxAndScreen.HShaDirTil, HShaDirTil) annotation (Line(points={{-6,-46},
                  {40,-46},{40,50}},color={0,0,127}));
          connect(boxAndScreen.HShaSkyDifTil, HShaSkyDifTil) annotation (Line(points={{-6,-48},
                  {40,-48},{40,30}},color={0,0,127}));
          connect(boxAndScreen.iAngInc, iAngInc) annotation (Line(points={{-6,-56},{40,-56},
                  {40,-50}},          color={0,0,127}));
          connect(Ctrl, boxAndScreen.Ctrl) annotation (Line(points={{-10,-110},{-10,-62},
                  {-11,-62}}, color={0,0,127}));
          connect(box.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,92},{-60,92},{-60,10}}, color={0,0,127}));
          connect(buildingShade.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,72},{-60,72},{-60,10}}, color={0,0,127}));
          connect(overhang.HGroDifTil, HGroDifTil) annotation (Line(points={{-16,52},{
                  -22,52},{-60,52},{-60,10}}, color={0,0,127}));
          connect(overhangAndScreen.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,32},{-60,32},{-60,10}}, color={0,0,127}));
          connect(screen.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,12},{-60,12},{-60,10}}, color={0,0,127}));
          connect(sideFins.HGroDifTil, HGroDifTil) annotation (Line(points={{-16,-8},{
                  -30,-8},{-60,-8},{-60,10}}, color={0,0,127}));
          connect(none.HGroDifTil, HGroDifTil) annotation (Line(points={{-16,-28},{-32,
                  -28},{-60,-28},{-60,10}}, color={0,0,127}));
          connect(boxAndScreen.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,-50},{-60,-50},{-60,10}}, color={0,0,127}));
          connect(box.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,92},{40,92},{40,10}}, color={0,0,127}));
          connect(buildingShade.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,72},{40,72},{40,10}}, color={0,0,127}));
          connect(overhang.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,52},{40,52},{40,10}}, color={0,0,127}));
          connect(overhangAndScreen.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,32},{40,32},{40,10}}, color={0,0,127}));
          connect(screen.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,12},{40,12},{40,10}}, color={0,0,127}));
          connect(sideFins.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,-8},{40,-8},{40,10}}, color={0,0,127}));
          connect(none.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,-28},{40,-28},{40,10}}, color={0,0,127}));
          connect(boxAndScreen.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,-50},{40,-50},{40,10}}, color={0,0,127}));
          connect(horizontalFins.Ctrl, Ctrl) annotation (Line(points={{-11,100},{-10,100},
                  {-10,-110}}, color={0,0,127}, visible=false));
          connect(horizontalFins.iAngInc, iAngInc)
            annotation (Line(points={{-6,106},{40,106},{40,-50}}, color={0,0,127}));
          connect(horizontalFins.HShaGroDifTil, HShaGroDifTil) annotation (Line(points={
                  {-6,112},{14,112},{40,112},{40,10}}, color={0,0,127}));
          connect(horizontalFins.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,114},{40,114},{40,30}}, color={0,0,127}));
          connect(horizontalFins.HShaDirTil, HShaDirTil) annotation (Line(points={{-6,116},
                  {16,116},{40,116},{40,50}},      color={0,0,127}));
          connect(HDirTil, horizontalFins.HDirTil) annotation (Line(points={{-60,50},{-60,
                  50},{-60,116},{-16,116},{-16,116}}, color={0,0,127}));
          connect(HSkyDifTil, horizontalFins.HSkyDifTil) annotation (Line(points={{-60,30},
                  {-60,30},{-60,114},{-16,114}}, color={0,0,127}));
          connect(HGroDifTil, horizontalFins.HGroDifTil) annotation (Line(points={{-60,10},
                  {-60,10},{-60,112},{-16,112}}, color={0,0,127}));
          connect(angInc, horizontalFins.angInc) annotation (Line(points={{-60,-50},{-60,
                  -50},{-60,106},{-16,106}}, color={0,0,127}));
          connect(horizontalFins.angAzi, angAzi)
            annotation (Line(points={{-16,102},{-60,102},{-60,-90}}, color={0,0,127}));
          connect(horizontalFins.angZen, angZen)
            annotation (Line(points={{-16,104},{-60,104},{-60,-70}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.Ctrl, Ctrl) annotation (Line(points={{-11,120},
                  {-10,120},{-10,-110}},            color={0,0,127}, visible=false));
          connect(overhangAndHorizontalFins.iAngInc, iAngInc)
            annotation (Line(points={{-6,126},{40,126},{40,-50}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HShaGroDifTil, HShaGroDifTil) annotation (
              Line(points={{-6,132},{16,132},{40,132},{40,10}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HShaSkyDifTil, HShaSkyDifTil) annotation (
              Line(points={{-6,134},{18,134},{40,134},{40,30}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HShaDirTil, HShaDirTil) annotation (Line(
                points={{-6,136},{38,136},{40,136},{40,50}},          color={0,0,127}));
          connect(overhangAndHorizontalFins.angAzi, angAzi)
            annotation (Line(points={{-16,122},{-60,122},{-60,-90}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.angInc, angInc) annotation (Line(points={{-16,
                  126},{-34,126},{-60,126},{-60,-50}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HGroDifTil, HGroDifTil) annotation (Line(
                points={{-16,132},{-40,132},{-60,132},{-60,10}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HSkyDifTil, HSkyDifTil) annotation (Line(
                points={{-16,134},{-36,134},{-60,134},{-60,30}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HDirTil, HDirTil) annotation (Line(points={{
                  -16,136},{-38,136},{-60,136},{-60,50}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.angZen, angZen)
            annotation (Line(points={{-16,124},{-60,124},{-60,-70}}, color={0,0,127}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
Aug 2 2018, by Iago Cupeiro:<br/>
Added missing beta parameter.
</li>
<li>
May 4 2018, by Iago Cupeiro:<br/>
Extended with HorizontalFins and OverhangAndHorizontalFins models.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
</ul>
</html>",         info="<html>
<ul>
<li>
August 22, 2018 by Filip Jorissen:<br/>
Fixed bug in implementation due to missing <code>irr</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/pull/818\">
#818</a>.
</li>
</ul>
</html>"),  Diagram(graphics,
                    coordinateSystem(extent={{-100,-100},{100,140}})),
            Icon(graphics,
                 coordinateSystem(extent={{-100,-100},{100,140}})));
        end Shading;

        model SideFins "Vertical side fins next to windows"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=false);
          // Window properties
          parameter Modelica.SIunits.Length hWin
            "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin
            "Window width"
            annotation(Dialog(group="Window properties"));
          // Sidefin properties
          parameter Modelica.SIunits.Length hFin
            "Height of side fin above window"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length dep
            "Side fin depth perpendicular to the wall plane"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length gap
            "Vertical distance between side fin and window"
            annotation(Dialog(group="Side fin properties"));
          final parameter Real fraSunDif(final min=0,final max=1, final unit="1") = 1-2*vieAngFin/Modelica.Constants.pi
            "Fraction of window area exposed to diffuse sun light";
          Real fraSunDir(final min=0,final max=1, final unit="1")
            "Fraction of window area exposed to the sun";
      protected
          final parameter Modelica.SIunits.Angle vieAngFin = atan(dep/(gap+wWin/2)) "Viewing angle of overhang";
          final parameter Modelica.SIunits.Area AWin= hWin*wWin "Window area";
          final parameter Modelica.SIunits.Length tmpH[4] = {hFin+hWin,hFin,hFin+hWin,hFin}
            "Height rectangular sections used for superposition";
          final parameter Modelica.SIunits.Length tmpW[4] = {gap+wWin,gap+wWin,gap,gap}
            "Width rectangular sections used for superposition";
          Modelica.SIunits.Length x1[4]
            "Horizontal distance between side fin and point where shadow line and window lower edge intersects";
          Modelica.SIunits.Length x2
            "Horizontal distance between side fin and shadow corner";
          Modelica.SIunits.Length x3[4] "Window width";
          Modelica.SIunits.Length y1[4] "Window height";
          Modelica.SIunits.Length y2
            "Vertical distance between window upper edge and shadow corner";
          Modelica.SIunits.Length y3[4]
            "Vertical distance between window upper edge and point where shadow line and window side edge intersects";
          Modelica.SIunits.Area area[4]
            "Shaded areas of the sections used in superposition";
          Modelica.SIunits.Area shdArea "Shaded area";
          Modelica.SIunits.Area crShdArea "Final value of shaded area";
          Modelica.SIunits.Area crShdArea1
            "Shaded area, corrected for the sun behind the surface/wall";
          Modelica.SIunits.Area crShdArea2
            "Shaded area, corrected for the sun below horizon";
          Modelica.SIunits.Length minX[4];
          Modelica.SIunits.Length minY[4];
          Modelica.SIunits.Length minX2X3[4];
          Modelica.SIunits.Length minY2Y3[4];
          Real deltaL=1e-6 "Small number to avoid division by zero";
          Modelica.SIunits.Angle alt = (Modelica.Constants.pi/2) - angZen;
          Real verAzi;
          Real lambda;
        initial equation
            assert(dep > 0, "The depth of the sidefins must be larger than zero.");
        equation
          lambda = tan(alt) / cos(verAzi);
          verAzi = Modelica.Math.acos(cos(angInc)/cos(alt));
          y2*Modelica.Math.cos(verAzi) = dep*Modelica.Math.tan(alt);
          x2 = dep*Modelica.Math.tan(verAzi);
          for i in 1:4 loop
            x1[i] = tmpH[i]/lambda;
            x3[i] = tmpW[i];
            y1[i] = tmpH[i];
            y3[i] = tmpW[i]*lambda;
            minX2X3[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=x2,x2=x3[i],deltaX=deltaL);
            minX[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=x1[i],x2=minX2X3[i],deltaX=deltaL);
            minY2Y3[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=y2,x2=y3[i],deltaX=deltaL);
            minY[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=y1[i],x2=minY2Y3[i],deltaX=deltaL);
            area[i] = tmpH[i]*minX[i] - minX[i]*minY[i]/2;
          end for;
          shdArea = area[4] - area[3] - area[2] + area[1];
          // correction case: Sun not in front of the wall
          crShdArea1 = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=shdArea,neg=AWin,x=(Modelica.Constants.pi/2)-verAzi,deltax=0.01);
          // correction case: Sun not above horizon
          crShdArea2 = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=shdArea,neg=AWin,x=alt,deltax=0.01);
          crShdArea=IDEAS.Utilities.Math.Functions.smoothMax(x1=crShdArea1,x2=crShdArea2,deltaX=0.01);
          fraSunDir = IDEAS.Utilities.Math.Functions.smoothMin( x1=IDEAS.Utilities.Math.Functions.smoothMax(x1=1-crShdArea/AWin,x2=0,deltaX=0.01),x2=1.0,deltaX=0.01);
          HShaDirTil = HDirTil * fraSunDir;
          HShaSkyDifTil = fraSunDif * HSkyDifTil;
          HShaGroDifTil = fraSunDif * HGroDifTil;
          connect(angInc, iAngInc) annotation (Line(
              points={{-60,-50},{-14,-50},{-14,-50},{40,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (                   Documentation(info="<html>
<p>
Shading model of side fins (or similar objects) 
next to a window where
hWin is the window height,
wWin is the window width,
gap equals the horizontal distances between the window edges and the side fins,
dep fin length in the direction normal to the window.
</p>
<h4>Assumption and limitations</h4>
<p>
This model computes a simplified view factor of the side fins.
The view factor determines how much diffuse light 
is blocked by the fins.
We assume that the fins do not reflect light
towards the window.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Added computation of diffuse solar shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end SideFins;
      end Shading;

      model SlabOnGround "opaque floor on ground slab"
         extends IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface(
           final nWin=1,
           QTra_design=UEqui*A    *(273.15 + 21 - sim.Tdes),
              dT_nominal_a=-3,
              inc=IDEAS.Types.Tilt.Floor,
              azi=0,
          redeclare replaceable Data.Constructions.FloorOnGround constructionType,
          layMul(disableInitPortB=true));

        parameter Modelica.SIunits.Length PWall=4*sqrt(A)
          "Total floor slab perimeter";
        parameter Modelica.SIunits.Temperature TeAvg = 273.15+10.8
          "Annual average outdoor temperature";
        parameter Modelica.SIunits.Temperature TiAvg = 273.15+22
          "Annual average indoor temperature";
        parameter Modelica.SIunits.TemperatureDifference dTeAvg = 4
          "Amplitude of variation of monthly average outdoor temperature";
        parameter Modelica.SIunits.TemperatureDifference dTiAvg = 2
          "Amplitude of variation of monthly average indoor temperature";
        parameter Boolean linearise=sim.lineariseDymola
          "= true, if heat flow to ground should be linearized"
          annotation(Dialog(tab="Convection"));
        Modelica.SIunits.HeatFlowRate Qm = if not linearise then UEqui*A*(TiAvg - TeAvg) - Lpi*dTiAvg*cos(2*3.1415/12*(m- 1 + alfa)) + Lpe*dTeAvg*cos(2*3.1415/12*(m - 1 - beta)) else
          sum({UEqui*A*(TiAvg - TeAvg) - Lpi*dTiAvg*cos(2*3.1415/12*(i- 1 + alfa)) + Lpe*dTeAvg*cos(2*3.1415/12*(i - 1 - beta)) for i in 1:12})/12
          "Two-dimensional correction for edge flow";

      //Calculation of heat loss based on ISO 13370
    protected
        final parameter IDEAS.Buildings.Data.Materials.Ground ground1(final d=0.50);
        final parameter IDEAS.Buildings.Data.Materials.Ground ground2(final d=0.33);
        final parameter IDEAS.Buildings.Data.Materials.Ground ground3(final d=0.17);
        final parameter Real U_value=1/(1/6 + sum(constructionType.mats.R) + 0)
          "Floor theoretical U-value";

        final parameter Modelica.SIunits.Length B=A/(0.5*PWall + 1E-10)
          "Characteristic dimension of the slab on ground";
        final parameter Modelica.SIunits.Length dt=sum(constructionType.mats.d) + ground1.k*1/U_value
          "Equivalent thickness";//Thickness of basement walls assumed to be as the thickness of the slab
        final parameter Real UEqui=if (dt<B) then (2*ground1.k/(Modelica.Constants.pi*B+dt)*Modelica.Math.log(Modelica.Constants.pi*B/dt+1)) else (ground1.k/(0.457*B + dt))
          "Equivalent thermal transmittance coefficient";
        final parameter Real alfa=1.5 - 12/(2*3.14)*atan(dt/(dt + delta));
        final parameter Real beta=1.5 - 0.42*log(delta/(dt + 1));
        final parameter Real delta=sqrt(3.15*10^7*ground1.k/3.14/ground1.rho/ground1.c);
        final parameter Real Lpi=A    *ground1.k/dt*sqrt(1/((1 + delta/dt)^2 + 1));
        final parameter Real Lpe=0.37*PWall*ground1.k*log(delta/dt + 1);
        Real m = sim.solTim.y/3.1536e7*12 "time in months";

        BaseClasses.ConductiveHeatTransfer.MultiLayer layGro(
          final inc=inc,
          final nLay=3,
          final mats={ground1,ground2,ground3},
          final T_start={TeAvg,TeAvg,TeAvg},
          monLay(each energyDynamics=energyDynamics),
          final A=A)
          "Declaration of array of resistances and capacitances for ground simulation"
          annotation (Placement(transformation(extent={{-20,-10},{-40,10}})));
        Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow periodicFlow(T_ref=284.15)
                      annotation (Placement(transformation(
              extent={{10,10},{-10,-10}},
              rotation=180,
              origin={-30,22})));
        Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow adiabaticBoundary(Q_flow=0,
            T_ref=285.15)
          annotation (Placement(transformation(extent={{-70,-10},{-50,10}})));
    public
        Modelica.Blocks.Math.Product product
          annotation (Placement(transformation(extent={{-30,36},{-38,44}})));
        Modelica.Blocks.Sources.RealExpression Qm_val(y=-Qm)
          annotation (Placement(transformation(extent={{0,50},{-20,70}})));
      equation

        connect(periodicFlow.port, layMul.port_b) annotation (Line(points={{-20,22},{
                -14,22},{-14,0},{-10,0}}, color={191,0,0}));
        connect(layGro.port_a, layMul.port_b)
          annotation (Line(points={{-20,0},{-15,0},{-10,0}}, color={191,0,0}));
        connect(layGro.port_b, adiabaticBoundary.port)
          annotation (Line(points={{-40,0},{-45,0},{-50,0}}, color={191,0,0}));
        connect(Qm_val.y, product.u1) annotation (Line(points={{-21,60},{-26,60},{-26,
                42.4},{-29.2,42.4}}, color={0,0,127}));
        connect(product.u2, propsBusInt.weaBus.dummy) annotation (Line(points={{-29.2,
                37.6},{56.09,37.6},{56.09,19.91}},
                                            color={0,0,127}));
        connect(product.y, periodicFlow.Q_flow) annotation (Line(points={{-38.4,40},{-50,
                40},{-50,22},{-40,22}}, color={0,0,127}));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-50,-70},{50,100}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-50,-90},{50,-70}},
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Line(
                points={{-50,-20},{-30,-20},{-30,-70},{-30,-70},{-30,-70}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,-20},{-50,-90},{-50,-90}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,60},{-30,60},{-30,80},{50,80}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,60},{-50,66},{-50,100},{50,100}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-44,60},{-44,-20}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,-70},{50,-70}},
                color={0,0,0},
                thickness=0.5,
                smooth=Smooth.None)}),
          Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false,extent={{-60,-100},{60,100}})),
          Documentation(info="<html>
<p>
This is a floor model that should be used to
simulate floors on solid ground.
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces.
</p>
<h4>Typical use and important parameters</h4>
<p>
The model contains several parameters that are used
to set up a simplified model of the influence of the 
environment on the ground themperature.
The model assumes that the floor plate is connected to a (heated)
zone that is surrounded by air at the ambient temperature.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
August 10, 2018 by Damien Picard:<br/>
Set nWin final to 1 as this should only be used for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. 
</li>
<li>
May 14, 2018, by Filip Jorissen:<br/>
Revised value of <code>energyDynamics</code>
for ground layers such that unique initial conditions
can be defined.
</li>
<li>
January 2, 2017, by Filip Jorissen:<br/>
Added default values for parameters <code>inc</code> and 
<code>azi</code>.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
December 7, 2016 by Damien Picard:<br/>
Set placeCapacityAtSurf_b to false for the last layMul layer. 
This is necessary due to the initialization which is overspecified when two capacities are
connected to each other without resistances between. 
Using dynamicFreeInitial for both the first layer of layGro and 
the last one of LayMul did not solve the problem.
</li>
<li>
September 27, 2016 by Filip Jorissen:<br/>
Different initialisation for state between layMul 
and layGround for avoiding conflicting initial equations.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
</ul>
</html>"));
      end SlabOnGround;

      package ThermalBridges "Thermal bridge models"
      extends Modelica.Icons.Package;

        package BaseClasses
        extends Modelica.Icons.BasesPackage;

          record ThermalBridge "Record data for thermal bridges"
            parameter Modelica.SIunits.ThermalConductance G "Effective thermal loss";
            parameter Boolean present = true
              annotation(Evaluate=true);
            annotation (Icon(graphics,
                             coordinateSystem(preserveAspectRatio=false)), Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false)));
          end ThermalBridge;
        end BaseClasses;

        record None "No thermal bridge included"
          extends
          IDEAS.Buildings.Components.ThermalBridges.BaseClasses.ThermalBridge(
            final G=0,
            final present=false);
          annotation (Icon(graphics,
                           coordinateSystem(preserveAspectRatio=false)), Diagram(graphics,
                coordinateSystem(preserveAspectRatio=false)));
        end None;
      end ThermalBridges;

      model Window "Multipane window"
        replaceable IDEAS.Buildings.Data.Interfaces.Glazing glazing
          constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type"
          annotation (__Dymola_choicesAllMatching=true, Dialog(group=
                "Construction details"));
        extends IDEAS.Buildings.Components.Interfaces.PartialSurface(
          dT_nominal_a=-3,
          intCon_a(final A=
                 A*(1 - frac),
                 linearise=linIntCon_a or sim.linearise,
                 dT_nominal=dT_nominal_a),
          QTra_design(fixed=false),
          Qgai(y=if sim.computeConservationOfEnergy then
                                                        (gain.propsBus_a.surfCon.Q_flow +
              gain.propsBus_a.surfRad.Q_flow + gain.propsBus_a.iSolDif.Q_flow + gain.propsBus_a.iSolDir.Q_flow) else 0),
          E(y=0),
          layMul(
            A=A*(1 - frac),
            nLay=glazing.nLay,
            mats=glazing.mats,
            energyDynamics=if windowDynamicsType == IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Normal then energyDynamics else Modelica.Fluid.Types.Dynamics.SteadyState,
            dT_nom_air=5,
            linIntCon=true));
        parameter Boolean linExtCon=sim.linExtCon
          "= true, if exterior convective heat transfer should be linearised (uses average wind speed)"
          annotation(Dialog(tab="Convection"));
        parameter Boolean linExtRad=sim.linExtRadWin
          "= true, if exterior radiative heat transfer should be linearised"
          annotation(Dialog(tab="Radiation"));
        parameter Real frac(
          min=0,
          max=1) = 0.15 "Area fraction of the window frame";
        parameter IDEAS.Buildings.Components.Interfaces.WindowDynamicsType
          windowDynamicsType=IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Two
          "Type of dynamics for glazing and frame: using zero, one combined or two states"
          annotation (Dialog(tab="Dynamics", group="Equations", enable = not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));
        parameter Real fraC = frac
          "Ratio of frame and glazing thermal masses"
          annotation(Dialog(tab="Dynamics", group="Equations", enable= not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState and windowDynamicsType == IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Two));
        parameter Boolean controlled = shaType.controlled
          " = true if shaType has a control input (see e.g. screen). Can be set to false manually to force removal of input icon."
          annotation(Dialog(tab="Advanced",group="Icon"));
        replaceable parameter IDEAS.Buildings.Data.Frames.None fraType
          constrainedby IDEAS.Buildings.Data.Interfaces.Frame "Window frame type"
          annotation (choicesAllMatching=true, Dialog(group=
                "Construction details"));
        replaceable IDEAS.Buildings.Components.Shading.None shaType constrainedby
        Shading.Interfaces.PartialShading(
                                  final azi=azi) "First shading type"  annotation (Placement(transformation(extent={{-70,-60},
                  {-60,-40}})),
            __Dymola_choicesAllMatching=true, Dialog(group="Construction details"));
        Modelica.Blocks.Interfaces.RealInput Ctrl if controlled
          "Control signal between 0 and 1, i.e. 1 is fully closed" annotation (
            Placement(transformation(
              extent={{20,-20},{-20,20}},
              rotation=-90,
              origin={-50,-110}), iconTransformation(
              extent={{10,-10},{-10,10}},
              rotation=-90,
              origin={-40,-100})));
    protected
        final parameter Real U_value=glazing.U_value*(1-frac)+fraType.U_value*frac
          "Average window U-value";
        final parameter Boolean addCapGla =  windowDynamicsType == IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Two and not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
          "Add lumped thermal capacitor for window glazing";
        final parameter Boolean addCapFra =  fraType.present and not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
          "Added lumped thermal capacitor for window frame";
        final parameter Modelica.SIunits.HeatCapacity Cgla = layMul.C
          "Heat capacity of glazing state";
        final parameter Modelica.SIunits.HeatCapacity Cfra = layMul.C*fraC
          "Heat capacity of frame state";
        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.ExteriorConvection
          eCon(final A=A*(1 - frac), linearise=linExtCon or sim.linearise)
          "convective surface heat transimission on the exterior side of the wall"
          annotation (Placement(transformation(extent={{-20,-38},{-40,-18}})));
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorHeatRadiation
          skyRad(final A=A*(1 - frac), Tenv_nom=sim.Tenv_nom,
          linearise=linExtRad or sim.linearise)
          "determination of radiant heat exchange with the environment and sky"
          annotation (Placement(transformation(extent={{-20,-10},{-40,10}})));
        replaceable
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.SwWindowResponse
          solWin(
          final nLay=glazing.nLay,
          final SwAbs=glazing.SwAbs,
          final SwTrans=glazing.SwTrans,
          final SwTransDif=glazing.SwTransDif,
          final SwAbsDif=glazing.SwAbsDif)
          annotation (Placement(transformation(extent={{-10,-60},{10,-40}})));
        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.InteriorConvection
          iConFra(final A=A*frac, final inc=inc,
          linearise=linIntCon_a or sim.linearise) if
                              fraType.present
          "convective surface heat transimission on the interior side of the wall"
          annotation (Placement(transformation(extent={{20,60},{40,80}})));
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorHeatRadiation
          skyRadFra(final A=A*frac, Tenv_nom=sim.Tenv_nom,
          linearise=linExtRad or sim.linearise) if
                               fraType.present
          "determination of radiant heat exchange with the environment and sky"
          annotation (Placement(transformation(extent={{-20,80},{-40,100}})));
        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.ExteriorConvection
          eConFra(final A=A*frac, linearise=linExtCon or sim.linearise) if
                       fraType.present
          "convective surface heat transimission on the exterior side of the wall"
          annotation (Placement(transformation(extent={{-20,60},{-40,80}})));
        Modelica.Thermal.HeatTransfer.Components.ThermalConductor layFra(final G=(if
              fraType.briTyp.present then fraType.briTyp.G else 0) + (fraType.U_value)
              *A*frac) if                fraType.present  annotation (Placement(transformation(extent={{10,60},
                  {-10,80}})));
        BoundaryConditions.SolarIrradiation.RadSolData radSolData(
          inc=inc,
          azi=azi,
          lat=sim.lat,
          outputAngles=sim.outputAngles,
          incAndAziInBus=sim.incAndAziInBus,
          numIncAndAziInBus=sim.numIncAndAziInBus)
          annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
        Modelica.Blocks.Math.Gain gainDir(k=A*(1 - frac))
          "Gain for direct solar irradiation"
          annotation (Placement(transformation(extent={{-42,-46},{-38,-42}})));
        Modelica.Blocks.Math.Gain gainDif(k=A*(1 - frac))
          "Gain for diffuse solar irradiation"
          annotation (Placement(transformation(extent={{-36,-50},{-32,-46}})));
        Modelica.Blocks.Routing.RealPassThrough Tdes
          "Design temperature passthrough since propsBus variables cannot be addressed directly";
        Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heaCapGla(
           C=Cgla, T(fixed= energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial, start=T_start)) if addCapGla
          "Heat capacitor for glazing"
          annotation (Placement(transformation(extent={{6,-12},{26,-32}})));
        Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heaCapFra(
           C=Cfra, T(fixed= energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial, start=T_start)) if addCapFra
          "Heat capacitor for frame"
          annotation (Placement(transformation(extent={{6,88},{26,108}})));
        Modelica.Blocks.Sources.Constant constEpsSwFra(final k=fraType.mat.epsSw)
          "Shortwave emissivity of frame"
          annotation (Placement(transformation(extent={{4,46},{-6,56}})));
        Modelica.Blocks.Sources.Constant constEpsLwFra(final k=fraType.mat.epsLw)
          "Shortwave emissivity of frame"
          annotation (Placement(transformation(extent={{4,86},{-6,96}})));
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorSolarAbsorption
          solAbs(A=A*frac) if fraType.present
          "Solar absorption model for shortwave radiation"
          annotation (Placement(transformation(extent={{-20,40},{-40,60}})));
        Modelica.Blocks.Math.Add solDif(final k1=1, final k2=1)
          "Sum of ground and sky diffuse solar irradiation"
          annotation (Placement(transformation(extent={{-56,-50},{-50,-44}})));
      initial equation
        QTra_design = (U_value*A + (if fraType.briTyp.present then fraType.briTyp.G else 0)) *(273.15 + 21 - Tdes.y);
      equation
        connect(eCon.port_a, layMul.port_b) annotation (Line(
            points={{-20,-28},{-14,-28},{-14,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(skyRad.port_a, layMul.port_b) annotation (Line(
            points={{-20,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(solWin.iSolDir, propsBusInt.iSolDir) annotation (Line(
            points={{-2,-60},{-2,-70},{56.09,-70},{56.09,19.91}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(solWin.iSolDif, propsBusInt.iSolDif) annotation (Line(
            points={{2,-60},{2,-70},{56.09,-70},{56.09,19.91}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(solWin.iSolAbs, layMul.port_gain) annotation (Line(
            points={{0,-40},{0,-10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layMul.iEpsLw_b, skyRad.epsLw) annotation (Line(
            points={{-10,8},{-14,8},{-14,3.4},{-20,3.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaType.Ctrl, Ctrl) annotation (Line(
            points={{-65,-60},{-50,-60},{-50,-110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(iConFra.port_b, propsBusInt.surfCon) annotation (Line(
            points={{40,70},{46,70},{46,19.91},{56.09,19.91}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layFra.port_a, iConFra.port_a) annotation (Line(
            points={{10,70},{20,70}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(skyRadFra.port_a, layFra.port_b) annotation (Line(
            points={{-20,90},{-16,90},{-16,70},{-10,70}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(eConFra.port_a, layFra.port_b) annotation (Line(
            points={{-20,70},{-10,70}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(radSolData.angInc, shaType.angInc) annotation (Line(
            points={{-79.4,-54},{-70,-54}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.angAzi, shaType.angAzi) annotation (Line(
            points={{-79.4,-58},{-70,-58}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.angZen, shaType.angZen) annotation (Line(
            points={{-79.4,-56},{-70,-56}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.weaBus, propsBusInt.weaBus) annotation (Line(
            points={{-80,-42},{-80,20},{0,20},{0,19.91},{56.09,19.91}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(radSolData.Tenv, skyRad.Tenv) annotation (Line(
            points={{-79.4,-52},{-72,-52},{-72,10},{-20,10},{-20,6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyRadFra.Tenv, skyRad.Tenv) annotation (Line(
            points={{-20,96},{-12,96},{-12,6},{-20,6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(eConFra.Te, eCon.Te) annotation (Line(
            points={{-20,65.2},{-20,66},{-16,66},{-16,-32.8},{-20,-32.8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(eCon.hConExt, eConFra.hConExt) annotation (Line(
            points={{-20,-37},{-20,-36},{-14,-36},{-14,61},{-20,61}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(eCon.Te, propsBusInt.weaBus.Te) annotation (Line(
            points={{-20,-32.8},{56.09,-32.8},{56.09,19.91}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(eCon.hConExt, propsBusInt.weaBus.hConExt) annotation (Line(
            points={{-20,-37},{56.09,-37},{56.09,19.91}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(Tdes.u, propsBusInt.weaBus.Tdes);
        connect(shaType.iAngInc, solWin.angInc) annotation (Line(points={{-60,-54},{
                -60,-54},{-10,-54}},           color={0,0,127}));
        connect(heaCapGla.port, layMul.port_a)
          annotation (Line(points={{16,-12},{16,0},{10,0}},     color={191,0,0}));
        connect(heaCapFra.port, layFra.port_a)
          annotation (Line(points={{16,88},{16,70},{10,70}}, color={191,0,0}));
        connect(skyRadFra.epsLw, constEpsLwFra.y) annotation (Line(points={{-20,93.4},
                {-14,93.4},{-14,91},{-6.5,91}}, color={0,0,127}));
        connect(solAbs.port_a, layFra.port_b) annotation (Line(points={{-20,50},{-16,
                50},{-16,70},{-10,70}},
                                    color={191,0,0}));
        connect(solAbs.epsSw, constEpsSwFra.y) annotation (Line(points={{-20,56},{-10,
                56},{-10,51},{-6.5,51}}, color={0,0,127}));
        connect(gainDir.y, solWin.solDir)
          annotation (Line(points={{-37.8,-44},{-10,-44}}, color={0,0,127}));
        connect(gainDif.y, solWin.solDif) annotation (Line(points={{-31.8,-48},{-22,
                -48},{-10,-48}}, color={0,0,127}));
        connect(radSolData.HDirTil, shaType.HDirTil) annotation (Line(points={{-79.4,
                -46},{-78,-46},{-78,-44},{-70,-44}}, color={0,0,127}));
        connect(radSolData.HSkyDifTil, shaType.HSkyDifTil) annotation (Line(points={{
                -79.4,-48},{-76,-48},{-76,-46},{-70,-46}}, color={0,0,127}));
        connect(radSolData.HGroDifTil, shaType.HGroDifTil) annotation (Line(points={{
                -79.4,-50},{-74,-50},{-74,-48},{-70,-48}}, color={0,0,127}));
        connect(shaType.HShaGroDifTil, solDif.u2) annotation (Line(points={{-60,-48},
                {-56.6,-48},{-56.6,-48.8}}, color={0,0,127}));
        connect(solDif.u1, shaType.HShaSkyDifTil) annotation (Line(points={{-56.6,
                -45.2},{-56.3,-45.2},{-56.3,-46},{-60,-46}}, color={0,0,127}));
        connect(gainDif.u, solDif.y) annotation (Line(points={{-36.4,-48},{-49.7,-48},
                {-49.7,-47}}, color={0,0,127}));
        connect(solDif.y, solAbs.solDif) annotation (Line(points={{-49.7,-47},{-48,
                -47},{-48,52},{-40,52}}, color={0,0,127}));
        connect(shaType.HShaDirTil, solAbs.solDir) annotation (Line(points={{-60,-44},
                {-60,-44},{-60,56},{-40,56}}, color={0,0,127}));
        connect(gainDir.u, shaType.HShaDirTil) annotation (Line(points={{-42.4,-44},{
                -51.2,-44},{-60,-44}}, color={0,0,127}));
          annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-50,-90},{50,100}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-46,60},{50,24},{50,-50},{-30,-20},{-46,-20},{-46,60}},
                smooth=Smooth.None,
                pattern=LinePattern.None,
                fillColor={255,255,170},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Line(
                points={{-50,60},{-30,60},{-30,80},{50,80}},
                color={175,175,175}),
              Line(
                points={{-50,-20},{-30,-20},{-30,-70},{-30,-70},{52,-70}},
                color={175,175,175}),
              Line(
                points={{-50,60},{-50,66},{-50,100},{50,100}},
                color={175,175,175}),
              Line(
                points={{-50,-20},{-50,-90},{50,-90}},
                color={175,175,175}),
              Line(
                points={{-46,60},{-46,-20}},
                color={0,0,0},
                thickness=0.5,
                smooth=Smooth.None)}),
          Diagram(graphics,
                  coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                  100}})),
          Documentation(info="<html>
<p>
This model should be used to model windows or other transparant surfaces.
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialSurface>IDEAS.Buildings.Components.Interfaces.PartialSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces and windows.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameter <code>A</code> is the total window surface area, i.e. the
sum of the frame surface area and the glazing surface area.
</p>
<p>
Parameter <code>frac</code> may be used to define the surface
area of the frame as a fraction of <code>A</code>. 
</p>
<p>
Parameter <code>glazing</code>  must be used to define the glass properties.
It contains information about the number of glass layers,
their thickness, thermal properties and emissivity.
</p>
<p>
Optional parameter <code>briType</code> may be used to compute additional line losses
along the edges of the glazing.
</p>
<p>
Optional parameter <code>fraType</code> may be used to define the frame thermal properties.
If <code>fraType = None</code> then the frame is assumed to be perfectly insulating.
</p>
<p>
Optional parameter <code>shaType</code> may be used to define the window shading properties.
</p>
<p>
The parameter <code>n</code> may be used to scale the window to <code>n</code> identical windows.
For example, if a wall has 10 identical windows with identical shading, this parameter
can be used to simulate 10 windows by scaling the model of a single window.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
Add scaling to propsBus_a to allow simulation of n windows instead of 1
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>.
</li>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Changed implementation such that control input is visible.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/761\">
#761</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
March 6, 2017, by Filip Jorissen:<br/>
Added option for using 'normal' dynamics for the window glazing.
Removed the option for having a combined state for 
window and frame this this is non-physical.
This is for 
<a href=https://github.com/open-ideas/IDEAS/issues/678>#678</a>.
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Removed declaration of 
<code>A</code> since this is now declared in 
<a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialSurface>
IDEAS.Buildings.Components.Interfaces.PartialSurface</a>.
This is for 
<a href=https://github.com/open-ideas/IDEAS/issues/609>#609</a>.
</li>
<li>
January 10, 2017 by Filip Jorissen:<br/>
Set <code>linExtRad = sim.linExtRadWin</code>.
See <a href=https://github.com/open-ideas/IDEAS/issues/615>#615</a>.
</li>
<li>
December 19, 2016, by Filip Jorissen:<br/>
Added solar irradiation on window frame.
</li>
<li>
December 19, 2016, by Filip Jorissen:<br/>
Removed briType, which had default value LineLoss.
briType is now part of the Frame model and has default
value None.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
December 17, 2015, Filip Jorissen:<br/>
Added thermal connection between frame and glazing state. 
This is required for decoupling steady state thermal dynamics
without adding a second state for the window.
</li>
<li>
July 14, 2015, Filip Jorissen:<br/>
Removed second shading device since a new partial was created
for handling this.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
      end Window;

      package ZoneAirModels "Package containing zone air models"

        package BaseClasses
          extends Modelica.Icons.BasesPackage;

          partial model PartialAirModel "Partial for air models"
            extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations(
              energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
              redeclare replaceable package Medium = IDEAS.Media.Air);
            outer IDEAS.BoundaryConditions.SimInfoManager sim
              "Simulation information manager for climate data"
              annotation (Placement(transformation(extent={{80,-100},{100,-80}})));
            parameter Integer nSurf "Number of connected surfaces";
            parameter Integer nSeg(min=1)=1 "Number of air segments";
            parameter Integer nPorts "Number of fluid port connections to zone air volume";
            parameter Modelica.SIunits.Volume Vtot "Total zone air volume";
            parameter Boolean allowFlowReversal=true
               "= false to simplify equations, assuming, but not enforcing, no flow reversal"
              annotation(Dialog(tab="Advanced"));
            parameter Modelica.SIunits.MassFlowRate m_flow_nominal
              "Nominal flow rate of the ventilation system";
            Modelica.Blocks.Interfaces.RealOutput E(unit="J") "Model internal energy";
            Modelica.Blocks.Interfaces.RealOutput QGai(unit="J/s") "Model internal energy";
            Modelica.Blocks.Interfaces.RealOutput TAir "Zone air temperature"
              annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSurf] ports_surf
              "Heat convection ports for surfaces"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] inc
              "Inclination angle of surface"
              annotation (Placement(transformation(extent={{-128,60},{-88,100}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] A
              "Surface area of surfaces"
              annotation (Placement(transformation(extent={{-126,-80},{-86,-40}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] azi
              "Azimuth of surface"
              annotation (Placement(transformation(extent={{-128,20},{-88,60}})));
            Modelica.Fluid.Interfaces.FluidPort_a port_a(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal),
              h_outflow(nominal=Medium.h_default))
              annotation (Placement(transformation(extent={{50,90},{70,110}})));
            Modelica.Fluid.Interfaces.FluidPort_b port_b(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal),
              h_outflow(nominal=Medium.h_default))
              annotation (Placement(transformation(extent={{-70,90},{-50,110}})));
            Modelica.Fluid.Interfaces.FluidPorts_a[nPorts] ports(
              redeclare each package Medium = Medium,
              each m_flow(nominal=m_flow_nominal),
              each h_outflow(nominal=Medium.h_default))
              "Ports connector for multiple ports" annotation (Placement(
                  transformation(
                  extent={{-10,-40},{10,40}},
                  rotation=90,
                  origin={0,100})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSeg] ports_air
              "Heat convection ports for air volumes"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealInput mWat_flow
              "Moisture mass flow rate being added to the zone air"
              annotation (Placement(transformation(extent={{128,60},{88,100}})));
            Modelica.Blocks.Interfaces.RealInput C_flow[max(Medium.nC,1)]
              "Trace substance mass flow rate being added to the zone air"
              annotation (Placement(transformation(extent={{128,20},{88,60}})));
            Modelica.Blocks.Interfaces.RealOutput phi(unit="1")
              "Relative humidity in the zone"
              annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
            Modelica.Blocks.Interfaces.RealOutput ppm(unit="1")
              "CO2 concentration in the zone" annotation (Placement(transformation(extent=
                     {{100,-30},{120,-10}})));
        protected
            final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
                T=Medium.T_default,
                p=Medium.p_default,
                X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
            final parameter Modelica.SIunits.Density rho_default = Medium.density(
              state=state_default) "Medium default density";
            final parameter Modelica.SIunits.SpecificHeatCapacity cp_default = Medium.specificHeatCapacityCp(state=state_default);
            annotation (Diagram(graphics,
                                coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}})), Documentation(revisions="<html>
<ul>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added output for the CO2 concentration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
July 11, 2018, Filip Jorissen:<br/>
Added <code>m_flow_nominal</code> for setting nominal values 
of <code>h_outflow</code> and <code>m_flow</code>
in <code>FluidPorts</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/859\">#859</a>.
</li>
<li>
May 29, 2018, Filip Jorissen:<br/>
Removed conditional fluid ports for JModelica compatibility.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/834\">#834</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
Modified model for supporting new interzonal air flow models.
Air leakage model and its parameters have been removed.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
<li>
November 15, 2016 by Filip Jorissen:<br/>
Revised documentation.
</li>
<li>
August 26, 2016 by Filip Jorissen:<br/>
Added support for conservation of energy.
</li>
<li>
April 30, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>
Zone air model partial containing main parameters and connectors.
</p>
</html>"),    Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{90,-80}},
                    pattern=LinePattern.None,
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Backward,
                    lineColor={0,0,0}),
                  Line(
                    points={{-68,60},{68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{68,60},{68,-60},{-68,-60},{-68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Rectangle(
                    extent={{68,60},{-68,-60}},
                    pattern=LinePattern.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Line(points={{-30,42},{38,42},{38,-12},{28,-2},{38,-12},{46,-2}}, color=
                       {28,108,200}),
                  Line(points={{40,-32},{-30,-32},{-30,22},{-20,12},{-30,22},{-38,12}},
                      color={238,46,47})}));
          end PartialAirModel;
        end BaseClasses;

        model WellMixedAir "Zone air model assuming perfectly mixed air"
          // We assume an initial CO2 concentration of 400 ppm, if the medium contains CO2
          extends
          IDEAS.Buildings.Components.ZoneAirModels.BaseClasses.PartialAirModel(
            C_start=400*s*MMFraction/1e6,
            final nSeg=1,
            mSenFac(min=0)=5);

            parameter StateSelect stateSelectTVol = if sim.linearise then StateSelect.prefer else StateSelect.default
              "Set to .prefer to use temperature as a state in mixing volume";


      protected
          final parameter Modelica.SIunits.MolarMass MM=
            Modelica.Media.IdealGases.Common.SingleGasesData.CO2.MM
            "Molar mass of the trace substance";
          final parameter Modelica.SIunits.MolarMass MMBul=Medium.molarMass(
            Medium.setState_phX(
              p=Medium.p_default,
              h=Medium.h_default,
              X=Medium.X_default)) "Molar mass of bulk medium";
          final parameter Real MMFraction=MM/MMBul
            "Molar mass of CO2 divided by the molar mass of the medium";

          constant Modelica.SIunits.SpecificEnthalpy lambdaWater = Medium.enthalpyOfCondensingGas(T=273.15+35)
            "Latent heat of evaporation water";
          constant Boolean hasVap = Medium.nXi>0
            "Medium has water vapour";
          constant Boolean hasPpm = sum(s)>0
            "Medium has trace substance";
          MixingVolumeNominal       vol(
            redeclare package Medium = Medium,
            energyDynamics=energyDynamics,
            massDynamics=massDynamics,
            p_start=p_start,
            T_start=T_start,
            X_start=X_start,
            C_start=C_start,
            C_nominal=C_nominal,
            allowFlowReversal=allowFlowReversal,
            V=Vtot,
            mSenFac=mSenFac,
            U_nominal=mSenFac*10*Vtot*1.2*1000,
            use_C_flow=true,
            nPorts=(2 + (if hasVap then 1 else 0) + (if hasPpm then 1 else 0))+nPorts,
            m_flow_nominal=0.1,
            T(stateSelect=stateSelectTVol))  annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={0,0})));

          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor senTem
            annotation (Placement(transformation(extent={{10,-50},{30,-70}})));
          Modelica.Blocks.Math.Gain gaiLat(k=lambdaWater)
            "Gain for computing latent heat flow rate based on water vapor mass flow rate"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={64,58})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloLat(final
              alpha=0)
            "Prescribed heat flow rate for latent heat gain corresponding to water vapor mass flow rate"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={64,22})));
      protected
          constant Real s[:]= {
            if ( Modelica.Utilities.Strings.isEqual(string1=Medium.extraPropertiesNames[i],
                                                    string2="CO2",
                                                    caseSensitive=false))
            then 1 else 0 for i in 1:Medium.nC}
            "Vector with zero everywhere except where species is";

          IDEAS.Fluid.Sensors.RelativeHumidity senRelHum(
            redeclare package Medium = Medium) if hasVap
            "Relative humidity of the zone air"
            annotation (Placement(transformation(extent={{30,-30},{50,-50}})));
            model MixingVolumeNominal
              "To avoid warning when modifying parameters of protected submodel dynBal of MixingVolumeMoistAir"
              parameter Modelica.SIunits.Energy U_nominal = mSenFac*10*m_nominal*1000 "Nominal value of internal energy";
              parameter Modelica.SIunits.Mass m_nominal = V*1.2 "Nominal value of internal energy";
              parameter Real[Medium.nXi] mXi_nominal = m_nominal*Medium.X_default[1:Medium.nXi] "Nominal value of internal energy";
              parameter Real[Medium.nC] mC_nominal = m_nominal*0.0015*ones(Medium.nC) "Nominal value of internal energy";
              extends IDEAS.Fluid.MixingVolumes.MixingVolumeMoistAir(
                mSenFac(min=0),
                dynBal(
                  U(nominal=U_nominal),
                  mC(nominal=mC_nominal),
                  mXi(nominal=mXi_nominal),
                  m(nominal=m_nominal)));
            end MixingVolumeNominal;
          IDEAS.Fluid.Sensors.PPM senPPM(
            redeclare package Medium = Medium) if hasPpm
            "CO2 sensor"
            annotation (Placement(transformation(extent={{50,-10},{70,-30}})));

        equation
          if hasVap then
            assert(vol.ports[1].Xi_outflow[1] <= 0.1,
                   "The water content of the zone air model is very high. 
           Possibly you are simulating occupants (that generates a latent heat load), 
           but air is not being refreshed (for instance using ventilation or air leakage models)?",
                   level=AssertionLevel.warning);
          else
            phi=0;
          end if;
          if not hasPpm then
            ppm=0;
          end if;

          E=vol.U;
          QGai=preHeaFloLat.Q_flow;
          for i in 1:nSurf loop
            connect(vol.heatPort, ports_surf[i]) annotation (Line(points={{10,
                    -1.33227e-15},{10,-20},{-40,-20},{-40,0},{-100,0}},
                                                       color={191,0,0}));
          end for;
          for i in 1:nSeg loop
            connect(ports_air[i], vol.heatPort) annotation (Line(points={{100,0},{20,0},
                    {20,-20},{10,-20},{10,0}},
                                           color={191,0,0}));
          end for;
          connect(senTem.port, vol.heatPort) annotation (Line(points={{10,-60},{10,0}},
                                      color={191,0,0}));
          connect(senTem.T,TAir)
            annotation (Line(points={{30,-60},{110,-60}},          color={0,0,127}));
          connect(vol.mWat_flow, mWat_flow) annotation (Line(points={{12,-8},{16,-8},{
                  16,80},{108,80}},
                                 color={0,0,127}));
          connect(vol.C_flow[1:Medium.nC], C_flow[1:Medium.nC]) annotation (Line(points={{12,6},{
                  18,6},{18,40},{108,40}},
                        color={0,0,127}));
          connect(gaiLat.y, preHeaFloLat.Q_flow)
            annotation (Line(points={{64,47},{64,32}}, color={0,0,127}));
          connect(gaiLat.u, mWat_flow)
            annotation (Line(points={{64,70},{64,80},{108,80}}, color={0,0,127}));
          connect(preHeaFloLat.port, vol.heatPort) annotation (Line(points={{64,12},{64,
                  0},{20,0},{20,-20},{10,-20},{10,0}},
                                         color={191,0,0}));
          connect(senRelHum.phi, phi)
            annotation (Line(points={{51,-40},{110,-40}},          color={0,0,127}));
          connect(port_b, vol.ports[2]) annotation (Line(points={{-60,100},{-60,10},{
                  1.33227e-15,10}},
                        color={0,127,255}));
          connect(port_a, vol.ports[1]) annotation (Line(points={{60,100},{60,10},{8.88178e-16,
                  10}}, color={0,127,255}));
          connect(senRelHum.port, vol.ports[nPorts+3]) annotation (Line(points={{40,-30},
                  {40,10},{1.33227e-15,10}},
                                  color={0,127,255}));
          connect(senPPM.port, vol.ports[nPorts+3+(if hasVap then 1 else 0)]) annotation (Line(points={{60,-10},
                  {60,10},{1.33227e-15,10}},
                                  color={0,127,255}));
          connect(ports[1:nPorts], vol.ports[3:nPorts+2]) annotation (Line(points={{0,100},
                  {0,10},{1.33227e-15,10}},
                                  color={0,127,255}));
          connect(senPPM.ppm, ppm)
            annotation (Line(points={{71,-20},{110,-20}}, color={0,0,127}));
           annotation (Diagram(graphics,
                               coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})), Documentation(revisions="<html>
<ul>
<li>
March 29, 2019 by Filip Jorissen:<br/>
Added start value for CO2 concentration for
<a href=\"https://github.com/open-ideas/IDEAS/issues/1004\">#1004</a>.
</li>
<li>
February 14, 2019 by Filip Jorissen:<br/>
Changed default value of <code>stateSelectTVol</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/982\">#982</a>.
</li>
<li>
December 11, 2018 by Filip Jorissen:<br/>
Revised mixing volume connection order to avoid triggering flow reversal warnings.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/964\">#964</a>.
</li>
<li>
August 30, 2018 by Damien Picard:<br/>
Added constant StateSelectTVol to be able to select preferred state
of mixing volume.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/905\">#905</a>.
</li>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added nominal values for <code>m</code>, <code>mXi</code> and <code>mC</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/864\">#864</a>.
</li>
<li>
Added output for the CO2 concentration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
Created <code>MixingVolumeNominalU</code> such that 
<code>MixingVolume</code> can be used without generating a warning.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
Added nominal value for internal energy of mixing volume.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/797\">#797</a>.
</li>
<li>
Modified model for supporting new interzonal air flow models.
Air leakage model and its parameters have been removed.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
<li>
August 5, 2017 by Filip Jorissen:<br/>
Added support for dry air.
</li>
<li>
November 15, 2016 by Filip Jorissen:<br/>
Revised documentation.
</li>
<li>
August 26, 2016 by Filip Jorissen:<br/>
Added support for conservation of energy.
</li>
<li>
April 30, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Perfectly mixed air model.
</p>
<h4>Main equations</h4>
<p>
This model computes a single air temperature that is used to 
evaluate convective heat transfer of all surfaces,
components connected to gainCon (e.g. radiators), etc.
The air outlet temperature equals the well mixed air temperature.
</p>
<h4>Assumption and limitations</h4>
<p>
This model is not valid for buildings where stratification occurs, 
e.g. when using floor cooling
or ceiling heating.
</p>
<p>
When dry air is used, then the relative humidity output is set to zero.
</p>
<h4>Typical use and important parameters</h4>
<p>
The zone air volume <code>Vto</code> determines the thermal mass of the air.
This mass may be artificially increased using <code>mSenFac</code> if desired, 
e.g. to take into account the thermal mass of furniture.
</p>
<h4>Dynamics</h4>
This model only contains states to represent the energy and mass dynamics, 
typically using a temperature and pressure variable.
Parameters <code>energyDynamics</code> and <code>massDynamics</code>
may be used to change the model dynamics.
<h4>Validation</h4>
<p>
See BESTEST.
</p>
</html>"));
        end WellMixedAir;
      end ZoneAirModels;
    end Components;

    package Data "Data for transient thermal building simulation"
    extends Modelica.Icons.MaterialPropertiesPackage;

      package Constructions "Library of building envelope constructions"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record CavityWall
          "Cavity wall with fully-filled cavity"
          extends IDEAS.Buildings.Data.Interfaces.Construction(
            mats={IDEAS.Buildings.Data.Materials.BrickMe(d=0.08),
                  IDEAS.Buildings.Data.Insulation.Rockwool(d=0.1),
                  IDEAS.Buildings.Data.Materials.BrickMi(d=0.14),
                  IDEAS.Buildings.Data.Materials.Gypsum(d=0.015)});
          annotation (Documentation(info="<html>
<p>
Example implementation of a cavity wall.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
        end CavityWall;

        record FloorOnGround "Floor on ground for floor heating system"
          extends IDEAS.Buildings.Data.Interfaces.Construction(
            locGain={3},
            incLastLay = IDEAS.Types.Tilt.Floor,
            mats={
              IDEAS.Buildings.Data.Materials.Concrete(d=0.20),
              IDEAS.Buildings.Data.Insulation.Rockwool(d=0.1),
              IDEAS.Buildings.Data.Materials.Screed(d=0.08),
              IDEAS.Buildings.Data.Materials.Concrete(d=0.015)});
          annotation (Documentation(revisions="<html>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
        end FloorOnGround;
      annotation (Documentation(info="<html>
<p>By convention the last material layer of a construction type is connected to propsBus_a of the building component.</p>
</html>"));
      end Constructions;

      package Frames "Library of building glazing frames"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record None "None"
          extends IDEAS.Buildings.Data.Interfaces.Frame( present=false);
          annotation (Documentation(info="<html>
<p>
A dummy model that should be used if the window has no frame.
</p>
</html>"));
        end None;
      end Frames;

      package Glazing "Library of building glazing systems"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Ins2 = IDEAS.Buildings.Data.Interfaces.Glazing (
            final nLay=3,
            final mats={
              Materials.Glass(d=0.004,epsLw_a=0.04),
              Materials.Air(d=0.015),
              Materials.Glass(d=0.004, epsLw_b=0.04)},
            final SwTrans=[0, 0.521;
                          10, 0.524;
                          20, 0.517;
                          30, 0.508;
                          40, 0.495;
                          50, 0.472;
                          60, 0.418;
                          70, 0.312;
                          80, 0.153;
                          90, 0.000],
            final SwAbs=[0, 0.102, 0.0, 0.022;
                        10, 0.104, 0.0, 0.022;
                        20, 0.112, 0.0, 0.023;
                        30, 0.117, 0.0, 0.023;
                        40, 0.119, 0.0, 0.025;
                        50, 0.123, 0.0, 0.026;
                        60, 0.135, 0.0, 0.027;
                        70, 0.142, 0.0, 0.029;
                        80, 0.105, 0.0, 0.031;
                        90, 0.000, 0.0, 0.000],
            final SwTransDif=0.418,
            final SwAbsDif={0.135,0.0,0.027},
            final U_value=1.4,
            final g_value=0.755)
          "Saint Gobain ClimaPlus Futur AR 1.4 4/15/4 (U = 1.4 W/m2K, g = 0.755)"
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 2, 2015, by Filip Jorissen:<br/>
Moved epsLw definition to solid layer to be consistent 
with changed implementation of MultiLayerLucent.
</li>
</ul>
</html>",         info="<html>
<p>
Double insulated glazing system.
</p>
</html>"));
      end Glazing;

      package Insulation "Library of thermal insulation materials"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Rockwool = IDEAS.Buildings.Data.Interfaces.Insulation (
            k=0.036,
            c=840,
            rho=110,
            epsLw=0.8,
            epsSw=0.8) "Rockwool" annotation (Documentation(info="<html>
<p>
Rockwool insulation thermal properties.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
      end Insulation;

      package Interfaces "Building data interfaces"
      extends Modelica.Icons.InterfacesPackage;

        record BasicMaterial
          "Template record for properties of building materials"
          extends Modelica.Icons.MaterialProperty;
          parameter Modelica.SIunits.ThermalConductivity k "Thermal conductivity";
          parameter Modelica.SIunits.SpecificHeatCapacity c "Specific thermal capacity";
          parameter Modelica.SIunits.Density rho "Density";
          annotation (Documentation(info="<html>
<p>
This record may be used to define material properties.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end BasicMaterial;

        partial record Construction "Template record for surface structure: define/order layers from outer to inner"
          extends Modelica.Icons.MaterialProperty;
          final parameter Integer nLay(min=1)=size(mats,1)
            "Number of layers of the construction, including gaps";
          final parameter Integer nGain = size(locGain,1)
           "Number of gain heat ports";
          parameter Integer locGain[:](each min=1) = {1}
            "Location of possible embedded system: between layer locGain and layer locGain + 1";
          // where locGain=1 is the first layer
          parameter IDEAS.Buildings.Data.Interfaces.Material[:] mats
            "Array of materials. The last layer is connected to propsBus_a.";
          parameter Modelica.SIunits.Angle incLastLay = IDEAS.Types.Tilt.Other
            "Set to IDEAS.Types.Tilt.Floor if the last layer of mats is a floor, to .Ceiling if it is a ceiling and to .Other if other. For verification purposes.";
          annotation (Documentation(info="<html>
<p>
This record may be used to define the structure of constructions (walls).
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameter <code>mats</code> should be used to define 
the type and thickness of each material layers.
</p>
<p>
Parameter <code>incLastLay</code> may be used
to define the intended inclination angle
of the last material layer.
This is to check if you correctly connect
models that used this construction since
otherwise the natural convection correlations
may be computed for instance assuming a floor
orientation instead of a ceiling orientation.
</p>
<h4>Assumption and limitations</h4>
<p>
Edge effects are neglected. 
A simple correlation for unventilated cavities
is used when modeling an air layer.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
November 14, 2016 by Filip Jorissen:<br/>
Removed insulationType and insulationThickness
as these parameters could lead to confusion.
See <a href=https://github.com/open-ideas/IDEAS/issues/583>issue 583</a>.
</li>
<li>
Augustus 1, 2016 by Filip Jorissen:<br/>
Set default <code>nLay(min=1)=size(mats,1)</code> 
and <code>nGain = size(locGain,1)</code>.
</li>
</ul>
</html>"));
        end Construction;

        partial record Frame "Template record for window frames"
          extends Modelica.Icons.MaterialProperty;
          parameter Boolean present=true;
          parameter Modelica.SIunits.ThermalConductance U_value=1.1 "U-value window frame";
          replaceable parameter IDEAS.Buildings.Components.ThermalBridges.None briTyp "Thermal bridge type";
          replaceable parameter IDEAS.Buildings.Data.Interfaces.Material mat(
            k=0.1,
            rho=1000,
            c=1000) "Material type, used for emissivity properties only";
          annotation (Documentation(info="<html>
<p>
This record may be used to define the thermal properties of a window frame. 
The U_value is used to compute the thermal losses of the frame. 
The material type <code>mat</code> is only used for the emissivity values 
and is therefore of lesser importance.
A thermal bridge may optionally be defined as well. 
</p>
</html>",         revisions="<html>
<ul>
<li>
December 19, 2016, by Filip Jorissen:<br/>
Added thermal bridge type and material type.
</li>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end Frame;

        record Glazing
          "Template record for glazing, based on  Window software by LBNL"
          extends Modelica.Icons.MaterialProperty;

          parameter Integer nLay(min=1)
            "Number of layers of the glazing, including gaps";
          parameter IDEAS.Buildings.Data.Interfaces.Material[nLay] mats
            "Array of materials";
          parameter Real[:, nLay + 1] SwAbs
            "Absorbed solar radiation for each layer as function of angle of incidence";
          parameter Real[:, 2] SwTrans
            "Transmitted solar radiation as function of angle of incidence";
          parameter Real[nLay] SwAbsDif
            "Absorbed solar radiation for each layer as function of angle of incidence";
          parameter Real SwTransDif
            "Transmitted solar radiation as function of angle of incidence";

          parameter Real U_value "Design U-value. (Only used for calculation Qdesign)";
          parameter Real g_value
            "Design g-value. (Not used in calculation, only informative)";

          annotation (Documentation(info="<html>
  <p>
  The <code>Glazing.mo</code> partial describes the material data 
  required for glazing construction modelling.
  </p>
  <p>
  The correct parameter values for your type of glazing can be 
  generated using the 
  <a href=\"http://windows.lbl.gov/software/window/window.html\">Window software from LBNL</a>. 
  In the software open the \"glazing system\" library. 
  On this page choose the number of layers (typical two or three) and 
  fill in the glazing types. Make sure to \"flip\" the glass sheet 
  when necessary so that the coating is on the correct side of the glass. 
  Press calc to calculate the parameters.
  </p>
  <p>
  The resulting parameters can be filled in as follows. 
  </p>
  <p>
  In result tab \"Center of Glass Results\" copy <code>Ufactor</code>
  to <code>U_value</code>. In result tab \"Angular data\" open 
  \"Angular data\". Fill in the values of <code>Tsol</code> 
  (0-90 degrees) in <code>SwTrans</code>. The last value (Hemis) is filled 
  in under <code>SwTransDif</code>. Fill in the values under <code>Abs1</code>, 
  <code>Abs2</code>, <code>Abs3</code> in into <code>SwAbs</code> and 
  <code>SwAbsDif</code> in a similar fashion. Parameter <code>g_value</code> 
  does not need to be filled in. 
  </p>
  <p>
Furthermore, it is important that the <code>epsLw_b</code>
or <code>epsLw_a</code> fields of the glazing layers are adjusted
to reflect the effect of the glazing coating, assuming it exists.
This makes the difference of a U value of about 3 W/mK or 1 W/mK for double glazing!
See <a href=\"modelica://IDEAS.Buildings.Data.Glazing.Ins2Ar\">IDEAS.Buildings.Data.Glazing.Ins2Ar</a>
for an example with double glazing that has 1 glazed sheet with a coating on the inside.
</p> 
</html>",         revisions="<html>
<ul>
<li>
November 27, 2018, by Filip Jorissen:<br/>
Revised documentation for issue
<a href=\"https://github.com/open-ideas/IDEAS/issues/959\">#959</a>.
</li>
</ul>
</html>"));
        end Glazing;

        record Insulation
          "Template record for insulation (optional, may be directly implemented in construction!)"
          extends IDEAS.Buildings.Data.Interfaces.Material;
        end Insulation;

        record Material "Template record for properties of building materials"
          extends IDEAS.Buildings.Data.Interfaces.BasicMaterial;
          parameter Modelica.SIunits.Length d=0 "Layer thickness";
          parameter Modelica.SIunits.Emissivity epsLw = 0.85 "Longwave emisivity";
          parameter Modelica.SIunits.Emissivity epsSw = 0.85 "Shortwave emissivity";
          parameter Boolean gas=false "Boolean whether the material is a gas"
            annotation(Evaluate=true);
          parameter Boolean glass=false "Boolean whether the material is made of glass"
            annotation(Evaluate=true);
          parameter Modelica.SIunits.KinematicViscosity mhu = 0
            "Viscosity, i.e. if the material is a fluid";
          parameter Modelica.SIunits.Emissivity epsLw_a = epsLw
            "Longwave emisivity for surface a if different";
          parameter Modelica.SIunits.Emissivity epsLw_b = epsLw
            "Longwave emisivity for surface a if different";
          parameter Modelica.SIunits.Emissivity epsSw_a = epsSw
            "Shortwave emisivity for surface a if different";
          parameter Modelica.SIunits.Emissivity epsSw_b = epsSw
            "Shortwave emisivity for surface a if different";
          final parameter Modelica.SIunits.ThermalInsulance R=d/k;
          final parameter Modelica.SIunits.ThermalDiffusivity alpha=k/(c*rho)
            "Thermal diffusivity";
          final parameter Integer nStaRef=3
            "Number of states of a reference case, ie. 20 cm dense concrete";
          final parameter Real piRef=224
            "d/sqrt(mat.alpha) of a reference case, ie. 20 cm dense concrete";
          final parameter Real piLay=d/sqrt(alpha)
            "d/sqrt(mat.alpha) of the depicted layer";
          final parameter Integer nSta(min=2) = max(2, integer(ceil(nStaRef*piLay/piRef)))
            "Actual number of state variables in material";
          annotation (Documentation(info="<html>
<p>
This record may be used to define material properties.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end Material;
      end Interfaces;

      package Materials "Library of construction materials"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Air = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.0241,
            c=1008,
            rho=1.23,
            epsSw=0,
            epsLw=0,
            gas=true,
            mhu=18.3*10e-6) "Air" annotation (Documentation(info="<html>
<p>
Constant air thermal properties.
</p>
</html>"));

        record Argon = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.0162,
            c=519,
            rho=1.70,
            epsSw=0,
            epsLw=0,
            gas=true,
            mhu=22.9*10e-6) "Argon gass" annotation (Documentation(info="<html>
<p>
Constant argon thermal properties.
</p>
</html>"));

        record BrickMe = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.75,
            c=840,
            rho=1400,
            epsLw=0.88,
            epsSw=0.55) "Medium masonry for exterior applications " annotation (
            Documentation(info="<html>
<p>
Thermal properties of medium bricks for exterior masonry.
</p>
</html>"));

        record BrickMi = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.54,
            c=840,
            rho=1400,
            epsLw=0.88,
            epsSw=0.55) "Medium masonry for interior applications " annotation (
            Documentation(info="<html>
<p>
Thermal properties of medium bricks for interior masonry.
</p>
</html>"));

        record Concrete = IDEAS.Buildings.Data.Interfaces.Material (
            k=1.4,
            c=840,
            rho=2100,
            epsLw=0.88,
            epsSw=0.55) "Dense cast concrete, also for finishing" annotation (
            Documentation(info="<html>
<p>
Thermal properties of concrete.
</p>
</html>"));

        record Glass = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.96,
            c=750,
            rho=2500,
            epsLw=0.84,
            epsSw=0.67) "Glass" annotation (Documentation(info="<html>
<p>
Thermal properties of glass.
</p>
</html>"));

        record Ground = IDEAS.Buildings.Data.Interfaces.Material (
            k=2.0,
            c=1250,
            rho=1600,
            epsLw=0.88,
            epsSw=0.68) annotation (Documentation(info="<html>
<p>
Thermal properties of ground/soil.
</p>
</html>"));

        record Gypsum = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.6,
            c=840,
            rho=975,
            epsLw=0.85,
            epsSw=0.65) "Gypsum plaster for finishing" annotation (Documentation(info="<html>
<p>
Thermal properties of gypsum.
</p>
</html>"));

        record Screed = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.6,
            c=840,
            rho=1100,
            epsLw=0.88,
            epsSw=0.55) "Light cast concrete" annotation (Documentation(info="<html>
<p>
Thermal properties of screed.
</p>
</html>"));
      end Materials;
    end Data;

    package Validation "BESTEST Validation"
    extends Modelica.Icons.SensorsPackage;

      package Data
      extends Modelica.Icons.MaterialPropertiesPackage;

        package Constructions
        extends Modelica.Icons.MaterialPropertiesPackage;

          record HeavyFloor "BESTEST heavy floor"
            extends IDEAS.Buildings.Data.Interfaces.Construction(
              incLastLay = IDEAS.Types.Tilt.Floor,
              final mats={
                IDEAS.Buildings.Validation.Data.Insulation.InsulationFloor(d=1.007),
                IDEAS.Buildings.Validation.Data.Materials.ConcreteSlab(d=0.08)});
          end HeavyFloor;

          record HeavyWall "BESTEST heavy wall"
            extends IDEAS.Buildings.Data.Interfaces.Construction(
              final mats={
                IDEAS.Buildings.Validation.Data.Materials.WoodSiding(d=0.009),
                IDEAS.Buildings.Validation.Data.Insulation.FoamInsulation(d=0.0615),
                IDEAS.Buildings.Validation.Data.Materials.ConcreteBlock(d=0.10)});
          end HeavyWall;

          record LightRoof "BESTEST light roof"
            extends IDEAS.Buildings.Data.Interfaces.Construction(
              incLastLay = IDEAS.Types.Tilt.Ceiling,
              final mats={
                IDEAS.Buildings.Validation.Data.Materials.Roofdeck(d=0.019),
                IDEAS.Buildings.Validation.Data.Insulation.FiberGlass(d=0.1118),
                IDEAS.Buildings.Validation.Data.Materials.PlasterBoard(d=0.010)});
          end LightRoof;
        end Constructions;

        package Insulation
        extends Modelica.Icons.MaterialPropertiesPackage;

          record FiberGlass =
            IDEAS.Buildings.Data.Interfaces.Insulation (
              final k=0.040,
              final c=840,
              final rho=12,
              epsLw=0.9,
              epsSw=0.6) "BESTEST fiberglass insulation";

          record FoamInsulation =
            IDEAS.Buildings.Data.Interfaces.Insulation (
              final k=0.040,
              final c=1400,
              final rho=10,
              epsLw=0.9,
              epsSw=0.6) "BESTEST foam insulation";

          record InsulationFloor =
            IDEAS.Buildings.Data.Interfaces.Insulation (
              final k=0.040,
              final c=10,
              final rho=10,
              epsLw=0.9,
              epsSw=0.6) "BESTEST floor insulation";
        end Insulation;

        package Materials
        extends Modelica.Icons.MaterialPropertiesPackage;

          record ConcreteBlock
            "BESTEST concrete blocks"
            extends IDEAS.Buildings.Data.Interfaces.Material(
              final k=0.51,
              final c=1000,
              final rho=1400,
              epsLw=0.9,
              epsSw=0.6);
          end ConcreteBlock;

          record ConcreteSlab
            "BESTEST concrete slab"
            extends IDEAS.Buildings.Data.Interfaces.Material(
              final k=1.130,
              final c=1000,
              final rho=1400,
              epsLw=0.9,
              epsSw=0.6);
          end ConcreteSlab;

          record PlasterBoard
            "BESTEST plasterboard"
            extends IDEAS.Buildings.Data.Interfaces.Material(
              final k=0.160,
              final c=840,
              final rho=950,
              epsLw=0.9,
              epsSw=0.6);
          end PlasterBoard;

          record Roofdeck
            "BESTEST roof deck"
            extends IDEAS.Buildings.Data.Interfaces.Material(
              final k=0.14,
              final c=900,
              final rho=530,
              epsLw=0.9,
              epsSw=0.6);
          end Roofdeck;

          record WoodSiding
            "BESTEST wood siding"
            extends IDEAS.Buildings.Data.Interfaces.Material(
              final k=0.14,
              final c=900,
              final rho=530,
              epsLw=0.9,
              epsSw=0.6);
          end WoodSiding;
        end Materials;
      end Data;
    end Validation;
  end Buildings;

  package Controls "Package with models for controls"
    extends Modelica.Icons.Package;

    package Continuous "Package with models for discrete time controls"
      extends Modelica.Icons.Package;

      block LimPID
        "P, PI, PD, and PID controller with limited output, anti-windup compensation and setpoint weighting"
        extends Modelica.Blocks.Interfaces.SVcontrol;
        output Real controlError = u_s - u_m
          "Control error (set point - measurement)";
        parameter Modelica.Blocks.Types.SimpleController controllerType=
               Modelica.Blocks.Types.SimpleController.PID "Type of controller";
        parameter Real k(min=0, unit="1") = 1 "Gain of controller";
        parameter Modelica.SIunits.Time Ti(min=Modelica.Constants.small)=0.5
          "Time constant of Integrator block" annotation (Dialog(enable=
                controllerType == Modelica.Blocks.Types.SimpleController.PI or
                controllerType == Modelica.Blocks.Types.SimpleController.PID));
        parameter Modelica.SIunits.Time Td(min=0)=0.1
          "Time constant of Derivative block" annotation (Dialog(enable=
                controllerType == Modelica.Blocks.Types.SimpleController.PD or
                controllerType == Modelica.Blocks.Types.SimpleController.PID));
        parameter Real yMax(start=1)=1 "Upper limit of output";
        parameter Real yMin=0 "Lower limit of output";
        parameter Real wp(min=0) = 1 "Set-point weight for Proportional block (0..1)";
        parameter Real wd(min=0) = 0 "Set-point weight for Derivative block (0..1)"
             annotation(Dialog(enable=controllerType==.Modelica.Blocks.Types.SimpleController.PD or
                                      controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real Ni(min=100*Modelica.Constants.eps) = 0.9
          "Ni*Ti is time constant of anti-windup compensation"
           annotation(Dialog(enable=controllerType==.Modelica.Blocks.Types.SimpleController.PI or
                                    controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real Nd(min=100*Modelica.Constants.eps) = 10
          "The higher Nd, the more ideal the derivative block"
             annotation(Dialog(enable=controllerType==.Modelica.Blocks.Types.SimpleController.PD or
                                      controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Modelica.Blocks.Types.InitPID initType= Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
                                           annotation(Evaluate=true,
            Dialog(group="Initialization"));
            // Removed as the Limiter block no longer uses this parameter.
            // parameter Boolean limitsAtInit = true
            //  "= false, if limits are ignored during initialization"
            // annotation(Evaluate=true, Dialog(group="Initialization"));
        parameter Real xi_start=0
          "Initial or guess value value for integrator output (= integrator state)"
          annotation (Dialog(group="Initialization",
                      enable=controllerType==.Modelica.Blocks.Types.SimpleController.PI or
                             controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real xd_start=0
          "Initial or guess value for state of derivative block"
          annotation (Dialog(group="Initialization",
                               enable=controllerType==.Modelica.Blocks.Types.SimpleController.PD or
                                      controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real y_start=0 "Initial value of output"
          annotation(Dialog(enable=initType == Modelica.Blocks.Types.InitPID.InitialOutput, group=
                "Initialization"));
        parameter Boolean strict=true "= true, if strict limits with noEvent(..)"
          annotation (Evaluate=true, choices(checkBox=true), Dialog(tab="Advanced"));
        parameter Boolean reverseAction = false
          "Set to true for throttling the water flow rate through a cooling coil controller";
        parameter IDEAS.Types.Reset reset = IDEAS.Types.Reset.Disabled
          "Type of controller output reset"
          annotation(Evaluate=true, Dialog(group="Integrator reset"));
        parameter Real y_reset=xi_start
          "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == IDEAS.Types.Reset.Parameter"
          annotation(Dialog(enable=reset == IDEAS.Types.Reset.Parameter,
                            group="Integrator reset"));
        Modelica.Blocks.Interfaces.BooleanInput trigger if
             reset <> IDEAS.Types.Reset.Disabled
          "Resets the controller output when trigger becomes true"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-120})));
        Modelica.Blocks.Interfaces.RealInput y_reset_in if
             reset == IDEAS.Types.Reset.Input
          "Input signal for state to which integrator is reset, enabled if reset = IDEAS.Types.Reset.Input"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Modelica.Blocks.Math.Add addP(k1=revAct*wp, k2=-revAct) "Adder for P gain"
         annotation (Placement(
              transformation(extent={{-80,40},{-60,60}})));
        Modelica.Blocks.Math.Add addD(k1=revAct*wd, k2=-revAct) if with_D
          "Adder for D gain"
          annotation (Placement(
              transformation(extent={{-80,-10},{-60,10}})));
        Modelica.Blocks.Math.Gain P(k=1) "Proportional term"
          annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
        Utilities.Math.IntegratorWithReset I(
          final reset=if reset == IDEAS.Types.Reset.Disabled then reset else IDEAS.Types.Reset.Input,
          final y_reset=y_reset,
          final k=unitTime/Ti,
          final y_start=xi_start,
          final initType=if initType == Modelica.Blocks.Types.InitPID.SteadyState then
              Modelica.Blocks.Types.Init.SteadyState
                   else if initType == Modelica.Blocks.Types.InitPID.InitialState
                        or initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
                   then Modelica.Blocks.Types.Init.InitialState
                   else Modelica.Blocks.Types.Init.NoInit) if
             with_I "Integral term"
             annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));
        Modelica.Blocks.Continuous.Derivative D(
          final k=Td/unitTime,
          final T=max([Td/Nd,1.e-14]),
          final x_start=xd_start,
          final initType=if initType == Modelica.Blocks.Types.InitPID.SteadyState or
                      initType == Modelica.Blocks.Types.InitPID.InitialOutput
                   then
                     Modelica.Blocks.Types.Init.SteadyState
                   else
                     if initType == Modelica.Blocks.Types.InitPID.InitialState then
                       Modelica.Blocks.Types.Init.InitialState
                     else
                       Modelica.Blocks.Types.Init.NoInit) if with_D "Derivative term"
                                                           annotation (Placement(
              transformation(extent={{-40,-10},{-20,10}})));
        Modelica.Blocks.Math.Add3 addPID(
          final k1=1,
          final k2=1,
          final k3=1) "Adder for the gains"
          annotation (Placement(transformation(extent={{0,-10},{20,10}})));
    protected
        constant Modelica.SIunits.Time unitTime=1 annotation (HideResult=true);
        final parameter Real revAct = if reverseAction then -1 else 1
          "Switch for sign for reverse action";
        parameter Boolean with_I = controllerType==Modelica.Blocks.Types.SimpleController.PI or
                                   controllerType==Modelica.Blocks.Types.SimpleController.PID
          "Boolean flag to enable integral action"
          annotation(Evaluate=true, HideResult=true);
        parameter Boolean with_D = controllerType==Modelica.Blocks.Types.SimpleController.PD or
                                   controllerType==Modelica.Blocks.Types.SimpleController.PID
          "Boolean flag to enable derivative action"
          annotation(Evaluate=true, HideResult=true);
        Modelica.Blocks.Sources.Constant Dzero(final k=0) if not with_D
          "Zero input signal"
          annotation(Evaluate=true, HideResult=true,
                     Placement(transformation(extent={{-30,20},{-20,30}})));
        Modelica.Blocks.Sources.Constant Izero(final k=0) if not with_I
          "Zero input signal"
          annotation(Evaluate=true, HideResult=true,
                     Placement(transformation(extent={{10,-55},{0,-45}})));
        Modelica.Blocks.Interfaces.RealInput y_reset_internal
         "Internal connector for controller output reset"
         annotation(Evaluate=true);
        Modelica.Blocks.Math.Add3 addI(
          final k1=revAct,
          final k2=-revAct) if with_I
          "Adder for I gain"
             annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
        Modelica.Blocks.Math.Add addSat(
          final k1=+1,
          final k2=-1) if with_I
          "Adder for integrator feedback"
          annotation (Placement(
              transformation(
              origin={80,-50},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Modelica.Blocks.Math.Gain gainPID(final k=k) "Multiplier for control gain"
         annotation (Placement(transformation(
                extent={{30,-10},{50,10}})));
        Modelica.Blocks.Math.Gain gainTrack(k=1/(k*Ni)) if with_I
          "Gain for anti-windup compensation"
          annotation (
            Placement(transformation(extent={{60,-80},{40,-60}})));
        Modelica.Blocks.Nonlinear.Limiter limiter(
          final uMax=yMax,
          final uMin=yMin,
          final strict=strict) "Output limiter"
          annotation (Placement(transformation(extent={{70,-10},{90,10}})));
        Modelica.Blocks.Sources.RealExpression intRes(
          final y=y_reset_internal/k - addPID.u1 - addPID.u2) if
             reset <> IDEAS.Types.Reset.Disabled
          "Signal source for integrator reset"
          annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));
      initial equation
        if initType==Modelica.Blocks.Types.InitPID.InitialOutput then
           gainPID.y = y_start;
        end if;
      equation
        assert(yMax >= yMin, "LimPID: Limits must be consistent. However, yMax (=" + String(yMax) +
                             ") < yMin (=" + String(yMin) + ")");
        if initType == Modelica.Blocks.Types.InitPID.InitialOutput and (y_start < yMin or y_start > yMax) then
            Modelica.Utilities.Streams.error("LimPID: Start value y_start (=" + String(y_start) +
               ") is outside of the limits of yMin (=" + String(yMin) +") and yMax (=" + String(yMax) + ")");
        end if;
        // Equations for conditional connectors
        connect(y_reset_in, y_reset_internal);
        if reset <> IDEAS.Types.Reset.Input then
          y_reset_internal = y_reset;
        end if;
        connect(u_s, addP.u1) annotation (Line(points={{-120,0},{-96,0},{-96,56},{
                -82,56}}, color={0,0,127}));
        connect(u_s, addD.u1) annotation (Line(points={{-120,0},{-96,0},{-96,6},{
                -82,6}}, color={0,0,127}));
        connect(u_s, addI.u1) annotation (Line(points={{-120,0},{-96,0},{-96,-42},{
                -82,-42}}, color={0,0,127}));
        connect(addP.y, P.u) annotation (Line(points={{-59,50},{-42,50}}, color={0,
                0,127}));
        connect(addD.y, D.u)
          annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
        connect(addI.y, I.u) annotation (Line(points={{-59,-50},{-42,-50}}, color={
                0,0,127}));
        connect(P.y, addPID.u1) annotation (Line(points={{-19,50},{-10,50},{-10,8},
                {-2,8}}, color={0,0,127}));
        connect(D.y, addPID.u2)
          annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
        connect(I.y, addPID.u3) annotation (Line(points={{-19,-50},{-10,-50},{-10,
                -8},{-2,-8}}, color={0,0,127}));
        connect(addPID.y, gainPID.u)
          annotation (Line(points={{21,0},{28,0}}, color={0,0,127}));
        connect(gainPID.y, addSat.u2) annotation (Line(points={{51,0},{60,0},{60,
                -20},{74,-20},{74,-38}}, color={0,0,127}));
        connect(gainPID.y, limiter.u)
          annotation (Line(points={{51,0},{68,0}}, color={0,0,127}));
        connect(limiter.y, addSat.u1) annotation (Line(points={{91,0},{94,0},{94,
                -20},{86,-20},{86,-38}}, color={0,0,127}));
        connect(limiter.y, y)
          annotation (Line(points={{91,0},{110,0}}, color={0,0,127}));
        connect(addSat.y, gainTrack.u) annotation (Line(points={{80,-61},{80,-70},{62,
                -70}},    color={0,0,127}));
        connect(gainTrack.y, addI.u3) annotation (Line(points={{39,-70},{-88,-70},{-88,
                -58},{-82,-58}},     color={0,0,127}));
        connect(u_m, addP.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,44},{-82,44}},
            color={0,0,127},
            thickness=0.5));
        connect(u_m, addD.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,-6},{-82,-6}},
            color={0,0,127},
            thickness=0.5));
        connect(u_m, addI.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,-50},{-82,-50}},
            color={0,0,127},
            thickness=0.5));
        connect(Dzero.y, addPID.u2) annotation (Line(points={{-19.5,25},{-14,25},{
                -14,0},{-2,0}}, color={0,0,127}));
        connect(Izero.y, addPID.u3) annotation (Line(points={{-0.5,-50},{-10,-50},{
                -10,-8},{-2,-8}}, color={0,0,127}));
        connect(trigger, I.trigger) annotation (Line(points={{-80,-120},{-80,-88},{-30,
                -88},{-30,-62}}, color={255,0,255}));
        connect(intRes.y, I.y_reset_in) annotation (Line(points={{-59,-80},{-50,-80},{
                -50,-58},{-42,-58}}, color={0,0,127}));
         annotation (
      defaultComponentName="conPID",
      Documentation(info="<html>
<p>
This model is similar to
<a href=\"modelica://Modelica.Blocks.Continuous.LimPID\">Modelica.Blocks.Continuous.LimPID</a>,
except for the following changes:
</p>

<ol>
<li>
<p>
It can be configured to have a reverse action.
</p>
<p>If the parameter <code>reverseAction=false</code> (the default), then
<code>u_m &lt; u_s</code> increases the controller output,
otherwise the controller output is decreased. Thus,
</p>
<ul>
  <li>for a heating coil with a two-way valve, set <code>reverseAction = false</code>, </li>
  <li>for a cooling coils with a two-way valve, set <code>reverseAction = true</code>. </li>
</ul>
</li>

<li>
<p>
It can be configured to enable an input port that allows resetting the controller
output. The controller output can be reset as follows:
</p>
<ul>
  <li>
  If <code>reset = IDEAS.Types.Reset.Disabled</code>, which is the default,
  then the controller output is never reset.
  </li>
  <li>
  If <code>reset = IDEAS.Types.Reset.Parameter</code>, then a boolean
  input signal <code>trigger</code> is enabled. Whenever the value of
  this input changes from <code>false</code> to <code>true</code>,
  the controller output is reset by setting <code>y</code>
  to the value of the parameter <code>y_reset</code>.
  </li>
  <li>
  If <code>reset = IDEAS.Types.Reset.Input</code>, then a boolean
  input signal <code>trigger</code> is enabled. Whenever the value of
  this input changes from <code>false</code> to <code>true</code>,
  the controller output is reset by setting <code>y</code>
  to the value of the input signal <code>y_reset_in</code>.
  </li>
</ul>
<p>
Note that this controller implements an integrator anti-windup. Therefore,
for most applications, keeping the default setting of
<code>reset = IDEAS.Types.Reset.Disabled</code> is sufficient.
Examples where it may be beneficial to reset the controller output are situations
where the equipment control input should continuously increase as the equipment is
switched on, such as as a light dimmer that may slowly increase the luminance, or
a variable speed drive of a motor that should continuously increase the speed.
</p>
</li>

<li>
The parameter <code>limitsAtInit</code> has been removed.
</li>

<li>
Some parameters assignments in the instances have been made final.
</li>

</ol>
</html>",
      revisions="<html>
<ul>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model.
</li>
<li>
August 25, 2016, by Michael Wetter:<br/>
Removed parameter <code>limitsAtInit</code> because it was only propagated to
the instance <code>limiter</code>, but this block no longer makes use of this parameter.
This is a non-backward compatible change.<br/>
Revised implemenentation, added comments, made some parameter in the instances final.
</li>
<li>July 18, 2016, by Philipp Mehrfeld:<br/>
Added integrator reset.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/494\">issue 494</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Changed the default value to <code>strict=true</code> in order to avoid events
when the controller saturates.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/433\">issue 433</a>.
</li>
<li>
February 24, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                extent={{-6,-20},{66,-66}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.P),
                extent={{-32,-22},{68,-62}},
                lineColor={0,0,0},
                textString="P",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PI),
                extent={{-28,-22},{72,-62}},
                lineColor={0,0,0},
                textString="PI",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PD),
                extent={{-16,-22},{88,-62}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175},
                textString="P D"),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PID),
                extent={{-14,-22},{86,-62}},
                lineColor={0,0,0},
                textString="PID",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
              Line(points={{-80,-80},{-80,-20},{30,60},{80,60}}, color={0,0,127}),
              Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
              Polygon(
                points={{90,-80},{68,-72},{68,-88},{90,-80}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(
                visible=strict,
                points={{30,60},{81,60}},
                color={255,0,0},
                smooth=Smooth.None)}));
      end LimPID;
    annotation (
    preferredView="info", Documentation(info="<html>
This package contains component models for continuous time controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks.Continuous\">
Modelica.Blocks.Discrete</a>.
</html>"),
    Icon(graphics={Line(
              origin={0.061,4.184},
              points={{81.939,36.056},{65.362,36.056},{14.39,-26.199},{-29.966,
                  113.485},{-65.374,-61.217},{-78.061,-78.184}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Continuous;

    package ControlHeating "Controllers for thermal systems"
    extends Modelica.Icons.Package;

      model RunningMeanTemperatureEN15251
        "Calculate the running mean temperature of 7 days, acccording to norm EN15251"
         discrete Modelica.Blocks.Interfaces.RealOutput TRm(unit="K",displayUnit = "degC")
          "Running mean average temperature"
           annotation (Placement(transformation(extent={{96,-10},{116,10}})));
        Modelica.Blocks.Sources.RealExpression TAmb(y=sim.Te)
          annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
        outer BoundaryConditions.SimInfoManager sim
          annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
    protected
        parameter Modelica.SIunits.Time t_start(fixed=false) "Start time of the model";
        parameter Real coeTRm[7] = {1, 0.8, 0.6, 0.5, 0.4, 0.3, 0.2}./3.8
          "weighTAmb.yg coefficient for the running average";
        discrete Real[7] TAveDay(each unit="K",each displayUnit = "degC")
          "Vector with the average day temperatures of the previous nTermRm days";
        Real intTAmb "integral of TAmb.y";
      initial equation
        intTAmb=0;
        t_start = time;
        TAveDay=ones(7).*sim.Te;
        TRm=sim.Te;
      equation
        der(intTAmb) =  TAmb.y;
      algorithm
        when sample(t_start+24*3600,24*3600) then
          // Update of TAveDay
          for i in 2:7 loop
            TAveDay[i] := pre(TAveDay[i-1]);
          end for;
          TAveDay[1] := intTAmb / 24/3600;
          TRm :=TAveDay*coeTRm;
        end when;
      equation
          // reinitialisation of the intTAmb
        when sample(t_start+24*3600,24*3600) then
          reinit(intTAmb,0);
        end when;
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics),
          experiment(StopTime=864000),
          __Dymola_experimentSetupOutput,
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Rectangle(
                extent={{100,100},{-100,-100}},
                lineColor={100,100,100},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255}),
              Line(
                points={{0,100},{98,0},{0,-100}},
                color={100,100,100},
                smooth=Smooth.None),
              Text(
                extent={{-100,140},{100,100}},
                lineColor={0,0,255},
                textString="%name"),
              Text(
                extent={{-48,32},{58,-26}},
                lineColor={0,0,255},
                textString="EN15251")}),
      Documentation(revisions="<html>
<ul>
<li>
April 17, 2018, by Damien Picard:<br/>
Add t_start in sample to compute correctly for non zero initial time.<br/>
Use sim.Te as initialization instead of an arbitrary value of 283.15K.
</li>
<li>
January 19, 2015, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
      end RunningMeanTemperatureEN15251;
    end ControlHeating;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains component models for controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}));
  end Controls;

  package Examples "IDEAS Examples"
  extends Modelica.Icons.ExamplesPackage;

    package TwinHouses
    "Models for validation on Twin house test cases IEA EBC Annex 58"
      extends Modelica.Icons.ExamplesPackage;

      package BaseClasses
        extends Modelica.Icons.BasesPackage;

        package Data
        extends Modelica.Icons.Package;

          package Materials
          extends Modelica.Icons.MaterialPropertiesPackage;

            record Glazing =IDEAS.Buildings.Data.Interfaces.Glazing (
                final nLay=3,
                final mats={IDEAS.Buildings.Data.Materials.Glass(
                                            d=0.004,
                                            epsLw_b=0.837),
                            IDEAS.Buildings.Data.Materials.Argon(
                                            d=0.016),
                            IDEAS.Buildings.Data.Materials.Glass(
                                            d=0.004,
                                            epsLw_b=0.04,
                                            epsLw_a=0.837)},
                final SwTrans=[0, 0.543;
                              10, 0.546;
                              20, 0.538;
                              30, 0.528;
                              40, 0.514;
                              50, 0.486;
                              60, 0.426;
                              70, 0.310;
                              80, 0.145;
                              90, 0.000],
                final SwAbs=[0, 0.107, 0.0, 0.085;
                            10, 0.108, 0.0, 0.087;
                            20, 0.109, 0.0, 0.094;
                            30, 0.112, 0.0, 0.1;
                            40, 0.116, 0.0, 0.102;
                            50, 0.121, 0.0, 0.106;
                            60, 0.126, 0.0, 0.119;
                            70, 0.130, 0.0, 0.127;
                            80, 0.124, 0.0, 0.091;
                            90, 0.000, 0.0, 0.000],
                final SwTransDif=0.427,
                final SwAbsDif={0.118,0.0,0.104},
                final U_value=1.1,
                final g_value=0.525)
              "Glass properties as specified by EN410 spectrum (U = 1.1 W/m2K, g = 0.525)"
              annotation (Documentation(revisions="<html>
<ul>
<li>
September 2, 2015, by Filip Jorissen:<br/>
Moved epsLw definition to solid layer to be consistent 
with changed implementation of MultiLayerLucent.
</li>
</ul>
</html>"));
          end Materials;
        end Data;
      end BaseClasses;
    end TwinHouses;
  end Examples;

  package Fluid "Package with models for fluid flow systems"
    extends Modelica.Icons.Package;

    package Actuators "Package with actuator models such as valves and dampers"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses "Package with base classes for IDEAS.Fluid.Actuators"
        extends Modelica.Icons.BasesPackage;

        model ActuatorSignal
          "Partial model that implements the filtered opening for valves and dampers"
          parameter Boolean use_inputFilter=true
            "= true, if opening is filtered with a 2nd order CriticalDamping filter"
            annotation(Dialog(tab="Dynamics", group="Filtered opening"));
          parameter Modelica.SIunits.Time riseTime=120
            "Rise time of the filter (time to reach 99.6 % of an opening step)"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          parameter Integer order(min=1) = 2 "Order of filter"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
            "Type of initialization (no init/steady state/initial state/initial output)"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          parameter Real y_start=1 "Initial value of output"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          Modelica.Blocks.Interfaces.RealInput y(min=0, max=1)
            "Actuator position (0: closed, 1: open)"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                  rotation=270,
                origin={0,120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,120})));
          Modelica.Blocks.Interfaces.RealOutput y_actual "Actual valve position"
            annotation (Placement(transformation(extent={{40,60},{60,80}})));
          // Classes used to implement the filtered opening
      protected
          Modelica.Blocks.Interfaces.RealOutput y_filtered if use_inputFilter
            "Filtered valve position in the range 0..1"
            annotation (Placement(transformation(extent={{40,78},{60,98}}),
                iconTransformation(extent={{60,50},{80,70}})));
          Modelica.Blocks.Continuous.Filter filter(
             final order=order,
             f_cut=5/(2*Modelica.Constants.pi*riseTime),
             final init=init,
             final y_start=y_start,
             final analogFilter=Modelica.Blocks.Types.AnalogFilter.CriticalDamping,
             final filterType=Modelica.Blocks.Types.FilterType.LowPass,
             x(each stateSelect=StateSelect.always)) if
                use_inputFilter
            "Second order filter to approximate valve opening time, and to improve numerics"
            annotation (Placement(transformation(extent={{6,81},{20,95}})));
        equation
         connect(filter.y, y_filtered) annotation (Line(
              points={{20.7,88},{50,88}},
              color={0,0,127}));
          if use_inputFilter then
          connect(y, filter.u) annotation (Line(
              points={{1.11022e-15,120},{1.11022e-15,88},{4.6,88}},
              color={0,0,127}));
          connect(filter.y, y_actual) annotation (Line(
              points={{20.7,88},{30,88},{30,70},{50,70}},
              color={0,0,127}));
          else
            connect(y, y_actual) annotation (Line(
              points={{1.11022e-15,120},{0,120},{0,70},{50,70}},
              color={0,0,127}));
          end if;
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={
                Line(
                  points={{0,40},{0,100}}),
                Line(
                  points={{0,70},{40,70}}),
                Rectangle(
                  visible=use_inputFilter,
                  extent={{-32,40},{32,100}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  visible=use_inputFilter,
                  extent={{-32,100},{32,40}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=use_inputFilter,
                  extent={{-20,92},{20,48}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  textString="M",
                  textStyle={TextStyle.Bold})}),
        Documentation(info="<html>
<p>
This model implements the filter that is used to approximate the travel
time of the actuator.
Models that extend this model use the signal
<code>y_actual</code> to obtain the
current position of the actuator.
</p>
<p>
The filter order can be changed to modify the transient response
of the actuator.
</p>
<p>
See
<a href=\"modelica://IDEAS.Fluid.Actuators.UsersGuide\">
IDEAS.Fluid.Actuators.UsersGuide</a>
for a description of the filter.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 16, 2018, by Filip Jorissen:<br/>
Propagated parameter <code>order</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/891\">#891</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
February 14, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ActuatorSignal;

        partial model PartialTwoWayValve "Partial model for a two way valve"
          extends IDEAS.Fluid.BaseClasses.PartialResistance(
               final dp_nominal=dpValve_nominal + dpFixed_nominal,
               dp(nominal=6000),
               final m_flow_turbulent = deltaM * abs(m_flow_nominal));
          extends IDEAS.Fluid.Actuators.BaseClasses.ValveParameters(
              rhoStd=Medium.density_pTX(101325, 273.15+4, Medium.X_default));
          extends IDEAS.Fluid.Actuators.BaseClasses.ActuatorSignal;
          parameter Modelica.SIunits.PressureDifference dpFixed_nominal(displayUnit="Pa", min=0) = 0
            "Pressure drop of pipe and other resistances that are in series"
             annotation(Dialog(group = "Nominal condition"));
          parameter Real l(min=1e-10, max=1) = 0.0001
            "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          input Real phi
            "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)";
          parameter Real kFixed(unit="", min=0) = if dpFixed_nominal > Modelica.Constants.eps
            then m_flow_nominal / sqrt(dpFixed_nominal) else 0
            "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
          Real kVal(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
          Real k(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
        initial equation
          assert(dpFixed_nominal > -Modelica.Constants.eps, "Require dpFixed_nominal >= 0. Received dpFixed_nominal = "
                + String(dpFixed_nominal) + " Pa.");
        equation
          assert(phi > -0.2, "Valve control signal needs to be bigger than zero, received phi = " + String(phi));
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}),       graphics={
                Polygon(
                  points={{2,-2},{-76,60},{-76,-60},{2,-2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-50,40},{0,-2},{54,40},{54,40},{-50,40}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-52,-42},{0,-4},{60,40},{60,-42},{-52,-42}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,-2},{82,60},{82,-60},{0,-2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{0,40},{0,-4}}),
                Line(
                  visible=not use_inputFilter,
                  points={{0,100},{0,40}})}),
        Documentation(info="<html>
<p>
Partial model for a two way valve. This is the base model for valves
with different opening characteristics, such as linear, equal percentage,
quick opening or pressure-independent.
</p>
<p>
To prevent the derivative <code>d/dP (m_flow)</code> to be infinite near
the origin, this model linearizes the pressure drop versus flow relation
ship. The region in which it is linearized is parameterized by
</p>
<pre>
  m_turbulent_flow = deltaM * m_flow_nominal
</pre>
<p>
Because the parameterization contains <code>Kv_SI</code>, the values for
<code>deltaM</code> and <code>dp_nominal</code> need not be changed if the valve size
changes.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
</p>
<h4>Options</h4>
<p>
This model allows different parameterization of the flow resistance.
The different parameterizations are described in
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.ValveParameters\">
IDEAS.Fluid.Actuators.BaseClasses.ValveParameters</a>.
</p>
<h4>Implementation</h4>
<p>
The two way valve models are implemented using this partial model, as opposed to using
different functions for the valve opening characteristics, because
each valve opening characteristics has different parameters.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
November 16, 2017, by Michael Wetter:<br/>
Relaxed assertion on <code>phi</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/592\">#592</a>.
</li>
<li>
October 27, 2016, by Filip Jorissen:<br/>
Added assert for <code>phi &gt; 0</code>.
This fixes a bug that caused valves to behave
like pumps for negative control signals.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/558\">#558</a>.
</li>
<li>
April 23, 2016, by Michael Wetter:<br/>
Changed test in assertion from <code>dpFixed_nominal > -Modelica.Constants.small</code>
to
<code>dpFixed_nominal > -Modelica.Constants.eps</code>.
Otherwise, JModelica evaluates it as <code>true</code> in
<a href=\"modelica://IDEAS.Fluid.Actuators.Valves.Examples.TwoWayValves\">
IDEAS.Fluid.Actuators.Valves.Examples.TwoWayValves</a>.
See also
<a href=\"https://trac.jmodelica.org/ticket/4932\">https://trac.jmodelica.org/ticket/4932</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/510\">Buildings, issue 510</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
January 29, 2015, by Filip Jorissen:<br/>
Moved the governing equations to
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValveKv\">
PartialTwoWayValveKv</a>
in order to be able to extend from this partial in
<a href=\"modelica://IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent\">
TwoWayPressureIndependent</a>
</li>
<li>
August 8, 2014, by Michael Wetter:<br/>
Reformulated the computation of <code>k</code> to make the model
work in OpenModelica.
</li>
<li>
April 4, 2014, by Michael Wetter:<br/>
Added keyword <code>input</code> to variable <code>phi</code>
to require models that extend this model to provide a binding equation.
This is done to use the same modeling concept as is used for example in
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
March 20, 2013, by Michael Wetter:<br/>
Set <code>dp(nominal=6000)</code> as the previous formulation gives an error during model check
in Dymola 2014. The reason is that the previous formulation used <code>dpValve_nominal</code>, which
is not known at translation time.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters.
Removed default value for <code>dpValve_nominal</code>, as this
parameter has the attribute <code>fixed=false</code> for some values
of <code>CvData</code>. In this case, assigning a value is not allowed.
Changed assignment of nominal attribute of <code>dp</code> to avoid assigning
a non-literal value.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://IDEAS.Fluid.Actuators.UsersGuide\">
IDEAS.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IDEAS.Fluid.BaseClasses.PartialResistance</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IDEAS.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 12, 2011 by Michael Wetter:<br/>
Added <code>assert</code> statement to prevent <code>l=0</code> due to the
implementation of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>.
</li>
<li>
April 4, 2011 by Michael Wetter:<br/>
Revised implementation to use new base class for actuators.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
Implemented parameterization of flow coefficient as in
<code>Modelica.Fluid</code>.
</li>
<li>
August 15, 2008 by Michael Wetter:<br/>
Set valve leakage to nonzero value.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialTwoWayValve;

        partial model ValveParameters "Model with parameters for valves"
          parameter IDEAS.Fluid.Types.CvTypes CvData=IDEAS.Fluid.Types.CvTypes.OpPoint
            "Selection of flow coefficient"
           annotation(Dialog(group = "Flow Coefficient"));
          parameter Real Kv(
            fixed= if CvData==IDEAS.Fluid.Types.CvTypes.Kv then true else false)
            "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==IDEAS.Fluid.Types.CvTypes.Kv)));
          parameter Real Cv(
            fixed= if CvData==IDEAS.Fluid.Types.CvTypes.Cv then true else false)
            "Cv (US) flow coefficient [USG/min/(psi)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==IDEAS.Fluid.Types.CvTypes.Cv)));
          parameter Modelica.SIunits.Area Av(
            fixed= if CvData==IDEAS.Fluid.Types.CvTypes.Av then true else false)
            "Av (metric) flow coefficient"
           annotation(Dialog(group = "Flow Coefficient",
                             enable = (CvData==IDEAS.Fluid.Types.CvTypes.Av)));
          parameter Real deltaM = 0.02
            "Fraction of nominal flow rate where linearization starts, if y=1"
            annotation(Dialog(group="Pressure-flow linearization"));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.PressureDifference dpValve_nominal(
             displayUnit="Pa",
             min=0,
             fixed= if CvData==IDEAS.Fluid.Types.CvTypes.OpPoint then true else false)
            "Nominal pressure drop of fully open valve, used if CvData=IDEAS.Fluid.Types.CvTypes.OpPoint"
            annotation(Dialog(group="Nominal condition",
                       enable = (CvData==IDEAS.Fluid.Types.CvTypes.OpPoint)));
          parameter Modelica.SIunits.Density rhoStd
            "Inlet density for which valve coefficients are defined"
          annotation(Dialog(group="Nominal condition", tab="Advanced"));
      protected
          parameter Real Kv_SI(
            min=0,
            fixed= false)
            "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==IDEAS.Fluid.Types.CvTypes.OpPoint)));
        initial equation
          if  CvData == IDEAS.Fluid.Types.CvTypes.OpPoint then
            Kv_SI =           m_flow_nominal/sqrt(dpValve_nominal);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
          elseif CvData == IDEAS.Fluid.Types.CvTypes.Kv then
            Kv_SI =           Kv*rhoStd/3600/sqrt(1E5)
              "Unit conversion m3/(h*sqrt(bar)) to kg/(s*sqrt(Pa))";
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          elseif CvData == IDEAS.Fluid.Types.CvTypes.Cv then
            Kv_SI =           Cv*rhoStd*0.0631/1000/sqrt(6895)
              "Unit conversion USG/(min*sqrt(psi)) to kg/(s*sqrt(Pa))";
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          else
            assert(CvData == IDEAS.Fluid.Types.CvTypes.Av, "Invalid value for CvData.
Obtained CvData = "         + String(CvData) + ".");
            Kv_SI =           Av*sqrt(rhoStd);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          end if;
          annotation (Documentation(info="<html>
<p>
Model that computes the flow coefficients of valves. This base class allows the following modeling options,
which have been adapted from the valve implementation
in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
to specify the valve flow coefficient in fully open conditions:
</p>
<ul>
<li><code>CvData = IDEAS.Fluid.Types.CvTypes.Av</code>: the flow coefficient is given by the metric <code>Av</code> coefficient (m^2).</li>
<li><code>CvData = IDEAS.Fluid.Types.CvTypes.Kv</code>: the flow coefficient is given by the metric <code>Kv</code> coefficient (m^3/h).</li>
<li><code>CvData = IDEAS.Fluid.Types.CvTypes.Cv</code>: the flow coefficient is given by the US <code>Cv</code> coefficient (USG/min).</li>
<li><code>CvData = IDEAS.Fluid.Types.CvTypes.OpPoint</code>: the flow is computed from the nominal operating point specified by <code>dp_nominal</code> and <code>m_flow_nominal</code>.</li>
</ul>
<p>
The treatment of parameters <code>Kv</code> and <code>Cv</code> is
explained in detail in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">Users Guide</a>.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the protected parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
The value of <code>Kv_SI</code> is computed based on the parameters
<code>Av</code>,
<code>Kv</code>,
<code>Cv</code>, or, if
<code>CvData = IDEAS.Fluid.Types.CvTypes.OpPoint</code>, based on
<code>m_flow_nominal</code> and <code>dpValve_nominal</code>.
Conversely, if
<code>CvData &lt;&gt; IDEAS.Fluid.Types.CvTypes.OpPoint</code>, then
<code>dpValve_nominal</code> is computed based on
<code>Av</code>,
<code>Kv</code>, or
<code>Cv</code>, and the nominal mass flow rate <code>m_flow_nominal</code>.
Therefore, if
<code>CvData &lt;&gt; IDEAS.Fluid.Types.CvTypes.OpPoint</code>,
then specifying a value for <code>dpValve_nominal</code> is a syntax error.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 12, 2014, by Michael Wetter:<br/>
Changed attribute <code>min</code> of <code>dpValve_nominal</code>
to <code>0</code>.
This is needed as for example in
<a href=\"modelica://IDEAS.Fluid.Actuators.Valves.Examples.TwoWayValveTable\">
IDEAS.Fluid.Actuators.Valves.Examples.TwoWayValveTable</a>,
<code>dpValve_nominal=0</code>.
</li>
<li>
August 8, 2014, by Michael Wetter:<br/>
Changed the <code>initial algorithm</code> to an <code>initial equation</code>
section. Otherwise, OpenModelica attempts to solve for the parameter
values using numerical iteration, and fails in doing so.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 25, 2013, by Michael Wetter:<br/>
Removed stray backslash in write statement.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters, and removed <code>Kv_SI</code> as
a public parameter because it is always computed based on other parameters.
This change avoids a translation error in Dymola 2014 beta1 in
the pedantic mode, and a translation warning otherwise.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ValveParameters;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.Actuators\">IDEAS.Fluid.Actuators</a>.
</p>
</html>"));
      end BaseClasses;

      package Valves "Package with valve models"
        extends Modelica.Icons.VariantsPackage;

        package Simplified
          extends Modelica.Icons.VariantsPackage;

          package BaseClasses
          extends Modelica.Icons.BasesPackage;

            model Partial3WayValve "Partial for 3-way valves"
              extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations;
              parameter Real tau = 1 "Thermal time constant"
                annotation(Dialog(tab="Dynamics", group="Filter"));
              parameter Real l = 0.001
                "Valve leakage, minimum fraction of flow rate passing through ports 
    a";
              parameter Modelica.SIunits.MassFlowRate m_flow_nominal
                "Nominal mass flow rate";
              parameter Boolean allowFlowReversal=true
                "= true to allow flow reversal";
              final parameter Modelica.SIunits.Mass m = m_flow_nominal*tau
                "Fluid content of the mixing valve";

              Modelica.Fluid.Interfaces.FluidPort_a port_a1(
                redeclare package Medium = Medium) "First fluid inlet"
                annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
              Modelica.Fluid.Interfaces.FluidPort_a port_a2(
                redeclare package Medium = Medium) "Second fluid inlet"
                annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
              Modelica.Fluid.Interfaces.FluidPort_b port_b(
                redeclare package Medium = Medium) "Fluid outlet"
                annotation (Placement(transformation(extent={{90,-10},{110,10}})));

              IDEAS.Fluid.MixingVolumes.MixingVolume vol(nPorts=3,
                redeclare package Medium = Medium,
                m_flow_nominal=m_flow_nominal,
                energyDynamics=energyDynamics,
                massDynamics=massDynamics,
                p_start=p_start,
                T_start=T_start,
                X_start=X_start,
                C_start=C_start,
                C_nominal=C_nominal,
                V=m/Medium.density(Medium.setState_pTX(
                    Medium.p_default,
                    Medium.T_default,
                    Medium.X_default)),
                allowFlowReversal=allowFlowReversal,
                mSenFac=mSenFac)
                annotation (Placement(transformation(extent={{-10,0},{10,20}})));

              IDEAS.Fluid.Interfaces.IdealSource idealSource(
                redeclare package Medium = Medium,
                control_m_flow=true,
                allowFlowReversal=allowFlowReversal)
                                       annotation (Placement(transformation(
                    extent={{-10,10},{10,-10}},
                    rotation=90,
                    origin={0,-44})));
            equation
              connect(port_a1, vol.ports[1]) annotation (Line(
                  points={{-100,0},{-2.66667,0}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(port_b, vol.ports[2]) annotation (Line(
                  points={{100,0},{2.22045e-16,0}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(idealSource.port_a, port_a2) annotation (Line(
                  points={{0,-54},{4.44089e-16,-54},{4.44089e-16,-100}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(idealSource.port_b, vol.ports[3]) annotation (Line(
                  points={{0,-34},{0,-4.44089e-16},{2.66667,-4.44089e-16}},
                  color={0,127,255},
                  smooth=Smooth.None));
              annotation (
                Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                        100,100}}),
                        graphics),
                Icon(graphics={
                    Polygon(
                      points={{-60,30},{-60,-30},{0,0},{-60,30}},
                      lineColor={0,0,127},
                      smooth=Smooth.None),
                    Polygon(
                      points={{60,30},{60,-30},{0,0},{60,30}},
                      lineColor={0,0,127},
                      smooth=Smooth.None),
                    Polygon(
                      points={{-30,30},{-30,-30},{30,0},{-30,30}},
                      lineColor={0,0,127},
                      smooth=Smooth.None,
                      origin={0,-30},
                      rotation=90),
                    Ellipse(extent={{-20,80},{20,40}}, lineColor={0,0,127}),
                    Line(
                      points={{0,0},{0,40}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Text(
                      extent={{-10,70},{10,50}},
                      lineColor={0,0,127},
                      textString="M"),
                    Line(
                      points={{-70,30},{-70,-30}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{70,30},{70,-30}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{-30,-70},{30,-70}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{-70,0},{-100,0}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{70,0},{100,0}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{0,-70},{0,-100}},
                      color={0,0,127},
                      smooth=Smooth.None)}),
                Documentation(info="<html>
<p><b>Description</b> </p>
<p>3-way valve with temperature set point for mixing a cold and hot fluid to obtain outlet fluid at the desired temperature. If the desired temperature is higher than the hot fluid, no mixing will occur and the outlet will have the temperature of the hot fluid. </p>
<p>Inside the valve, the cold water flowrate is fixed with a pump component.  The fluid content in the valve is equally split between the mixing volume and this pump.  Without fluid content in the pump, this model does not work in all operating conditions.  </p>
<h4>Assumptions and limitations </h4>
<ol>
<li>Correct connections of hot and cold fluid to the corresponding flowPorts is NOT CHECKED.</li>
<li>The fluid content m of the valve has to be larger than zero</li>
<li>There is an internal parameter mFlowMin which sets a minimum mass flow rate for mixing to start. </li>
</ol>
<h4>Model use</h4>
<ol>
<li>Set medium and the internal fluid content of the valve (too small values of m could increase simulation times)</li>
<li>Set mFlowMin, the minimum mass flow rate for mixing to start. </li>
<li>Supply a set temperature at the outlet</li>
</ol>
<h4>Validation </h4>
<p>None </p>
<h4>Example (optional) </h4>
<p>Examples of this model can be found in<a href=\"modelica://IDEAS.Thermal.Components.Examples.TempMixingTester\"> IDEAS.Thermal.Components.Examples.TempMixingTester</a> and<a href=\"modelica://IDEAS.Thermal.Components.Examples.RadiatorWithMixingValve\"> IDEAS.Thermal.Components.Examples.RadiatorWithMixingValve</a></p>
</html>",             revisions="<html>
<ul>
<li>
May 3, 2019 by Filip Jorissen:<br/> 
Propagated <code>mSenFac</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1018\">#1018</a>.
</li>
<li>
April 23, 2019 by Filip Jorissen:<br/> 
Using separate port for each connection to avoid algebraic loops.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1019\">#1019</a>.
</li>
<li>
March 26, 2018 by Filip Jorissen:<br/> 
Implemented valve leakage,
see <a href=\"https://github.com/open-ideas/IDEAS/issues/782\">#782</a>.
</li>
<li>
March 2014 by Filip Jorissen:<br/> 
Initial implementation
</li>
</ul>
</html>
"));
            end Partial3WayValve;
          end BaseClasses;

          model ThreeWayValveMotor
            "Ideal three way valve with a krane controlled with a Real input with value between 0 and 1"
            extends BaseClasses.Partial3WayValve(idealSource(dp_start=0));
            Modelica.Blocks.Interfaces.RealInput ctrl(min=0, max=1)
              "procentage of flow through flowPort_a1" annotation (Placement(transformation(
                  extent={{20,-20},{-20,20}},
                  rotation=90,
                  origin={10,118}),iconTransformation(
                  extent={{10,-10},{-10,10}},
                  rotation=90,
                  origin={0,108})));
            Modelica.Blocks.Sources.RealExpression realExpression(y=-(l + (1 - ctrl)*(1 -
                  2*l))*port_b.m_flow)
              annotation (Placement(transformation(extent={{92,-60},{28,-40}})));
          equation
            connect(realExpression.y, idealSource.m_flow_in) annotation (Line(
                points={{24.8,-50},{8,-50}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Icon(coordinateSystem(preserveAspectRatio=false,
                             extent={{-100,-100},{100,100}}),
                                                graphics={
                  Polygon(
                    points={{-60,30},{-60,-30},{0,0},{-60,30}},
                    lineColor={0,0,127},
                    smooth=Smooth.None,
                    fillColor={0,127,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-30,30},{-30,-30},{30,0},{-30,30}},
                    lineColor={0,0,127},
                    smooth=Smooth.None,
                    origin={0,-30},
                    rotation=90,
                    fillColor={0,127,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-30,-70},{30,-70}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-70},{0,-100}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Text(
                    extent={{-100,-56},{100,-100}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(revisions="<html>
<ul>
<li>
March 26, 2018 by Filip Jorissen:<br/> 
Implemented valve leakage,
see <a href=\"https://github.com/open-ideas/IDEAS/issues/782\">#782</a>.
</li>
<li>March 2014 by Filip Jorissen:<br/> 
Annex60 compatibility
</li>
<li>January 2014, Damien Picard:<br/> 
First implementation
</li>
</ul>
</html>
"));
          end ThreeWayValveMotor;

          model ThreeWayValveSwitch "Switches between two circuits"
            extends BaseClasses.Partial3WayValve;
            parameter Modelica.SIunits.MassFlowRate mFlowMin = 0.01
              "Minimum outlet flowrate for mixing to start";
            Modelica.Blocks.Interfaces.BooleanInput switch
              "if true, the flow goes from leg a2 to leg b. Otherwise from leg a1"                                              annotation (Placement(
                  transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,102}), iconTransformation(
                 extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,80})));
            Modelica.Blocks.Sources.RealExpression realExpression(y=-port_b.m_flow)
              "Outlet flow rate"
              annotation (Placement(transformation(extent={{78,50},{34,70}})));
            Modelica.Blocks.Math.Product product
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={22,32})));
            Modelica.Blocks.Math.BooleanToReal booleanToReal(realTrue=1 - l, realFalse=l)
                                                             annotation (Placement(
                  transformation(
                  extent={{-6,-6},{6,6}},
                  rotation=270,
                  origin={4.44089e-16,70})));
          equation
            connect(product.u2, booleanToReal.y) annotation (Line(
                points={{16,44},{16,60},{0,60},{0,63.4},{-1.33227e-15,63.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(switch, booleanToReal.u) annotation (Line(
                points={{0,102},{0,77.2},{1.11022e-15,77.2}},
                color={255,0,255},
                smooth=Smooth.None));
            connect(realExpression.y, product.u1) annotation (Line(
                points={{31.8,60},{28,60},{28,44}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(product.y, idealSource.m_flow_in) annotation (Line(
                points={{22,21},{24,21},{24,-50},{8,-50}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Icon(graphics={
                  Polygon(
                    points={{-60,30},{-60,-30},{0,0},{-60,30}},
                    lineColor={100,100,100},
                    smooth=Smooth.None),
                  Polygon(
                    points={{60,30},{60,-30},{0,0},{60,30}},
                    lineColor={100,100,100},
                    smooth=Smooth.None),
                  Polygon(
                    points={{-30,30},{-30,-30},{30,0},{-30,30}},
                    lineColor={100,100,100},
                    smooth=Smooth.None,
                    origin={0,-30},
                    rotation=90),
                  Line(
                    points={{-70,30},{-70,-30}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Line(
                    points={{70,30},{70,-30}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Line(
                    points={{-30,-70},{30,-70}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Line(
                    points={{-70,0},{-100,0}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Line(
                    points={{70,0},{100,0}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-70},{0,-100}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Text(
                    extent={{-76,-20},{-22,16}},
                    lineColor={255,0,0},
                    textString="0"),
                  Text(
                    extent={{-28,-62},{26,-26}},
                    lineColor={255,0,0},
                    textString="1")}),
              Documentation(revisions="<html>
<ul>
<li>March 26, 2018 by Filip Jorissen:<br/> 
Implemented valve leakage,
see <a href=\"https://github.com/open-ideas/IDEAS/issues/782\">#782</a>.
</li>
<li>March 2014 by Filip Jorissen:<br/> 
Annex60 compatibility
</li>
<li>January 2014, Dieter Patteeuw:<br/> 
First implementation
</li>
</ul>
</html>
"));
          end ThreeWayValveSwitch;
        end Simplified;

        model TwoWayPressureIndependent "Model of a pressure-independent two way valve"
          extends IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve(
                    final linearized = false,
                    from_dp=true,
                    phi=l + y_actual*(1 - l));
          parameter Real l2(min=1e-10) = 0.01
            "Gain for mass flow increase if pressure is above nominal pressure"
            annotation(Dialog(tab="Advanced"));
          parameter Real deltax = 0.02 "Transition interval for flow rate"
            annotation(Dialog(tab="Advanced"));
      protected
          parameter Real coeff1 = l2/dp_nominal*m_flow_nominal
            "Parameter for avoiding unnecessary computations";
          parameter Real coeff2 = 1/coeff1
            "Parameter for avoiding unnecessary computations";
          constant Real y2dd = 0
            "Second derivative at second support point";
          Modelica.SIunits.MassFlowRate m_flow_set
            "Requested mass flow rate";
          Modelica.SIunits.PressureDifference dp_min(displayUnit="Pa")
            "Minimum pressure difference required for delivering requested mass flow rate";
          Modelica.SIunits.PressureDifference dp_x, dp_x1, dp_x2, dp_y2, dp_y1
            "Support points for interpolation flow functions";
          Modelica.SIunits.MassFlowRate m_flow_x, m_flow_x1, m_flow_x2, m_flow_y2, m_flow_y1
            "Support points for interpolation flow functions";
          Modelica.SIunits.MassFlowRate m_flow_smooth
            "Smooth interpolation result between two flow regimes";
          Modelica.SIunits.PressureDifference dp_smooth
            "Smooth interpolation result between two flow regimes";
        equation
          m_flow_set = m_flow_nominal*phi;
          kVal = Kv_SI;
          if (dpFixed_nominal > Modelica.Constants.eps) then
            k = sqrt(1/(1/kFixed^2 + 1/kVal^2));
          else
            k = kVal;
          end if;
          dp_min = IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                      m_flow=m_flow_set,
                      k=k,
                      m_flow_turbulent=m_flow_turbulent);
          if from_dp then
            m_flow_x=0;
            m_flow_x1=0;
            m_flow_x2=0;
            dp_y1=0;
            dp_y2=0;
            dp_smooth=0;
            dp_x = dp-dp_min;
            dp_x1 = -dp_x2;
            dp_x2 = deltax*dp_min;
            // min function ensures that m_flow_y1 does not increase further for dp_x > dp_x1
            m_flow_y1 = IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                                          dp=min(dp, dp_min+dp_x1),
                                          k=k,
                                          m_flow_turbulent=m_flow_turbulent);
            // max function ensures that m_flow_y2 does not decrease further for dp_x < dp_x2
            m_flow_y2 = m_flow_set + coeff1*max(dp_x,dp_x2);
            m_flow_smooth = noEvent(smooth(2,
                if dp_x <= dp_x1
                then m_flow_y1
                elseif dp_x >=dp_x2
                then m_flow_y2
                else IDEAS.Utilities.Math.Functions.quinticHermite(
                         x=dp_x,
                         x1=dp_x1,
                         x2=dp_x2,
                         y1=m_flow_y1,
                         y2=m_flow_y2,
                         y1d= IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der(
                                             dp=dp_min + dp_x1,
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent,
                                             dp_der=1),
                         y2d=coeff1,
                         y1dd=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2(
                                             dp=dp_min + dp_x1,
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent,
                                             dp_der=1,
                                             dp_der2=0),
                         y2dd=y2dd)));
          else
            dp_x=0;
            dp_x1=0;
            dp_x2=0;
            m_flow_y1=0;
            m_flow_y2=0;
            m_flow_smooth=0;
            m_flow_x = m_flow-m_flow_set;
            m_flow_x1 = -m_flow_x2;
            m_flow_x2 = deltax*m_flow_set;
            // min function ensures that dp_y1 does not increase further for m_flow_x > m_flow_x1
            dp_y1 = IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                                             m_flow=min(m_flow, m_flow_set + m_flow_x1),
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent);
            // max function ensures that dp_y2 does not decrease further for m_flow_x < m_flow_x2
            dp_y2 = dp_min + coeff2*max(m_flow_x, m_flow_x2);
            dp_smooth = noEvent(smooth(2,
                if m_flow_x <= m_flow_x1
                then dp_y1
                elseif m_flow_x >=m_flow_x2
                then dp_y2
                else IDEAS.Utilities.Math.Functions.quinticHermite(
                         x=m_flow_x,
                         x1=m_flow_x1,
                         x2=m_flow_x2,
                         y1=dp_y1,
                         y2=dp_y2,
                         y1d=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(
                                             m_flow=m_flow_set + m_flow_x1,
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent,
                                             m_flow_der=1),
                         y2d=coeff2,
                         y1dd=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2(
                                             m_flow=m_flow_set + m_flow_x1,
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent,
                                             m_flow_der=1,
                                             m_flow_der2=0),
                         y2dd=y2dd)));
          end if;
          if homotopyInitialization then
            if from_dp then
              m_flow=homotopy(actual=m_flow_smooth,
                              simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
            else
                dp=homotopy(
                   actual=dp_smooth,
                   simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
            end if;
          else
            if from_dp then
              m_flow=m_flow_smooth;
            else
              dp=dp_smooth;
            end if;
          end if;
          annotation (defaultComponentName="val",
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}),       graphics={
                Polygon(
                  points={{2,-2},{-76,60},{-76,-60},{2,-2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-50,40},{0,-2},{54,40},{54,40},{-50,40}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-52,-42},{0,-4},{60,40},{60,-42},{-52,-42}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,-2},{82,60},{82,-60},{0,-2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{0,40},{0,-4}}),
                Line(
                  visible=not use_inputFilter,
                  points={{0,100},{0,40}})}),
        Documentation(info="<html>
<p>
Two way valve with a pressure-independent valve opening characteristic.
The mass flow rate is controlled such that it is nearly equal to its
set point <code>y*m_flow_nominal</code>, unless the pressure
<code>dp</code> is too low, in which case a regular <code>Kv</code>
characteristic is used.
</p>
<h4>Main equations</h4>
<p>
First the minimum pressure head <code>dp_min</code>
required for delivering the requested mass flow rate
<code>y*m_flow_nominal</code> is computed. If
<code>dp &gt; dp_min</code> then the requested mass flow
rate is supplied. If <code>dp &lt; dp_min</code> then
<code>m_flow = Kv/sqrt(dp)</code>. Transition between
these two flow regimes happens in a smooth way.
</p>
<h4>Typical use and important parameters</h4>
<p>
This model is configured by setting <code>m_flow_nominal</code>
to the mass flow rate that the valve should supply when it is
completely open, i.e., <code>y = 1</code>. The pressure drop corresponding
to this working point can be set using <code>dpValve_nominal</code>,
or using a <code>Kv</code>, <code>Cv</code> or <code>Av</code>
value. The parameter <code>dpValve_fixed</code> can be used to add
additional pressure drops, although in this valve it is equivalent to
add these to <code>dpValve_nominal</code>.
</p>
<p>
The parameter <code>l2</code> represents the non-ideal
leakage behaviour of this valve for high pressures.
It is assumed that the mass flow rate will rise beyond
the requested mass flow rate <code>y*m_flow_nominal</code>
if <code>dp &gt; dpValve_nominal+dpFixed_nominal</code>.
The parameter <code>l2</code> represents the slope
of this rise:
<code>d(m_flow)/d(dp) = l2* m_flow_nominal/dp_nominal</code>.
In the ideal case <code>l2=0</code>, but
this may introduce singularities, for instance when
connecting this component with a fixed mass flow source.
</p>
<h4>Options</h4>
<p>
Parameter <code>deltax</code> sets the duration of
the transition region between the two flow regimes
as a fraction of <code>dp_nominal</code> or <code>m_flow_nominal</code>,
depending on the value of <code>from_dp</code>.
</p>
<h4>Implementation</h4>
<p>
Note that the result in the transition region when
using <code>from_dp = true</code> is not identical to
the result when using <code>from_dp = false</code>.
</p>
<p>
Variables <code>*_y1</code> and <code>*_y2</code>
serve a dual use.
They are used to
1) compute the support points at <code>*_x1</code> and <code>*_x2</code>,
which should not depend on <code>m_flow</code> or <code>dp</code> and
2) to compute the flow functions when outside of this regime,
which does depend on <code>m_flow</code> or <code>dp</code>.
Min and max functions are therefore used such that one equation
can serve both puroposes.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2017, by Filip Jorissen:<br/>
Revised implementation using <code>cubicHermite</code>
such that it does not have a local maximum
and such that it is C2-continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/156\">#156</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
January 29, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TwoWayPressureIndependent;
      annotation (preferredView="info", Documentation(info="<html>
This package contains component models for two- and three-way valves.
For motor models, see
<a href=\"modelica://IDEAS.Fluid.Actuators.Motors\">IDEAS.Fluid.Actuators.Motors</a>.
</html>"));
      end Valves;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models for actuators.
</html>"));
    end Actuators;

    package BaseClasses "Package with base classes for IDEAS.Fluid"
      extends Modelica.Icons.BasesPackage;

      package FlowModels "Flow models for pressure drop calculations"
        extends Modelica.Icons.BasesPackage;

        function basicFlowFunction_dp
          "Function that computes mass flow rate for given pressure drop"

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
           m_flow :=  if noEvent(abs(dp)>dp_turbulent)
                      then sign(dp)*k*sqrt(abs(dp))
                      else (1.40625  + (0.15625*dpNormSq - 0.5625)*dpNormSq)*m_flow_turbulent*dpNorm;
          annotation(LateInline=true,
                   smoothOrder=2,
                   derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der,
                   inverse(dp=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                     m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent)),
                   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
March 19, 2016, by Michael Wetter:<br/>
Added <code>abs</code> function for
<code>IDEAS.Fluid.FixedResistances.Validation.PressureDropsExplicit</code>
to work in OpenModelica.
See <a href=\"https://trac.openmodelica.org/OpenModelica/ticket/3778\">
OpenModelica ticket 3778</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
January 9, 2014, by Michael Wetter:<br/>
Correct revision section, of which there were two.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>m_flow=0</code> if <code>dp=0</code>,
as this causes the derivative to be discontinuous at <code>dp=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2010 by Michael Wetter:<br/>
Changed implementation to allow <code>k=0</code>, which is
the case for a closed valve with no leakage
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_dp;

        function basicFlowFunction_dp_der
          "1st derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNormSq=(dp/dp_turbulent)^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der := (if noEvent(abs(dp)>dp_turbulent)
                        then 0.5*k/sqrt(abs(dp))
                        else (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*m_flow_turbulent/dp_turbulent)*dp_der;
         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
April 14, 2017, by Filip Jorissen:<br/>
Changed implementation such that it cannot lead to square roots
of negative numbers and reduced the number of required operations.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/723\">#723</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der;

        function basicFlowFunction_dp_der2
          "2nd derivative of flow function2nd derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "1st derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der2
            "2nd derivative of mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der2 := if noEvent(abs(dp)>dp_turbulent)
                         then 0.5*k/sqrt(abs(dp))*(-0.5/dp * dp_der^2 + dp_der2)
                         else m_flow_turbulent/dp_turbulent*(
                               (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*dp_der2
                             + (-3.375 + 3.125*dpNormSq)*dpNorm/dp_turbulent*dp_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der2;

        function basicFlowFunction_m_flow
          "Function that computes pressure drop for given mass flow rate"

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";

        algorithm
         dp :=if noEvent(abs(m_flow)>m_flow_turbulent)
              then sign(m_flow)*(m_flow/k)^2
              else (0.375 + (0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm;

         annotation (LateInline=true,
                     smoothOrder=2,
                     derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der,
                     inverse(m_flow=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                       dp=dp, k=k, m_flow_turbulent=m_flow_turbulent)),
                     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = sign(m) (m &frasl; k)<sup>2</sup>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>dp=0</code> if <code>m_flow=0</code>,
as this causes the derivative to be discontinuous at <code>m_flow=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow;

        function basicFlowFunction_m_flow_der
          "1st derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
          output Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNormSq = (m_flow/m_flow_turbulent)^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der :=(if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2*m_flow/k^2
                   else (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent/m_flow_turbulent)*m_flow_der;

         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der;

        function basicFlowFunction_m_flow_der2
          "2nd derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "1st derivative of mass flow rate in design flow direction";
          input Real m_flow_der2(unit="kg/s3")
            "2nd derivative of mass flow rate in design flow direction";
          output Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der2 :=if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2/k^2 * (m_flow_der^2 + m_flow * m_flow_der2)
                   else dp_turbulent/m_flow_turbulent*(
                         (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*m_flow_der2
                       + (4.5 - 2.5*m_flowNormSq)*m_flowNorm/m_flow_turbulent*m_flow_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der2;
      annotation (Documentation(info="<html>
<p>
This package contains a basic flow model that is used by the
various models that compute pressure drop.
</p>
<h4>Assumption and limitations</h4>
<p>
Because the density does not change signficantly in heating,
ventilation and air conditioning systems for buildings,
the flow models compute the pressure drop based on the mass flow
rate and not the volume flow rate. This typically leads to simpler
equations because it does not require
the mass density, which changes when the flow is reversed.
Although, for conceptual design of building energy system, there is
in general not enough information available that would warrant a more
detailed pressure drop calculation.
If a more detailed computation of the flow resistance is needed,
then a user can use models from the
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a> library.
</p>
<p>
All functions have an argument <code>m_flow_turbulent</code> that determines where the
flow transitions to fully turbulent flow. For smaller mass flow rates,
the quadratic relation is replaced by a function that has finite slope
near zero pressure drop. This is done for numerical reasons, and to approximate
laminar flow, although the implementation does not use a linear function.
</p>
<h4>Implementation</h4>
<p>
The two main functions are
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
and
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
that compute the mass flow rate or the pressure drop, respectively.
Both functions are two times continuously differentiable.
First and second order derivatives are provided
in the function that have the suffix <code>_der</code> and <code>_der2</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 10, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FlowModels;

      model MassFlowRateMultiplier "Model that multiplies the mass flow rate"
        extends IDEAS.Fluid.Interfaces.PartialTwoPort;
        parameter Real k "Gain for mass flow rate";
      initial equation
        assert(k > Modelica.Constants.small or -k < -Modelica.Constants.small,
          "Gain must not be zero. Received k = " + String(k));
      equation
          // Pressure drop in design flow direction
        port_a.p = port_b.p;
        // Mass balance (mass is not conserved by this model!)
        port_b.m_flow = -k*port_a.m_flow;
        // Specific enthalpy flow rate
        port_a.h_outflow = inStream(port_b.h_outflow);
        port_b.h_outflow = inStream(port_a.h_outflow);
        // Transport of substances
        port_a.Xi_outflow = inStream(port_b.Xi_outflow);
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);
        port_a.C_outflow = inStream(port_b.C_outflow);
        port_b.C_outflow = inStream(port_a.C_outflow);
        annotation (Documentation(info="<html>
<p>
This model multiplies the mass flow rate so that
<code>0 = port_b.m_flow + k * port_a.m_flow</code>.
</p>
<p>
The specific enthalpy, the species concentration and the trace substance concentration
remain unchanged.
Therefore, this model does not conserve mass or energy.
It is used in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.PartialBorefield\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.PartialBorefield</a>
and also in the Buildings library
to avoid having to instantiate circuits in parallel, with each
having the same mass flow rate and temperatures.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2013, by Michael Wetter:<br/>
Changed implementation to extend from <code>Modelica.Fluid</code>.
</li>
<li>
June 27, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,237,228},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
                                Polygon(
                points={{-100,8},{100,20},{100,-20},{-100,-8},{-100,8}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid)}));
      end MassFlowRateMultiplier;

      partial model PartialResistance "Partial model for a hydraulic resistance"
          extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
           show_T=false,
           dp(nominal=if dp_nominal_pos > Modelica.Constants.eps
                then dp_nominal_pos else 1),
           m_flow(
              nominal=if m_flow_nominal_pos > Modelica.Constants.eps
                then m_flow_nominal_pos else 1),
           final m_flow_small = 1E-4*abs(m_flow_nominal));
        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.SIunits.PressureDifference dp_nominal(displayUnit="Pa")
          "Pressure drop at nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
          "Turbulent flow if |m_flow| >= m_flow_turbulent";
    protected
        parameter Medium.ThermodynamicState sta_default=
           Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.DynamicViscosity eta_default=Medium.dynamicViscosity(sta_default)
          "Dynamic viscosity, used to compute transition to turbulent flow regime";
        final parameter Modelica.SIunits.MassFlowRate m_flow_nominal_pos = abs(m_flow_nominal)
          "Absolute value of nominal flow rate";
        final parameter Modelica.SIunits.PressureDifference dp_nominal_pos(displayUnit="Pa") = abs(dp_nominal)
          "Absolute value of nominal pressure difference";
      equation
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
        port_b.h_outflow = inStream(port_a.h_outflow);
        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;
        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);
        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-42}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,22},{100,-24}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Rectangle(
                visible=linearized,
                extent={{-100,22},{100,-24}},
                fillPattern=FillPattern.Backward,
                fillColor={0,128,255},
                pattern=LinePattern.None,
                lineColor={255,255,255})}),
                defaultComponentName="res",
      Documentation(info="<html>
<p>
Partial model for a flow resistance, possible with variable flow coefficient.
Models that extend this class need to implement an equation that relates
<code>m_flow</code> and <code>dp</code>, and they need to assign the parameter
<code>m_flow_turbulent</code>.
</p>
<p>
See for example
<a href=\"modelica://IDEAS.Fluid.FixedResistances.PressureDrop\">
IDEAS.Fluid.FixedResistances.PressureDrop</a> for a model that extends
this base class.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start value for pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Avoided assignment of <code>dp(nominal=0)</code> if <code>dp_nominal_pos = 0</code>
and of <code>m_flow(nominal=0)</code> if <code>m_flow_nominal_pos = 0</code>
as nominal values are not allowed to be zero.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
January 13, 2015, by Marcus Fuchs:<br/>
Revised revisions section (there were two revisions statements)
</li>
<li>
November 20, 2014 by Michael Wetter:<br/>
Removed <code>start</code> attribute for <code>m_flow</code>
as this is already set in its base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to base class as it has no longer this parameter.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
February 12, 2012, by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Made assignment of <code>m_flow_small</code> <code>final</code> as it is no
longer used in the base class.
</li>
<li>
January 16, 2012, by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IDEAS.Fluid.BaseClasses.PartialResistance</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IDEAS.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 5, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
June 20, 2011, by Michael Wetter:<br/>
Set start values for <code>m_flow</code> and <code>dp</code> to zero, since
most HVAC systems start at zero flow. With this change, the start values
appear in the GUI and can be set by the user.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>m_flow_nominal_pos</code> and <code>dp_nominal_pos</code> to allow
providing negative nominal values which will be used, for example, to set start
values of flow splitters which may have negative flow rates and pressure drop
at the initial condition.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23, 2011 by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 30, 2010 by Michael Wetter:<br/>
Changed base classes to allow easier initialization.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Extracted pressure drop computation and implemented it in the
new model
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.BasicFlowModel\">
IDEAS.Fluid.BaseClasses.FlowModels.BasicFlowModel</a>.
</li>
<li>
September 18, 2008, by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialResistance;

      partial model PartialThreeWayResistance
        "Flow splitter with partial resistance model at each port"
        extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations(
          final mSenFac=1);
        Modelica.Fluid.Interfaces.FluidPort_a port_1(
          redeclare package Medium = Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_1 == Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_1== Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "First port, typically inlet"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_2(
          redeclare package Medium = Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "Second port, typically outlet"
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        Modelica.Fluid.Interfaces.FluidPort_a port_3(
          redeclare package Medium=Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "Third port, can be either inlet or outlet"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
        parameter Modelica.SIunits.Time tau=10
          "Time constant at nominal flow for dynamic energy and momentum balance"
          annotation(Dialog(tab="Dynamics", group="Nominal condition",
                     enable=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));
        parameter Modelica.SIunits.MassFlowRate mDyn_flow_nominal
          "Nominal mass flow rate for dynamic momentum and energy balance"
          annotation(Dialog(tab="Dynamics", group="Equations",
                     enable=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));
        parameter Boolean from_dp = true
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_1"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_2"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_3"
         annotation(Dialog(tab="Advanced"));
        parameter Boolean verifyFlowReversal = false
          "=true, to assert that the flow does not reverse when portFlowDirection_* does not equal Bidirectional"
          annotation(Dialog(tab="Advanced"));
        parameter Modelica.SIunits.MassFlowRate m_flow_small
          "Small mass flow rate for checking flow reversal"
          annotation(Dialog(tab="Advanced",enable=verifyFlowReversal));
        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface res1
          constrainedby IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_1 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface res2
          constrainedby IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{60,-10},{40,10}})));
        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface res3
          constrainedby IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_3 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(
              origin={0,-50},
              extent={{-10,10},{10,-10}},
              rotation=90)));
        IDEAS.Fluid.Delays.DelayFirstOrder vol(
          redeclare final package Medium = Medium,
          final nPorts=3,
          final tau=tau,
          final m_flow_nominal=mDyn_flow_nominal,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final allowFlowReversal=true,
          final prescribedHeatFlowRate=false) if
             have_controlVolume "Fluid volume to break algebraic loop"
          annotation (Placement(transformation(extent={{-10,0},{10,20}})));
    protected
        parameter Boolean have_controlVolume=
            energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or
             massDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState
          "Boolean flag used to remove conditional components";
        Modelica.Fluid.Interfaces.FluidPort_a port_internal(
          redeclare package Medium = Medium) if not have_controlVolume
          "Internal dummy port for easier connection of conditional connections"
          annotation (Placement(transformation(extent={{-10,50},{10,70}})));
      initial equation
        assert(portFlowDirection_1<>Modelica.Fluid.Types.PortFlowDirection.Leaving or
               portFlowDirection_2<>Modelica.Fluid.Types.PortFlowDirection.Leaving or
               portFlowDirection_3<>Modelica.Fluid.Types.PortFlowDirection.Leaving,
               "In " + getInstanceName() + ": All ports are configured to
         Modelica.Fluid.Types.PortFlowDirection.Leaving, which is non-physical.");
        assert(portFlowDirection_1<>Modelica.Fluid.Types.PortFlowDirection.Entering or
               portFlowDirection_2<>Modelica.Fluid.Types.PortFlowDirection.Entering or
               portFlowDirection_3<>Modelica.Fluid.Types.PortFlowDirection.Entering,
               "In " + getInstanceName() + ": All ports are configured to
         Modelica.Fluid.Types.PortFlowDirection.Entering, which is non-physical.");
      equation
        if verifyFlowReversal then
          if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_1.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_1 but portFlowDirection_1=PortFlowDirection.Entering since m_flow="       +
            String(port_1.m_flow) + ">-"+String(m_flow_small));
          end if;
          if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_1.m_flow< m_flow_small,
            "In " + getInstanceName() + ":
      Flow is entering port_1 but portFlowDirection_1=PortFlowDirection.Leaving since m_flow="       +
            String(port_1.m_flow) + "<"+String(m_flow_small));
          end if;
          if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_2.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_2 but portFlowDirection_2=PortFlowDirection.Entering since m_flow="       +
            String(port_2.m_flow) + ">-"+String(m_flow_small));
          end if;
          if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_2.m_flow< m_flow_small,
            "In " + getInstanceName() + ":
      Flow is entering port_2 but portFlowDirection_2=PortFlowDirection.Leaving since m_flow="       +
            String(port_2.m_flow) + "<"+String(m_flow_small));
          end if;
          if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_3.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_3 but portFlowDirection_3=PortFlowDirection.Entering since m_flow="       +
            String(port_3.m_flow) + ">-"+String(m_flow_small));
          end if;
          if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_3.m_flow< m_flow_small,
            "In " + getInstanceName() + ": 
      Flow is entering port_3 but portFlowDirection_3=PortFlowDirection.Leaving since m_flow="       +
            String(port_3.m_flow) + "<"+String(m_flow_small));
          end if;
        end if;
        if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res1.port_a, port_internal) annotation (Line(
            points={{-60,0},{-60,60},{0,60}},
            color={0,127,255}));
          else
             connect(res1.port_a, vol.ports[1]) annotation (Line(
            points={{-60,0},{-2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_1, res1.port_b) annotation (Line(points={{-100,0},{-100,0},{-40,
                  0}}, color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res1.port_b, port_internal) annotation (Line(
            points={{-40,0},{-40,60},{0,60}},
            color={0,127,255}));
          else
             connect(res1.port_b, vol.ports[1]) annotation (Line(
            points={{-40,0},{-2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_1, res1.port_a) annotation (Line(points={{-100,0},{-100,0},{-60,0}}, color={0,127,255}));
        end if;
        if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res2.port_a, port_internal) annotation (Line(
            points={{60,0},{60,60},{0,60}},
            color={0,127,255}));
          else
             connect(res2.port_a, vol.ports[2]) annotation (Line(
            points={{60,0},{2.22045e-16,0}},
            color={0,127,255}));
          end if;
          connect(port_2, res2.port_b) annotation (Line(points={{100,0},{100,0},{40,0}},    color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res2.port_b, port_internal) annotation (Line(
            points={{40,0},{40,60},{0,60}},
            color={0,127,255}));
          else
             connect(res2.port_b, vol.ports[2]) annotation (Line(
            points={{40,0},{2.22045e-16,0}},
            color={0,127,255}));
          end if;
          connect(port_2, res2.port_a) annotation (Line(points={{100,0},{100,0},{60,0}},    color={0,127,255}));
        end if;
        if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res3.port_a, port_internal) annotation (Line(
            points={{-4.44089e-16,-60},{20,-60},{20,60},{0,60}},
            color={0,127,255}));
          else
             connect(res3.port_a, vol.ports[3]) annotation (Line(
            points={{-6.66134e-16,-60},{0,-60},{0,0},{2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_3, res3.port_b) annotation (Line(points={{0,-100},{0,-100},{0,-40}}, color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res3.port_b, port_internal) annotation (Line(
            points={{4.44089e-16,-40},{20,-40},{20,60},{0,60}},
            color={0,127,255}));
          else
             connect(res3.port_b, vol.ports[3]) annotation (Line(
            points={{4.44089e-16,-40},{0,-40},{0,0},{2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_3, res3.port_a) annotation (Line(points={{0,-100},{0,-100},{0,-60}}, color={0,127,255}));
        end if;
         annotation (
          Documentation(info="<html>
<p>
Partial model for flow resistances with three ports such as a
flow mixer/splitter or a three way valve.
</p>
<p>
If <code>energyDynamics &ne; Modelica.Fluid.Types.Dynamics.SteadyState</code>,
then at the junction of the three flows,
a mixing volume will be present. This will introduce a dynamic energy and momentum
balance, which often breaks algebraic loops.
The time constant of the mixing volume is determined by the parameter <code>tau</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 7, 2018, by Filip Jorissen:<br/>
Added asserts that verify whether flow reversal occurs when 
<code>verifyFlowReversal=true</code> and <code>portFlowDirection&lt;&gt;Bidirectional</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/963\">#963</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added graphical illustrations for the values of <code>portFlowDirection</code>.
Added asserts that verify the consistency of
the values of <code>portFlowDirection</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/902\">#902</a>.
</li>
<li>
February 22, 2016, by Michael Wetter:<br/>
Conditionally removed control volume <code>vol</code>, and added the conditional connnector
<code>port_internal</code>.
This was already done when the parameter <code>dynamicBalance</code> was present, but
was updated wrong when this parameter was removed.
Without these conditional components, the regression test for
<code>IDEAS.Fluid.Examples.ResistanceVolumeFlowReversal</code> fails to simulate.
</li>
<li>
December 17, 2015, by Michael Wetter:<br/>
Added assignment <code>redeclare final package Medium=Medium</code>
as this is required for OpenModelica.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/475\">
https://github.com/lbl-srg/modelica-buildings/issues/475</a>.
</li>
<li>
February 20, 2016, by Ruben Baetens:<br/>
Removal of <code>dynamicBalance</code> as parameter for <code>massDynamics</code> and <code>energyDynamics</code>.
</li>
<li>
April 13 2015, by Filip Jorissen:<br/>
Exposed options for flow reversal to users and added corresponding implementation.
</li>
<li>
March 23 2010, by Michael Wetter:<br/>
Changed start values from <code>system.p_start</code> or (code <code>T_start</code>)
to <code>Medium.p_default</code>.
</li>
<li>
September 18, 2008 by Michael Wetter:<br/>
Replaced splitter model with a fluid port since the
splitter model in Modelica.Fluid 1.0 beta does not transport
<code>mC_flow</code>.
</li>
<li>
June 11, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Polygon(
                points={{104,28},{124,20},{104,12},{104,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving),
              Polygon(
                points={{124,28},{104,20},{124,12},{124,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Entering),
              Polygon(
                points={{-124,28},{-104,20},{-124,12},{-124,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Entering),
              Polygon(
                points={{-104,28},{-124,20},{-104,12},{-104,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving),
              Polygon(
                points={{1,8},{21,6.12323e-17},{1,-8},{1,8}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering,
                origin={20,-125},
                rotation=90),
              Polygon(
                points={{21,14},{1,6},{21,-2},{21,14}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving,
                origin={26,-125},
                rotation=90)}));
      end PartialThreeWayResistance;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid\">IDEAS.Fluid</a>.
</p>
</html>"));
    end BaseClasses;

    package Delays "Package with delay models"
      extends Modelica.Icons.VariantsPackage;

      model DelayFirstOrder
        "Delay element, approximated by a first order differential equation"
        extends IDEAS.Fluid.MixingVolumes.MixingVolume(final V=V_nominal,
                                                         final mSenFac=1);
        parameter Modelica.SIunits.Time tau = 60 "Time constant at nominal flow"
          annotation (Dialog(tab="Dynamics", group="Nominal condition"));
    protected
         parameter Modelica.SIunits.Volume V_nominal = m_flow_nominal*tau/rho_default
          "Volume of delay element";
        annotation (    Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,98},{100,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={170,213,255}), Text(
                extent={{-72,22},{68,-18}},
                lineColor={0,0,0},
                textString="tau=%tau")}),
      defaultComponentName="del",
          Documentation(info="<html>
<p>
This model approximates a transport delay using a first order differential equations.
</p>
<p>
The model consists of a mixing volume with two ports. The size of the
mixing volume is such that at the nominal mass flow rate
<code>m_flow_nominal</code>,
the time constant of the volume is equal to the parameter <code>tau</code>.
</p>
<p>
The heat flux connector is optional, it need not be connnected.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 14, 2013, by Michael Wetter:<br/>
Renamed <code>V0</code> to <code>V_nominal</code> to use consistent notation.
</li>
<li>
September 24, 2008, by Michael Wetter:<br/>
Changed base class from <code>Modelica.Fluid</code> to <code>IDEAS</code> library.
This was done to track the auxiliary species flow <code>mC_flow</code>.
</li>
<li>
September 4, 2008, by Michael Wetter:<br/>
Fixed bug in assignment of parameter <code>sta0</code>.
The earlier implementation
required temperature to be a state, which is not always the case.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end DelayFirstOrder;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for transport delays in
piping networks.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.Delays.DelayFirstOrder\">
IDEAS.Fluid.Delays.DelayFirstOrder</a>
approximates transport delays using a first order differential equation.
</p>
</html>"));
    end Delays;

    package FixedResistances "Package with models for fixed flow resistances"
      extends Modelica.Icons.VariantsPackage;

      model Junction
        "Flow splitter with fixed resistance at each port"
          extends IDEAS.Fluid.BaseClasses.PartialThreeWayResistance(
          m_flow_small=mDyn_flow_nominal*1e-4,
          mDyn_flow_nominal = sum(abs(m_flow_nominal[:])/3),
          redeclare IDEAS.Fluid.FixedResistances.PressureDrop res1(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[1],
            final dp_nominal=dp_nominal[1],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM),
          redeclare IDEAS.Fluid.FixedResistances.PressureDrop res2(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[2],
            final dp_nominal=dp_nominal[2],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM),
          redeclare IDEAS.Fluid.FixedResistances.PressureDrop res3(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[3],
            final dp_nominal=dp_nominal[3],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM));
        parameter Modelica.SIunits.MassFlowRate[3] m_flow_nominal
          "Mass flow rate. Set negative at outflowing ports."
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.Pressure[3] dp_nominal(each displayUnit = "Pa")
          "Pressure drop at nominal mass flow rate, set to zero or negative number at outflowing ports."
          annotation(Dialog(group = "Nominal condition"));
        parameter Real deltaM(min=0) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Dialog(group = "Transition to laminar",
                               enable = not linearized));
        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(tab="Advanced"));
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}), graphics={
              Polygon(
                points={{-100,-46},{-32,-40},{-32,-100},{30,-100},{30,-36},{100,-30},
                    {100,38},{-100,52},{-100,-46}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-100,-34},{-18,-28},{-18,-100},{18,-100},{18,-26},{100,-20},
                    {100,22},{-100,38},{-100,-34}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,128,255}),
              Ellipse(
                visible=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState,
                extent={{-38,36},{40,-40}},
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-151,142},{149,102}},
                lineColor={0,0,255},
                textString="%name")}),
      defaultComponentName="jun",
          Documentation(info="<html>
<p>
Model of a flow junction with an optional fixed resistance in each flow leg
and an optional mixing volume at the junction.
</p>
<p>
The pressure drop is implemented using the model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.PressureDrop\">
IDEAS.Fluid.FixedResistances.PressureDrop</a>.
If its nominal pressure drop is set to zero, then the pressure drop
model will be removed.
For example, the pressure drop declaration
</p>
<pre>
  m_flow_nominal={ 0.1, 0.1,  -0.2},
  dp_nominal =   {500,    0, -6000}
</pre>
<p>
would model a flow mixer that has the nominal flow rates and associated pressure drops
as shown in the figure below. Note that <code>port_3</code> is set to negative values.
The negative values indicate that at the nominal conditions, fluid is leaving the component.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/FixedResistances/Junction.png\"/>
</p>
<p>
If
<code>energyDynamics &lt;&gt; Modelica.Fluid.Types.Dynamics.SteadyState</code>,
then at the flow junction, a fluid volume is modeled.
The fluid volume is implemented using the model
<a href=\"modelica://IDEAS.Fluid.Delays.DelayFirstOrder\">
IDEAS.Fluid.Delays.DelayFirstOrder</a>.
The fluid volume has the size
</p>
<pre>
  V = sum(abs(m_flow_nominal[:])/3)*tau/rho_nominal
</pre>
<p>
where <code>tau</code> is a parameter and <code>rho_nominal</code> is the density
of the medium in the volume at nominal condition.
Setting <code>energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial</code>
can help reducing the size of the nonlinear
system of equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 26, 2018 by Filip Jorissen:<br/>
Removed <code>final allowFlowReversal=true</code> from all resistances 
since this overrides the default simplification when the flow
is not bidirectional.
This change can lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/898\">issue 898</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Renamed model from <code>SplitterFixedResistanceDpM</code> to
<code>FlowJunction</code> and removed the parameters
<code>use_dh</code>, <code>dh</code> and <code>ReC</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/451\">issue 451</a>.
</li>
<li>
October 14, 2016 by Michael Wetter:<br/>
Added to Annex 60 library.<br/>
Updated comment for parameter <code>use_dh</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/451\">issue 451</a>.
</li>
<li>
Removed parameter <code>dynamicBalance</code> that overwrote the setting
of <code>energyDynamics</code> and <code>massDynamics</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/411\">
Annex 60, issue 411</a>.
</li>
<li>
February 1, 2012 by Michael Wetter:<br/>
Expanded documentation.
</li>
<li>
August 4, 2011 by Michael Wetter:<br/>
Added <code>final allowFlowReversal=true</code> to all resistances since it is impractical
to avoid flow reversal in large flow networks where such a setting may be useful.
</li>
<li>
June 11, 2008 by Michael Wetter:<br/>
Based class on
<a href=\"modelica://IDEAS.Fluid.BaseClasses.PartialThreeWayFixedResistance\">
PartialThreeWayFixedResistance</a>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Junction;

      model ParallelPressureDrop
        "Fixed flow resistance with multiple parallel circuits"
        extends IDEAS.Fluid.BaseClasses.PartialResistance(
          final m_flow_turbulent = if (computeFlowResistance and use_dh) then
                             eta_default*dh/4*Modelica.Constants.pi*ReC*nParCir
                             elseif (computeFlowResistance) then
                             deltaM * m_flow_nominal_pos
               else 0);
        parameter Real nParCir "Number of parallel circuits";
        parameter Boolean use_dh = false "Set to true to specify hydraulic diameter"
             annotation(Evaluate=true, Dialog(enable = not linearized));
        parameter Modelica.SIunits.Length dh=1 "Hydraulic diameter"
             annotation(Evaluate=true, Dialog(enable = use_dh and not linearized));
        parameter Real ReC(min=0)=4000
          "Reynolds number where transition to turbulent starts"
             annotation(Evaluate=true, Dialog(enable = use_dh and not linearized));
        parameter Real deltaM(min=0.01) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Evaluate=true, Dialog(enable = not use_dh and not linearized));
        final parameter Real k(unit="") = if computeFlowResistance then
              m_flow_nominal_pos/nParCir / sqrt(dp_nominal_pos) else 0
          "Flow coefficient for 1 of the parallel circuits";
        parameter Boolean computeFlowResistance=true
          "Flag to enable/disable computation of flow resistance"
         annotation(Evaluate=true);
      initial equation
       if computeFlowResistance then
         assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
       end if;
       assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
       if ( m_flow_turbulent > m_flow_nominal_pos) then
         Modelica.Utilities.Streams.print("Warning: In FixedResistanceDpM, m_flow_nominal is smaller than m_flow_turbulent."
                 + "\n"
                 + "  m_flow_nominal = " + String(m_flow_nominal) + "\n"
                 + "  dh      = " + String(dh) + "\n"
                 + "  To fix, set dh < " +
                      String(     4*m_flow_nominal/eta_default/Modelica.Constants.pi/ReC) + "\n"
                 + "  Suggested value: dh = " +
                      String(1/10*4*m_flow_nominal/eta_default/Modelica.Constants.pi/ReC));
       end if;
      equation
        // Pressure drop calculation
        if computeFlowResistance then
          if linearized then
            m_flow*m_flow_nominal_pos/nParCir^2 = k^2*dp;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                         m_flow_turbulent=m_flow_turbulent/nParCir)*nParCir,
                                         simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow/nParCir, k=k,
                                         m_flow_turbulent=m_flow_turbulent/nParCir),
                          simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                         m_flow_turbulent=m_flow_turbulent/nParCir)*nParCir;
              else
                dp=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow/nParCir, k=k,
                                         m_flow_turbulent=m_flow_turbulent/nParCir);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if;  // computeFlowResistance
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}),
                            graphics),
      defaultComponentName="res",
      Documentation(info="<html>
<p>
This is a model of a resistance with a fixed flow coefficient.
The mass flow rate is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775; = k  
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>,
</p>
<p>
where 
<i>k</i> is a constant and 
<i>&Delta;P</i> is the pressure drop.
The constant <i>k</i> is equal to
<code>k=m_flow_nominal/dp_nominal</code>,
where <code>m_flow_nominal</code> and <code>dp_nominal</code>
are parameters.
In the region
<code>abs(m_flow) &lt; m_flow_turbulent</code>, 
the square root is replaced by a differentiable function
with finite slope.
The value of <code>m_flow_turbulent</code> is
computed as follows:
</p>
<ul>
<li>
If the parameter <code>use_dh</code> is <code>false</code>
(the default setting), 
the equation 
<code>m_flow_turbulent = deltaM * abs(m_flow_nominal)</code>,
where <code>deltaM=0.3</code> and 
<code>m_flow_nominal</code> are parameters that can be set by the user.
</li>
<li>
Otherwise, the equation
<code>m_flow_turbulent = eta_nominal*dh/4*&pi;*ReC</code> is used,
where 
<code>eta_nominal</code> is the dynamic viscosity, obtained from
the medium model. The parameter
<code>dh</code> is the hydraulic diameter and
<code>ReC=4000</code> is the critical Reynolds number, which both
can be set by the user.
</li>
</ul>
<p>
The figure below shows the pressure drop for the parameters
<code>m_flow_nominal=5</code> kg/s,
<code>dp_nominal=10</code> Pa and
<code>deltaM=0.3</code>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/FixedResistances/FixedResistanceDpM.png\"/>
</p>
<p>
If the parameter
<code>show_T</code> is set to <code>true</code>,
then the model will compute the
temperature at its ports. Note that this can lead to state events
when the mass flow rate approaches zero,
which can increase computing time.
</p>
<p>
The parameter <code>from_dp</code> is used to determine
whether the mass flow rate is computed as a function of the 
pressure drop (if <code>from_dp=true</code>), or vice versa.
This setting can affect the size of the nonlinear system of equations.
</p>
<p>
If the parameter <code>linearized</code> is set to <code>true</code>,
then the pressure drop is computed as a linear function of the
mass flow rate.
</p>
<p>
Setting <code>allowFlowReversal=false</code> can lead to simpler
equations. However, this should only be set to <code>false</code>
if one can guarantee that the flow never reverses its direction.
This can be difficult to guarantee, as pressure imbalance after 
the initialization, or due to medium expansion and contraction,
can lead to reverse flow.
</p>
<h4>Notes</h4>
<p>
For more detailed models that compute the actual flow friction, 
models from the package 
<a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
can be used and combined with models from the 
<code>Buildings</code> library.
</p>
<h4>Implementation</h4>
<p>
The pressure drop is computed by calling a function in the package
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels\">
IDEAS.Fluid.BaseClasses.FlowModels</a>,
This package contains regularized implementations of the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
and its inverse function.
</p>
<p>
To decouple the energy equation from the mass equations,
the pressure drop is a function of the mass flow rate,
and not the volume flow rate.
This leads to simpler equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IDEAS.Fluid.BaseClasses.PartialResistance</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IDEAS.Fluid.FixedResistances.FixedResistanceDpM</code>.
</li>
<li>
May 30, 2008 by Michael Wetter:<br/>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-102,86},{-4,22}},
                lineColor={0,0,255},
                textString="dp_nominal=%dp_nominal"), Text(
                extent={{-106,106},{6,60}},
                lineColor={0,0,255},
                textString="m0=%m_flow_nominal")}));
      end ParallelPressureDrop;

      model PressureDrop
        "Fixed flow resistance with dp and m_flow as parameter"
        extends IDEAS.Fluid.BaseClasses.PartialResistance(
          final m_flow_turbulent = if computeFlowResistance then deltaM * m_flow_nominal_pos else 0);
        parameter Real deltaM(min=1E-6) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Evaluate=true,
                        Dialog(group = "Transition to laminar",
                               enable = not linearized));
        final parameter Real k = if computeFlowResistance then
              m_flow_nominal_pos / sqrt(dp_nominal_pos) else 0
          "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
    protected
        final parameter Boolean computeFlowResistance=(dp_nominal_pos > Modelica.Constants.eps)
          "Flag to enable/disable computation of flow resistance"
         annotation(Evaluate=true);
        final parameter Real coeff=
          if linearized and computeFlowResistance
          then if from_dp then k^2/m_flow_nominal_pos else m_flow_nominal_pos/k^2
          else 0
          "Precomputed coefficient to avoid division by parameter";
      initial equation
       if computeFlowResistance then
         assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
       end if;
       assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
      equation
        // Pressure drop calculation
        if computeFlowResistance then
          if linearized then
            if from_dp then
              m_flow = dp*coeff;
            else
              dp = m_flow*coeff;
            end if;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(
                  actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                    dp=dp,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(
                  actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                    m_flow=m_flow,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                  dp=dp,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              else
                dp=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                  m_flow=m_flow,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if;  // computeFlowResistance
        annotation (defaultComponentName="res",
      Documentation(info="<html>
<p>
Model of a flow resistance with a fixed flow coefficient.
The mass flow rate is
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775; = k
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>,
</p>
<p>
where
<i>k</i> is a constant and
<i>&Delta;P</i> is the pressure drop.
The constant <i>k</i> is equal to
<code>k=m_flow_nominal/sqrt(dp_nominal)</code>,
where <code>m_flow_nominal</code> and <code>dp_nominal</code>
are parameters.
</p>
<h4>Assumptions</h4>
<p>
In the region
<code>abs(m_flow) &lt; m_flow_turbulent</code>,
the square root is replaced by a differentiable function
with finite slope.
The value of <code>m_flow_turbulent</code> is
computed as
<code>m_flow_turbulent = deltaM * abs(m_flow_nominal)</code>,
where <code>deltaM=0.3</code> and
<code>m_flow_nominal</code> are parameters that can be set by the user.
</p>
<p>
The figure below shows the pressure drop for the parameters
<code>m_flow_nominal=5</code> kg/s,
<code>dp_nominal=10</code> Pa and
<code>deltaM=0.3</code>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/FixedResistances/PressureDrop.png\"/>
</p>
<h4>Important parameters</h4>
<p>
The parameter <code>from_dp</code> is used to determine
whether the mass flow rate is computed as a function of the
pressure drop (if <code>from_dp=true</code>), or vice versa.
This setting can affect the size of the nonlinear system of equations.
</p>
<p>
If the parameter <code>linearized</code> is set to <code>true</code>,
then the pressure drop is computed as a linear function of the
mass flow rate.
</p>
<p>
Setting <code>allowFlowReversal=false</code> can lead to simpler
equations. However, this should only be set to <code>false</code>
if one can guarantee that the flow never reverses its direction.
This can be difficult to guarantee, as pressure imbalance after
the initialization, or due to medium expansion and contraction,
can lead to reverse flow.
</p>
<p>
If the parameter
<code>show_T</code> is set to <code>true</code>,
then the model will compute the
temperature at its ports. Note that this can lead to state events
when the mass flow rate approaches zero,
which can increase computing time.
</p>
<h4>Notes</h4>
<p>
For more detailed models that compute the actual flow friction,
models from the package
<a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
can be used and combined with models from the
<code>IDEAS</code> library.
</p>
<p>
For a model that uses the hydraulic parameter and flow velocity at nominal conditions
as a parameter, use
<a href=\"modelica://IDEAS.Fluid.FixedResistances.HydraulicDiameter\">
IDEAS.Fluid.FixedResistances.HydraulicDiameter</a>.
</p>
<h4>Implementation</h4>
<p>
The pressure drop is computed by calling a function in the package
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels\">
IDEAS.Fluid.BaseClasses.FlowModels</a>,
This package contains regularized implementations of the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
and its inverse function.
</p>
<p>
To decouple the energy equation from the mass equations,
the pressure drop is a function of the mass flow rate,
and not the volume flow rate.
This leads to simpler equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 21, 2018, by Michael Wetter:<br/>
Decrease value of <code>deltaM(min=...)</code> attribute.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1026\">#1026</a>.
</li>
<li>
February 3, 2018, by Filip Jorissen:<br/>
Revised implementation of pressure drop equation
such that it depends on <code>from_dp</code>
when <code>linearized=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/884\">#884</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Simplified model by removing the geometry dependent parameters into the new
model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.HydraulicDiameter\">
IDEAS.Fluid.FixedResistances.HydraulicDiameter</a>.
</li>
<li>
November 23, 2016, by Filip Jorissen:<br/>
Removed <code>dp_nominal</code> and
<code>m_flow_nominal</code> labels from icon.
</li>
<li>
October 14, 2016, by Michael Wetter:<br/>
Updated comment for parameter <code>use_dh</code>.
</li>
<li>
November 26, 2014, by Michael Wetter:<br/>
Added the required <code>annotation(Evaluate=true)</code> so
that the system of nonlinear equations in
<a href=\"modelica://IDEAS.Fluid.FixedResistances.Validation.PressureDropsExplicit\">
IDEAS.Fluid.FixedResistances.Validation.PressureDropsExplicit</a>
remains the same.
</li>
<li>
November 20, 2014, by Michael Wetter:<br/>
Rewrote the warning message using an <code>assert</code> with
<code>AssertionLevel.warning</code>
as this is the proper way to write warnings in Modelica.
</li>
<li>
August 5, 2014, by Michael Wetter:<br/>
Corrected error in documentation of computation of <code>k</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IDEAS.Fluid.BaseClasses.PartialResistance</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IDEAS.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
May 30, 2008 by Michael Wetter:<br/>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PressureDrop;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for fixed flow resistances.
By fixed flow resistance, we mean resistances that do not change the
flow coefficient
</p>
<p align=\"center\" style=\"font-style:italic;\">
k = m &frasl;
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>.
</p>
<p>
For models of valves and air dampers, see
<a href=\"modelica://IDEAS.Fluid.Actuators\">
IDEAS.Fluid.Actuators</a>.
For models of flow resistances as part of the building constructions, see
<a href=\"modelica://IDEAS.Airflow.Multizone\">
IDEAS.Airflow.Multizone</a>.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.PressureDrop\">
IDEAS.Fluid.FixedResistances.PressureDrop</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and a nominal pressure drop. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.HydraulicDiameter\">
IDEAS.Fluid.FixedResistances.HydraulicDiameter</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and
a hydraulic diameter. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.LosslessPipe\">
IDEAS.Fluid.FixedResistances.LosslessPipe</a>
is an ideal pipe segment with no pressure drop. It is primarily used
in models in which the above pressure drop model need to be replaced by a model with no pressure drop.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.Junction\">
IDEAS.Fluid.FixedResistances.Junction</a>
can be used to model flow splitters or flow merges.
</p>
</html>"));
    end FixedResistances;

    package Geothermal "Package with models for geothermal heat exchange"
      extends Modelica.Icons.VariantsPackage;

      package Borefields "Package with borefield models"
        extends Modelica.Icons.VariantsPackage;

        package BaseClasses
        "Base classes used in IDEAS.Fluid.HeatExchangers.Ground"
        extends Modelica.Icons.BasesPackage;

          package Boreholes "Package with borehole heat exchangers"
          extends Modelica.Icons.VariantsPackage;

            package BaseClasses "Base classes for Borehole"
            extends Modelica.Icons.BasesPackage;

              package Functions
              "Package with functions for evaluation of borehole thermal resistances"
              extends Modelica.Icons.VariantsPackage;

                function convectionResistanceCircularPipe
                  "Thermal resistance from the fluid in pipes and the grout zones (Bauer et al. 2011)"
                  // Geometry of the borehole
                  input Modelica.SIunits.Height hSeg "Height of the element";
                  input Modelica.SIunits.Radius rTub "Tube radius";
                  input Modelica.SIunits.Length eTub "Tube thickness";
                  // thermal properties
                  input Modelica.SIunits.ThermalConductivity kMed
                    "Thermal conductivity of the fluid";
                  input Modelica.SIunits.DynamicViscosity muMed
                    "Dynamic viscosity of the fluid";
                  input Modelica.SIunits.SpecificHeatCapacity cpMed
                    "Specific heat capacity of the fluid";
                  input Modelica.SIunits.MassFlowRate m_flow "Mass flow rate";
                  input Modelica.SIunits.MassFlowRate m_flow_nominal "Nominal mass flow rate";
                  // Outputs
                  output Modelica.SIunits.ThermalResistance RFluPip
                    "Convection resistance (or conduction in fluid if no mass flow)";
              protected
                  parameter Modelica.SIunits.Radius rTub_in = rTub - eTub
                    "Pipe inner radius";
                  Modelica.SIunits.CoefficientOfHeatTransfer h
                    "Convective heat transfer coefficient of the fluid";
                  Real k(unit="s/kg")
                    "Coefficient used in the computation of the convective heat transfer coefficient";
                  Modelica.SIunits.MassFlowRate m_flow_abs = IDEAS.Utilities.Math.Functions.spliceFunction(m_flow,-m_flow,m_flow,m_flow_nominal/30);
                  Real Re "Reynolds number";
                  Real NuTurb "Nusselt at Re=2400";
                  Real Nu "Nusselt";
                algorithm
                  // Convection resistance and Reynolds number
                  k := 2/(muMed*Modelica.Constants.pi*rTub_in);
                  Re := m_flow_abs*k;
                  if Re>=2400 then
                    // Turbulent, fully-developped flow in a smooth circular pipe with the
                    // Dittus-Boelter correlation: h = 0.023*k_f*Re*Pr/(2*rTub)
                    // Re = rho*v*DTub / mue_f
                    //    = m_flow/(pi r^2) * DTub/mue_f = 2*m_flow / ( mue*pi*rTub)
                    Nu := 0.023*(cpMed*muMed/kMed)^(0.35)*
                      IDEAS.Utilities.Math.Functions.regNonZeroPower(
                        x=Re,
                        n=0.8,
                        delta=0.01*m_flow_nominal*k);
                  else
                    // Laminar, fully-developped flow in a smooth circular pipe with uniform
                    // imposed temperature: Nu=3.66 for Re<=2300. For 2300<Re<2400, a smooth
                    // transition is created with the splice function.
                    NuTurb := 0.023*(cpMed*muMed/kMed)^(0.35)*(2400)^(0.8);
                    Nu := IDEAS.Utilities.Math.Functions.spliceFunction(NuTurb,3.66,Re-(2300+2400)/2,((2300+2400)/2)-2300);
                  end if;
                  h := Nu*kMed/(2*rTub_in);
                  RFluPip := 1/(2*Modelica.Constants.pi*rTub_in*hSeg*h);
                  annotation (Diagram(graphics), Documentation(info="<html>
<p>
This model computes the convection resistance in the pipes of a borehole segment 
with heigth <i>h<sub>Seg</sub></i> using correlations suggested by Bergman et al. (2011).
</p>
<p>
If the flow is laminar (<i>Re &le; 2300</i>, with <i>Re</i> being the Reynolds number of the flow),
the Nusselt number of the flow is assumed to be constant at 3.66. If the flow is turbulent (<i>Re &gt; 2300</i>),
the correlation of Dittus-Boelter is used to find the convection heat transfer coefficient as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Nu = 0.023 &nbsp; Re<sup>0.8</sup> &nbsp; Pr<sup>n</sup>,
</p>
<p>
where <i>Nu</i> is the Nusselt number and 
<i>Pr</i> is the Prandlt number.
A value of <i>n=0.35</i> is used, as the reference uses <i>n=0.4</i> for heating and 
<i>n=0.3</i> for cooling. To ensure that the function is continuously differentiable,
a smooth transition between the laminar and turbulent values is created for the
range <i>2300 &lt; Re &lt; 2400</i>.
</p>
<h4>References</h4>
<p>
Bergman, T. L., Incropera, F. P., DeWitt, D. P., &amp; Lavine, A. S. (2011). <i>Fundamentals of heat and mass
transfer</i> (7th ed.). New York: John Wiley &amp; Sons.
</p>
</html>",                 revisions="<html>
<ul>
<li>
July 10, 2018, by Alex Laferri&egrave;re:<br/>
Added laminar flow and smooth laminar-turbulent transition.
Revised documentation.
</li>
<li>
February 14, 2014, by Michael Wetter:<br/>
Removed unused input <code>rBor</code>.
Revised documentation.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation. 
Changed <code>cpFluid</code> to <code>cpMed</code> to use consistent notation.
Added regularization for computation of convective heat transfer coefficient to
avoid an event and a non-differentiability.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
                end convectionResistanceCircularPipe;

                function internalResistancesOneUTube
                  "Thermal resistances for single U-tube, according to Bauer et al. (2011)"
                  extends
                  IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.partialInternalResistances;

                  // Outputs
                  output Modelica.SIunits.ThermalResistance Rgb
                    "Thermal resistance between grout zone and borehole wall";
                  output Modelica.SIunits.ThermalResistance Rgg
                    "Thermal resistance between the two grout zones";
                  output Modelica.SIunits.ThermalResistance RCondGro
                    "Thermal resistance between: pipe wall to capacity in grout";
              protected
                  Real[2,2] RDelta(each unit="(m.K)/W") "Delta-circuit thermal resistances";
                  Real[2,2] R(each unit="(m.K)/W") "Internal thermal resistances";
                  Modelica.SIunits.Position[2] xPip = {-sha, sha} "x-Coordinates of pipes";
                  Modelica.SIunits.Position[2] yPip = {0., 0.} "y-Coordinates of pipes";
                  Modelica.SIunits.Radius[2] rPip = {rTub, rTub} "Outer radius of pipes";
                  Real[2] RFluPip(each unit="(m.K)/W") = {RCondPipe+RConv, RCondPipe+RConv} "Fluid to pipe wall thermal resistances";
                  Modelica.SIunits.ThermalResistance Rg
                    "Thermal resistance between outer borehole wall and one tube";
                  Modelica.SIunits.ThermalResistance Rar
                    "Thermal resistance between the two pipe outer walls";

                  Real Ra(unit="(m.K)/W")
                    "Grout-to-grout resistance (2D) as defined by Hellstrom. Interaction between the different grout parts";

                algorithm
                  // Internal thermal resistances
                  (RDelta, R) :=
                    IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.multipoleThermalResistances(
                      2, 3, xPip, yPip, rBor, rPip, kFil, kSoi, RFluPip);

                  // Rb and Ra
                  Rb_multipole := 1./(1./RDelta[1,1] + 1./RDelta[2,2]);
                  Rb_internal := if use_Rb then Rb else Rb_multipole;
                  // The short-circuit resistance in weigthed by the ratio between the used
                  // value of Rb and the theoretical value
                  Ra := (R[1,1] + R[2,2] - 2*R[1,2])*Rb_internal/Rb_multipole;

                  // Conversion of Rb (resp. Ra) to Rg (resp. Rar) of Bauer:
                  Rg  :=(2*Rb_internal-RCondPipe-RConv)/hSeg;
                  Rar :=(Ra-2*(RCondPipe + RConv))/hSeg;

                  // If any of the internal delta-circuit resistances is negative, then
                  // the location (x) of the thermal capacity is set to zero to limit
                  // instabilities in the calculations. Otherwise, calculations follow the
                  // method of Bauer et al. (2011).
                  if (RDelta[1,2] < 0) then
                    //Thermal resistance between the grout zone and borehole wall
                    Rgb := Rg;

                    //Conduction resistance in grout from pipe wall to capacity in grout
                    RCondGro := RCondPipe/hSeg;

                    //Thermal resistance between the two grout zones
                    Rgg := 2*Rgb*Rar/(2*Rgb - Rar);

                    test := true;
                  else
                    // ********** Resistances and capacity location according to Bauer **********
                    while test == false and i <= 10 loop
                      // Capacity location (with correction factor in case that the test is
                      // negative)
                      x := Modelica.Math.log(sqrt(rBor^2 + 2*rTub^2)/(2*rTub))/
                        Modelica.Math.log(rBor/(sqrt(2)*rTub))*((15 - i + 1)/15);

                      //Thermal resistance between the grout zone and borehole wall
                      Rgb := (1 - x)*Rg;

                      //Conduction resistance in grout from pipe wall to capacity in grout
                      RCondGro := x*Rg + RCondPipe/hSeg;

                      //Thermal resistance between the two grout zones
                      Rgg := 2*Rgb*(Rar - 2*x*Rg)/(2*Rgb - Rar + 2*x*Rg);

                      // Thermodynamic test to check if negative R values make sense. If not,
                      // decrease x-value.
                      test := ((1/Rgg + 1/2/Rgb)^(-1) > 0);
                      i := i + 1;
                    end while;
                  end if;
                  assert(test,
                  "Maximum number of iterations exceeded. Check the borehole geometry.
  The tubes may be too close to the borehole wall.
  Input to the function 
  IDEAS.Fluid.HeatExchangers.Boreholes.BaseClasses.singleUTubeResistances
  is
           hSeg = "                 + String(hSeg) + " m
           rBor = "                 + String(rBor) + " m
           rTub = "                 + String(rTub) + " m
           eTub = "                 + String(eTub) + " m
           kSoi = "                 + String(kSoi) + " W/m/K
           kFil = "                 + String(kFil) + " W/m/K
           kTub = "                 + String(kTub) + " W/m/K
           i = "                  + String(i) + "
  Computed x    = "                 + String(x) + " K/W
           Rgb  = "                 + String(Rgb) + " K/W
           Rgg  = "                 + String(Rgg) + " K/W");

                  if printDebug then
                    Modelica.Utilities.Streams.print("
      Rb = "                 + String(Rb_internal) + " m K / W
      RCondPipe = "                + String(RCondPipe) + " m K / W
      RConv = "                 +String(RConv) +"m K / W
      hSeg = "                 + String(hSeg) + " m
      Rg = "                +String(Rg) + " K / W
      Ra = "                 + String(Ra)  + " m K / W
      x = "                 + String(x) + "
      i = "                  + String(i));
                  end if;
                                                                        annotation (Diagram(graphics), Documentation(info="<html>
<p>
This model computes the different thermal resistances present in a single-U-tube borehole 
using the method of Bauer et al. (2011).
It also computes the fluid-to-ground thermal resistance <i>R<sub>b</sub></i> 
and the grout-to-grout thermal resistance <i>R<sub>a</sub></i> 
as defined by Claesson and Hellstrom (2011) using the multipole method.
</p>

<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
<p>D. Bauer, W. Heidemann, H. M&uuml;ller-Steinhagen, and H.-J. G. Diersch. 
<i>Thermal resistance and capacity models for borehole heat exchangers</i>. 
International Journal of Energy Research, 35:312&ndash;320, 2011.</p>
</html>",                 revisions="<html>
<ul>
<li>
July 18, 2018 by Massimo Cimmino:<br/>
Implemented multipole method.
</li>
<li>
February 14, 2014 by Michael Wetter:<br/>
Added an assert statement to test for non-physical values.
</li>
<li>
February 12, 2014, by Damien Picard:<br/>
Remove the flow dependency of the resistances, as this function calculates the conduction resistances only.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
                end internalResistancesOneUTube;

                function multipoleFluidTemperature "Fluid temperatures from multipole solution"
                  extends Modelica.Icons.Function;

                  input Integer nPip "Number of pipes";
                  input Integer J "Number of multipoles";
                  input Modelica.SIunits.Position xPip[nPip] "x-Coordinates of pipes";
                  input Modelica.SIunits.Position yPip[nPip] "y-Coordinates of pipes";
                  input Real QPip_flow[nPip](each unit="W/m") "Heat flow in pipes";
                  input Modelica.SIunits.Temperature TBor "Average borehole wall temperature";
                  input Modelica.SIunits.Radius rBor "Borehole radius";
                  input Modelica.SIunits.Radius rPip[nPip] "Outter radius of pipes";
                  input Modelica.SIunits.ThermalConductivity kFil "Thermal conductivity of grouting material";
                  input Modelica.SIunits.ThermalConductivity kSoi "Thermal conductivity of soil material";
                  input Real RFluPip[nPip](each unit="(m.K)/W") "Fluid to pipe wall thermal resistances";
                  input Real eps=1.0e-5 "Iteration relative accuracy";
                  input Integer it_max=100 "Maximum number of iterations";

                  output Modelica.SIunits.Temperature TFlu[nPip] "Fluid temperature in pipes";

              protected
                  Real pikFil(unit="(m.K)/W")=1/(2*Modelica.Constants.pi*kFil) "Coefficient based on grout thermal conductivity";
                  Real sigma=(kFil - kSoi)/(kFil + kSoi) "Thermal conductivity ratio";
                  Real betaPip[nPip]=2*Modelica.Constants.pi*kFil*RFluPip "Dimensionless fluid to outter pipe wall thermal resistance";
                  Complex zPip_i "Position of pipe i";
                  Complex zPip_j "Position of pipe j";
                  Complex P_nj "Multipole of order j for pipe n";
                  Real PRea[nPip,J] "Matrix of real part of multipoles";
                  Real PIma[nPip,J] "Matrix of imaginary part of multipole";
                  Complex P_nj_new "New value of multipole of order j for pipe n";
                  Real PRea_new[nPip,J] "New value of real part of multipoles";
                  Real PIma_new[nPip,J] "New value of imaginary part of multipoles";
                  Complex F_mk "Coefficient F of order k of pipe m";
                  Real FRea[nPip,J] "Real part of matrix F_mk";
                  Real FIma[nPip,J] "Imaginary part of matrix F_mk";
                  Real R0[nPip,nPip](each unit="(m.K)/W") "Line source approximation of thermal resistances";
                  Complex deltaTFlu "Fluid temperature difference with line source approximation";
                  Real rbm "Intermediate coefficient";
                  Modelica.SIunits.Distance dz "Pipe to pipe distance";
                  Real coeff[nPip,J] "Coefficient for multiplication with matrix F_mk";
                  Real diff "Difference in subsequent multipole evaluations";
                  Real diff_max "Maximum difference in subsequent multipole evaluations";
                  Real diff_min "Minimum difference in subsequent multipole evaluations";
                  Real diff0 "Difference in subsequent multipole evaluations";
                  Integer it "Iteration counter";
                  Real eps_max "Convergence variable";

                algorithm
                  // Thermal resistance matrix from 0th order multipole
                  for i in 1:nPip loop
                    zPip_i := Complex(xPip[i], yPip[i]);
                    rbm := rBor^2/(rBor^2 - Modelica.ComplexMath.'abs'(zPip_i)^2);
                    R0[i, i] := pikFil*(log(rBor/rPip[i]) + betaPip[i] + sigma*log(rbm));
                    for j in 1:nPip loop
                      zPip_j := Complex(xPip[j], yPip[j]);
                      if i <> j then
                        dz := Modelica.ComplexMath.'abs'(zPip_i - zPip_j);
                        rbm := rBor^2/Modelica.ComplexMath.'abs'(rBor^2 - zPip_j*
                          Modelica.ComplexMath.conj(zPip_i));
                        R0[i, j] := pikFil*(log(rBor/dz) + sigma*log(rbm));
                      end if;
                    end for;
                  end for;

                  // Initialize maximum error and iteration counter
                  eps_max := 1.0e99;
                  it := 0;
                  // Multipoles
                  if J > 0 then
                    for m in 1:nPip loop
                      for k in 1:J loop
                        coeff[m, k] := -(1 - k*betaPip[m])/(1 + k*betaPip[m]);
                        PRea[m, k] := 0;
                        PIma[m, k] := 0;
                      end for;
                    end for;
                    while eps_max > eps and it < it_max loop
                      it := it + 1;
                      (FRea, FIma) :=
                        IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.multipoleFmk(
                        nPip,
                        J,
                        QPip_flow,
                        PRea,
                        PIma,
                        rBor,
                        rPip,
                        xPip,
                        yPip,
                        kFil,
                        kSoi);
                      for m in 1:nPip loop
                        for k in 1:J loop
                          F_mk := Complex(FRea[m, k], FIma[m, k]);
                          P_nj_new := coeff[m, k]*Modelica.ComplexMath.conj(F_mk);
                          PRea_new[m, k] := Modelica.ComplexMath.real(P_nj_new);
                          PIma_new[m, k] := Modelica.ComplexMath.imag(P_nj_new);
                        end for;
                      end for;
                      diff_max := 0;
                      diff_min := 1e99;
                      for m in 1:nPip loop
                        for k in 1:J loop
                          P_nj := Complex(PRea[m, k], PIma[m, k]);
                          P_nj_new := Complex(PRea_new[m, k], PIma_new[m, k]);
                          diff_max := max(diff_max,
                                           Modelica.ComplexMath.'abs'(P_nj_new - P_nj));
                          diff_min := min(diff_min,
                                           Modelica.ComplexMath.'abs'(P_nj_new - P_nj));
                        end for;
                      end for;
                      diff := diff_max - diff_min;
                      if it == 1 then
                        diff0 :=diff;
                      end if;
                      eps_max := diff/diff0;
                      PRea := PRea_new;
                      PIma := PIma_new;
                    end while;
                  end if;

                  // Fluid Temperatures
                  TFlu := TBor .+ R0*QPip_flow;
                  if J > 0 then
                    for m in 1:nPip loop
                      zPip_i :=Complex(xPip[m], yPip[m]);
                      deltaTFlu := Complex(0, 0);
                      for n in 1:nPip loop
                        zPip_j :=Complex(xPip[n], yPip[n]);
                        for j in 1:J loop
                          P_nj := Complex(PRea[n, j], PIma[n, j]);
                          if n <> m then
                            // Second term
                            deltaTFlu := deltaTFlu + P_nj*(rPip[n]/(zPip_i - zPip_j))^j;
                          end if;
                          // Third term
                          deltaTFlu := deltaTFlu + sigma*P_nj*(rPip[n]*
                            Modelica.ComplexMath.conj(zPip_i)/(rBor^2 - zPip_j*
                            Modelica.ComplexMath.conj(zPip_i)))^j;
                        end for;
                      end for;
                      TFlu[m] := TFlu[m] + Modelica.ComplexMath.real(deltaTFlu);
                    end for;
                  end if;

                  annotation (Documentation(info="<html>
<p> This model evaluates the fluid temperatures using the multipole method of Claesson and Hellstrom (2011).
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
</html>",                 revisions="<html>
<ul>
<li>
February 12, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
                end multipoleFluidTemperature;

                function multipoleFmk "Complex matrix F_mk from Claesson and Hellstrom (2011)"
                  extends Modelica.Icons.Function;

                  input Integer nPip "Number of pipes";
                  input Integer J "Number of multipoles";
                  input Real QPip_flow[nPip](each unit="W/m") "Heat flow in pipes";
                  input Real PRea[nPip,J] "Multipoles (Real part)";
                  input Real PIma[nPip,J] "Multipoles (Imaginary part)";
                  input Modelica.SIunits.Radius rBor "Borehole radius";
                  input Modelica.SIunits.Radius rPip[nPip] "Outter radius of pipes";
                  input Modelica.SIunits.Position xPip[nPip] "x-Coordinates of pipes";
                  input Modelica.SIunits.Position yPip[nPip] "y-Coordinates of pipes";
                  input Modelica.SIunits.ThermalConductivity kFil "Thermal conductivity of grouting material";
                  input Modelica.SIunits.ThermalConductivity kSoi "Thermal conductivity of soil material";

                  output Real FRea[nPip,J] "Multipole coefficients";
                  output Real FIma[nPip,J] "Multipole coefficients";

              protected
                  Complex zPip_i "Position of pipe i";
                  Complex zPip_j "Position of pipe j";
                  Complex P_nj "Multipole of order j for pipe n";
                  Real pikFil(unit="(m.K)/W")=1/(2*Modelica.Constants.pi*kFil) "Coefficient based on grout thermal conductivity";
                  Real sigma=(kFil - kSoi)/(kFil + kSoi) "Thermal conductivity ratio";
                  Complex f "Intermedia value of multipole coefficient";
                  Integer j_pend "Maximum loop index in fourth term";

                algorithm

                  for m in 1:nPip loop
                    zPip_i := Complex(xPip[m], yPip[m]);
                    for k in 1:J loop
                      f := Complex(0, 0);
                      for n in 1:nPip loop
                        zPip_j := Complex(xPip[n], yPip[n]);
                        // First term
                        if m <> n then
                          f := f + QPip_flow[n]*pikFil/k*(rPip[m]/(zPip_j - zPip_i))^k;
                        end if;
                        // Second term
                        f := f + sigma*QPip_flow[n]*pikFil/k*(rPip[m]*Modelica.ComplexMath.conj(
                          zPip_j)/(rBor^2 - zPip_i*Modelica.ComplexMath.conj(zPip_j)))^k;
                        for j in 1:J loop
                          P_nj := Complex(PRea[n, j], PIma[n, j]);
                          // Third term
                          if m <> n then
                            f := f + P_nj*IDEAS.Utilities.Math.Functions.binomial(j + k - 1, j -
                              1)*rPip[n]^j*(-rPip[m])^k/(zPip_i - zPip_j)^(j + k);
                          end if;
                          //Fourth term
                          j_pend := min(k, j);
                          for jp in 0:j_pend loop
                            f := f + sigma*Modelica.ComplexMath.conj(P_nj)*
                              IDEAS.Utilities.Math.Functions.binomial(j, jp)*
                              IDEAS.Utilities.Math.Functions.binomial(j + k - jp - 1, j - 1)*
                              rPip[n]^j*rPip[m]^k*zPip_i^(j - jp)*Modelica.ComplexMath.conj(
                              zPip_j)^(k - jp)/(rBor^2 - zPip_i*Modelica.ComplexMath.conj(
                              zPip_j))^(k + j - jp);
                          end for;
                        end for;
                      end for;
                      FRea[m, k] := Modelica.ComplexMath.real(f);
                      FIma[m, k] := Modelica.ComplexMath.imag(f);
                    end for;
                  end for;

                  annotation (Documentation(info="<html>
<p>This model evaluates the complex coefficient matrix F_mk from Claesson and Hellstrom (2011).
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
</html>",                 revisions="<html>
<ul>
<li>
February 12, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
                end multipoleFmk;

                function multipoleThermalResistances
                  "Thermal resistances from multipole solution"
                  extends Modelica.Icons.Function;

                  input Integer nPip "Number of pipes";
                  input Integer J "Number of multipoles";
                  input Modelica.SIunits.Position xPip[nPip] "x-Coordinates of pipes";
                  input Modelica.SIunits.Position yPip[nPip] "y-Coordinates of pipes";
                  input Modelica.SIunits.Radius rBor "Borehole radius";
                  input Modelica.SIunits.Radius rPip[nPip] "Outter radius of pipes";
                  input Modelica.SIunits.ThermalConductivity kFil "Thermal conductivity of grouting material";
                  input Modelica.SIunits.ThermalConductivity kSoi "Thermal conductivity of soil material";
                  input Real RFluPip[nPip](each unit="(m.K)/W") "Fluid to pipe wall thermal resistances";
                  input Modelica.SIunits.Temperature TBor=0 "Average borehole wall temperature";

                  output Real RDelta[nPip,nPip](each unit="(m.K)/W") "Delta-circuit thermal resistances";
                  output Real R[nPip,nPip](each unit="(m.K)/W") "Internal thermal resistances";

              protected
                  Real QPip_flow[nPip](each unit="W/m") "Pipe heat transfer rates";
                  Modelica.SIunits.Temperature TFlu[nPip] "Fluid temperatures";
                  Real K[nPip,nPip](each unit="W/(m.K)") "Internal thermal conductances";

                algorithm
                  for m in 1:nPip loop
                    for n in 1:nPip loop
                      if n == m then
                        QPip_flow[n] := 1;
                      else
                        QPip_flow[n] := 0;
                      end if;
                    end for;
                    TFlu :=
                      IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.multipoleFluidTemperature(
                      nPip,
                      J,
                      xPip,
                      yPip,
                      QPip_flow,
                      TBor,
                      rBor,
                      rPip,
                      kFil,
                      kSoi,
                      RFluPip);
                    for n in 1:nPip loop
                      R[n, m] := TFlu[n];
                    end for;
                  end for;
                  K := -Modelica.Math.Matrices.inv(R);
                  for m in 1:nPip loop
                    K[m, m] := -K[m, m];
                    for n in 1:nPip loop
                      if m <> n then
                        K[m, m] := K[m, m] - K[m, n];
                      end if;
                    end for;
                  end for;
                  for m in 1:nPip loop
                    for n in 1:nPip loop
                      RDelta[m, n] := 1./K[m, n];
                    end for;
                  end for;

                  annotation (Documentation(info="<html>
<p>This model evaluates the delta-circuit borehole thermal resistances using the multipole method of Claesson and Hellstrom (2011).
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
</html>",                 revisions="<html>
<ul>
<li>
February 12, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
                end multipoleThermalResistances;

                partial function partialInternalResistances
                  "Partial model for borehole resistance calculation"
                  extends Modelica.Icons.Function;
                  // Geometry of the borehole
                  input Boolean use_Rb = false
                    "True if the value Rb should be used instead of calculated";
                  input Real Rb(unit="(m.K)/W") "Borehole thermal resistance";
                  input Modelica.SIunits.Height hSeg "Height of the element";
                  input Modelica.SIunits.Radius rBor "Radius of the borehole";
                  // Geometry of the pipe
                  input Modelica.SIunits.Radius rTub "Radius of the tube";
                  input Modelica.SIunits.Length eTub "Thickness of the tubes";
                  input Modelica.SIunits.Length sha
                    "Shank spacing, defined as the distance between the center of a pipe and the center of the borehole";
                  // Thermal properties
                  input Modelica.SIunits.ThermalConductivity kFil
                    "Thermal conductivity of the grout";
                  input Modelica.SIunits.ThermalConductivity kSoi
                    "Thermal conductivity of the soi";
                  input Modelica.SIunits.ThermalConductivity kTub
                    "Thermal conductivity of the tube";
                  input Modelica.SIunits.ThermalConductivity kMed
                    "Thermal conductivity of the fluid";
                  input Modelica.SIunits.DynamicViscosity muMed
                    "Dynamic viscosity of the fluid";
                  input Modelica.SIunits.SpecificHeatCapacity cpMed
                    "Specific heat capacity of the fluid";
                  input Modelica.SIunits.MassFlowRate m_flow_nominal "Nominal mass flow rate";
                  input Boolean printDebug=false
                    "Print resistances values in log for debug purposes.";
                  // Outputs
                  output Real x "Capacity location";
              protected
                  parameter Real pi = 3.141592653589793 "pi";
                  parameter Real rTub_in = rTub-eTub "Inner radius of tube";
                  Real RConv(unit="(m.K)/W")=
                    IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.convectionResistanceCircularPipe(
                      hSeg=hSeg,
                      rTub=rTub,
                      eTub=eTub,
                      kMed=kMed,
                      muMed=muMed,
                      cpMed=cpMed,
                      m_flow=m_flow_nominal,
                      m_flow_nominal=m_flow_nominal)*hSeg;
                  Boolean test=false "thermodynamic test for R and x value";
                  Real RCondPipe(unit="(m.K)/W") =  Modelica.Math.log((rTub)/rTub_in)/(2*Modelica.Constants.pi*kTub)
                    "Thermal resistance of the pipe wall";
                  Real Rb_internal(unit="(m.K)/W")
                    "Resistance from the fluid in the pipe to the borehole wall";
                  Real Rb_multipole(unit="(m.K)/W")
                    "Theoretical Fluid-to-borehole-wall resistance evaluated from the multipole method";
                  Integer i=1 "Loop counter";
                  annotation (Diagram(graphics), Documentation(info="<html>
<p>
This partial function defines the common inputs to functions that calculate
the borehole internal resistances.
</p>
</html>",                 revisions="<html>
<ul>
<li>
July 18, 2018 by Massimo Cimmino:<br/>
Implemented multipole method.
</li>
<li>
February 14, 2014 by Michael Wetter:<br/>
Added an assert statement to test for non-physical values.
</li>
<li>
February 12, 2014, by Damien Picard:<br/>
Remove the flow dependency of the resistances, as this function calculates the conduction resistances only.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
                end partialInternalResistances;
              annotation (
              Documentation(info="<html>
<p>
This package contains functions to evaluate borehole internal resistances used by models in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses</a>.
</p>
</html>"));
              end Functions;

              model InternalHEXOneUTube
                "Internal heat exchanger of a borehole for a single U-tube configuration"
                extends
                IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialInternalHEX;
                extends IDEAS.Fluid.Interfaces.FourPortHeatMassExchanger(
                  redeclare final package Medium1 = Medium,
                  redeclare final package Medium2 = Medium,
                  T1_start=TFlu_start,
                  T2_start=TFlu_start,
                  final tau1=VTubSeg*rho1_nominal/m1_flow_nominal,
                  final tau2=VTubSeg*rho2_nominal/m2_flow_nominal,
                  redeclare final IDEAS.Fluid.MixingVolumes.MixingVolume vol1(
                    final energyDynamics=energyDynamics,
                    final massDynamics=massDynamics,
                    final prescribedHeatFlowRate=false,
                    final m_flow_small=m1_flow_small,
                    final V=VTubSeg,
                    final mSenFac=mSenFac),
                  redeclare final IDEAS.Fluid.MixingVolumes.MixingVolume vol2(
                    final energyDynamics=energyDynamics,
                    final massDynamics=massDynamics,
                    final prescribedHeatFlowRate=false,
                    final m_flow_small=m2_flow_small,
                    final V=VTubSeg,
                    final mSenFac=mSenFac));
            protected
                parameter Real Rgg_val(fixed=false) "Thermal resistance between the two grout zones";
            public
                Modelica.Blocks.Sources.RealExpression RVol1(y=
                  IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.convectionResistanceCircularPipe(
                    hSeg=hSeg,
                    rTub=borFieDat.conDat.rTub,
                    eTub=borFieDat.conDat.eTub,
                    kMed=kMed,
                    muMed=muMed,
                    cpMed=cpMed,
                    m_flow=m1_flow,
                    m_flow_nominal=m1_flow_nominal))
                  "Convective and thermal resistance at fluid 1"
                  annotation (Placement(transformation(extent={{-100,-2},{-80,18}})));
                Modelica.Blocks.Sources.RealExpression RVol2(y=
                  IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.convectionResistanceCircularPipe(
                    hSeg=hSeg,
                    rTub=borFieDat.conDat.rTub,
                    eTub=borFieDat.conDat.eTub,
                    kMed=kMed,
                    muMed=muMed,
                    cpMed=cpMed,
                    m_flow=m2_flow,
                    m_flow_nominal=m2_flow_nominal))
                  "Convective and thermal resistance at fluid 2"
                  annotation (Placement(transformation(extent={{-100,-18},{-80,2}})));
                IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.InternalResistancesOneUTube
                  intResUTub(
                    dynFil=dynFil,
                    hSeg=hSeg,
                    energyDynamics=energyDynamics,
                    Rgb_val=Rgb_val,
                    Rgg_val=Rgg_val,
                    RCondGro_val=RCondGro_val,
                    borFieDat=borFieDat,
                    T_start=TGro_start)
                  "Internal resistances for a single U-tube configuration"
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
                Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor RConv2
                  "Pipe convective resistance"
                  annotation (Placement(transformation(extent={{-12,12},{12,-12}},
                      rotation=270,
                      origin={0,-28})));
                Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor RConv1
                  "Pipe convective resistance"
                  annotation (Placement(transformation(extent={{-12,-12},{12,12}},
                      rotation=90,
                      origin={0,28})));
              initial equation
                (x, Rgb_val, Rgg_val, RCondGro_val) =
                  IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.internalResistancesOneUTube(
                    hSeg=hSeg,
                    rBor=borFieDat.conDat.rBor,
                    rTub=borFieDat.conDat.rTub,
                    eTub=borFieDat.conDat.eTub,
                    sha=borFieDat.conDat.xC,
                    kFil=borFieDat.filDat.kFil,
                    kSoi=borFieDat.soiDat.kSoi,
                    kTub=borFieDat.conDat.kTub,
                    use_Rb=borFieDat.conDat.use_Rb,
                    Rb=borFieDat.conDat.Rb,
                    kMed=kMed,
                    muMed=muMed,
                    cpMed=cpMed,
                    m_flow_nominal=m1_flow_nominal,
                    printDebug=false);
              equation
                  assert(borFieDat.conDat.borCon == IDEAS.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.SingleUTube,
                "This model should be used for single U-type borefield, not double U-type. 
  Check that the conDat record has been correctly parametrized");
                connect(RVol2.y, RConv2.Rc) annotation (Line(points={{-79,-8},{-60,-8},{-40,
                        -8},{-40,-28},{-12,-28}},
                                              color={0,0,127}));
                connect(RVol1.y, RConv1.Rc) annotation (Line(points={{-79,8},{-40,8},{-40,28},
                        {-12,28}}, color={0,0,127}));
                connect(vol1.heatPort, RConv1.fluid) annotation (Line(points={{-10,60},{-20,
                        60},{-20,40},{6.66134e-016,40}}, color={191,0,0}));
                connect(RConv1.solid, intResUTub.port_1)
                  annotation (Line(points={{0,16},{0,16},{0,10}}, color={191,0,0}));
                connect(RConv2.fluid, vol2.heatPort) annotation (Line(points={{0,-40},{20,-40},
                        {20,-60},{12,-60}}, color={191,0,0}));
                connect(RConv2.solid, intResUTub.port_2) annotation (Line(points={{0,-16},{0,
                        -12},{16,-12},{16,0},{10,0}}, color={191,0,0}));
                connect(intResUTub.port_wall, port_wall) annotation (Line(points={{0,0},{0,0},
                        {0,6},{-28,6},{-28,86},{0,86},{0,100}},             color={191,0,0}));
                  annotation (Dialog(tab="Dynamics"),
                  Icon(coordinateSystem(preserveAspectRatio=false, initialScale=0.1),
                                  graphics={Rectangle(
                        extent={{88,54},{-88,64}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,255},
                        fillPattern=FillPattern.Solid), Rectangle(
                        extent={{88,-66},{-88,-56}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,255},
                        fillPattern=FillPattern.Solid)}),
                  Documentation(info="<html>
<p>
Model for the heat transfer between the fluid and within the borehole filling
for a single borehole segment. 
This model computes the dynamic response of the fluid in the tubes, 
the heat transfer between the fluid and the borehole filling, 
and the heat storage within the fluid and the borehole filling.
</p>
<p>
This model computes the different thermal resistances present 
in a single-U-tube borehole using the method of Bauer et al. (2011) 
and computing explicitely the fluid-to-ground thermal resistance 
<i>R<sub>b</sub></i> and the 
grout-to-grout resistance
<i>R<sub>a</sub></i> as defined by Claesson and Hellstrom (2011)
using the multipole method. 
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
<p>
D. Bauer, W. Heidemann, H. M&uuml;ller-Steinhagen, and H.-J. G. Diersch.
<i>
Thermal resistance and capacity models for borehole heat exchangers
</i>.
International Journal Of Energy Research, 35:312-320, 2011.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 10, 2018, by Alex Laferri&egrave;re:<br/>
Updated documentation following major changes to the IDEAS.Fluid.HeatExchangers.Ground package.
Additionally, implemented a partial InternalHex model.
</li>
<li>
June 18, 2014, by Michael Wetter:<br/>
Added initialization for temperatures and derivatives of <code>capFil1</code>
and <code>capFil2</code> to avoid a warning during translation.
</li>
<li>
February 14, 2014, by Michael Wetter:<br/>
Removed unused parameters <code>B0</code> and <code>B1</code>.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation, added comments, replaced 
<code>HeatTransfer.Windows.BaseClasses.ThermalConductor</code>
with resistance models from the Modelica Standard Library.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"),        Diagram(coordinateSystem(preserveAspectRatio=false, initialScale=0.1),
                  graphics));
              end InternalHEXOneUTube;

              model InternalResistancesOneUTube
                "Internal resistance model for single U-tube borehole segments."
                extends
                IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialInternalResistances;
                parameter Modelica.SIunits.ThermalResistance Rgg_val "Thermal resistance between the two grout zones";
                parameter Modelica.SIunits.HeatCapacity Co_fil=borFieDat.filDat.dFil*borFieDat.filDat.cFil*hSeg*Modelica.Constants.pi
                  *(borFieDat.conDat.rBor^2 - 2*borFieDat.conDat.rTub^2)
                  "Heat capacity of the whole filling material";
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rpg1(R=RCondGro_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=-90,
                      origin={0,70})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgb1(R=Rgb_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=-90,
                      origin={-30,30})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor capFil1(
                  C=Co_fil/2,
                  T(start=T_start, fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)),
                  der_T(fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial))) if
                     dynFil
                  "Heat capacity of the filling material" annotation (Placement(
                      transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=90,
                      origin={-70,50})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor capFil2(
                  C=Co_fil/2,
                  T(start=T_start, fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)),
                  der_T(fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial))) if
                     dynFil
                  "Heat capacity of the filling material" annotation (Placement(
                      transformation(
                      extent={{-10,10},{10,-10}},
                      rotation=90,
                      origin={70,50})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgg(R=Rgg_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=0,
                      origin={30,50})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rpg2(R=RCondGro_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=0,
                      origin={70,0})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgb2(R=Rgb_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}},
                      rotation=0,
                      origin={30,0})));
              equation
                connect(port_1, Rpg1.port_a)
                  annotation (Line(points={{0,100},{0,100},{0,80}}, color={191,0,0}));
                connect(Rpg1.port_b, Rgb1.port_a) annotation (Line(points={{0,60},{0,60},{0,50},
                        {-30,50},{-30,40}}, color={191,0,0}));
                connect(Rgb1.port_b, port_wall) annotation (Line(points={{-30,20},{-30,20},{-30,
                        0},{0,0}}, color={191,0,0}));
                connect(capFil1.port, Rgb1.port_a)
                  annotation (Line(points={{-60,50},{-30,50},{-30,40}}, color={191,0,0}));
                connect(Rgg.port_a, Rgb1.port_a)
                  annotation (Line(points={{20,50},{-30,50},{-30,40}}, color={191,0,0}));
                connect(port_2, Rpg2.port_b)
                  annotation (Line(points={{100,0},{90,0},{80,0}}, color={191,0,0}));
                connect(Rgg.port_b, Rpg2.port_a) annotation (Line(points={{40,50},{46,50},{50,
                        50},{50,0},{60,0}}, color={191,0,0}));
                connect(Rgb2.port_b, Rpg2.port_a)
                  annotation (Line(points={{40,0},{60,0}}, color={191,0,0}));
                connect(Rgb2.port_a, port_wall)
                  annotation (Line(points={{20,0},{0,0},{0,0}}, color={191,0,0}));
                connect(capFil2.port, Rgg.port_b)
                  annotation (Line(points={{60,50},{50,50},{40,50}}, color={191,0,0}));
                  annotation (
                  Documentation(info="<html>
<p>
This model simulates the internal thermal resistance network of a borehole segment in
the case of a single U-tube borehole using the method of Bauer et al. (2011) 
and computing explicitely the fluid-to-ground thermal resistance 
<i>R<sub>b</sub></i> and the 
grout-to-grout resistance
<i>R<sub>a</sub></i> as defined by Claesson and Hellstrom (2011)
using the multipole method. 
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
<p>
D. Bauer, W. Heidemann, H. M&uuml;ller-Steinhagen, and H.-J. G. Diersch.
<i>
Thermal resistance and capacity models for borehole heat exchangers
</i>.
International Journal Of Energy Research, 35:312-320, 2011.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 5, 2018, by Alex Laferri&egrave;re:<br/>
Extended the model from a partial class.
</li>
<li>
June, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"),               Icon(graphics={
                      Line(
                        points={{-2,100}},
                        color={0,0,0},
                        thickness=1),          Text(
                        extent={{-100,144},{100,106}},
                        lineColor={0,0,255},
                        fillPattern=FillPattern.HorizontalCylinder,
                        fillColor={0,127,255},
                        textString="%name")}));
              end InternalResistancesOneUTube;

              partial model PartialBorehole
                "Partial model to implement multi-segment boreholes"
                extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface;

                extends IDEAS.Fluid.Interfaces.TwoPortFlowResistanceParameters(
                  computeFlowResistance=dp_nominal > Modelica.Constants.eps);

                replaceable package Medium =
                  Modelica.Media.Interfaces.PartialMedium "Medium in the component"
                    annotation (choices(
                      choice(redeclare package Medium = IDEAS.Media.Water "Water"),
                      choice(redeclare package Medium =
                          IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                            property_T=293.15,
                            X_a=0.40)
                            "Propylene glycol water, 40% mass fraction")));

                constant Real mSenFac(min=1)=1
                 "Factor for scaling the sensible thermal mass of the volume";

                parameter Integer nSeg(min=1) = 10
                  "Number of segments to use in vertical discretization of the boreholes";
                parameter Modelica.SIunits.Temperature TGro_start[nSeg]
                  "Start value of grout temperature"
                  annotation (Dialog(tab="Initialization"));

                parameter Modelica.SIunits.Temperature TFlu_start[nSeg] = TGro_start
                  "Start value of fluid temperature"
                  annotation (Dialog(tab="Initialization"));

                // Assumptions
                parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
                  "Type of energy balance: dynamic (3 initialization options) or steady state"
                  annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

                // Initialization
                parameter Medium.AbsolutePressure p_start = Medium.p_default
                  "Start value of pressure"
                  annotation(Dialog(tab = "Initialization"));

                parameter Boolean dynFil=true
                    "Set to false to remove the dynamics of the filling material"
                    annotation (Dialog(tab="Dynamics"));
                parameter Data.Borefield.Template borFieDat "Borefield parameters"
                  annotation (Placement(transformation(extent={{-80,-80},{-60,-60}})));

                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_wall[nSeg]
                  "Thermal connection for borehole wall"
                  annotation (Placement(transformation(extent={{-10,90},{10,110}})));

                  annotation(Documentation(info="<html>
<p>
Partial model to implement models simulating geothermal U-tube boreholes modeled
as several borehole segments, with a uniform borehole wall boundary condition.
</p>
</html>",               revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice to water and glycolWater.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation of partial model.
</li>
<li>
July 2014, by Damien Picard:<br/>
First implementation.
</ul>
</html>"),    Icon(coordinateSystem(
                      preserveAspectRatio=true,
                      extent={{-100,-100},{100,100}},
                      grid={2,2},
                      initialScale=0.5), graphics={
                      Rectangle(
                        extent={{-68,76},{72,-84}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-60,-56},{64,-64}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-60,54},{64,50}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-60,2},{64,-4}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-70,76},{-60,-84}},
                        lineColor={0,0,0},
                        fillColor={192,192,192},
                        fillPattern=FillPattern.Backward),
                      Rectangle(
                        extent={{64,76},{74,-84}},
                        lineColor={0,0,0},
                        fillColor={192,192,192},
                        fillPattern=FillPattern.Backward)}));
              end PartialBorehole;

              partial model PartialInternalHEX
                "Partial model to implement the internal heat exchanger of a borehole segment"
                parameter IDEAS.Fluid.Geothermal.Borefields.Data.Borefield.Template
                  borFieDat "Borefield parameters"
                  annotation (Placement(transformation(extent={{-100,-100},{-80,-80}})));
                replaceable package Medium =
                  Modelica.Media.Interfaces.PartialMedium "Medium"
                  annotation (choices(
                      choice(redeclare package Medium = IDEAS.Media.Water "Water"),
                      choice(redeclare package Medium =
                          IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                            property_T=293.15,
                            X_a=0.40)
                            "Propylene glycol water, 40% mass fraction")));
                constant Real mSenFac=1
                  "Factor for scaling the sensible thermal mass of the volume";
                parameter Boolean dynFil=true
                  "Set to false to remove the dynamics of the filling material"
                  annotation (Dialog(tab="Dynamics"));
                parameter Modelica.SIunits.Length hSeg
                  "Length of the internal heat exchanger";
                parameter Modelica.SIunits.Volume VTubSeg = hSeg*Modelica.Constants.pi*(borFieDat.conDat.rTub-borFieDat.conDat.eTub)^2
                  "Fluid volume in each tube";
                parameter Modelica.SIunits.Temperature TFlu_start
                  "Start value of fluid temperature"
                  annotation (Dialog(tab="Initialization"));
                parameter Modelica.SIunits.Temperature TGro_start
                  "Start value of grout temperature"
                  annotation (Dialog(tab="Initialization"));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_wall
                  "Thermal connection for borehole wall"
                  annotation (Placement(transformation(extent={{-10,90},{10,110}})));
            protected
                parameter Modelica.SIunits.SpecificHeatCapacity cpMed=
                    Medium.specificHeatCapacityCp(Medium.setState_pTX(
                    Medium.p_default,
                    Medium.T_default,
                    Medium.X_default)) "Specific heat capacity of the fluid";
                parameter Modelica.SIunits.ThermalConductivity kMed=
                    Medium.thermalConductivity(Medium.setState_pTX(
                    Medium.p_default,
                    Medium.T_default,
                    Medium.X_default)) "Thermal conductivity of the fluid";
                parameter Modelica.SIunits.DynamicViscosity muMed=Medium.dynamicViscosity(
                    Medium.setState_pTX(
                    Medium.p_default,
                    Medium.T_default,
                    Medium.X_default)) "Dynamic viscosity of the fluid";
                parameter Real Rgb_val(fixed=false)
                  "Thermal resistance between grout zone and borehole wall";
                parameter Real RCondGro_val(fixed=false)
                  "Thermal resistance between: pipe wall to capacity in grout";
                parameter Real x(fixed=false) "Capacity location";
              initial equation
                assert(borFieDat.conDat.rBor > borFieDat.conDat.xC + borFieDat.conDat.rTub and
                       0 < borFieDat.conDat.xC - borFieDat.conDat.rTub,
                       "The borehole geometry is not physical. Check the borefield data record
         to ensure that the shank spacing is larger than the outer tube radius
         and that the borehole radius is sufficiently large.");
                annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                      Rectangle(
                        extent={{-70,80},{70,-80}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid)}),                      Diagram(graphics,
                      coordinateSystem(preserveAspectRatio=false)),
                Documentation(info="<html>
<p>
Partial model to implement models simulating the thermal and fluid behaviour of a borehole segment.
</p>
<p>
The thermodynamic properties of the fluid circulating in the borehole are calculated
as protected parameters in this partial model: <i>c<sub>p</sub></i> (<code>cpMed</code>),
<i>k</i> (<code>kMed</code>) and <i>&mu;</i> (<code>muMed</code>). Additionally, the
following parameters are already declared as protected parameters and thus do not
need to be declared in models which extend this partial model:
</p>
<ul>
<li>
<code>Rgb_val</code> (Thermal resistance between grout zone and borehole wall)
</li>
<li>
<code>RCondGro_val</code> (Thermal resistance between pipe wall and capacity in grout)
</li>
<li>
<code>x</code> (Grout capacity location)
</li>
</ul>
</html>",               revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice to water and glycolWater.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 10, 2018, by Alex Laferri&egrave;re:<br/>
First implementation of partial model.
</li>
<li>
June 18, 2014, by Michael Wetter:<br/>
Added initialization for temperatures and derivatives of <code>capFil1</code>
and <code>capFil2</code> to avoid a warning during translation.
</li>
<li>
February 14, 2014, by Michael Wetter:<br/>
Removed unused parameters <code>B0</code> and <code>B1</code>.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation, added comments, replaced
<code>HeatTransfer.Windows.BaseClasses.ThermalConductor</code>
with resistance models from the Modelica Standard Library.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
              end PartialInternalHEX;

              partial model PartialInternalResistances
                "Partial model to implement borehole segment internal resistance models"
                parameter Modelica.SIunits.Length hSeg
                  "Length of the internal heat exchanger";
                parameter Modelica.SIunits.Temperature T_start
                  "Initial temperature of the filling material";
                parameter Data.Borefield.Template borFieDat "Borefield data"
                  annotation (Placement(transformation(extent={{-100,-100},{-80,-80}})));
                parameter Modelica.SIunits.ThermalResistance Rgb_val
                  "Thermal resistance between grout zone and borehole wall";
                parameter Modelica.SIunits.ThermalResistance RCondGro_val
                  "Thermal resistance between: pipe wall to capacity in grout";
                parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
                  "Type of energy balance: dynamic (3 initialization options) or steady state"
                  annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
                parameter Boolean dynFil=true
                    "Set to false to remove the dynamics of the filling material."
                    annotation (Dialog(tab="Dynamics"));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_1
                  "Thermal connection for pipe 1"
                  annotation (Placement(transformation(extent={{-10,90},{10,110}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_wall
                  "Thermal connection for pipe 2"
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_2
                  "Thermal connection for borehole wall"
                  annotation (Placement(transformation(extent={{90,-10},{110,10}})));
                annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                      Rectangle(
                        extent={{-100,100},{100,-100}},
                        lineColor={0,0,0},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                      Line(points={{0,0},{0,10},{-10,20},{10,40},{-10,60},{10,80},{0,90},{0,
                            100}},
                          color={0,0,0},
                        thickness=0.5),
                      Line(
                        points={{0,-70.7107},{0,-40},{-10,-30},{10,-10},{-10,10},{10,30},{0,
                            40},{-7.10543e-015,70.7107}},
                        color={0,0,0},
                        origin={50,50},
                        rotation=45,
                        thickness=0.5),
                      Line(
                        points={{0,-50},{0,-40},{-10,-30},{10,-10},{-10,10},{10,30},{0,40},{0,
                            50}},
                        color={0,0,0},
                        origin={50,0},
                        rotation=-90,
                        thickness=0.5)}),                                      Diagram(graphics,
                      coordinateSystem(preserveAspectRatio=false)),
                      Documentation(info="<html>
<p>
Partial model to implement the inner resistance network of a borehole segment.
</p>
<p>
The partial model uses a thermal port representing a uniform borehole wall for
that segment, and at least two other thermal ports (one for each tube going through the borehole
segment).
</p>
</html>",               revisions="<html>
<ul>
<li>
July 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation of partial class.
</li>
<li>
June, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
              end PartialInternalResistances;
            annotation (Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.HeatExchangers.Boreholes\">IDEAS.Fluid.HeatExchangers.Boreholes</a>.
</p>
</html>"));
            end BaseClasses;

            model OneUTube "Single U-tube borehole heat exchanger"
              extends
              IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialBorehole;
              IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.InternalHEXOneUTube
                intHex[nSeg](
                redeclare each final package Medium = Medium,
                each final hSeg=borFieDat.conDat.hBor/nSeg,
                each final from_dp1=from_dp,
                each final from_dp2=from_dp,
                each final linearizeFlowResistance1=linearizeFlowResistance,
                each final linearizeFlowResistance2=linearizeFlowResistance,
                each final deltaM1=deltaM,
                each final deltaM2=deltaM,
                each final energyDynamics=energyDynamics,
                each final dynFil=dynFil,
                each final mSenFac=mSenFac,
                final dp1_nominal={if i == 1 then dp_nominal else 0 for i in 1:nSeg},
                each final dp2_nominal=0,
                each final m1_flow_nominal=m_flow_nominal,
                each final m2_flow_nominal=m_flow_nominal,
                each final borFieDat=borFieDat,
                each final allowFlowReversal1=allowFlowReversal,
                each final allowFlowReversal2=allowFlowReversal,
                each final show_T=show_T,
                each final p1_start=p_start,
                each final p2_start=p_start,
                final TFlu_start=TFlu_start,
                final TGro_start=TGro_start) "Borehole segments"
                annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
            equation
              connect(port_a, intHex[1].port_a1) annotation (Line(
                  points={{-100,5.55112e-016},{-52,5.55112e-016},{-52,6},{-10,6}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(port_b, intHex[1].port_b2) annotation (Line(
                  points={{100,5.55112e-016},{28,5.55112e-016},{28,-40},{-32,-40},{-32,-6},{
                      -10,-6}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(intHex[nSeg].port_b1, intHex[nSeg].port_a2)
                annotation (Line(
                  points={{10,6},{20,6},{20,-6},{10,-6}},
                  color={0,127,255},
                  smooth=Smooth.None));
              for i in 1:nSeg - 1 loop
                connect(intHex[i].port_b1, intHex[i + 1].port_a1) annotation (Line(
                    points={{10,6},{10,20},{-10,20},{-10,6}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(intHex[i].port_a2, intHex[i + 1].port_b2) annotation (Line(
                    points={{10,-6},{10,-20},{-10,-20},{-10,-6}},
                    color={0,127,255},
                    smooth=Smooth.None));
              end for;
              connect(intHex.port_wall, port_wall)
                annotation (Line(points={{0,10},{0,10},{0,100}}, color={191,0,0}));
              annotation (
                defaultComponentName="borHol",
                Icon(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={2,2},
                    initialScale=0.5), graphics={
                    Rectangle(
                      extent={{56,88},{48,-92}},
                      lineColor={0,0,255},
                      pattern=LinePattern.None,
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-52,-92},{-44,88}},
                      lineColor={0,0,255},
                      pattern=LinePattern.None,
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-50,-84},{56,-92}},
                      lineColor={0,0,255},
                      pattern=LinePattern.None,
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid)}),
                Diagram(coordinateSystem(
                    preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}},
                    grid={2,2},
                    initialScale=0.5), graphics={Text(
                      extent={{60,72},{84,58}},
                      lineColor={0,0,255},
                      textString="")}),
                Documentation(info="<html>
<p>
Model of a single U-tube borehole heat exchanger. 
The borehole heat exchanger is vertically discretized into
<i>n<sub>seg</sub></i> elements of height
<i>h=h<sub>Bor</sub>&frasl;n<sub>seg</sub></i>.
Each segment contains a model for the heat transfer in the borehole, 
with a uniform borehole wall boundary temperature given by the
<code>port_wall</code> port.
</p>
<p>
The heat transfer in the borehole is computed using a convective heat transfer
coefficient that depends on the fluid velocity, a heat resistance between the
two pipes, and a heat resistance between the pipes and the borehole wall.
The heat capacity of the fluid and the heat capacity of the grout are taken
into account. The vertical heat flow is assumed to be zero.
</p>
</html>",             revisions="<html>
<ul>
<li>
July 2018, by Alex Laferri&egrave;re:<br/>
Following major changes to the structure of the IDEAS.Fluid.HeatExchangers.Ground package,
the documentation has been changed to reflect the new role of this model.
Additionally, this model now extends a partial borehole model.
</li>
<li>
July 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end OneUTube;
          annotation (Documentation(info="<html>
<p>
This package contains models for borehole heat exchangers.
</p>
</html>"));
          end Boreholes;

          package HeatTransfer "Package with ground heat transfer models"
          extends Modelica.Icons.VariantsPackage;

            model GroundTemperatureResponse "Model calculating discrete load aggregation"
              parameter Modelica.SIunits.Time tLoaAgg(final min = Modelica.Constants.eps)=3600
                "Time resolution of load aggregation";
              parameter Integer nCel(min=1)=5 "Number of cells per aggregation level";
              parameter Boolean forceGFunCalc = false
                "Set to true to force the thermal response to be calculated at the start instead of checking whether it has been pre-computed";
              parameter IDEAS.Fluid.Geothermal.Borefields.Data.Borefield.Template borFieDat
                "Record containing all the parameters of the borefield model" annotation (
                 choicesAllMatching=true, Placement(transformation(extent={{-80,-80},{-60,-60}})));
              Modelica.Blocks.Interfaces.RealOutput delTBor(unit="K")
                "Temperature difference current borehole wall temperature minus initial borehole wall temperature"
                annotation (Placement(transformation(extent={{100,-14},{126,12}}),
                    iconTransformation(extent={{100,-10},{120,10}})));
              Modelica.Blocks.Interfaces.RealInput QBor_flow(unit="W")
                "Heat flow from all boreholes combined (positive if heat from fluid into soil)"
                annotation (Placement(transformation(extent={{-120,-10},{-100,10}}),
                    iconTransformation(extent={{-120,-10},{-100,10}})));
          protected
              constant Integer nSegMax = 1500 "Max total number of segments in g-function calculation";
              final parameter Integer nSeg = integer(if 12*borFieDat.conDat.nBor<nSegMax then 12 else floor(nSegMax/borFieDat.conDat.nBor))
                "Number of segments per borehole for g-function calculation";
              constant Integer nTimSho = 26 "Number of time steps in short time region";
              constant Integer nTimLon = 50 "Number of time steps in long time region";
              constant Real ttsMax = exp(5) "Maximum non-dimensional time for g-function calculation";
              constant Integer nTimTot = nTimSho+nTimLon
                "Total length of g-function vector";
              constant Real lvlBas = 2 "Base for exponential cell growth between levels";
              parameter String SHAgfun=
                IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.shaGFunction(
                  nBor=borFieDat.conDat.nBor,
                  cooBor=borFieDat.conDat.cooBor,
                  hBor=borFieDat.conDat.hBor,
                  dBor=borFieDat.conDat.dBor,
                  rBor=borFieDat.conDat.rBor,
                  aSoi=borFieDat.soiDat.aSoi,
                  nSeg=nSeg,
                  nTimSho=nTimSho,
                  nTimLon=nTimLon,
                  ttsMax=ttsMax) "String with encrypted g-function arguments";
              parameter Modelica.SIunits.Time timFin=
                (borFieDat.conDat.hBor^2/(9*borFieDat.soiDat.aSoi))*ttsMax
                "Final time for g-function calculation";
              parameter Integer i(min=1)=
                IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.countAggregationCells(
                  lvlBas=lvlBas,
                  nCel=nCel,
                  timFin=timFin,
                  tLoaAgg=tLoaAgg)
                  "Number of aggregation cells";
              final parameter Real[nTimTot,2] timSer(each fixed=false)
                "g-function input from matrix, with the second column as temperature Tstep";
              final parameter Modelica.SIunits.Time t_start(fixed=false) "Simulation start time";
              final parameter Modelica.SIunits.Time[i] nu(each fixed=false)
                "Time vector for load aggregation";
              final parameter Real[i] kappa(each fixed=false)
                "Weight factor for each aggregation cell";
              final parameter Real[i] rCel(each fixed=false) "Cell widths";
              discrete Modelica.SIunits.HeatFlowRate[i] QAgg_flow
                "Vector of aggregated loads";
              discrete Modelica.SIunits.HeatFlowRate[i] QAggShi_flow
                "Shifted vector of aggregated loads";
              discrete Integer curCel "Current occupied cell";
              discrete Modelica.SIunits.TemperatureDifference delTBor0
                "Previous time step's temperature difference current borehole wall temperature minus initial borehole temperature";
              discrete Real derDelTBor0(unit="K/s")
                "Derivative of wall temperature change from previous time steps";
              final parameter Real dTStepdt(fixed=false)
                "Time derivative of g/(2*pi*H*Nb*ks) within most recent cell";
              Modelica.SIunits.Heat U "Accumulated heat flow from all boreholes";
              discrete Modelica.SIunits.Heat U_old "Accumulated heat flow from all boreholes at last aggregation step";
            initial equation
              QAgg_flow = zeros(i);
              curCel = 1;
              delTBor = 0;
              QAggShi_flow = QAgg_flow;
              delTBor0 = 0;
              U = 0;
              U_old = 0;
              derDelTBor0 = 0;
              (nu,rCel) = IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.aggregationCellTimes(
                i=i,
                lvlBas=lvlBas,
                nCel=nCel,
                tLoaAgg=tLoaAgg,
                timFin=timFin);
              t_start = time;
              kappa = IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.aggregationWeightingFactors(
                i=i,
                nTimTot=nTimTot,
                TStep=timSer,
                nu=nu);
              dTStepdt = kappa[1]/tLoaAgg;
              timSer =
                IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.temperatureResponseMatrix(
                  nBor=borFieDat.conDat.nBor,
                  cooBor=borFieDat.conDat.cooBor,
                  hBor=borFieDat.conDat.hBor,
                  dBor=borFieDat.conDat.dBor,
                  rBor=borFieDat.conDat.rBor,
                  aSoi=borFieDat.soiDat.aSoi,
                  kSoi=borFieDat.soiDat.kSoi,
                  nSeg=nSeg,
                  nTimSho=nTimSho,
                  nTimLon=nTimLon,
                  nTimTot=nTimTot,
                  ttsMax=ttsMax,
                  sha=SHAgfun,
                  forceGFunCalc=forceGFunCalc);
            equation
              der(delTBor) = dTStepdt*QBor_flow + derDelTBor0;
              der(U) = QBor_flow;
              when sample(t_start, tLoaAgg) then
                // Assign average load since last aggregation step to the first cell of the
                // aggregation vector
                U_old = U;
                // Store (U - pre(U_old))/tLoaAgg in QAgg_flow[1], and pre(QAggShi_flow) in the other elements
                QAgg_flow = cat(1, {(U - pre(U_old))/tLoaAgg}, pre(QAggShi_flow[2:end]));
                // Shift loads in aggregation cells
                (curCel,QAggShi_flow) = IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.shiftAggregationCells(
                  i=i,
                  QAgg_flow=QAgg_flow,
                  rCel=rCel,
                  nu=nu,
                  curTim=(time - t_start));
                // Determine the temperature change at the next aggregation step (assuming
                // no loads until then)
                delTBor0 = IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.temporalSuperposition(
                  i=i,
                  QAgg_flow=QAggShi_flow,
                  kappa=kappa,
                  curCel=curCel);
                derDelTBor0 = (delTBor0-delTBor)/tLoaAgg;
              end when;
              annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-100,30},{100,-100}},
                      lineColor={0,0,0},
                      fillColor={127,127,0},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-52,30},{-94,-100}},
                      lineColor={0,0,0},
                      fillColor={135,135,135},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-66,-4},{72,-4}},
                      color={255,0,0},
                      arrow={Arrow.None,Arrow.Filled}),
                    Rectangle(
                      extent={{-100,30},{-94,-100}},
                      lineColor={0,0,0},
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-151,147},{149,107}},
                      lineColor={0,0,255},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={0,127,255},
                        textString="%name")}),
              Diagram(graphics,
                    coordinateSystem(preserveAspectRatio=false)),
                    Documentation(info="<html>
<p>
This model calculates the ground temperature response to obtain the temperature
at the borehole wall in a geothermal system where heat is being injected into or
extracted from the ground.
</p>
<p>
A load-aggregation scheme based on that developed by Claesson and Javed (2012) is
used to calculate the borehole wall temperature response with the temporal superposition
of ground thermal loads. In its base form, the
load-aggregation scheme uses fixed-length aggregation cells to agglomerate
thermal load history together, with more distant cells (denoted with a higher cell and vector index)
representing more distant thermal history. The more distant the thermal load, the
less impactful it is on the borehole wall temperature change at the current time step.
Each cell has an <em>aggregation time</em> associated to it denoted by <code>nu</code>,
which corresponds to the simulation time (since the beginning of heat injection or
extraction) at which the cell will begin shifting its thermal load to more distant
cells. To determine <code>nu</code>, cells have a temporal size <i>r<sub>cel</sub></i>
(<code>rcel</code> in this model)
which follows the exponential growth
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_02.png\" />
</p>
<p>
where <i>n<sub>Cel</sub></i> is the number of consecutive cells which can have the same size.
Decreasing <i>r<sub>cel</sub></i> will generally decrease calculation times, at the cost of
precision in the temporal superposition. <code>rcel</code> is expressed in multiples
of the aggregation time resolution (via the parameter <code>tLoaAgg</code>).
Then, <code>nu</code> may be expressed as the sum of all <code>rcel</code> values
(multiplied by the aggregation time resolution) up to and including that cell in question.
</p>
<p>
To determine the weighting factors, the borefield's temperature
step response at the borefield wall is determined as
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_03.png\" />
</p>
<p>
where <i>g(&middot;)</i> is the borefield's thermal response factor known as the <em>g-function</em>,
<i>H</i> is the total length of all boreholes and <i>k<sub>s</sub></i> is the thermal
conductivity of the soil. The weighting factors <code>kappa</code> (<i>&kappa;</i> in the equation below)
for a given cell <i>i</i> are then expressed as follows.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_04.png\" />
</p>
<p>
where <i>&nu;</i> refers to the vector <code>nu</code> in this model and
<i>T<sub>step</sub>(&nu;<sub>0</sub>)</i>=0.
</p>
<p>
At every aggregation time step, a time event is generated to perform the load aggregation steps.
First, the thermal load is shifted. When shifting between cells of different size, total
energy is conserved. This operation is illustred in the figure below by Cimmino (2014).
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_01.png\" />
</p>
<p>
After the cell-shifting operation is performed, the first aggregation cell has its
value set to the average thermal load since the last aggregation step.
Temporal superposition is then applied by means
of a scalar product between the aggregated thermal loads <code>QAgg_flow</code> and the
weighting factors <i>&kappa;</i>.
</p>
<p>
Due to Modelica's variable time steps, the load aggregation scheme is modified by separating
the thermal response between the current aggregation time step and everything preceding it.
This is done according to
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_05.png\" />
<br/>
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_06.png\" />
</p>
<p>
where <i>T<sub>b</sub></i> is the borehole wall temperature,
<i>T<sub>g</sub></i>
is the undisturbed ground temperature,
<i>Q</i> is the ground thermal load per borehole length and <i>h = g/(2 &pi; k<sub>s</sub>)</i>
is a temperature response factor based on the g-function. <i>t<sub>k</sub></i>
is the last discrete aggregation time step, meaning that the current time <i>t</i>
satisfies <i>t<sub>k</sub>&le;t&le;t<sub>k+1</sub></i>.
<i>&Delta;t<sub>agg</sub>(=t<sub>k+1</sub>-t<sub>k</sub>)</i> is the
parameter <code>tLoaAgg</code> in the present model.
</p>
<p>
Thus,
<i>&Delta;T<sub>b</sub>*(t)</i>
is the borehole wall temperature change due to the thermal history prior to the current
aggregation step. At every aggregation time step, load aggregation and temporal superposition
are used to calculate its discrete value. Assuming no heat injection or extraction until
<i>t<sub>k+1</sub></i>, this term is assumed to have a linear
time derivative, which is given by the difference between <i>&Delta;T<sub>b</sub>*(t<sub>k+1</sub>)</i>
(the temperature change from load history at the next discrete aggregation time step, which
is constant over the duration of the ongoing aggregation time step) and the total
temperature change at the last aggregation time step, <i>&Delta;T<sub>b</sub>(t)</i>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_09.png\" />
</p>
<p>
The second term <i>&Delta;T<sub>b,q</sub>(t)</i> concerns the ongoing aggregation time step.
To obtain the time derivative of this term, the thermal response factor <i>h</i> is assumed
to vary linearly over the course of an aggregation time step. Therefore, because
the ongoing aggregation time step always concerns the first aggregation cell, its derivative (denoted
by the parameter <code>dTStepdt</code> in this model) can be calculated as
<code>kappa[1]</code>, the first value in the <code>kappa</code> vector,
divided by the aggregation time step <i>&Delta;t</i>.
The derivative of the temperature change at the borehole wall is then expressed
as the multiplication of <code>dTStepdt</code> (which only needs to be
calculated once at the start of the simulation) and the heat flow <i>Q</i> at
the borehole wall.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_10.png\" />
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_11.png\" />
</p>
<p>
With the two terms in the expression of <i>&Delta;T<sub>b</sub>(t)</i> expressed
as time derivatives, <i>&Delta;T<sub>b</sub>(t)</i> can itself also be
expressed as its time derivative and implemented as such directly in the Modelica
equations block with the <code>der()</code> operator.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_07.png\" />
<br/>
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_08.png\" />
</p>
<p>
This load aggregation scheme is validated in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.Validation.Analytic_20Years\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.Validation.Analytic_20Years</a>.
</p>
<h4>References</h4>
<p>
Cimmino, M. 2014. <i>D&eacute;veloppement et validation exp&eacute;rimentale de facteurs de r&eacute;ponse
thermique pour champs de puits g&eacute;othermiques</i>,
Ph.D. Thesis, &Eacute;cole Polytechnique de Montr&eacute;al.
</p>
<p>
Claesson, J. and Javed, S. 2012. <i>A load-aggregation method to calculate extraction temperatures of borehole heat exchangers</i>. ASHRAE Transactions 118(1): 530-539.
</p>
</html>",             revisions="<html>
<ul>
<li>
August 30, 2018, by Michael Wetter:<br/>
Refactored model to compute the temperature difference relative to the initial temperature,
because the model is independent of the initial temperature.
</li>
<li>
April 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
            end GroundTemperatureResponse;

            package LoadAggregation
            "Package with functions for load aggregation"
              extends Modelica.Icons.BasesPackage;

              function aggregationCellTimes
                "Function which builds the time and cell width vectors for aggregation"
                extends Modelica.Icons.Function;
                input Integer i "Size of time vector";
                input Real lvlBas "Base for growth between each level, e.g. 2";
                input Integer nCel "Number of cells of same size per level";
                input Modelica.SIunits.Time tLoaAgg(final min=Modelica.Constants.small) "Time resolution of load aggregation";
                input Modelica.SIunits.Time timFin "Total simulation max length";
                output Modelica.SIunits.Time nu[i] "Time vector nu of size i";
                output Real rCel[i](each unit="1") "Cell width vector of size i";
            protected
                Real width_j;
              algorithm
                width_j := 0;
                for j in 1:i loop
                  width_j := width_j + tLoaAgg*lvlBas^floor((j-1)/nCel);
                  nu[j] := width_j;
                  rCel[j] := lvlBas^floor((j-1)/nCel);
                end for;
                if nu[i]>timFin then
                  nu[i] := timFin;
                  rCel[i] := (nu[i]-nu[i-1])/tLoaAgg;
                end if;
                annotation (Documentation(info="<html>
<p>Simultaneously constructs both the <code>nu</code> vector, which is the
aggregation time of each cell, and the <code>rCel</code> vector, which
is the temporal size of each cell normalized with the time resolution of load
aggregation <code>tLoaAgg</code>.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Added <code>min=Modelica.Constants.small</code> to <code>tLoaAgg</code>
so that a tool can infer that this quantity is non-zero.
</li>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end aggregationCellTimes;

              function aggregationWeightingFactors
                "Calculates the kappa vector for load aggregation"
                extends Modelica.Icons.Function;

                input Integer i "Size of aggregation vector";
                input Integer nTimTot "Size of g-function time table";
                input Modelica.SIunits.ThermalResistance TStep[nTimTot,2] "Time matrix with TStep";
                input Modelica.SIunits.Time nu[i] "Aggregation time vector nu";

                output Modelica.SIunits.ThermalResistance kappa[i] "Weighting factors vector";

            protected
                Modelica.SIunits.ThermalResistance prevT "Interpolated value of TStep at previous cell";
                Modelica.SIunits.ThermalResistance curT "Interpolated value of TStep at current cell";
                Integer curInt "Integer to select data interval";
                Real[size(TStep[:,1], 1)] d(each unit="K/J") "Derivatives at the support points";

              algorithm
                d := IDEAS.Utilities.Math.Functions.splineDerivatives(
                  x=TStep[:,1],
                  y=TStep[:,2],
                  ensureMonotonicity=false);

                for j in 1:i loop
                  if j==1 then
                    prevT := 0;
                  else
                    //Spline interpolation at nu[j-1]
                    for k in 1:size(TStep[:,1], 1) - 1 loop
                      if nu[j-1] > TStep[k,1] then
                        curInt := k;
                      end if;
                    end for;

                    prevT := IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                      x=nu[j-1],
                      x1=TStep[curInt,1],
                      x2=TStep[curInt+1,1],
                      y1=TStep[curInt,2],
                      y2=TStep[curInt+1,2],
                      y1d=d[curInt],
                      y2d=d[curInt + 1]);
                  end if;

                  //Spline interpolation at nu[j]
                  for k in 1:size(TStep[:,1], 1) - 1 loop
                    if nu[j] > TStep[k,1] then
                      curInt := k;
                    end if;
                  end for;

                  curT := IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                    x=nu[j],
                    x1=TStep[curInt,1],
                    x2=TStep[curInt+1,1],
                    y1=TStep[curInt,2],
                    y2=TStep[curInt+1,2],
                    y1d=d[curInt],
                    y2d=d[curInt + 1]);

                  kappa[j] := curT-prevT;
                end for;

                annotation (Documentation(info="<html>
<p>
This function uses spline interpolation to construct the weighting factors
vector <code>kappa</code> using the aggregation times <code>nu</code> and the
temperature step reponse (a time-series in the form of a matrix) of the
borefield as an input.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end aggregationWeightingFactors;

              function countAggregationCells
                "Function which returns the number of aggregation cells in the aggregation vector"
                extends Modelica.Icons.Function;
                input Real lvlBas "Base for growth between each level, e.g. 2";
                input Integer nCel(min=1) "Number of cells of same size per level";
                input Modelica.SIunits.Time timFin "Total simulation max length";
                input Modelica.SIunits.Time tLoaAgg "Time resolution of load aggregation";
                output Integer i(min=1) "Size of aggregation vectors";
            protected
                Modelica.SIunits.Duration width_i "Width of current aggregation cell";
                Modelica.SIunits.Time nu_i "End time of current aggregation cell";
              algorithm
                assert(timFin > 0, "Total simulation time must be bigger than 0.");
                width_i := 0;
                nu_i := 0;
                i := 0;
                while nu_i<timFin loop
                  i := i+1;
                  width_i := tLoaAgg*lvlBas^floor((i-1)/nCel);
                  nu_i := nu_i + width_i;
                end while;
              annotation (Documentation(info="<html>
<p>
Function that counts the required length of the aggregation time vector
<code>nu</code> and of the weighting factor vectors <code>kappa</code> based on
the maximum time for calculations related to the ground temperature response.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Added <code>min=1</code> to <code>nCel</code>
so that a tool can infer that this quantity is non-zero.
</li>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end countAggregationCells;

              function shiftAggregationCells
                "Performs the shifting operation for load aggregation and determines the current cell"
                extends Modelica.Icons.Function;
                input Integer i "Number of aggregation cells";
                input Modelica.SIunits.HeatFlowRate QAgg_flow[i] "Vector of aggregated loads";
                input Real rCel[i](each min=Modelica.Constants.small) "Aggregation cell widths";
                input Modelica.SIunits.Time nu[i] "Cell aggregation times";
                input Modelica.SIunits.Time curTim "Current simulation time";
                output Integer curCel "Current occupied aggregation cell";
                output Modelica.SIunits.HeatFlowRate QAggShi_flow[i] "Shifted vector of aggregated loads";
              algorithm
                curCel := 1;
                for j in (i-1):-1:1 loop
                  if curTim>=nu[j+1] then
                    QAggShi_flow[j+1] := ((rCel[j+1] - 1)*QAgg_flow[j+1] + QAgg_flow[j])/rCel[j+1];
                    if j==(i-1) then
                      curCel := i;
                    end if;
                  elseif curTim>=nu[j] then
                    QAggShi_flow[j+1] := (rCel[j+1]*QAgg_flow[j+1] + QAgg_flow[j])/rCel[j+1];
                    curCel := j+1;
                  else
                    QAggShi_flow[j+1] := QAgg_flow[j+1];
                  end if;
                end for;
                QAggShi_flow[1] := 0;
                annotation (Documentation(info="<html>
<p>
Performs the shifting operation which propagates the thermal load history
towards the more distant aggregation cells, and then sets the current cell's
value at <i>0</i>. Additionally, this function also outputs the last filled load
aggregation cell.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Added <code>min=Modelica.Constants.small</code> to <code>rCel</code>
so that a tool can infer that this quantity is non-zero.
</li>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end shiftAggregationCells;

              function temperatureResponseMatrix
                "Reads and possibly writes a matrix with a time series of the borefield's temperature response"
                extends Modelica.Icons.Function;
                input Integer nBor "Number of boreholes";
                input Real cooBor[nBor, 2] "Borehole coordinates";
                input Modelica.SIunits.Height hBor "Borehole length";
                input Modelica.SIunits.Height dBor "Borehole buried depth";
                input Modelica.SIunits.Radius rBor "Borehole radius";
                input Modelica.SIunits.ThermalDiffusivity aSoi
                  "Thermal diffusivity of soil";
                input Modelica.SIunits.ThermalConductivity kSoi
                  "Thermal conductivity of soil";
                input Integer nSeg "Number of line source segments per borehole";
                input Integer nTimSho "Number of time steps in short time region";
                input Integer nTimLon "Number of time steps in long time region";
                input Integer nTimTot "Number of g-function points";
                input Real ttsMax "Maximum non-dimensional time for g-function calculation";
                input String sha "SHA-1 encryption of the g-function arguments";
                input Boolean forceGFunCalc
                  "Set to true to force the thermal response to be calculated at the start";
                output Modelica.SIunits.ThermalResistance TStep[nTimTot, 2] "Temperature step-response time series";
            protected
                String pathSave "Path of the folder used to save the g-function";
                Modelica.SIunits.Time[nTimTot] tGFun "g-function evaluation times";
                Real[nTimTot] gFun "g-function vector";
                Boolean writegFun = false "True if g-function was succesfully written to file";
              algorithm
                pathSave := "tmp/temperatureResponseMatrix/" + sha + "TStep.mat";
                if forceGFunCalc or not Modelica.Utilities.Files.exist(pathSave) then
                  (tGFun,gFun) :=
                    IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.gFunction(
                    nBor=nBor,
                    cooBor=cooBor,
                    hBor=hBor,
                    dBor=dBor,
                    rBor=rBor,
                    aSoi=aSoi,
                    nSeg=nSeg,
                    nTimSho=nTimSho,
                    nTimLon=nTimLon,
                    ttsMax=ttsMax);
                  for i in 1:nTimTot loop
                    TStep[i,1] := tGFun[i];
                    TStep[i,2] := gFun[i]/(2*Modelica.Constants.pi*hBor*nBor*kSoi);
                  end for;
                  //creation of a temporary folder in the simulation folder
                  Modelica.Utilities.Files.createDirectory("tmp");
                  Modelica.Utilities.Files.createDirectory("tmp/temperatureResponseMatrix");
                  writegFun := Modelica.Utilities.Streams.writeRealMatrix(
                    fileName=pathSave,
                    matrixName="TStep",
                    matrix=TStep,
                    append=false);
                end if;
                TStep := Modelica.Utilities.Streams.readRealMatrix(
                  fileName=pathSave,
                  matrixName="TStep",
                  nrow=nTimTot,
                  ncol=2);
                annotation (Documentation(info="<html>
<p>
This function uses the parameters required to calculate the borefield's thermal
response to build a SHA1-encrypted string unique to the borefield in question.
Then, if the <code>forceGFunCalc</code> input is <code>true</code> or if
there is no <code>.mat</code> file with the SHA1 hash as its filename in the
<code>tmp/temperatureResponseMatrix</code> folder,
the thermal response will be calculated and written as a 
<code>.mat</code> file. Otherwise, the
thermal response will simply be read from the 
<code>.mat</code> file. In the <code>.mat</code> file, the data
is saved in a matrix with the name <code>TStep</code>, where the first column is
the time (in seconds) and the second column is the temperature step response,
which is the g-function divided by <i>2 &pi; H k<sub>soi</sub></i>, with
<code>H</code> being the borehole length and <i>k<sub>soi</sub></i> being the thermal
conductivity of the soil.
</p>
</html>",               revisions="<html>
<ul>
<li>
August 27, 2018, by Michael Wetter:<br/>
Changed name of temporary directory so that it is clear for users
that this is a temporary directory.
</li>
<li>
July 15, 2018, by Michael Wetter:<br/>
Changed implementation to use matrix read and write from
the Modelica Standard Library.
</li>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end temperatureResponseMatrix;

              function temporalSuperposition
                "Performs temporal superposition for the load aggregation procedure"
                extends Modelica.Icons.Function;
                input Integer i "Number of aggregation cells";
                input Modelica.SIunits.HeatFlowRate QAgg_flow[i]
                  "Vector of aggregated loads";
                input Modelica.SIunits.ThermalResistance kappa[i]
                  "Weighting factors for each aggregation cell";
                input Integer curCel "Current occupied aggregation cell";
                output Modelica.SIunits.TemperatureDifference deltaTb "Delta T at wall";
              algorithm
                deltaTb := QAgg_flow[1:curCel]*kappa[1:curCel];
                annotation (
              Inline=true,
              Documentation(info="<html>
<p>
Performs the temporal superposition operation to obtain the temperature change
at the borehole wall at the current time step, which is the scalar product of
the aggregated load vector and the <code>kappa</code> step response vector. To
avoid unnecessary calculations, the current aggregation cell in the simulation
is used to truncate the values from the vectors that are not required.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end temporalSuperposition;
            annotation (Documentation(info="<html>
<p>
This package contains functions for load aggregation. For further information,
consult the documentation of <a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse</a>.
</p>
</html>"));
            end LoadAggregation;

            package ThermalResponseFactors
            "Models for heat transfer outside boreholes"
            extends Modelica.Icons.BasesPackage;

              function cylindricalHeatSource
                "Cylindrical heat source solution from Carslaw and Jaeger"
                extends Modelica.Icons.Function;
                input Modelica.SIunits.Time t "Time";
                input Modelica.SIunits.ThermalDiffusivity aSoi "Ground thermal diffusivity";
                input Modelica.SIunits.Distance dis "Radial distance between borehole axes";
                input Modelica.SIunits.Radius rBor "Radius of emitting borehole";
                output Real G "Thermal response factor of borehole 1 on borehole 2";
            protected
                Real Fo = aSoi*t/rBor^2 "Fourier number";
                Real p = dis/rBor "Fourier number";
              algorithm
                G := Modelica.Math.Nonlinear.quadratureLobatto(
                    function IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource_Integrand(
                    Fo=Fo,
                    p=p),
                  a = 1e-12,
                  b = 100,
                  tolerance = 1e-6);
              annotation (
              Inline=true,
              Documentation(info="<html>
<p>
This function evaluates the cylindrical heat source solution. This solution
gives the relation between the constant heat transfer rate (per unit length)
injected by a cylindrical heat source of infinite length and the temperature
raise in the medium. The cylindrical heat source solution is defined by
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/CylindricalHeatSource_01.png\" />
</p>
<p>
where <i>&Delta;T(t,r)</i> is the temperature raise after a time <i>t</i> of
constant heat injection and at a distance <i>r</i> from the cylindrical source,
<i>Q'</i> is the heat injection rate per unit length, <i>k<sub>s</sub></i> is
the soil thermal conductivity, <i>Fo</i> is the Fourier number,
<i>aSoi<sub>s</sub></i> is the ground thermal diffusivity,
<i>r<sub>b</sub></i> is the radius of the cylindrical source and <i>G</i>
is the cylindrical heat source solution.
</p>
<p>
The cylindrical heat source solution is given by:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/CylindricalHeatSource_02.png\" />
</p>
<p>
The integral is solved numerically, with the integrand defined in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.ThermalResponseFactors.cylindricalHeatSource_Integrand\">IDEAS.Fluid.Geothermal.Borefields.BaseClasses.ThermalResponseFactors.cylindricalHeatSource_Integrand</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end cylindricalHeatSource;

              function cylindricalHeatSource_Integrand
                "Integrand function for cylindrical heat source evaluation"
                extends Modelica.Icons.Function;
                input Real u "Normalized integration variable";
                input Real Fo "Fourier number";
                input Real p "Ratio of distance over radius";
                output Real y "Value of integrand";
              algorithm
                y := 1.0/(u^2*Modelica.Constants.pi^2)*(exp(-u^2*Fo) - 1.0)
                  /(IDEAS.Utilities.Math.Functions.besselJ1(u)^2+IDEAS.Utilities.Math.Functions.besselY1(u)^2)
                  *(IDEAS.Utilities.Math.Functions.besselJ0(p*u)*IDEAS.Utilities.Math.Functions.besselY1(u)
                    -IDEAS.Utilities.Math.Functions.besselJ1(u)*IDEAS.Utilities.Math.Functions.besselY0(p*u));
              annotation (
              Inline=true,
              Documentation(info="<html>
<p>
Integrand of the cylindrical heat source solution for use in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end cylindricalHeatSource_Integrand;

              function finiteLineSource
                "Finite line source solution of Claesson and Javed"
                extends Modelica.Icons.Function;
                input Modelica.SIunits.Time t "Time";
                input Modelica.SIunits.ThermalDiffusivity aSoi "Ground thermal diffusivity";
                input Modelica.SIunits.Distance dis "Radial distance between borehole axes";
                input Modelica.SIunits.Height len1 "Length of emitting borehole";
                input Modelica.SIunits.Height burDep1 "Buried depth of emitting borehole";
                input Modelica.SIunits.Height len2 "Length of receiving borehole";
                input Modelica.SIunits.Height burDep2 "Buried depth of receiving borehole";
                input Boolean includeRealSource = true "True if contribution of real source is included";
                input Boolean includeMirrorSource = true "True if contribution of mirror source is included";
                output Real h_21 "Thermal response factor of borehole 1 on borehole 2";
            protected
                Real lowBou(unit="m-1") "Lower bound of integration";
                // Upper bound is infinite
                Real uppBou(unit="m-1") = 100.0 "Upper bound of integration";
                Modelica.SIunits.Distance disMin
                  "Minimum distance between sources and receiving line";
                Modelica.SIunits.Time timTre "Time treshold for evaluation of the solution";
              algorithm
                h_21 := 0;
                if t > 0 and (includeRealSource or includeMirrorSource) then
                  // Find the minimum distance between the line source and the line where the
                  // finite line source solution is evaluated.
                  if includeRealSource then
                    if (burDep2 + len2) < burDep1 then
                      disMin := sqrt(dis^2 + (burDep1 - burDep2 - len2)^2);
                    elseif burDep2 > (burDep1 + len1) then
                      disMin := sqrt(dis^2 + (burDep1 - burDep2 + len1)^2);
                    else
                      disMin := dis;
                    end if;
                  else
                    disMin := sqrt(dis^2 + (burDep1 + burDep2)^2);
                  end if;
                  // The traveled distance of the temperature front is assumed to be:
                  // d = 5*sqrt(aSoi*t).
                  // The solution is only evaluated at times when the traveled distance is
                  // greater than the minimum distance.
                  timTre := disMin^2/(25*aSoi);
                  if t >= timTre then
                    lowBou := 1.0/sqrt(4*aSoi*t);
                    h_21 := Modelica.Math.Nonlinear.quadratureLobatto(
                      function
                        IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Integrand(
                        dis=dis,
                        len1=len1,
                        burDep1=burDep1,
                        len2=len2,
                        burDep2=burDep2,
                        includeRealSource=includeRealSource,
                        includeMirrorSource=includeMirrorSource),
                      lowBou,
                      uppBou,
                      1.0e-6);
                  else
                    // Linearize the solution at times below the time treshold.
                    lowBou := 1.0/sqrt(4*aSoi*timTre);
                    h_21 := t/timTre*Modelica.Math.Nonlinear.quadratureLobatto(
                      function
                        IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Integrand(
                        dis=dis,
                        len1=len1,
                        burDep1=burDep1,
                        len2=len2,
                        burDep2=burDep2,
                        includeRealSource=includeRealSource,
                        includeMirrorSource=includeMirrorSource),
                      lowBou,
                      uppBou,
                      1.0e-6);
                  end if;
                end if;
              annotation (
              Documentation(info="<html>
<p>
This function evaluates the finite line source solution. This solution
gives the relation between the constant heat transfer rate (per unit length)
injected by a line source of finite length <i>H<sub>1</sub></i> buried at a
distance <i>D<sub>1</sub></i> from a constant temperature surface
(<i>T=0</i>) and the average temperature raise over a line of finite length
<i>H<sub>2</sub></i> buried at a distance <i>D<sub>2</sub></i> from the constant
temperature surface.
The finite line source solution is defined by:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/FiniteLineSource_01.png\" />
</p>
<p>
where <i>&Delta;T<sub>1-2</sub>(t,r,H<sub>1</sub>,D<sub>1</sub>,H<sub>2</sub>,D<sub>2</sub>)</i>
is the temperature raise after a time <i>t</i> of constant heat injection and at
a distance <i>r</i> from the line heat source, <i>Q'</i> is the heat injection
rate per unit length, <i>k<sub>s</sub></i> is the soil thermal conductivity and
<i>h<sub>FLS</sub></i> is the finite line source solution.
</p>
<p>
The finite line source solution is given by:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/FiniteLineSource_02.png\" />
</p>
<p>
where <i>&alpha;<sub>s</sub></i> is the ground thermal diffusivity and
<i>erfint</i> is the integral of the error function, defined in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint\">IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_erfint</a>.
The integral is solved numerically, with the integrand defined in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Integrand\">IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Integrand</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end finiteLineSource;

              function finiteLineSource_Erfint "Integral of the error function"
                extends
                Modelica.Math.Nonlinear.Interfaces.partialScalarFunction;
              algorithm
                y := u*Modelica.Math.Special.erf(u) - 1/sqrt(Modelica.Constants.pi)*(1 - exp(-u^2));
              annotation (
              Inline=true,
              Documentation(info="<html>
<p>
This function evaluates the integral of the error function, given by:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/ErrorFunctionIntegral_01.png\" />
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end finiteLineSource_Erfint;

              function finiteLineSource_Integrand
                "Integrand function for finite line source evaluation"
                extends Modelica.Icons.Function;
                input Real u(unit="1/m") "Integration variable";
                input Modelica.SIunits.Distance dis "Radial distance between borehole axes";
                input Modelica.SIunits.Height len1 "Length of emitting borehole";
                input Modelica.SIunits.Height burDep1 "Buried depth of emitting borehole";
                input Modelica.SIunits.Height len2 "Length of receiving borehole";
                input Modelica.SIunits.Height burDep2 "Buried depth of receiving borehole";
                input Boolean includeRealSource = true "true if contribution of real source is included";
                input Boolean includeMirrorSource = true "true if contribution of mirror source is included";
                output Real y(unit="m") "Value of integrand";
            protected
                Real f "Intermediate variable";
              algorithm
                if includeRealSource then
                  f := sum({
                    +IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                     (burDep2 - burDep1 + len2)*u),
                    -IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                     (burDep2 - burDep1)*u),
                    +IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                     (burDep2 - burDep1 - len1)*u),
                    -IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                     (burDep2 - burDep1 + len2 - len1)*u)});
                else
                  f := 0;
                end if;
                if includeMirrorSource then
                  f := f + sum({
                    +IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                    (burDep2 + burDep1 + len2)*u),
                    -IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                    (burDep2 + burDep1)*u),
                    +IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                    (burDep2 + burDep1 + len1)*u),
                    -IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                    (burDep2 + burDep1 + len2 + len1)*u)});
                end if;
                y := 0.5/(len2*u^2)*f*exp(-dis^2*u^2);
              annotation (
              Documentation(info="<html>
<p>
Integrand of the cylindrical heat source solution for use in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
August 23, 2018 by Michael Wetter:<br/>
Reformulated function to use <code>sum</code>.
</li>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end finiteLineSource_Integrand;

              function gFunction "Evaluate the g-function of a bore field"
                extends Modelica.Icons.Function;
                input Integer nBor "Number of boreholes";
                input Modelica.SIunits.Position cooBor[nBor, 2] "Coordinates of boreholes";
                input Modelica.SIunits.Height hBor "Borehole length";
                input Modelica.SIunits.Height dBor "Borehole buried depth";
                input Modelica.SIunits.Radius rBor "Borehole radius";
                input Modelica.SIunits.ThermalDiffusivity aSoi "Ground thermal diffusivity used in g-function evaluation";
                input Integer nSeg "Number of line source segments per borehole";
                input Integer nTimSho "Number of time steps in short time region";
                input Integer nTimLon "Number of time steps in long time region";
                input Real ttsMax "Maximum adimensional time for gfunc calculation";
                input Real relTol = 0.02 "Relative tolerance on distance between boreholes";
                output Modelica.SIunits.Time tGFun[nTimSho+nTimLon] "Time of g-function evaluation";
                output Real g[nTimSho+nTimLon] "g-function";
            protected
                Modelica.SIunits.Time ts = hBor^2/(9*aSoi) "Characteristic time";
                Modelica.SIunits.Time tSho_min = 1 "Minimum time for short time calculations";
                Modelica.SIunits.Time tSho_max = 3600 "Maximum time for short time calculations";
                Modelica.SIunits.Time tLon_min = tSho_max "Minimum time for long time calculations";
                Modelica.SIunits.Time tLon_max = ts*ttsMax "Maximum time for long time calculations";
                Modelica.SIunits.Time tSho[nTimSho] "Time vector for short time calculations";
                Modelica.SIunits.Time tLon[nTimLon] "Time vector for long time calculations";
                Modelica.SIunits.Distance dis "Separation distance between boreholes";
                Modelica.SIunits.Distance dis_mn "Separation distance for comparison";
                Modelica.SIunits.Radius rLin=0.0005*hBor "Radius for evaluation of same-borehole line source solutions";
                Real hSegRea[nSeg] "Real part of the FLS solution";
                Real hSegMir[2*nSeg-1] "Mirror part of the FLS solution";
                Modelica.SIunits.Height dSeg "Buried depth of borehole segment";
                Integer Done[nBor, nBor] "Matrix for tracking of FLS evaluations";
                Real A[nSeg*nBor+1, nSeg*nBor+1] "Coefficient matrix for system of equations";
                Real B[nSeg*nBor+1] "Coefficient vector for system of equations";
                Real X[nSeg*nBor+1] "Solution vector for system of equations";
                Real FLS "Finite line source solution";
                Real ILS "Infinite line source solution";
                Real CHS "Cylindrical heat source solution";
              algorithm
                // Generate geometrically expanding time vectors
                tSho :=
                  IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.timeGeometric(
                    tSho_min, tSho_max, nTimSho);
                tLon :=
                  IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.timeGeometric(
                    tLon_min, tLon_max, nTimLon);
                // Concatenate the short- and long-term parts
                tGFun := cat(1, {0}, tSho[1:nTimSho - 1], tLon);
                // -----------------------
                // Short time calculations
                // -----------------------
                g[1] := 0.;
                for k in 1:nTimSho loop
                  // Finite line source solution
                  FLS :=
                    IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource(
                    tSho[k],
                    aSoi,
                    rLin,
                    hBor,
                    dBor,
                    hBor,
                    dBor);
                  // Infinite line source solution
                  ILS := 0.5*
                    IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.infiniteLineSource(
                    tSho[k],
                    aSoi,
                    rLin);
                  // Cylindrical heat source solution
                  CHS := 2*Modelica.Constants.pi*
                    IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource(
                    tSho[k],
                    aSoi,
                    rBor,
                    rBor);
                  // Correct finite line source solution for cylindrical geometry
                  g[k+1] := FLS + (CHS - ILS);
                end for;
                // ----------------------
                // Long time calculations
                // ----------------------
                // Initialize coefficient matrix A
                for m in 1:nBor loop
                  for u in 1:nSeg loop
                    // Tb coefficient in spatial superposition equations
                    A[(m-1)*nSeg+u,nBor*nSeg+1] := -1;
                    // Q coefficient in heat balance equation
                    A[nBor*nSeg+1,(m-1)*nSeg+u] := 1;
                  end for;
                end for;
                // Initialize coefficient vector B
                // The total heat extraction rate is constant
                B[nBor*nSeg+1] := nBor*nSeg;
                // Evaluate thermal response matrix at all times
                for k in 1:nTimLon-1 loop
                  for i in 1:nBor loop
                    for j in i:nBor loop
                      // Distance between boreholes
                      if i == j then
                        // If same borehole, distance is the radius
                        dis := rLin;
                      else
                        dis := sqrt((cooBor[i,1] - cooBor[j,1])^2 + (cooBor[i,2] - cooBor[j,2])^2);
                      end if;
                      // Only evaluate the thermal response factors if not already evaluated
                      if Done[i,j] < k then
                        // Evaluate Real and Mirror parts of FLS solution
                        // Real part
                        for m in 1:nSeg loop
                          hSegRea[m] :=
                            IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource(
                            tLon[k + 1],
                            aSoi,
                            dis,
                            hBor/nSeg,
                            dBor,
                            hBor/nSeg,
                            dBor + (m - 1)*hBor/nSeg,
                            includeMirrorSource=false);
                        end for;
                      // Mirror part
                        for m in 1:(2*nSeg-1) loop
                          hSegMir[m] :=
                            IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource(
                            tLon[k + 1],
                            aSoi,
                            dis,
                            hBor/nSeg,
                            dBor,
                            hBor/nSeg,
                            dBor + (m - 1)*hBor/nSeg,
                            includeRealSource=false);
                        end for;
                      // Apply to all pairs that have the same separation distance
                        for m in 1:nBor loop
                          for n in m:nBor loop
                            if m == n then
                              dis_mn := rLin;
                            else
                              dis_mn := sqrt((cooBor[m,1] - cooBor[n,1])^2 + (cooBor[m,2] - cooBor[n,2])^2);
                            end if;
                            if abs(dis_mn - dis) < relTol*dis then
                              // Add thermal response factor to coefficient matrix A
                              for u in 1:nSeg loop
                                for v in 1:nSeg loop
                                  A[(m-1)*nSeg+u,(n-1)*nSeg+v] := hSegRea[abs(u-v)+1] + hSegMir[u+v-1];
                                  A[(n-1)*nSeg+v,(m-1)*nSeg+u] := hSegRea[abs(u-v)+1] + hSegMir[u+v-1];
                                end for;
                              end for;
                              // Mark current pair as evaluated
                              Done[m,n] := k;
                              Done[n,m] := k;
                            end if;
                          end for;
                        end for;
                      end if;
                    end for;
                  end for;
                  // Solve the system of equations
                  X := Modelica.Math.Matrices.solve(A,B);
                  // The g-function is equal to the borehole wall temperature
                  g[nTimSho+k+1] := X[nBor*nSeg+1];
                end for;
                // Correct finite line source solution for cylindrical geometry
                for k in 2:nTimLon loop
                  // Infinite line source
                  ILS := 0.5*
                    IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.infiniteLineSource(
                    tLon[k],
                    aSoi,
                    rLin);
                  // Cylindrical heat source
                  CHS := 2*Modelica.Constants.pi*
                    IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource(
                    tLon[k],
                    aSoi,
                    rBor,
                    rBor);
                  g[nTimSho+k] := g[nTimSho+k] + (CHS - ILS);
                end for;
              annotation (
              Documentation(info="<html>
<p>
This function implements the <i>g</i>-function evaluation method introduced by
Cimmino and Bernier (see: Cimmino and Bernier (2014), and Cimmino (2018)) based
on the <i>g</i>-function function concept first introduced by Eskilson (1987).
The <i>g</i>-function gives the relation between the variation of the borehole
wall temperature at a time <i>t</i> and the heat extraction and injection rates
at all times preceding time <i>t</i> as
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/GFunction_01.png\" />
</p>
<p>
where <i>T<sub>b</sub></i> is the borehole wall temperature,
<i>T<sub>g</sub></i> is the undisturbed ground temperature, <i>Q</i> is the
heat injection rate into the ground through the borehole wall per unit borehole
length, <i>k<sub>s</sub></i> is the soil thermal conductivity and <i>g</i> is
the <i>g</i>-function.
</p>
<p>
The <i>g</i>-function is constructed from the combination of the combination of
the finite line source (FLS) solution (see
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource</a>),
the cylindrical heat source (CHS) solution (see
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource</a>),
and the infinite line source (ILS) solution (see
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.infiniteLineSource\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.infiniteLineSource</a>).
To obtain the <i>g</i>-function of a bore field, each borehole is divided into a
series of <code>nSeg</code> segments of equal length, each modeled as a line
source of finite length. The finite line source solution is superimposed in
space to obtain a system of equations that gives the relation between the heat
injection rate at each of the segments and the borehole wall temperature at each
of the segments. The system is solved to obtain the uniform borehole wall
temperature required at any time to maintain a constant total heat injection
rate (<i>Q<sub>tot</sub> = 2&pi;k<sub>s</sub>H<sub>tot</sub>)</i> into the bore
field. The uniform borehole wall temperature is then equal to the finite line
source based <i>g</i>-function.
</p>
<p>
Since this <i>g</i>-function is based on line sources of heat, rather than
cylinders, the <i>g</i>-function is corrected to consider the cylindrical
geometry. The correction factor is then the difference between the cylindrical
heat source solution and the infinite line source solution, as proposed by
Li et al. (2014) as
</p>
<p align=\"center\">
<i>g(t) = g<sub>FLS</sub> + (g<sub>CHS</sub> - g<sub>ILS</sub>)</i>
</p>
<h4>Implementation</h4>
<p>
The calculation of the <i>g</i>-function is separated into two regions: the
short-time region and the long-time region. In the short-time region,
corresponding to times <i>t</i> &lt; 1 hour, heat interaction between boreholes
and axial variations of heat injection rate are not considered. The
<i>g</i>-function is calculated using only one borehole and one segment. In the
long-time region, corresponding to times <i>t</i> &gt; 1 hour, all boreholes
are represented as series of <code>nSeg</code> line segments and the
<i>g</i>-function is evaluated as described above.
</p>
<h4>References</h4>
<p>
Cimmino, M. and Bernier, M. 2014. <i>A semi-analytical method to generate
g-functions for geothermal bore fields</i>. International Journal of Heat and
Mass Transfer 70: 641-650.
</p>
<p>
Cimmino, M. 2018. <i>Fast calculation of the g-functions of geothermal borehole
fields using similarities in the evaluation of the finite line source
solution</i>. Journal of Building Performance Simulation. DOI:
10.1080/19401493.2017.1423390.
</p>
<p>
Eskilson, P. 1987. <i>Thermal analysis of heat extraction boreholes</i>. Ph.D.
Thesis. Department of Mathematical Physics. University of Lund. Sweden.
</p>
<p>
Li, M., Li, P., Chan, V. and Lai, A.C.K. 2014. <i>Full-scale temperature
response function (G-function) for heat transfer by borehole heat exchangers
(GHEs) from sub-hour to decades</i>. Applied Energy 136: 197-205.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end gFunction;

              function infiniteLineSource
                "Infinite line source model for borehole heat exchangers"
                extends Modelica.Icons.Function;
                input Real t "Time";
                input Real aSoi "Ground thermal diffusivity";
                input Real dis "Radial distance between borehole axes";
                output Real h_ils "Thermal response factor of borehole 1 on borehole 2";
              algorithm
                h_ils := if t > 0.0 then
                            IDEAS.Utilities.Math.Functions.exponentialIntegralE1(dis^2/(4*aSoi*t))
                         else
                            0.0;
              annotation (
              Inline=true,
              Documentation(info="<html>
<p>
This function evaluates the infinite line source solution. This solution gives
the relation between the constant heat transfer rate (per unit length) injected
by a line heat source of infinite length and the temperature raise in the
medium. The infinite line source solution is defined by
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/InfiniteLineSource_01.png\" />
</p>
<p>
where <i>&Delta;T(t,r)</i> is the temperature raise after a time <i>t</i> of
constant heat injection and at a distance <i>r</i> from the line source,
<i>Q'</i> is the heat injection rate per unit length, <i>k<sub>s</sub></i> is
the soil thermal conductivity and <i>h<sub>ILS</sub></i> is the infinite line
source solution.
</p>
<p>
The infinite line source solution is given by the exponential integral
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/Geothermal/Borefields/InfiniteLineSource_02.png\" />
</p>
<p>
where <i>&alpha;<sub>s</sub></i> is the ground thermal diffusivity. The
exponential integral is implemented in
<a href=\"modelica://IDEAS.Utilities.Math.Functions.exponentialIntegralE1\">IDEAS.Utilities.Math.Functions.exponentialIntegralE1</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end infiniteLineSource;

              function shaGFunction
                "Returns a SHA1 encryption of the formatted arguments for the g-function generation"
                extends Modelica.Icons.Function;
                input Integer nBor "Number of boreholes";
                input Modelica.SIunits.Position cooBor[nBor, 2] "Coordinates of boreholes";
                input Modelica.SIunits.Height hBor "Borehole length";
                input Modelica.SIunits.Height dBor "Borehole buried depth";
                input Modelica.SIunits.Radius rBor "Borehole radius";
                input Modelica.SIunits.ThermalDiffusivity aSoi "Ground thermal diffusivity used in g-function evaluation";
                input Integer nSeg "Number of line source segments per borehole";
                input Integer nTimSho "Number of time steps in short time region";
                input Integer nTimLon "Number of time steps in long time region";
                input Real ttsMax "Maximum adimensional time for gfunc calculation";
                output String sha
                "SHA1 encryption of the g-function arguments";
            protected
                String formatStrGen =  "1.3e" "String format for general parameters";
                String formatStrCoo =  ".2f" "String format for coordinate";
              algorithm
                sha := IDEAS.Utilities.Cryptographics.sha(String(nBor, format=formatStrGen));
                sha := IDEAS.Utilities.Cryptographics.sha(sha + String(hBor, format=formatStrGen));
                sha := IDEAS.Utilities.Cryptographics.sha(sha + String(dBor, format=formatStrGen));
                sha := IDEAS.Utilities.Cryptographics.sha(sha + String(rBor, format=formatStrGen));
                sha := IDEAS.Utilities.Cryptographics.sha(sha + String(aSoi, format=formatStrGen));
                sha := IDEAS.Utilities.Cryptographics.sha(sha + String(nSeg, format=formatStrGen));
                sha := IDEAS.Utilities.Cryptographics.sha(sha + String(nTimSho, format=formatStrGen));
                sha := IDEAS.Utilities.Cryptographics.sha(sha + String(nTimLon, format=formatStrGen));
                sha := IDEAS.Utilities.Cryptographics.sha(sha + String(ttsMax, format=formatStrGen));
                for i in 1:nBor loop
                  sha := IDEAS.Utilities.Cryptographics.sha(sha + String(cooBor[i, 1], format=formatStrCoo));
                  sha := IDEAS.Utilities.Cryptographics.sha(sha + String(cooBor[i, 2], format=formatStrCoo));
                end for;
              annotation (
              Inline=false,
              Documentation(info="<html>
<p>
This function returns the SHA1 encryption of its arguments.
</p>
<h4>Implementation</h4>
<p>
Each argument is formatted in exponential notation
with four significant digits, for example <code>1.234e+001</code>, with no spaces or
other separating characters between each argument value.
To prevent too long strings that can cause buffer overflows,
the sha encoding of each argument is computed and added to the next string that
is parsed.
</p>
<p>
The SHA1 encryption is computed using
<a href=\"modelica://IDEAS.Utilities.Cryptographics.sha\">IDEAS.Utilities.Cryptographics.sha</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
September 11, 2018, by Michael Wetter:<br/>
Refactored implementation to avoid buffer overflow.
</li>
<li>
September 11, 2018 by Damien Picard:<br/>
Split long strings into small strings to avoid buffer overflow.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1018\">#1018</a>.
</li>
<li>
June 22, 2018 by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end shaGFunction;

              function timeGeometric "Geometric expansion of time steps"
                extends Modelica.Icons.Function;
                input Modelica.SIunits.Duration dt "Minimum time step";
                input Modelica.SIunits.Time t_max "Maximum value of time";
                input Integer nTim "Number of time values";
                output Real t[nTim] "Time vector";
            protected
                Real r(min=1.) "Expansion rate of time values";
                Real dr "Error on expansion rate evaluation";
              algorithm
                if t_max > nTim*dt then
                  // Determine expansion rate (r)
                  dr := 1e99;
                  r := 2;
                  while abs(dr) > 1e-10 loop
                    dr := (1+t_max/dt*(r-1))^(1/nTim) - r;
                    r := r + dr;
                  end while;
                  // Assign time values
                  for i in 1:nTim-1 loop
                    t[i] := dt*(1-r^i)/(1-r);
                  end for;
                    t[nTim] := t_max;
                else
                  // Number of time values too large for chosen parameters:
                  // Use a constant time step
                  for i in 1:nTim loop
                    t[i] := i*dt;
                  end for;
                end if;
              annotation (
              Documentation(info="<html>
<p>
This function attemps to build a vector of length <code>nTim</code> with a geometric
expansion of the time variable between <code>dt</code> and <code>t_max</code>.
</p>
<p>
If <code>t_max &gt; nTim*dt</code>, then a geometrically expanding vector is built as
</p>
<p align=\"center\">
<i>t = [dt, dt*(1-r<sup>2</sup>)/(1-r), ... , dt*(1-r<sup>n</sup>)/(1-r), ... , t<sub>max</sub>],</i>
</p>
<p>
where <i>r</i> is the geometric expansion factor.
</p>
<p>
If <code>t_max &lt; nTim*dt</code>, then a linearly expanding vector is built as
</p>
<p align=\"center\">
<i>t = [dt, 2*dt, ... , n*dt, ... , <code>nTim</code>*dt]</i>
</p>
</html>",               revisions="<html>
<ul>
<li>
June 28, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end timeGeometric;
            annotation (
            Documentation(info="<html>
<p>
This package contains functions to evaluate temperature response factors used by
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse</a>
to evaluate borehole wall temperatures.
</p>
</html>"));
            end ThermalResponseFactors;
          annotation (Documentation(info="<html>
<p>This package contains models and functions to solve ground heat transfer
around ground heat exchangers. For more information on the model implementation,
see the documentation of
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse\">
IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse</a>.</p>
</html>"));
          end HeatTransfer;

          partial model PartialBorefield
            "Borefield model using single U-tube borehole heat exchanger configuration.Calculates the average fluid temperature T_fts of the borefield for a given (time dependent) load Q_flow"

            extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
              final m_flow_nominal=borFieDat.conDat.mBorFie_flow_nominal);

            extends IDEAS.Fluid.Interfaces.TwoPortFlowResistanceParameters(
              final dp_nominal=borFieDat.conDat.dp_nominal,
              final computeFlowResistance=(borFieDat.conDat.dp_nominal > Modelica.Constants.eps));

            replaceable package Medium =
              Modelica.Media.Interfaces.PartialMedium                            "Medium in the component"
                annotation (choices(
                  choice(redeclare package Medium = IDEAS.Media.Water "Water"),
                  choice(redeclare package Medium =
                      IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                        property_T=293.15,
                        X_a=0.40)
                        "Propylene glycol water, 40% mass fraction")));

            constant Real mSenFac(min=1)=1
              "Factor for scaling the sensible thermal mass of the volume";

            // Assumptions
            parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
              "Type of energy balance: dynamic (3 initialization options) or steady state"
              annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

            // Initialization
            parameter Medium.AbsolutePressure p_start = Medium.p_default
              "Start value of pressure"
              annotation(Dialog(tab = "Initialization"));

            // Simulation parameters
            parameter Modelica.SIunits.Time tLoaAgg=300 "Time resolution of load aggregation";
            parameter Integer nCel(min=1)=5 "Number of cells per aggregation level";
            parameter Integer nSeg(min=1)=10
              "Number of segments to use in vertical discretization of the boreholes";
            parameter Boolean forceGFunCalc = false
              "Set to true to force the thermal response to be calculated at the start instead of checking whether this has been pre-computed"
              annotation (Dialog(tab="Advanced"));

            // General parameters of borefield
            parameter IDEAS.Fluid.Geothermal.Borefields.Data.Borefield.Template borFieDat "Borefield data"
              annotation (Placement(transformation(extent={{-80,-80},{-60,-60}})));

            // Temperature gradient in undisturbed soil
            parameter Modelica.SIunits.Temperature TExt0_start=283.15
              "Initial far field temperature"
              annotation (Dialog(tab="Initialization", group="Soil"));
            parameter Modelica.SIunits.Temperature TExt_start[nSeg]=
              {if z[i] >= z0 then TExt0_start + (z[i] - z0)*dT_dz else TExt0_start for i in 1:nSeg}
              "Temperature of the undisturbed ground"
              annotation (Dialog(tab="Initialization", group="Soil"));

            parameter Modelica.SIunits.Temperature TGro_start[nSeg]=TExt_start
              "Start value of grout temperature"
              annotation (Dialog(tab="Initialization", group="Filling material"));

            parameter Modelica.SIunits.Temperature TFlu_start[nSeg]=TGro_start
              "Start value of fluid temperature"
              annotation (Dialog(tab="Initialization"));

            parameter Modelica.SIunits.Height z0=10
              "Depth below which the temperature gradient starts"
              annotation (Dialog(tab="Initialization", group="Temperature profile"));
            parameter Real dT_dz(final unit="K/m", min=0) = 0.01
              "Vertical temperature gradient of the undisturbed soil for h below z0"
              annotation (Dialog(tab="Initialization", group="Temperature profile"));

            // Dynamics of filling material
            parameter Boolean dynFil=true
              "Set to false to remove the dynamics of the filling material."
              annotation (Dialog(tab="Dynamics"));

            IDEAS.Fluid.BaseClasses.MassFlowRateMultiplier masFloDiv(
              redeclare final package Medium = Medium,
              final k=borFieDat.conDat.nBor) "Division of flow rate"
              annotation (Placement(transformation(extent={{-60,-50},{-80,-30}})));

            IDEAS.Fluid.BaseClasses.MassFlowRateMultiplier masFloMul(
              redeclare final package Medium = Medium,
              final k=borFieDat.conDat.nBor) "Mass flow multiplier"
              annotation (Placement(transformation(extent={{60,-50},{80,-30}})));

            IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse groTemRes(
              final tLoaAgg=tLoaAgg,
              final nCel=nCel,
              final borFieDat=borFieDat,
              final forceGFunCalc=forceGFunCalc)
              "Ground temperature response"
              annotation (Placement(transformation(extent={{20,70},{40,90}})));

            replaceable IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialBorehole borHol constrainedby
            IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialBorehole(
              redeclare final package Medium = Medium,
              final borFieDat=borFieDat,
              final nSeg=nSeg,
              final m_flow_nominal=m_flow_nominal/borFieDat.conDat.nBor,
              final dp_nominal=dp_nominal,
              final allowFlowReversal=allowFlowReversal,
              final m_flow_small=m_flow_small,
              final show_T=show_T,
              final computeFlowResistance=computeFlowResistance,
              final from_dp=from_dp,
              final linearizeFlowResistance=linearizeFlowResistance,
              final deltaM=deltaM,
              final energyDynamics=energyDynamics,
              final p_start=p_start,
              final mSenFac=mSenFac,
              final dynFil=dynFil,
              final TFlu_start=TFlu_start,
              final TGro_start=TGro_start) "Borehole"
              annotation (Placement(transformation(extent={{-10,-50},{10,-30}})));

            Modelica.Blocks.Math.Gain gaiQ_flow(k=borFieDat.conDat.nBor)
              "Gain to multiply the heat extracted by one borehole by the number of boreholes"
              annotation (Placement(transformation(extent={{-20,70},{0,90}})));
        protected
            parameter Modelica.SIunits.Height z[nSeg]={borFieDat.conDat.hBor/nSeg*(i - 0.5) for i in 1:nSeg}
              "Distance from the surface to the considered segment";

            Modelica.Blocks.Sources.Constant TSoiUnd[nSeg](
              k = TExt_start,
              y(each unit="K",
                each displayUnit="degC"))
              "Undisturbed soil temperature"
              annotation (Placement(transformation(extent={{-40,14},{-20,34}})));

            Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor QBorHol[nSeg]
              "Heat flow rate of all segments of the borehole"
              annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                  rotation=90,
                  origin={0,-10})));

            Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature TemBorWal[nSeg]
              "Borewall temperature"
              annotation (Placement(transformation(extent={{40,20},{60,40}})));

            Modelica.Blocks.Math.Add TSoiDis[nSeg](each final k1=1, each final k2=1)
              "Addition of undisturbed soil temperature and change of soil temperature"
              annotation (Placement(transformation(extent={{10,20},{30,40}})));

            Modelica.Blocks.Math.Sum QTotSeg_flow(
              final nin=nSeg,
              final k = ones(nSeg))
              "Total heat flow rate for all segments of this borehole"
              annotation (Placement(transformation(extent={{-60,70},{-40,90}})));

            Modelica.Blocks.Routing.Replicator repDelTBor(final nout=nSeg)
              "Signal replicator for temperature difference of the borehole"
              annotation (Placement(transformation(extent={{60,70},{80,90}})));

          equation
            connect(masFloMul.port_b, port_b)
              annotation (Line(points={{80,-40},{90,-40},{90,0},{100,0}},
                                                               color={0,127,255}));
            connect(masFloDiv.port_b, port_a)
              annotation (Line(points={{-80,-40},{-90,-40},{-90,0},{-100,0}},
                                                          color={0,127,255}));
            connect(masFloDiv.port_a, borHol.port_a)
              annotation (Line(points={{-60,-40},{-10,-40}},     color={0,127,255}));
            connect(borHol.port_b, masFloMul.port_a)
              annotation (Line(points={{10,-40},{60,-40}},    color={0,127,255}));
            connect(QBorHol.port_a, borHol.port_wall)
              annotation (Line(points={{-4.44089e-16,-20},{0,-20},{0,-30}},
                                                                  color={191,0,0}));
            connect(QBorHol.Q_flow, QTotSeg_flow.u)
              annotation (Line(points={{-10,-10},{-86,-10},{-86,80},{-62,80}},
                                                                    color={0,0,127}));
            connect(groTemRes.delTBor, repDelTBor.u)
              annotation (Line(points={{41,80},{58,80}}, color={0,0,127}));
            connect(TSoiDis.u1, repDelTBor.y) annotation (Line(points={{8,36},{0,36},{0,
                    60},{90,60},{90,80},{81,80}},
                                  color={0,0,127}));
            connect(TSoiDis.u2, TSoiUnd.y) annotation (Line(points={{8,24},{-19,24}},
                                   color={0,0,127}));
            connect(QTotSeg_flow.y, gaiQ_flow.u)
              annotation (Line(points={{-39,80},{-22,80}}, color={0,0,127}));
            connect(gaiQ_flow.y, groTemRes.QBor_flow)
              annotation (Line(points={{1,80},{19,80}}, color={0,0,127}));
            connect(TSoiDis.y, TemBorWal.T)
              annotation (Line(points={{31,30},{38,30}}, color={0,0,127}));
            connect(QBorHol.port_b, TemBorWal.port) annotation (Line(points={{6.66134e-16,
                    0},{0,0},{0,10},{80,10},{80,30},{60,30}}, color={191,0,0}));
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-100,60},{100,-66}},
                    lineColor={0,0,0},
                    fillColor={234,210,210},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-88,-6},{-32,-62}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-82,-12},{-38,-56}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-88,54},{-32,-2}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-82,48},{-38,4}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-26,54},{30,-2}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-20,48},{24,4}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-28,-6},{28,-62}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-22,-12},{22,-56}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{36,56},{92,0}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{42,50},{86,6}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{38,-4},{94,-60}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{44,-10},{88,-54}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward)}),
              Diagram(graphics,
                      coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})),Documentation(info="<html>
<p>
This model simulates a borefield containing one or multiple boreholes
using the parameters in the <code>borFieDat</code> record.
</p>
<p>
Heat transfer to the soil is modeled using only one borehole heat exchanger
(To be added in an extended model). The
fluid mass flow rate into the borehole is divided to reflect the per-borehole
fluid mass flow rate. The borehole model calculates the dynamics within the
borehole itself using an axial discretization and a resistance-capacitance
network for the internal thermal resistances between the individual pipes and
between each pipe and the borehole wall.
</p>
<p>
The thermal interaction between the borehole wall and the surrounding soil
is modeled using <a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse\">IDEAS.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse</a>,
which uses a cell-shifting load aggregation technique to calculate the borehole wall
temperature after calculating and/or read (from a previous calculation) the borefield's thermal response factor.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice to water and glycolWater.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 2018, by Alex Laferri&egrave;re:<br/>
Changed into a partial model and changed documentation to reflect the new approach
used by the borefield models.
</li>
<li>
July 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PartialBorefield;
        annotation (Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.HeatExchangers.Ground\">IDEAS.Fluid.HeatExchangers.Ground</a>.
</p>
</html>"));
        end BaseClasses;

        package Data
        "Collection of data records for ground heat exchanger models"
        extends Modelica.Icons.MaterialPropertiesPackage;

          package Borefield "Collection of borefield data records"
            extends Modelica.Icons.MaterialPropertiesPackage;

            record Example
              "Example definition of a borefield data record"
              extends IDEAS.Fluid.Geothermal.Borefields.Data.Borefield.Template(
                  filDat=IDEAS.Fluid.Geothermal.Borefields.Data.Filling.Bentonite(),
                  soiDat=IDEAS.Fluid.Geothermal.Borefields.Data.Soil.SandStone(),
                  conDat=IDEAS.Fluid.Geothermal.Borefields.Data.Configuration.Example());
              annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="borFieDat",
            Documentation(
            info="<html>
<p>This record presents an example on how to define borefield records
using the template in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.Data.Borefield.Template\">
IDEAS.Fluid.Geothermal.Borefields.Data.Borefield.Template</a>.</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Example;

            record Template
              "Template for borefield data records"
              extends Modelica.Icons.Record;
              parameter IDEAS.Fluid.Geothermal.Borefields.Data.Filling.Template filDat
                "Filling data";
              parameter IDEAS.Fluid.Geothermal.Borefields.Data.Soil.Template soiDat
                "Soil data";
              parameter IDEAS.Fluid.Geothermal.Borefields.Data.Configuration.Template conDat
                "Configuration data";
              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="borFieDat",
            Documentation(
            info="<html>
<p>
This record is a template for the records in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.Data.Borefield\">
IDEAS.Fluid.Geothermal.Borefields.Data.Borefield</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Template;
          annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IDEAS.Fluid.HeatExchangers.Ground\">
IDEAS.Fluid.HeatExchangers.Ground</a>.
The borefield data records
contain one of the
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.Data.Configuration\">
IDEAS.Fluid.Geothermal.Borefields.Data.Configuration</a> records, one of the
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.Data.Filling\">
IDEAS.Fluid.Geothermal.Borefields.Data.Filling</a> records, and one of the
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.Data.Soil\">
IDEAS.Fluid.Geothermal.Borefields.Data.Soil</a> records.
</p>
</html>"));
          end Borefield;

          package Configuration
          "Collection of records of configuration data of borefields"
            extends Modelica.Icons.MaterialPropertiesPackage;

            record Example
              "Example definition of a configuration data record"
              extends
              IDEAS.Fluid.Geothermal.Borefields.Data.Configuration.Template(
                  borCon = Types.BoreholeConfiguration.SingleUTube,
                  cooBor={{0,0},{0,6},{6,0},{6,6}},
                  mBor_flow_nominal=0.3,
                  dp_nominal=5e4,
                  hBor=100.0,
                  rBor=0.075,
                  dBor=1.0,
                  rTub=0.02,
                  kTub=0.5,
                  eTub=0.002,
                  xC=0.05);
              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="conDat",
                Documentation(
            info="<html>
<p>
This record presents an example for how to define configuration data records
using the template in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.Data.Configuration.Template\">
IDEAS.Fluid.Geothermal.Borefields.Data.Configuration.Template</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Example;

            record Template
              "Template for configuration data records"
              extends Modelica.Icons.Record;
              parameter IDEAS.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration borCon
                "Borehole configuration";
              parameter Boolean use_Rb = false
                "true if the value borehole thermal resistance Rb should be given and used";
              parameter Real Rb(unit="(m.K)/W") = 0.0
                "Borehole thermal resistance Rb. Only to fill in if known"
                annotation(Dialog(enable=use_Rb));
              parameter Modelica.SIunits.MassFlowRate mBor_flow_nominal
                "Nominal mass flow rate per borehole"
                annotation (Dialog(group="Nominal condition"));
              parameter Modelica.SIunits.MassFlowRate mBorFie_flow_nominal = mBor_flow_nominal*nBor
                "Nominal mass flow of borefield"
                annotation (Dialog(group="Nominal condition"));
              parameter Modelica.SIunits.Pressure dp_nominal(displayUnit="Pa")
                "Pressure losses for the entire borefield"
                annotation (Dialog(group="Nominal condition"));
              //------------------------- Geometrical parameters ---------------------------
              parameter Modelica.SIunits.Height hBor "Total height of the borehole"
                annotation (Dialog(group="Borehole"));
              parameter Modelica.SIunits.Radius rBor "Radius of the borehole"
                annotation (Dialog(group="Borehole"));
              parameter Modelica.SIunits.Height dBor "Borehole buried depth"
                annotation (Dialog(group="Borehole"));
              parameter Integer nBor = size(cooBor, 1) "Total number of boreholes"
                annotation (Dialog(group="Borehole"));
              parameter Modelica.SIunits.Length[:,2] cooBor
                "Cartesian coordinates of the boreholes in meters"
                annotation (Dialog(group="Borehole"));
              // -- Tube
              parameter Modelica.SIunits.Radius rTub "Outer radius of the tubes"
                annotation (Dialog(group="Tubes"));
              parameter Modelica.SIunits.ThermalConductivity kTub "Thermal conductivity of the tube"
                annotation (Dialog(group="Tubes"));
              parameter Modelica.SIunits.Length eTub "Thickness of a tube"
                annotation (Dialog(group="Tubes"));
              parameter Modelica.SIunits.Length xC
                "Shank spacing, defined as the distance between the center of a pipe and the center of the borehole"
                annotation (Dialog(group="Tubes"));
              //------------------------- Advanced parameters ------------------------------
              /*--------Flow: */
              parameter Modelica.SIunits.MassFlowRate mBor_flow_small(min=0) = 1E-4*abs(mBor_flow_nominal)
                "Small mass flow rate for regularization of zero flow"
                annotation (Dialog(tab="Advanced"));
              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="conDat",
                Documentation(
            info="<html>
<p>
This record is a template for the records in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.Data.Configuration\">
IDEAS.Fluid.Geothermal.Borefields.Data.Configuration</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Template;
          annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IDEAS.Fluid.HeatExchangers.Ground\">
IDEAS.Fluid.HeatExchangers.Ground</a>. The configuration data
records contain the geometrical and operational characteristics of the borefield
and the boreholes.
</p>
</html>"));
          end Configuration;

          package Filling "Collection of records of filling data"
            extends Modelica.Icons.MaterialPropertiesPackage;

            record Bentonite
              "Filling data record of Bentonite heat transfer properties"
              extends IDEAS.Fluid.Geothermal.Borefields.Data.Filling.Template(
                  kFil=1.15,
                  dFil=1600,
                  cFil=800);
              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="filDat",
            Documentation(
            info="<html>
<p>
This filling data record contains the heat transfer properties of bentonite.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Bentonite;

            record Template
              "Template for filling data records"
              extends Modelica.Icons.Record;
              parameter Modelica.SIunits.ThermalConductivity kFil
                "Thermal conductivity of the borehole filling material";
              parameter Modelica.SIunits.SpecificHeatCapacity cFil
                "Specific heat capacity of the borehole filling material";
              parameter Modelica.SIunits.Density dFil(displayUnit="kg/m3")
                "Density of the borehole filling material";
              parameter Boolean steadyState = (cFil < Modelica.Constants.eps or dFil < Modelica.Constants.eps)
                "Flag, if true, then material is computed using steady-state heat conduction"
                annotation(Evaluate=true);
              final parameter Modelica.SIunits.ThermalDiffusivity aFil = kFil/(dFil*cFil)
                "Heat diffusion coefficient of the borehole filling material";
              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="filDat",
            Documentation(
            info="<html>
<p>This record is a template for the records in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.Data.Filling\">
IDEAS.Fluid.Geothermal.Borefields.Data.Filling</a>.</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
Corrected check of real variable against zero which is not allowed in Modelica.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Template;
          annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IDEAS.Fluid.HeatExchangers.Ground\">
IDEAS.Fluid.HeatExchangers.Ground</a>. The filling data
records contain the heat transfer properties of the borehole filling material.
</p>
</html>"));
          end Filling;

          package Soil "Collection of records of soil data"
            extends Modelica.Icons.MaterialPropertiesPackage;

            record SandStone
              "Soil data record of sandstone heat transfer properties"
              extends IDEAS.Fluid.Geothermal.Borefields.Data.Soil.Template(
                kSoi=2.5,
                dSoi=1800,
                cSoi=1200);
              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="soiDat",
            Documentation(
            info="<html>
<p>
This soil data record contains the heat transfer properties of sandstone.
</p>
</html>",   revisions="<html>
<ul>
<li>
December 21, 2018, by Jianjun Hu:<br/>
Changed the default properties based on Table 4 in the
<a href=\"http://www.15000inc.com/wp/wp-content/uploads/Geothermal-Heat-Pump-Design-Manual.pdf\">
McQuay geothermal heat pump design manual</a>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1062\">#1062</a>.
</li>

<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end SandStone;

            record Template
              "Template for soil data records"
              extends Modelica.Icons.Record;
              parameter Modelica.SIunits.ThermalConductivity kSoi
                "Thermal conductivity of the soil material";
              parameter Modelica.SIunits.SpecificHeatCapacity cSoi
                "Specific heat capacity of the soil material";
              parameter Modelica.SIunits.Density dSoi(displayUnit="kg/m3")
                "Density of the soil material";
              parameter Boolean steadyState = (cSoi < Modelica.Constants.eps or dSoi < Modelica.Constants.eps)
                "Flag, if true, then material is computed using steady-state heat conduction"
                annotation(Evaluate=true);
              final parameter Modelica.SIunits.ThermalDiffusivity aSoi=kSoi/(dSoi*cSoi)
                "Heat diffusion coefficient of the soil material";
              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="soiDat",
            Documentation(
            info="<html>
<p>
This record is a template for the records in
<a href=\"modelica://IDEAS.Fluid.Geothermal.Borefields.Data.Soil\">
IDEAS.Fluid.Geothermal.Borefields.Data.Soil</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
Corrected check of real variable against zero which is not allowed in Modelica.
</li>
<li>
June28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Template;
          annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IDEAS.Fluid.HeatExchangers.Ground\">
IDEAS.Fluid.HeatExchangers.Ground</a>. The soil data
records contain the heat transfer properties of soil materials.
</p>
</html>"));
          end Soil;
        annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IDEAS.Fluid.HeatExchangers.Ground\">
IDEAS.Fluid.HeatExchangers.Ground</a>.
</p>
</html>"));
        end Data;

        model OneUTube
          "Borefield model containing single U-tube boreholes"
          extends
          IDEAS.Fluid.Geothermal.Borefields.BaseClasses.PartialBorefield(
            redeclare IDEAS.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.OneUTube borHol);
          annotation (
          defaultComponentName="borFie",
          Documentation(info="<html>
<p>
This model simulates a borefield containing one or many single U-tube boreholes
using the parameters in the <code>borFieDat</code> record.
</p>
<p>
Heat transfer to the soil is modeled using only one borehole heat exchanger. The
fluid mass flow rate into the borehole is divided to reflect the per-borehole
fluid mass flow rate. The borehole model calculates the dynamics within the
borehole itself using an axial discretization and a resistance-capacitance
network for the internal thermal resistances between the individual pipes and
between each pipe and the borehole wall.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 2018, by Alex Laferri&egrave;re:<br/>
Extended partial model and changed documentation to reflect the new approach
used by the borefield models.
</li>
<li>
July 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
        end OneUTube;

        package Types "Package with type definitions"
          extends Modelica.Icons.TypesPackage;

          type BoreholeConfiguration = enumeration(
            SingleUTube
            "Single U-tube configuration",
            DoubleUTubeParallel
            "Double U-tube configuration with pipes connected in parallel",
            DoubleUTubeSeries
            "Double U-tube configuration with pipes connected in series")
          "Enumaration to define the borehole configurations"
          annotation (Documentation(info="<html>
<p>
Enumeration that defines the pipe configuration in the borehole.
</p>
<p>
The following pipe configurations are available in this enumeration:
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Enumeration</th><th>Description</th></tr>
<tr><td>SingleUTube</td><td>Single U-tube configuration</td></tr>

<tr><td>DoubleUTubeParallel</td><td>Double U-tube configuration with pipes connected in parallel</td></tr>
<tr><td>DoubleUTubeSeries</td><td>Double U-tube configuration with pipes connected in series</td></tr>
</table>
</html>", revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          annotation (preferredView="info", Documentation(info="<html>
 <p>
 This package contains type definitions.
 </p>
 </html>"));
        end Types;
      annotation (preferredView="info", Documentation(info="<html>
<p>
Package with models for geothermal borefields.
</p>
</html>"));
      end Borefields;
    annotation (preferredView="info", Documentation(info="<html>
<p>
Package with models for geothermal heat exchange.
</p>
</html>"));
    end Geothermal;

    package HeatExchangers "Package with heat exchanger models"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Package with base classes for IDEAS.Fluid.HeatExchangers"
        extends Modelica.Icons.BasesPackage;

        function epsilon_ntuZ
          "Computes heat exchanger effectiveness for given number of transfer units and heat exchanger flow regime"
          import f = IDEAS.Fluid.Types.HeatExchangerFlowRegime;
          input Real NTU "Number of transfer units";
          input Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
          input Integer flowRegime
            "Heat exchanger flow regime, see  IDEAS.Fluid.Types.HeatExchangerFlowRegime";
          output Real eps(min=0, max=1) "Heat exchanger effectiveness";
      protected
          Real a "Auxiliary variable";
        algorithm
          if (flowRegime == Integer(f.ParallelFlow)) then // parallel flow
            a := 0;
            eps := (1 - Modelica.Math.exp(-NTU*(1 + Z)))/(1 + Z);
          elseif (flowRegime == Integer(f.CounterFlow)) then// counter flow
           // a is constraining Z since eps is not defined for Z=1.
            a := smooth(1, if Z < 0.97 then Z else
              IDEAS.Utilities.Math.Functions.smoothMin(
              x1=Z,
              x2=0.98,
              deltaX=0.01));
            eps := (1 - Modelica.Math.exp(-NTU*(1 - a)))/(1 - a*Modelica.Math.exp(-NTU*(
              1 - a)));
          elseif (flowRegime == Integer(f.CrossFlowUnmixed)) then
           a := NTU^(-0.22);
            eps := 1 - Modelica.Math.exp( ( Modelica.Math.exp( - NTU * Z * a)  - 1)  / (Z * a));
          elseif (flowRegime == Integer(f.CrossFlowCMinUnmixedCMaxMixed)) then
            // cross flow, (single pass), CMax mixed, CMin unmixed. (Coil with one row.)
            a := 0;
            eps := (1 - Modelica.Math.exp(-Z*(1 - Modelica.Math.exp(-NTU))))/Z;
          elseif (flowRegime == Integer(f.CrossFlowCMinMixedCMaxUnmixed)) then
            // cross flow, (single pass), CMin mixed, CMax unmixed.
            a := 0;
            eps := 1 - Modelica.Math.exp(-(1 - Modelica.Math.exp(-Z*NTU))/Z);
          elseif (flowRegime == Integer(f.ConstantTemperaturePhaseChange)) then
            // one side is experiencing constant temperature phase change
            // Z is unused
            a := 0;
            eps := 1 - Modelica.Math.exp(-NTU);
          else
            a := 0;
            eps := 0;
            assert(Integer(f.ParallelFlow) <= flowRegime and
                   flowRegime <= Integer(f.ConstantTemperaturePhaseChange),
                   "Flow regime is not implemented.");
          end if;
          annotation(preferredView="info",
                     inverse(NTU=IDEAS.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(eps=eps, Z=Z, flowRegime=flowRegime)),
                   smoothOrder=1,
                   Documentation(info="<html>
<p>
This function computes the heat exchanger effectiveness for a given number of transfer units, capacity flow ratio and heat exchanger flow regime.
The different options for the flow regime are declared in
<a href=\"modelica://IDEAS.Fluid.Types.HeatExchangerFlowRegime\">
IDEAS.Fluid.Types.HeatExchangerFlowRegime</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 28, 2016, by Massimo Cimmino:<br/>
Added case for constant temperature phase change on one side of
the heat exchanger.
</li>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>IDEAS.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
This was required because this argument is passed in Dymola 2015 in the function
<a href=\"modelica://IDEAS.Fluid.HeatExchangers.BaseClasses.epsilon_C\">
IDEAS.Fluid.HeatExchangers.BaseClasses.epsilon_C</a>
as an integer. Without this change, a translation warning occurs.
</li>
<li>
September 25, 2013, by Michael Wetter:<br/>
Changed test in the <code>assert</code> statement as OpenModelica
had an error when comparing enumerations with integers.
</li>
<li>
February 11, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end epsilon_ntuZ;

        package Internal "Solve f(x, data) for x with given f"
          extends Modelica.Media.Common.OneNonLinearEquation;

          redeclare function extends f_nonlinear
          algorithm
          assert(x>0, "NTU needs to be strictly positive.
Received NTU = "         + String(x) + "
         Z   = "         + String(p));
            y := IDEAS.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(
                NTU=x,
                Z=p,
                flowRegime=Integer(IDEAS.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed));
          end f_nonlinear;
        annotation (
        Documentation(
        info="<html>
<p>
Function that internally solves a scalar equation.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>IDEAS.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
</li>
<li>
August 10, 2011, by Michael Wetter:
<ul>
<li>
Changed implementation to use
<code>Modelica.Media.Common.OneNonLinearEquation</code> instead of
<code>Buildings.Utilities.Math.BaseClasses.OneNonLinearEquation</code>.
</li>
<li>
Added assert statement as <code>epsilon_ntuZ</code> computes <code>NTU^(-0.22)</code>.
</li>
</ul>
</li>
<li>
February 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Internal;

        function ntu_epsilonZ
          "Computes number of transfer units for given heat exchanger effectiveness and heat exchanger flow regime"
          import f = IDEAS.Fluid.Types.HeatExchangerFlowRegime;
          input Real eps(min=0, max=0.999) "Heat exchanger effectiveness";
          input Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
          input Integer flowRegime
            "Heat exchanger flow regime";
          output Real NTU "Number of transfer units";
      protected
          Real a "Auxiliary variable";
          constant Modelica.Media.Common.OneNonLinearEquation.f_nonlinear_Data dummy
            "Dummy data for nonlinear function call";
        algorithm
          if (flowRegime == Integer(f.ParallelFlow)) then // parallel flow
            a := Z+1;
            assert(eps < 1/a,
              "Invalid input data. eps > 1/(1+Z) is physically not possible for parallel flow.
  Received eps = "         + String(eps) + "
             Z = "         + String(Z) + "
       1/(Z+1) = "         + String(1/a));
            NTU := -(Modelica.Math.log(1-eps*a))/(a);
          elseif (flowRegime == Integer(f.CounterFlow)) then// counter flow
           // a is constraining Z since eps is not defined for Z=1.
            a := smooth(1, if Z < 0.97 then Z else
              IDEAS.Utilities.Math.Functions.smoothMin(
              x1=Z,
              x2=0.98,
              deltaX=0.01));
            NTU := Modelica.Math.log((1-eps)/(1-eps*a)) / (a-1);
          elseif (flowRegime == Integer(f.CrossFlowUnmixed)) then
            a := 0;
            // The function Internal.solve evaluates epsilon_ntuZ at NTU=x_min-1e-10 and NTU=x_max+1e-10
            // when it solves iteratively epsilon_ntuZ for ntu
            // Therefore, we set x_min=1.5*1e-10 to prevent computing NTU^(-0.22)=(-1e-10)^(-0.22).
            NTU := IDEAS.Fluid.HeatExchangers.BaseClasses.Internal.solve(
              y_zero=eps,
              x_min=1.5*1e-10,
              x_max=1E6,
              pressure=Z,
              f_nonlinear_data=dummy);
          elseif (flowRegime == Integer(f.CrossFlowCMinUnmixedCMaxMixed)) then
            // cross flow, (single pass), CMax mixed, CMin unmixed. (Coil with one row.)
           a := smooth(1, if Z > 0.03 then Z else
              IDEAS.Utilities.Math.Functions.smoothMin(
              x1=0.02,
              x2=Z,
              deltaX=0.01));
            NTU := -Modelica.Math.log(1+(Modelica.Math.log(1-eps*a)/a));
          elseif (flowRegime == Integer(f.CrossFlowCMinMixedCMaxUnmixed)) then
            // cross flow, (single pass), CMin mixed, CMax unmixed.
           a := smooth(1, if Z > 0.03 then Z else
              IDEAS.Utilities.Math.Functions.smoothMin(
              x1=0.02,
              x2=Z,
              deltaX=0.01));
            NTU := -Modelica.Math.log(1+Z*Modelica.Math.log(1-eps))/Z;
          elseif (flowRegime == Integer(f.ConstantTemperaturePhaseChange)) then
            // one side is experiencing constant temperature phase change
            // Z is unused
            a := 0;
            NTU := -Modelica.Math.log((1-eps));
          else
            a := 0;
            NTU := 0;
            assert(Integer(f.ParallelFlow) <= flowRegime and
                   flowRegime <= Integer(f.ConstantTemperaturePhaseChange),
                   "Flow regime is not implemented.");
          end if;
          annotation (preferredView="info",
                     inverse(eps=IDEAS.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(NTU=NTU, Z=Z, flowRegime=flowRegime)),
                   smoothOrder=1,
        Documentation(info="<html>
<p>
This function computes the number of transfer units for a given heat exchanger effectiveness,
capacity flow ratio and heat exchanger flow regime.
The different options for the flow regime are declared in
<a href=\"modelica://IDEAS.Fluid.Types.HeatExchangerFlowRegime\">
IDEAS.Fluid.Types.HeatExchangerFlowRegime</a>.
</p>
<p>
Note that for the flow regime <code>CrossFlowUnmixed</code>, computing the
function requires the numerical solution of an equation in one variable.
This is handled internally and not exposed to the global solver.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 28, 2016, by Massimo Cimmino:<br/>
Added case for constant temperature phase change on one side of
the heat exchanger.
</li>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>IDEAS.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
This was done to have the same argument list as
<a href=\"modelica://IDEAS.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ\">
IDEAS.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ</a>,
in which the type had to be changed.
</li>
<li>
April 29, 2013, by Michael Wetter:<br/>
Added dummy argument to function call of <code>Internal.solve</code>
to avoid a warning during model check in Dymola 2015.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Changed implementation to use
<code>Modelica.Media.Common.OneNonLinearEquation</code> instead of
<code>Buildings.Utilities.Math.BaseClasses.OneNonLinearEquation</code>.
</li>
<li>
February 11, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ntu_epsilonZ;

        partial model PartialEffectiveness
          "Partial model to implement heat exchangers based on effectiveness model"
          extends Fluid.Interfaces.StaticFourPortHeatMassExchanger(
            prescribedHeatFlowRate1=true,
            prescribedHeatFlowRate2=true,
            show_T=false);

          Medium1.Temperature T_in1 = if allowFlowReversal1 then
            fra_a1 * Medium1.temperature(state_a1_inflow) + fra_b1 * Medium1.temperature(state_b1_inflow) else
            Medium1.temperature(state_a1_inflow)
            "Inlet temperature medium 1";
          Medium2.Temperature T_in2 = if allowFlowReversal2 then
            fra_a2 * Medium2.temperature(state_a2_inflow) + fra_b2 * Medium2.temperature(state_b2_inflow) else
            Medium2.temperature(state_a2_inflow)
            "Inlet temperature medium 2";
          Modelica.SIunits.ThermalConductance C1_flow = abs(m1_flow)*
            ( if allowFlowReversal1 then
                   fra_a1 * Medium1.specificHeatCapacityCp(state_a1_inflow) +
                   fra_b1 * Medium1.specificHeatCapacityCp(state_b1_inflow) else
                Medium1.specificHeatCapacityCp(state_a1_inflow))
            "Heat capacity flow rate medium 1";
          Modelica.SIunits.ThermalConductance C2_flow = abs(m2_flow)*
            ( if allowFlowReversal2 then
                   fra_a2 * Medium2.specificHeatCapacityCp(state_a2_inflow) +
                   fra_b2 * Medium2.specificHeatCapacityCp(state_b2_inflow) else
                Medium2.specificHeatCapacityCp(state_a2_inflow))
            "Heat capacity flow rate medium 2";
          Modelica.SIunits.ThermalConductance CMin_flow(min=0) = min(C1_flow, C2_flow)
            "Minimum heat capacity flow rate";
          Modelica.SIunits.HeatFlowRate QMax_flow = CMin_flow*(T_in2 - T_in1)
            "Maximum heat flow rate into medium 1";
      protected
          parameter Real delta=1E-3 "Parameter used for smoothing";

          parameter Modelica.SIunits.SpecificHeatCapacity cp1_default(fixed=false)
            "Specific heat capacity of medium 1 at default medium state";
          parameter Modelica.SIunits.SpecificHeatCapacity cp2_default(fixed=false)
            "Specific heat capacity of medium 2 at default medium state";
          parameter Modelica.SIunits.ThermalConductance CMin_flow_small(fixed=false)
            "Small value for smoothing of minimum heat capacity flow rate";
          Real fra_a1(min=0, max=1) = if allowFlowReversal1
            then Modelica.Fluid.Utilities.regStep(
              m1_flow,
              1,
              0,
              m1_flow_small)
            else 1
            "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b1(min=0, max=1) = if allowFlowReversal1
            then 1-fra_a1
            else 0
            "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
          Real fra_a2(min=0, max=1) = if allowFlowReversal2
            then Modelica.Fluid.Utilities.regStep(
              m2_flow,
              1,
              0,
              m2_flow_small)
            else 1
            "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b2(min=0, max=1) = if allowFlowReversal2
            then 1-fra_a2
            else 0
            "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
        initial equation
          cp1_default = Medium1.specificHeatCapacityCp(Medium1.setState_pTX(
            Medium1.p_default,
            Medium1.T_default,
            Medium1.X_default));
          cp2_default = Medium2.specificHeatCapacityCp(Medium2.setState_pTX(
            Medium2.p_default,
            Medium2.T_default,
            Medium2.X_default));
          CMin_flow_small = min(m1_flow_small*cp1_default, m2_flow_small*cp2_default);

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-70,78},{70,-80}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Partial model to implement heat exchanger models.
</p>
<p>
Classes that extend this model need to implement heat and
mass balance equations in a form like
</p>
<pre>
  // transferred heat
  Q1_flow = eps * QMax_flow;
  // no heat loss to ambient
  0 = Q1_flow + Q2_flow;
  // no mass exchange
  mXi1_flow = zeros(Medium1.nXi);
  mXi2_flow = zeros(Medium2.nXi);
</pre>
<p>
Thus, if medium 1 is heated in this device, then <code>Q1_flow &gt; 0</code>
and <code>QMax_flow &gt; 0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 21, 2019, by Filip Jorissen:<br/>
Revised implementation of all equations
such that a binding equation is used. 
I.e. we set the variable value at the variable definition
instead of using the equation section.
This allows overwriting the equation
when extending the model.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1102\">#1102</a>.
</li>
<li>
April 30, 2018, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate1=true</code> and 
<code>prescribedHeatFlowRate2=true</code>.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/907\">#907</a>.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Changed type of <code>T_in1</code> and <code>T_in2</code>
to <code>Medium1.Temperature</code> and <code>Medium2.Temperature</code>
to avoid an error because of conflicting start values if
<a href=\"modelica://IDEAS.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl\">
Buildings.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl</a>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
October 8, 2011, by Michael Wetter:<br/>
Set <code>show_T=false</code> to avoid state events near zero flow.
</li>
<li>
August 31, 2011, by Michael Wetter:<br/>
Removed unused variables <code>gai1</code> and <code>gai2</code>.
</li>
<li>
February 12, 2010, by Michael Wetter:<br/>
Changed model structure to implement effectiveness-NTU model.
</li>
<li>
January 28, 2010, by Michael Wetter:<br/>
Added regularization near zero flow.
</li>
<li>
October 2, 2009, by Michael Wetter:<br/>
Changed computation of inlet temperatures to use
<code>state_*_inflow</code> which is already known in base class.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialEffectiveness;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.HeatExchangers\">IDEAS.Fluid.HeatExchangers</a>.
</p>
</html>"));
      end BaseClasses;

      model ConstantEffectiveness "Heat exchanger with constant effectiveness"
        extends IDEAS.Fluid.HeatExchangers.BaseClasses.PartialEffectiveness(
          sensibleOnly1 = true,
          sensibleOnly2 = true,
          final prescribedHeatFlowRate1=true,
          final prescribedHeatFlowRate2=true,
          Q1_flow = eps * QMax_flow,
          Q2_flow = -Q1_flow,
          mWat1_flow = 0,
          mWat2_flow = 0);
        parameter Modelica.SIunits.Efficiency eps(max=1) = 0.8
          "Heat exchanger effectiveness";
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-70,78},{70,-82}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid), Text(
                extent={{-56,-12},{54,-72}},
                lineColor={255,255,255},
                textString="eps=%eps")}),
                preferredView="info",
      defaultComponentName="hex",
      Documentation(info="<html>
<p>
Model for a heat exchanger with constant effectiveness.
</p>
<p>
This model transfers heat in the amount of
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q = Q<sub>max</sub> &epsilon;,
</p>
<p>
where <i>&epsilon;</i> is a constant effectiveness and
<i>Q<sub>max</sub></i> is the maximum heat that can be transferred.
</p>
<p>
For a heat and moisture exchanger, use
<a href=\"modelica://IDEAS.Fluid.MassExchangers.ConstantEffectiveness\">
IDEAS.Fluid.MassExchangers.ConstantEffectiveness</a>
instead of this model.
</p>
</html>",
      revisions="<html>
<ul>
<li>
August 13, 2013 by Michael Wetter:<br/>
Corrected error in the documentation.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Updated model to use new variable <code>mWat_flow</code>
in the base class.
</li>
<li>
January 28, 2010, by Michael Wetter:<br/>
Added regularization near zero flow.
</li>
<li>
October 2, 2009, by Michael Wetter:<br/>
Changed computation of inlet temperatures to use
<code>state_*_inflow</code> which is already known in base class.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ConstantEffectiveness;

      model EvaporatorCondenser
        "Evaporator or condenser with refrigerant experiencing constant temperature phase change"
        extends IDEAS.Fluid.Interfaces.TwoPortHeatMassExchanger(redeclare final
            IDEAS.Fluid.MixingVolumes.MixingVolume vol(final
              prescribedHeatFlowRate=false));
        parameter Modelica.SIunits.ThermalConductance UA
          "Thermal conductance of heat exchanger";
        parameter Modelica.SIunits.ThermalConductance UA_small=UA/10
          "Small thermal conductance for regularisation of heat transfer "
          annotation(Dialog(tab = "Advanced"));
        Modelica.Blocks.Interfaces.RealOutput Q_flow(unit="W")
          "Heat added to the fluid"
          annotation (Placement(transformation(extent={{100,30},{120,50}})));
        Modelica.Blocks.Interfaces.RealOutput T(unit="K") "Medium temperature"
          annotation (Placement(transformation(extent={{100,70},{120,90}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_ref
          "Temperature and heat flow from the refrigerant"
          annotation (Placement(transformation(extent={{-5,-55},{5,-65}}),
              iconTransformation(extent={{-5,-55},{5,-65}})));
        Modelica.SIunits.Efficiency NTU = UA /
          (IDEAS.Utilities.Math.Functions.smoothMax(abs(port_a.m_flow),m_flow_small,m_flow_small)*cp_default)
         "Number of transfer units of heat exchanger";
        Modelica.SIunits.Efficiency eps=
          IDEAS.Utilities.Math.Functions.smoothMin(
            IDEAS.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(
            NTU,
            0,
            Integer(IDEAS.Fluid.Types.HeatExchangerFlowRegime.ConstantTemperaturePhaseChange)),
            0.999,
            1.0e-4)
          "Effectiveness of heat exchanger";
        Modelica.Blocks.Sources.RealExpression UAeff(
          final y=IDEAS.Utilities.Math.Functions.smoothMax(
            x1=UA,
            x2=eps*cp_default*abs(port_a.m_flow)/(1 - eps),
            deltaX=UA_small))
          "Effective heat transfer coefficient"
          annotation (Placement(transformation(extent={{-88,-80},{-68,-60}})));
    protected
        parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
          Medium.specificHeatCapacityCp(sta_default)
           "Density, used to compute fluid volume";
        Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFlo
          "Heat flow sensor"
          annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-36,-40})));
        Modelica.Thermal.HeatTransfer.Components.Convection con
          "Convective heat transfer"
          annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-36,-70})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor senTem
          "Temperature sensor"
          annotation (Placement(transformation(extent={{0,20},{20,40}})));
      equation
        connect(heaFlo.port_b, vol.heatPort) annotation (Line(points={{-36,-30},{-36,
                -30},{-36,-10},{-9,-10}}, color={191,0,0}));
        connect(heaFlo.Q_flow, Q_flow) annotation (Line(points={{-26,-40},{-20,-40},{
                60,-40},{60,40},{110,40}}, color={0,0,127}));
        connect(port_ref, con.solid) annotation (Line(points={{0,-60},{0,-90},{-36,-90},
                {-36,-80}}, color={191,0,0}));
        connect(con.fluid, heaFlo.port_a)
          annotation (Line(points={{-36,-60},{-36,-56},{-36,-50}}, color={191,0,0}));
        connect(UAeff.y, con.Gc) annotation (Line(points={{-67,-70},{-46,-70}},
                       color={0,0,127}));
        connect(senTem.port, vol.heatPort)
          annotation (Line(points={{0,30},{-9,30},{-9,-10}}, color={191,0,0}));
        connect(senTem.T, T) annotation (Line(points={{20,30},{40,30},{40,80},{110,80}},
              color={0,0,127}));
        annotation (Icon(graphics={
              Rectangle(
                extent={{70,60},{100,58}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{72,94},{116,66}},
                lineColor={0,0,127},
                textString="Q_flow")}),
      defaultComponentName="evaCon",
      Documentation(info="<html>
<p>
Model for a constant temperature evaporator or condenser based on a &epsilon;-NTU
heat exchanger model.
</p>
<p>
The heat exchanger effectiveness is calculated from the number of transfer units
(NTU):
</p>
<p align=\"center\" style=\"font-style:italic;\">
&epsilon; = 1 - exp(UA &frasl; (m&#775; c<sub>p</sub>))
</p>
<p>
Optionally, this model can have a flow resistance.
If no flow resistance is requested, set <code>dp_nominal=0</code>.
</p>
<h4>Limitations</h4>
<p>
This model does not consider any superheating or supercooling on the refrigerant
side. The refrigerant is considered to exchange heat at a constant temperature
throughout the heat exchanger.
</p>
</html>",
      revisions="<html>
<ul>
<li>
May 27, 2017, by Filip Jorissen:<br/>
Regularised heat transfer around zero flow.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
<li>
April 12, 2017, by Michael Wetter:<br/>
Corrected invalid syntax for computing the specific heat capacity.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/707\">#707</a>.
</li>
<li>
October 11, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
      end EvaporatorCondenser;

      package RadiantSlab
      extends Modelica.Icons.VariantsPackage;

        package BaseClasses
        extends Modelica.Icons.BasesPackage;

          record FH_Standard1 "Basic floor heating design 1"
            extends
            IDEAS.Fluid.HeatExchangers.RadiantSlab.BaseClasses.RadiantSlabChar;
          end FH_Standard1;

          record RadiantSlabChar
            "Record containing all parameters for a given a floor heating of concrete core activation"
            // The terminology from prEN 15377 is followed, even if I find the development of the theory
            // by Koschenz and Lehmann better (see Thermoaktive Bauteilsysteme tabs, from Empa)
            // First Version 20110622
            // Changed 20110629:
            // Important: this record ALSO contains the parameters that are specific to the building.
            extends Modelica.Icons.Record;
            parameter Boolean tabs = true
              "true if the model is used for tabs, false if the model is used for floor heating. This is used for the correction factor of the thermal resistances in EmbeddedPipe";
            parameter Modelica.SIunits.Length T(
              min=0.15,
              max=0.3) = 0.2 "Pipe spacing, limits imposed by prEN 15377-3 p22";
            parameter Modelica.SIunits.Length d_a=0.02 "External diameter of the pipe";
            parameter Modelica.SIunits.Length s_r=0.0025 "Thickness of the pipe wall";
            parameter Modelica.SIunits.ThermalConductivity lambda_r=0.35
              "Thermal conductivity of the material of the pipe";
            parameter Modelica.SIunits.Length S_1=0.1
              "Thickness of the concrete/screed ABOVE the pipe layer";
            parameter Modelica.SIunits.Length S_2=0.1
              "Thickness of the concrete/screed UNDER the pipe layer";
            parameter Modelica.SIunits.ThermalConductivity lambda_b=1.8
              "Thermal conductivity of the concrete or screed layer";
            parameter Modelica.SIunits.SpecificHeatCapacity c_b=840
              "Thermal capacity of the concrete/screed material";
            parameter Modelica.SIunits.Density rho_b=2100
              "Density of the concrete/screed layer";
            constant Integer n1=3 "Number of discrete capacities in upper layer";
            constant Integer n2=3 "Number of discrete capacities in lower layer";
            parameter Integer nParCir=1 "number of circuit in parallel";
            // Extra parameters for floor heating
            parameter Modelica.SIunits.ThermalConductivity lambda_i = 0.036
              "heat conductivity of the isolation";
            parameter Modelica.SIunits.Length d_i = 0.05 "Thickness of the insulation";
            final parameter Real alp2 = lambda_i / d_i
              "help variable for resistance calculation";
            annotation (Documentation(info="<html>
<p><b>Description</b> </p>
<p>Record containing the properties of a floor heating or TABS.  The&nbsp;terminology&nbsp;from&nbsp;prEN&nbsp;15377&nbsp;is&nbsp;followed,&nbsp;even&nbsp;if&nbsp;I&nbsp;find&nbsp;the&nbsp;development&nbsp;of&nbsp;the&nbsp;theory by&nbsp;Koschenz&nbsp;and&nbsp;Lehmann&nbsp;better&nbsp;(see&nbsp;Thermoaktive&nbsp;Bauteilsysteme&nbsp;tabs,&nbsp;from&nbsp;Empa)</p>
<h4>Model use</h4>
<ol>
<li>It&apos;s important to set at least the floor surface to something different from 1</li>
<li>The embeddedPipe model has a few assertions to check the validity of some parameters and their combinations.</li>
</ol>
</html>",           revisions="<html>
<ul>
<li>2013 May, Roel De Coninck, documentation</li>
<li>2011 June, Roel De Coninck, first version</li>
</ul>
</html>"));
          end RadiantSlabChar;
        end BaseClasses;

        model EmbeddedPipe
          "Embedded pipe model based on prEN 15377 and (Koschenz, 2000), water capacity lumped to TOut"
          extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations;
          replaceable parameter
            IDEAS.Fluid.HeatExchangers.RadiantSlab.BaseClasses.RadiantSlabChar RadSlaCha constrainedby
          IDEAS.Fluid.HeatExchangers.RadiantSlab.BaseClasses.RadiantSlabChar
            "Properties of the floor heating or TABS, if present"
            annotation (choicesAllMatching=true);
          final parameter Modelica.SIunits.Length pipeDiaInt = RadSlaCha.d_a - 2*RadSlaCha.s_r
            "Pipe internal diameter";
          extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface(allowFlowReversal=false);
          extends IDEAS.Fluid.Interfaces.TwoPortFlowResistanceParameters(
            dp_nominal=Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.pressureLoss_m_flow(
              m_flow=m_flow_nominal/nParCir,
              rho_a=rho_default,
              rho_b=rho_default,
              mu_a=mu_default,
              mu_b=mu_default,
              length=pipeEqLen/nParCir,
              diameter=pipeDiaInt,
              roughness=roughness,
              m_flow_small=m_flow_small/nParCir));
          parameter Modelica.SIunits.Area A_floor "Floor/tabs surface area";
          parameter Integer nDiscr(min=1) = 1
            "Number of series discretisations along the flow direction"
            annotation(Evaluate=true);
          parameter Real nParCir(min=1) = 1 "Number of parallel circuits in the tabs"
            annotation(Evaluate=true);
          parameter Modelica.SIunits.Length roughness(min=0) = 2.5e-5
            "Absolute roughness of pipe, with a default for a smooth steel pipe"
            annotation(Dialog(tab="Flow resistance"));
          parameter Modelica.SIunits.Length L_floor = A_floor^(1/2)
            "Floor length - along the pipe direction"
            annotation(Dialog(tab="Flow resistance"));
          parameter Real N_pipes = A_floor/L_floor/RadSlaCha.T - 1
            "Number of parallel pipes in the slab"
        annotation(Dialog(tab="Flow resistance"));
          parameter Modelica.SIunits.Length pipeBendEqLen = 2*(N_pipes-1)*(2.267*RadSlaCha.T/2/pipeDiaInt+6.18)*pipeDiaInt
            "Pipe bends equivalent length, default according to Fox and McDonald (chapter 8.7, twice the linearized losses of a 90 degree bend)"
        annotation(Dialog(tab="Flow resistance"));
          parameter Modelica.SIunits.Length pipeEqLen = pipeBendEqLen + (L_floor-2*RadSlaCha.T)*N_pipes
            "Total pipe equivalent length, default assuming 180 dg turns starting at RadSlaCha.T from the end of the slab"
        annotation(Dialog(tab="Flow resistance"));
          parameter Modelica.SIunits.MassFlowRate m_flowMin = m_flow_nominal*0.5
            "Minimal flowrate when in operation - used for validity check"
            annotation(Dialog(group="Nominal condition"));

          final parameter Modelica.SIunits.ThermalInsulance R_r_val=RadSlaCha.T*log(RadSlaCha.d_a
              /pipeDiaInt)/(2*Modelica.Constants.pi*RadSlaCha.lambda_r)
            "Fix resistance value of thermal conduction through pipe wall * surface of floor between 2 pipes (see RadSlaCha documentation)";
          //Calculation of the resistance from the outer pipe wall to the center of the tabs / floorheating. eqn 4-25 Koschenz
          final parameter Modelica.SIunits.ThermalInsulance R_x_val=RadSlaCha.T*(log(RadSlaCha.T
              /(3.14*RadSlaCha.d_a)) + corr)/(2*Modelica.Constants.pi*RadSlaCha.lambda_b)
            "Fix resistance value of thermal conduction from pipe wall to layer";
          final parameter Real corr = if RadSlaCha.tabs then 0 else
            sum( -(RadSlaCha.alp2/RadSlaCha.lambda_b * RadSlaCha.T - 2*3.14*s)/(RadSlaCha.alp2/RadSlaCha.lambda_b * RadSlaCha.T + 2*3.14*s)*exp(-4*3.14*s/RadSlaCha.T*RadSlaCha.S_2)/s for s in 1:10) "correction factor for the floor heating according to Multizone Building modeling with Type56 and TRNBuild (see documentation). 
    If tabs is used, corr=0 - fixme: deprecated?";

          parameter Boolean from_dp = false
            "= true, use m_flow = f(dp) else dp = f(m_flow)"
            annotation (Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean linearized = false
            "= true, use linear relation between m_flow and dp for any flow rate"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Modelica.SIunits.ThermalInsulance R_c = 1/(RadSlaCha.lambda_b/RadSlaCha.S_1 + RadSlaCha.lambda_b/RadSlaCha.S_2)
            "Specific thermal resistivity of (parallel) slabs connected to top and bottom of tabs"
            annotation(Dialog(group="Thermal"));

          Modelica.SIunits.Temperature[nDiscr] Tin = cat(1, {senTemIn.T}, vol[1:nDiscr-1].heatPort.T);
          Modelica.SIunits.Power[nDiscr] Q "Thermal power going into tabs";
          //For high flow rates see [Koshenz, 2000] eqn 4.37 in between
          // for laminar flow Nu_D = 4 is assumed: correlation for heat transfer constant heat flow and constant wall temperature
          Modelica.SIunits.ThermalInsulance R_w_val= IDEAS.Utilities.Math.Functions.spliceFunction(
            x=rey-(reyHi+reyLo)/2,
            pos=RadSlaCha.T^0.13/8/Modelica.Constants.pi*abs((pipeDiaInt/(m_flowSpLimit*L_r)))^0.87,
            neg=RadSlaCha.T/(4*Medium.thermalConductivity(sta_default)*Modelica.Constants.pi),
            deltax=(reyHi-reyLo)/2)
            "Flow dependent resistance value of convective heat transfer inside pipe for both turbulent and laminar heat transfer.";
          Modelica.SIunits.ThermalInsulance R_t
            "Total equivalent specific resistivity as defined by Koschenz in eqn 4-59";
          Modelica.SIunits.ThermalConductance G_t
            "Equivalent thermal conductance";
          Modelica.SIunits.ThermalConductance G_max
            "Maximum thermal conductance based on mass flow rate";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[nDiscr] heatPortEmb
            "Port to the core of a floor heating/concrete activation"
            annotation (Placement(transformation(extent={{-10,90},{10,110}}),
                iconTransformation(extent={{-10,90},{10,110}})));
          //Reynold number Re = ( (m_flow / rho / A) * D * rho )  / mu / numParCir.
          Modelica.SIunits.ReynoldsNumber rey=
            m_flow/nParCir/A_pipe*pipeDiaInt/mu_default "Reynolds number";

          IDEAS.Fluid.MixingVolumes.MixingVolume[nDiscr] vol(each nPorts=2, each m_flow_nominal = m_flow_nominal, each V=m/nDiscr/rho_default,
            redeclare each package Medium = Medium,
            each p_start=p_start,
            each T_start=T_start,
            each X_start=X_start,
            each C_start=C_start,
            each C_nominal=C_nominal,
            each allowFlowReversal=allowFlowReversal,
            each mSenFac=mSenFac,
            each m_flow_small=m_flow_small,
            each final prescribedHeatFlowRate=true,
            each energyDynamics=energyDynamics,
            each massDynamics=massDynamics)
            annotation (Placement(transformation(extent={{-50,0},{-70,20}})));

          FixedResistances.ParallelPressureDrop          res(
            redeclare package Medium = Medium,
            m_flow_nominal=m_flow_nominal,
            final dp_nominal=dp_nominal,
            allowFlowReversal=allowFlowReversal,
            from_dp=from_dp,
            homotopyInitialization=homotopyInitialization,
            linearized=linearized,
            dp(nominal=L_r*10),
            computeFlowResistance=computeFlowResistance,
            final nParCir=nParCir,
            final dh=pipeDiaInt,
            final ReC=reyHi)
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
          IDEAS.Fluid.Sensors.Temperature senTemIn(redeclare package Medium = Medium)
            annotation (Placement(transformation(extent={{-110,18},{-90,38}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow[nDiscr] heatFlowWater(
            each final alpha=0) "Heat flow rate that is extracted from the fluid"
            annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow[nDiscr] heatFlowSolid(
            each final alpha=0)
            "Heat flow rate that is injected in the solid material"
            annotation (Placement(transformation(extent={{-40,70},{-20,90}})));
          Modelica.Blocks.Math.Gain[nDiscr] negate(each k=-1)
            annotation (Placement(transformation(extent={{-56,36},{-48,44}})));
          Modelica.Blocks.Sources.RealExpression[nDiscr] Q_tabs(y=Q)
            annotation (Placement(transformation(extent={{-100,50},{-72,70}})));

          Modelica.Blocks.Math.Sum sumQTabs(nin=nDiscr, k=ones(nDiscr))
          "Block that sums the volume heat flow rates"
            annotation (Placement(transformation(extent={{20,50},{40,70}})));
          Modelica.Blocks.Interfaces.RealOutput QTot
            "Total thermal power going into the heat port"
            annotation (Placement(transformation(extent={{100,50},{120,70}})));
      protected
          final parameter Modelica.SIunits.Length L_r=A_floor/RadSlaCha.T/nParCir
            "Length of one of the parallel circuits";
          final parameter Modelica.SIunits.Area A_pipe=
            Modelica.Constants.pi/4*pipeDiaInt^2
            "Pipe internal cross section surface area";
          final parameter Medium.ThermodynamicState sta_default=
             Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
          final parameter Modelica.SIunits.Density rho_default = Medium.density(sta_default);
          final parameter Modelica.SIunits.DynamicViscosity mu_default = Medium.dynamicViscosity(sta_default)
            "Dynamic viscosity at nominal condition";
          final parameter Modelica.SIunits.SpecificHeatCapacity cp_default = Medium.specificHeatCapacityCp(sta_default)
            "Heat capacity at nominal condition";
          final parameter Modelica.SIunits.MassFlowRate m_flow_nominal_pos = abs(m_flow_nominal)
            "Absolute value of nominal flow rate";
          final parameter Modelica.SIunits.MassFlowRate m_flow_turbulent =  mu_default*pipeDiaInt/4*Modelica.Constants.pi*reyHi
            "Turbulent flow if |m_flow| >= m_flow_turbulent";
          final parameter Modelica.SIunits.Pressure dp_nominal_pos = abs(dp_nominal)
            "Absolute value of nominal pressure";
          final parameter Modelica.SIunits.ReynoldsNumber reyLo=2700
            "Reynolds number where transition to turbulence starts"
            annotation(Evaluate=true);
          final parameter Modelica.SIunits.ReynoldsNumber reyHi=4000
            "Reynolds number where transition to turbulence ends"
            annotation(Evaluate=true);
          final parameter Real deltaXR = m_flow_nominal/A_floor*cp_default/1000
            "Transition threshold for regularization function";
          final parameter Modelica.SIunits.ThermalInsulance R_w_val_min=
            IDEAS.Utilities.Math.Functions.spliceFunction(x=m_flowMin/nParCir/A_pipe*pipeDiaInt/mu_default-(reyHi+reyLo)/2,
              pos=RadSlaCha.T^0.13/8/Modelica.Constants.pi*abs((pipeDiaInt/(m_flow_nominal/A_floor*L_r)))^0.87,
              neg=RadSlaCha.T/(4*Medium.thermalConductivity(sta_default)*Modelica.Constants.pi),
              deltax=(reyHi-reyLo)/2)
            "Lowest value for R_w that is expected for the set mass flow rate";
          final parameter Modelica.SIunits.Mass m(start=1) = A_pipe*L_r*rho_default
            "Mass of medium";
          Real m_flowSp(unit="kg/(m2.s)")=port_a.m_flow/(A_floor/nDiscr)
            "mass flow rate per unit floor area";
          Real m_flowSpLimit
            "Specific mass flow rate regularized for no flow conditions";
        initial equation
           assert(m_flowMin/(A_floor/nDiscr)*Medium.specificHeatCapacityCp(sta_default)*(R_w_val_min + R_r_val + R_x_val) >= 0.5,
             "Model is not valid for the set nominal and minimal mass flow rate, discretisation in multiple parts is required", level = AssertionLevel.warning);
          if RadSlaCha.tabs then
            assert(RadSlaCha.S_1 > 0.3*RadSlaCha.T, "Thickness of the concrete or screed layer above the tubes is smaller than 0.3 * the tube interdistance. 
    The model is not valid for this case");
            assert(RadSlaCha.S_2 > 0.3*RadSlaCha.T, "Thickness of the concrete or screed layer under the tubes is smaller than 0.3 * the tube interdistance. 
      The model is not valid for this case");
          else
            assert(RadSlaCha.alp2 < 1.212, "In order to use the floor heating model, RadSlaCha.alp2 need to be < 1.212");
            assert(RadSlaCha.d_a/2 < RadSlaCha.S_2, "In order to use the floor heating model, RadSlaCha.alp2RadSlaCha.d_a/2 < RadSlaCha.S_2 needs to be true");
            assert(RadSlaCha.S_1/RadSlaCha.T <0.3, "In order to use the floor heating model, RadSlaCha.S_1/RadSlaCha.T <0.3 needs to be true");
          end if;

        equation
          assert(allowFlowReversal or port_a.m_flow>-m_flow_small, "In " + getInstanceName() + ": flow reversal detected.");
          assert(not allowFlowReversal, "In " +getInstanceName() + ": parameter allowFlowReversal=true, but the EmbeddedPipe model does not support it.", AssertionLevel.warning);
          // this need not be smooth since when active, G_max is already active
          m_flowSpLimit = max(m_flowSp, 1e-8);
          // Koschenz eq 4-59
          R_t = 1/(m_flowSpLimit*cp_default*(1-exp(-1/((R_w_val+R_r_val+R_x_val+R_c)*m_flowSpLimit*cp_default))))-R_c;
          G_t = abs(A_floor/nDiscr/R_t);
          // maximum thermal conductance based on second law
          G_max = abs(m_flow)*cp_default;
          // no smoothmin since this undershoots for near-zero values
          Q = (Tin - heatPortEmb.T)*min(G_t, G_max);

          connect(res.port_b, port_b) annotation (Line(
                 points={{40,0},{100,0}},
               color={0,127,255},
               smooth=Smooth.None));
          connect(port_a, vol[1].ports[1]) annotation (Line(
               points={{-100,0},{-58,0}},
               color={0,127,255},
                      smooth=Smooth.None));
          connect(res.port_a, vol[nDiscr].ports[2]) annotation (Line(
               points={{20,0},{-62,0}},
               color={0,127,255},
               smooth=Smooth.None));

          for i in 2:nDiscr loop
            connect(vol[i-1].ports[2], vol[i].ports[1]) annotation (Line(
              points={{-62,0},{-58,0}},
              color={0,127,255},
              smooth=Smooth.None));
          end for;

          connect(senTemIn.port, port_a) annotation (Line(
              points={{-100,18},{-100,0}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(heatFlowWater.port, vol.heatPort) annotation (Line(
              points={{-20,40},{-20,10},{-50,10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(heatFlowWater.Q_flow, negate.y) annotation (Line(
              points={{-40,40},{-47.6,40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(negate.u, Q_tabs.y) annotation (Line(
              points={{-56.8,40},{-60,40},{-60,60},{-70.6,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(heatFlowSolid.Q_flow, Q_tabs.y) annotation (Line(
              points={{-40,80},{-60,80},{-60,60},{-70.6,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(heatFlowSolid.port, heatPortEmb) annotation (Line(
              points={{-20,80},{0,80},{0,100}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(Q_tabs.y, sumQTabs.u)
            annotation (Line(points={{-70.6,60},{18,60}}, color={0,0,127}));
          connect(sumQTabs.y, QTot)
            annotation (Line(points={{41,60},{110,60}}, color={0,0,127}));
           annotation (
            Diagram(graphics,
                    coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}})),
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}),
                 graphics={
                Ellipse(
                  extent={{-20,22},{20,-20}},
                  fillColor={127,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-95,6},{106,-4}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-102,-4},{-2,6}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-20,22},{20,-20}},
                  fillColor={127,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-80,60},{80,-60}},
                  lineColor={0,0,0},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-66,60},{-66,-60}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{66,60},{66,-60}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{-66,60},{-66,-60},{66,-60},{-66,60}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Forward)}),
            Documentation(info="<html>
<p>
Dynamic model of an embedded pipe for a concrete core activation. 
This model is based on (Koschenz, 2000). 
In addition the model provides the options to simulate the concrete 
core activation as if there were multiple parallel branches. 
This affects the pressure drop calculation and also the thermal calculations.
</p>
<h4>Assumptions and limitations</h4>
<p>
The model has a limited validity range. 
Its validity will be checked using assert statements. 
Possibly the discretization needs to be 
increased using parameter <code>nDiscr</code>.
An alternative is to increase <code>m_flow_min</code>, 
but this limits the validity range of the model.
</p>
<h4>Typical use and important parameters</h4>
<p>
The embeddedPipe model is to be used together with an InternalWall component. 
Multiple InternalWalls may be required if the EmbeddedPipe is discretized (using <code>nDiscr</code>).
</p>
<p>
Following parameters need to be set:
</p>
<ul>
<li>RadSlaCha is a record with all the parameters of the geometry, materials and even number of discretization layers in the nakedTabs model.</li>
<li>mFlow_min is used to check the validity of the operating conditions and is by default half of the nominal mass flow rate.</li>
<li><code>A_floor</code> is the surface area of (one side of) the Thermally Activated Building part (TAB). </li>
<li><code>nDiscr</code> can be used for discretizing the EmbeddedPipe along the flow direction. This may be necessary to be in the validity range of the model.</li>
<li><code>nParCir</code> can be used for calculating the pressure drops as if there were multiple EmbeddedPipes connected in parallel. The total mass flow rate is then split over multiple circuits and the pressure drop is calculated accordingly.</li>
<li><code>R_C</code> is the thermal resistivity from the center of the tabs to the zones. Note that the upper and lower resistivities need to be calculated as if they were in parallel. This parameter has a default value based on RadSlaCha but it may be improved if necessary. The impact of the value of this parameter on the model performance is low except in cases of very low mass flow rates.</li>
</ul>
<h4>Options</h4>
<p>
By default pressure drops are not calculated (<code>dp = 0</code>). 
These can be enabled by setting parameter <code>computeFlowResistance = true</code>. 
Pressure drops are then calculated by default by making an estimate of the total pipe length. 
This pressure drop can be a large underestimation of the real pressure drop. 
The used pipe lengths can be changed in the Pressure drop tab.
Parameter <code>dp_nominal</code> can be used to override the default calculation.
</p>
<h4>Validation </h4>
<p>
A limited verification has been performed in IDEAS.Fluid.HeatExchangers.RadiantSlab.Examples.EmbeddedPipeVerification.
</p>
<h4>References</h4>
<p>[Koshenz, 2000] - Koschenz, Markus, and Beat Lehmann. 2000. <i>Thermoaktive Bauteilsysteme - Tabs</i>. D&uuml;bendorf: EMPA D&uuml;bendorf. </p>
<p>[TRNSYS, 2007] - Multizone Building modeling with Type 56 and TRNBuild.</p>
</html>",         revisions="<html>
<ul>
<li>
August 14, 2019 by Iago Cupeiro:<br/>
Added output that computes the total TABS heat flow of the <code>EmbeddedPipe</code>,
</li>
<li>
April 16, 2019 by Filip Jorissen:<br/>
Added checks for flow reversal.
See <a href=https://github.com/open-ideas/IDEAS/issues/1006>#1006</a>.
</li>
<li>
April 16, 2019 by Filip Jorissen:<br/>
Removed <code>computeFlowResistance=false</code> 
since this parameter was hidden in the advanced tab
and this setting can easily lead to singularities.
See <a href=https://github.com/open-ideas/IDEAS/issues/1014>#1014</a>.
</li>
<li>
June 21, 2018 by Filip Jorissen:<br/>
Set <code>final alpha=0</code> in <code>prescribedHeatFlow</code>
to avoid large algebraic loops in specific cases.
See <a href=https://github.com/open-ideas/IDEAS/issues/852>#852</a>.
</li>
<li>
April 26, 2017 by Filip Jorissen:<br/>
Removed <code>useSimplifiedRt</code> parameter
since this leads to a violation of the second 
law for small flow rates.
See <a href=https://github.com/open-ideas/IDEAS/issues/717>#717</a>.
</li>
<li>2015 November, Filip Jorissen: Revised implementation for small flow rates: v3: replaced SmoothMin by min function</li>
<li>2015 November, Filip Jorissen: Revised implementation for small flow rates: v2</li>
<li>2015 November, Filip Jorissen: Revised implementation for small flow rates</li>
<li>2015, Filip Jorissen: Revised implementation</li>
<li>2014 March, Filip Jorissen: IDEAS baseclasses</li>
<li>2013 May, Roel De Coninck: documentation</li>
<li>2012 April, Roel De Coninck: rebasing on common Partial_Emission</li>
<li>2011, Roel De Coninck: first version and validation</li>
</ul>
</html>"));
        end EmbeddedPipe;
      end RadiantSlab;
    annotation (preferredView="info", Documentation(info="<html>
This package contains models for heat exchangers with and without humidity condensation.
</html>"));
    end HeatExchangers;

    package HeatPumps "Package with models for heat pumps"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses "Package with base classes for IDEAS.Fluid.HeatPumps"
        extends Modelica.Icons.BasesPackage;

        partial model PartialWaterToWater
          "Partial model for water to water heat pumps and chillers"
          extends IDEAS.Fluid.Interfaces.PartialFourPortInterface;
          extends IDEAS.Fluid.Interfaces.FourPortFlowResistanceParameters(
            final computeFlowResistance1 = dp1_nominal > 0,
            final computeFlowResistance2 = dp2_nominal > 0);
          replaceable package ref = IDEAS.Media.Refrigerants.R410A
            "Refrigerant in the component"
            annotation (choicesAllMatching = true);
          parameter Boolean enable_variable_speed = true
            "Set to true to allow modulating of compressor speed";
          parameter Real scaling_factor = 1.0
            "Scaling factor for heat pump capacity";
          parameter Modelica.SIunits.ThermalConductance UACon
            "Thermal conductance of condenser";
          parameter Modelica.SIunits.ThermalConductance UAEva
            "Thermal conductance of evaporator";
          parameter Modelica.SIunits.Time tau1=60
            "Time constant at nominal flow rate (used if energyDynamics1 <> Modelica.Fluid.Types.Dynamics.SteadyState)"
            annotation (Dialog(tab="Dynamics", group="Condenser"));
          parameter Modelica.SIunits.Time tau2=60
            "Time constant at nominal flow rate (used if energyDynamics2 <> Modelica.Fluid.Types.Dynamics.SteadyState)"
            annotation (Dialog(tab="Dynamics", group="Evaporator"));
          parameter Modelica.SIunits.Temperature T1_start=Medium1.T_default
            "Initial or guess value of set point"
            annotation (Dialog(tab="Dynamics", group="Condenser"));
          parameter Modelica.SIunits.Temperature T2_start=Medium2.T_default
            "Initial or guess value of set point"
            annotation (Dialog(tab="Dynamics", group="Evaporator"));
          parameter Modelica.Fluid.Types.Dynamics energyDynamics=
            Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
            "Type of energy balance: dynamic (3 initialization options) or steady state"
            annotation (Dialog(tab="Dynamics", group="Evaporator and condenser"));
          parameter Boolean homotopyInitialization=true "= true, use homotopy method"
            annotation (Dialog(tab="Advanced"));
          parameter Boolean enable_temperature_protection = true
            "Enable temperature protection"
            annotation(Evaluate=true, Dialog(group="Temperature protection"));
          parameter Modelica.SIunits.Temperature TConMax = ref.TCri-5
            "Upper bound for condenser temperature"
            annotation(Dialog(enable=enable_temperature_protection, group="Temperature protection"));
          parameter Modelica.SIunits.Temperature TEvaMin = 275.15
            "Lower bound for evaporator temperature"
            annotation(Dialog(enable=enable_temperature_protection, group="Temperature protection"));
          parameter Real dTHys(unit="K",min=0) = 5
            "Hysteresis interval width"
            annotation(Dialog(enable=enable_temperature_protection, group="Temperature protection"));
          Modelica.Blocks.Interfaces.BooleanOutput errLowPre if enable_temperature_protection
            "if true, compressor disabled since evaporator temperature is above upper bound";
          Modelica.Blocks.Interfaces.BooleanOutput errHigPre if enable_temperature_protection
            "if true, compressor disabled since condenser temperature is below lower bound";
          Modelica.Blocks.Interfaces.BooleanOutput errNegTemDif if enable_temperature_protection
            "if true, compressor disabled since condenser temperature is below evaporator temperature";
          Modelica.Blocks.Interfaces.RealInput y(final unit = "1") if
            enable_variable_speed == true
            "Modulating signal for compressor frequency, equal to 1 at full load condition"
            annotation (Placement(transformation(extent={{-140,10},{-100,50}})));
          Modelica.Blocks.Interfaces.IntegerInput stage if
            enable_variable_speed == false
            "Current stage of the heat pump, equal to 1 at full load condition"
            annotation (Placement(transformation(extent={{-140,10},{-100,50}})));
          Modelica.Blocks.Interfaces.RealOutput QCon_flow(
            min = 0,
            final quantity="HeatFlowRate",
            final unit="W") "Actual heating heat flow rate added to fluid 1"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));
          Modelica.Blocks.Interfaces.RealOutput P(
            min = 0,
            final quantity="Power",
            final unit="W") "Electric power consumed by compressor"
            annotation (Placement(transformation(extent={{100,-10},{120,10}}),
                iconTransformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealOutput QEva_flow(
            max = 0,
            final quantity="HeatFlowRate",
            final unit="W") "Actual cooling heat flow rate removed from fluid 2"
            annotation (Placement(transformation(extent={{100,-100},{120,-80}}),
                iconTransformation(extent={{100,-100},{120,-80}})));
          IDEAS.Fluid.HeatExchangers.EvaporatorCondenser con(
            redeclare final package Medium = Medium1,
            final allowFlowReversal=allowFlowReversal1,
            final m_flow_nominal=m1_flow_nominal,
            final m_flow_small=m1_flow_small,
            m_flow(start=m1_flow_nominal),
            final from_dp=from_dp1,
            final dp_nominal=dp1_nominal,
            final linearizeFlowResistance=linearizeFlowResistance1,
            final deltaM=deltaM1,
            final tau=tau1,
            final T_start=T1_start,
            final energyDynamics=energyDynamics,
            final homotopyInitialization=homotopyInitialization,
            final UA=UACon) "Condenser"
            annotation (Placement(transformation(extent={{40,50},{60,70}})));
          IDEAS.Fluid.HeatExchangers.EvaporatorCondenser eva(
            redeclare final package Medium = Medium2,
            final allowFlowReversal=allowFlowReversal2,
            final m_flow_nominal=m2_flow_nominal,
            final m_flow_small=m2_flow_small,
            m_flow(start=m2_flow_nominal),
            final from_dp=from_dp2,
            final dp_nominal=dp2_nominal,
            final linearizeFlowResistance=linearizeFlowResistance2,
            final deltaM=deltaM2,
            final tau=tau2,
            final T_start=T2_start,
            final energyDynamics=energyDynamics,
            final homotopyInitialization=homotopyInitialization,
            final UA=UAEva) "Evaporator"
            annotation (Placement(transformation(extent={{60,-50},{40,-70}})));
          replaceable IDEAS.Fluid.HeatPumps.Compressors.BaseClasses.PartialCompressor com
            "Compressor" annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,-6})));
      protected
          Modelica.Blocks.Math.IntegerToReal intToRea if
            enable_variable_speed == false "Conversion for stage signal"
            annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
          Modelica.Blocks.Nonlinear.Limiter lim(final uMin=0, final uMax=1) if
            enable_variable_speed == false "Limiter for control signal"
            annotation (Placement(transformation(extent={{-50,-40},{-30,-20}})));
          Compressors.BaseClasses.TemperatureProtection temPro(
            final TConMax=TConMax,
            final TEvaMin=TEvaMin,
            final dTHys=dTHys) if enable_temperature_protection
            "Disables compressor when outside of allowed operation range"
            annotation (Placement(transformation(extent={{0,-10},{20,10}})));
        equation
          if enable_temperature_protection then
            connect(errLowPre, temPro.errLowPre);
            connect(errHigPre, temPro.errHigPre);
            connect(errNegTemDif, temPro.errNegTemDif);
          end if;
          connect(port_a1, con.port_a)
            annotation (Line(points={{-100,60},{40,60}},  color={0,127,255}));
          connect(con.port_b, port_b1)
            annotation (Line(points={{60,60},{60,60},{100,60}}, color={0,127,255}));
          connect(con.Q_flow, QCon_flow) annotation (Line(points={{61,64},{60,64},{60,90},
                  {110,90}}, color={0,0,127}));
          connect(eva.port_a, port_a2)
            annotation (Line(points={{60,-60},{100,-60}}, color={0,127,255}));
          connect(eva.port_b, port_b2)
            annotation (Line(points={{40,-60},{-100,-60}},  color={0,127,255}));
          connect(eva.Q_flow, QEva_flow) annotation (Line(points={{39,-64},{34,-64},{34,
                  -90},{110,-90}}, color={0,0,127}));
          connect(com.port_b, con.port_ref)
            annotation (Line(points={{50,4},{50,29},{50,54}},
                                                           color={191,0,0}));
          connect(com.port_a, eva.port_ref) annotation (Line(points={{50,-16},{50,-16},{
                  50,-54}},         color={191,0,0}));
          connect(com.P, P)
            annotation (Line(points={{61,0},{110,0}},         color={0,0,127}));
          if enable_variable_speed then
            if enable_temperature_protection then
              connect(y,temPro.u)
                annotation (Line(points={{-120,30},{-90,30},{-90,0},{-2,0}},
                color={0,0,127}));
            else
              connect(y,com.y)
                annotation (Line(points={{-120,30},{32,30},{32,14},{32,3.9968e-15},{36,
                      3.9968e-15},{39,3.9968e-15}},
                color={0,0,127}));
            end if;
          else
            if enable_temperature_protection then
              connect(lim.y, temPro.u)
                annotation (Line(points={{-29,-30},{-20,-30},{-20,0},{-2,0}},
                                                                       color={0,0,127}));
            else
              connect(lim.y, com.y)
                annotation (Line(points={{-29,-30},{32,-30},{32,0},{39,0},{39,0}},
                                                                       color={0,0,127}));
            end if;
          end if;
          connect(stage, intToRea.u) annotation (Line(points={{-120,30},{-120,30},{-90,30},
                  {-90,-16},{-90,-30},{-82,-30}}, color={255,127,0}));
          connect(intToRea.y, lim.u)
            annotation (Line(points={{-59,-30},{-52,-30}}, color={0,0,127}));
          connect(temPro.y, com.y)
            annotation (Line(points={{21,0},{39,0}},          color={0,0,127}));
          connect(temPro.TCon, con.T) annotation (Line(points={{-2,8},{-2,8},{-20,8},{
                  -20,76},{70,76},{70,68},{61,68}},
                                    color={0,0,127}));
          connect(temPro.TEva, eva.T)
            annotation (Line(points={{-2,-8},{-2,-8},{-12,-8},{-12,-68},{39,-68}},
                                                                    color={0,0,127}));
          annotation (
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},
                    {100,100}}),       graphics={
                Rectangle(
                  extent={{-70,80},{70,-80}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Rectangle(
                  extent={{-56,68},{58,50}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-56,-52},{58,-70}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-103,64},{98,54}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-2,54},{98,64}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-101,-56},{100,-66}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-100,-66},{0,-56}},
                  lineColor={0,0,127},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-42,0},{-52,-12},{-32,-12},{-42,0}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Polygon(
                  points={{-42,0},{-52,10},{-32,10},{-42,0}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Rectangle(
                  extent={{-44,50},{-40,10}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-44,-12},{-40,-52}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{38,50},{42,-52}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{18,22},{62,-20}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Polygon(
                  points={{40,22},{22,-10},{58,-10},{40,22}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{0,68},{0,90},{90,90},{100,90}},
                                                         color={0,0,255}),
                Line(points={{0,-70},{0,-90},{100,-90}}, color={0,0,255}),
                Line(points={{62,0},{100,0}},                 color={0,0,255})}),
            defaultComponentName="heaPum",
            Documentation(info="<html>
<p>
Partial model for a water to water heat pump, as detailed in Jin (2002). The
model for the compressor is a partial model and needs to be replaced by one of the
compressor models in
<a href = \"modelica://IDEAS.Fluid.HeatPumps.Compressors\">
IDEAS.Fluid.HeatPumps.Compressors</a>.
</p>
<h4>References</h4>
<p>
H. Jin.
<i>
Parameter estimation based models of water source heat pumps.
</i>
PhD Thesis. Oklahoma State University. Stillwater, Oklahoma, USA. 2012.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 30, 2017, by Filip Jorissen:<br/>
Added temperature protection block and
set <code>energyDynamics=DynamicFreeInitial</code>.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">
#769</a>.
</li>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialWaterToWater;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.HeatPumps\">IDEAS.Fluid.HeatPumps</a>.
</p>
</html>"));
      end BaseClasses;

      package Compressors "Package with compressor models"
        extends Modelica.Icons.VariantsPackage;

        package BaseClasses "Package with base classes for compressors"
          extends Modelica.Icons.BasesPackage;

          partial model PartialCompressor "Partial compressor model"
            replaceable package ref = IDEAS.Media.Refrigerants.R410A
              "Refrigerant in the component"
              annotation (choicesAllMatching = true);
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
                "Refrigerant connector a (corresponding to the evaporator)"
                annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
                "Refrigerant connector b (corresponding to the condenser)"
                annotation (Placement(transformation(extent={{110,-10},{90,10}})));
              Modelica.Blocks.Interfaces.RealInput y(final unit = "1")
               "Modulating signal for compressor frequency, equal to 1 at full load conditions"
                annotation (Placement(
                  transformation(
                    extent={{-120,70},{-100,50}},
                    rotation = -90)));
              Modelica.Blocks.Interfaces.RealOutput P(
                final quantity="Power",
                final unit="W") "Electric power consumed by compressor"
                annotation (Placement(transformation(extent={{100,50},{120,70}},
                    rotation=-90)));
            Modelica.SIunits.SpecificEnthalpy hEva
              "Specific enthalpy of saturated vapor at evaporator temperature";
            Modelica.SIunits.SpecificEnthalpy hCon
              "Specific enthalpy of saturated liquid at condenser temperature";
            Modelica.SIunits.AbsolutePressure pEva(start = 100e3)
              "Pressure of saturated vapor at evaporator temperature";
            Modelica.SIunits.AbsolutePressure pCon(start = 1000e3)
              "Pressure of saturated liquid at condenser temperature";
            Modelica.SIunits.AbsolutePressure pDis(start = 1000e3)
              "Discharge pressure of the compressor";
            Modelica.SIunits.AbsolutePressure pSuc(start = 100e3)
              "Suction pressure of the compressor";
            Modelica.SIunits.Temperature TSuc
              "Temperature at suction of the compressor";
            Boolean isOn(fixed=false)
              "State of the compressor, true if turned on";
            Modelica.SIunits.SpecificVolume vSuc(start = 1e-4, min = 0)
              "Specific volume of the refrigerant at suction of the compressor";
        protected
            Real PR(min = 0.0, unit = "1", start = 2.0)
              "Pressure ratio";
          initial equation
            pre(isOn) = if y > 0.01 then true else false;
          equation
            isOn = not pre(isOn) and y > 0.01 or pre(isOn) and y >= 0.005;
            PR = max(pDis/pSuc, 0);
            // The specific volume at suction of the compressor is calculated
            // from the Martin-Hou equation of state
            vSuc = ref.specificVolumeVap_pT(pSuc, TSuc);
            // Saturation pressure of refrigerant vapor at condenser temperature
            pCon = ref.pressureSatVap_T(port_b.T);
            // Specific enthaply of saturated liquid refrigerant at condenser temperature
            hCon = ref.enthalpySatLiq_T(port_b.T);
            // Saturation pressure of refrigerant vapor at evaporator temperature
            pEva = ref.pressureSatVap_T(port_a.T);
            // Specific enthaply of saturated refrigerant vapor at evaporator temperature
            hEva = ref.enthalpySatVap_T(port_a.T);
            // Assert statements to verify that the refrigerant temperatures are within
            // bounds of the property data in the refrigerant package
            assert(port_b.T > ref.T_min and port_b.T < ref.TCri,
              "Condensing temperature must be above the minimum refrigerant temperature
    and below the critical temperature.");
            assert(port_a.T > ref.T_min and port_a.T < ref.TCri,
              "Evaporating temperature must be above the minimum refrigerant temperature
    and below the critical temperature.");
            annotation (
            Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},
                      {100,100}}),       graphics={
                  Text(extent={{62,-82},{72,-98}},    textString="P",
                    lineColor={0,0,127}),
                  Text(extent={{62,98},{72,82}},
                    lineColor={0,0,127},
                    textString="y"),
                  Polygon(
                    points={{-70,-80},{-70,80},{70,60},{70,-60},{-70,-80}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-100,-5},{100,5}},
                    lineColor={255,0,0},
                    pattern=LinePattern.None,
                    fillColor={255,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{60,-58},{60,-100}},        color={0,0,255}),
                  Line(points={{60,58},{60,100}},        color={0,0,0}),
                  Text(
                    extent={{-149,-114},{151,-154}},
                    lineColor={0,0,255},
                    textString="%name")}),
              defaultComponentName="com",
                Documentation(info="<html>
<p>
This is the base class for the compressor model.
</p>
<p>
The model evaluates the evaporating pressure of the refrigerant <i>p<sub>eva</sub></i>,
the specific enthalpy of the evaporating saturated refrigerant vapor <i>h<sub>eva</sub></i>,
the condensing pressure of the refrigerant <i>p<sub>con</sub></i>
and the specific enthalpy of the condensing saturated liquid refrigerant <i>h<sub>cond</sub></i>
at the evaporating temperature <i>T<sub>eva</sub></i> = <code>port_a.T</code>
and condensing temperature <i>T<sub>con</sub></i> = <code>port_b.T</code>.
</p>
<p>
Thermodynamic properties are evaluated from functions contained in the specified refrigerant package.
</p>
<h4>Assumptions and limitations</h4>
<p>
The model assumes isothermal condensation and evaporation, therefore
refrigerant mass flow is not accounted for and heat ports are used instead of fluid ports.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 30, 2017, by Filip Jorissen:<br/>
Removed <code>pressure_error</code> as
this is replaced by
<a href=\"modelica://IDEAS.Fluid.HeatPumps.Compressors.BaseClasses.TemperatureProtection\">
IDEAS.Fluid.HeatPumps.Compressors.BaseClasses.TemperatureProtection</a>.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
<li>
May 26, 2017, by Michael Wetter and Thierry Nouidui:<br/>
Reformulated <code>isOn</code> to use the same construct as the hysteresis block,
and to work around a JModelica limitation.<br/>
This is for
<a href=\"modelica://https://github.com/lbl-srg/modelica-buildings/issues/774\">#774</a>.
</li>
<li>
April 25, 2017, by Michael Wetter:<br/>
Reformulated <code>when</code> conditions and moved common assignments
to this base class.<br/>
This is for
<a href=\"modelica://https://github.com/lbl-srg/modelica-buildings/issues/739\">#739</a>.
</li>
<li>
November 11, 2016, by Massimo Cimmino:<br/>
First implementation of this base class.
</li>
</ul>
</html>"));
          end PartialCompressor;

          model TemperatureProtection
            "Temperature protection for heat pump compressor"
            extends Modelica.Blocks.Icons.Block;
            parameter Modelica.SIunits.Temperature TConMax
              "Upper bound for condenser temperature";
            parameter Modelica.SIunits.Temperature TEvaMin
              "Lower bound for evaporator temperature";
            parameter Real dTHys(
              final unit="K",
              min=Modelica.Constants.small) = 5
              "Hysteresis interval width";
            parameter Boolean pre_y_start=false "Value of pre(y) of hysteresis at initial time";
            Modelica.Blocks.Interfaces.RealInput u "Compressor control signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            Modelica.Blocks.Interfaces.RealInput TEva(
              unit="K",
              displayUnit="degC")
              "Evaporator temperature"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  origin={-120,-80})));
            Modelica.Blocks.Interfaces.RealInput TCon(
              unit="K",
              displayUnit="degC")
              "Condenser temperature" annotation (
               Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  origin={-120,80})));
            Modelica.Blocks.Interfaces.RealOutput y "Modified compressor control signal"
              annotation (Placement(transformation(extent={{100,-10},{120,10}})));
            Modelica.Blocks.Interfaces.BooleanOutput errHigPre
              "Error signal condenser upper bound temperature "
              annotation (Placement(transformation(extent={{100,40},{120,60}})));
            Modelica.Blocks.Interfaces.BooleanOutput errLowPre
              "Error signal evaporator lower bound temperature "
              annotation (Placement(transformation(extent={{100,80},{120,100}})));
            Modelica.Blocks.Interfaces.BooleanOutput errNegTemDif
              "Error signal if evaporator temperature is above condenser temperature"
              annotation (Placement(transformation(extent={{100,60},{120,80}})));
        protected
            Modelica.Blocks.Logical.Switch switch
              "Switches control signal off when conditions not satisfied"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            Modelica.Blocks.Logical.Hysteresis hysHig(uLow=0, uHigh=dTHys,
              final pre_y_start=pre_y_start)
              "Hysteresis for condenser upper bound temperature"
              annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
            Modelica.Blocks.Sources.Constant zero(final k=0)
              "Zero control signal when check fails"
              annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
            Modelica.Blocks.Logical.Hysteresis hysLow(uLow=0, uHigh=dTHys,
              final pre_y_start=pre_y_start)
              "Hysteresis for evaporator lower bound temperature"
              annotation (Placement(transformation(extent={{-20,20},{0,40}})));
            Modelica.Blocks.Sources.Constant TMax(final k=TConMax)
              "Condenser maximum temperature"
              annotation (Placement(transformation(extent={{-92,-42},{-80,-30}})));
            Modelica.Blocks.Math.Add dTCon(k2=-1)
              "Difference between condenser temperature and its upper bound"
              annotation (Placement(transformation(extent={{-60,-20},{-40,-40}})));
            Modelica.Blocks.Math.Add dTEva(k1=-1)
              "Difference between evaporator temperature and its lower bound"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Modelica.Blocks.Sources.Constant TMin(final k=TEvaMin)
              "Evaporator minimum temperature"
              annotation (Placement(transformation(extent={{-92,30},{-80,42}})));
            Modelica.Blocks.MathBoolean.And on(nu=3) "Compressor status"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            Modelica.Blocks.Logical.Hysteresis hysdTConEva(
              final uLow=0,
              final uHigh=dTHys,
              final pre_y_start=pre_y_start)
              "Hysteresis for temperature difference between evaporator and condenser"
              annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
            Modelica.Blocks.Math.Add dTEvaCon(final k1=-1)
              "Difference between evaporator and condenser"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
            Modelica.Blocks.MathBoolean.Not notEva "Negation of signal"
              annotation (Placement(transformation(extent={{64,84},{76,96}})));
            Modelica.Blocks.MathBoolean.Not notdT "Negation of signal"
              annotation (Placement(transformation(extent={{64,64},{76,76}})));
            Modelica.Blocks.MathBoolean.Not notCon "Negation of signal"
              annotation (Placement(transformation(extent={{64,44},{76,56}})));
          equation
            connect(zero.y,switch. u3) annotation (Line(points={{41,-30},{50,-30},{50,-8},
                    {58,-8}},color={0,0,127}));
            connect(u, switch.u1) annotation (Line(points={{-120,0},{-96,0},{-96,60},{50,
                    60},{50,8},{58,8}}, color={0,0,127}));
            connect(switch.y, y)
              annotation (Line(points={{81,0},{110,0}},         color={0,0,127}));
            connect(TMax.y, dTCon.u1) annotation (Line(points={{-79.4,-36},{-79.4,-36},{-62,
                    -36}}, color={0,0,127}));
            connect(TMin.y, dTEva.u1) annotation (Line(points={{-79.4,36},{-62,36}},
                          color={0,0,127}));
            connect(dTEva.u2, TEva) annotation (Line(points={{-62,24},{-70,24},{-70,-80},
                    {-120,-80}},
                              color={0,0,127}));
            connect(dTCon.u2, TCon) annotation (Line(points={{-62,-24},{-76,-24},{-76,80},
                    {-120,80}},       color={0,0,127}));
            connect(dTEva.y, hysLow.u)
              annotation (Line(points={{-39,30},{-39,30},{-22,30}}, color={0,0,127}));
            connect(hysHig.u, dTCon.y)
              annotation (Line(points={{-22,-30},{-22,-30},{-39,-30}}, color={0,0,127}));
            connect(on.y, switch.u2)
              annotation (Line(points={{41.5,0},{41.5,0},{58,0}},
                                                              color={255,0,255}));
            connect(dTEvaCon.y, hysdTConEva.u)
              annotation (Line(points={{-39,0},{-32,0},{-22,0}}, color={0,0,127}));
            connect(dTEvaCon.u2, TCon) annotation (Line(points={{-62,-6},{-76,-6},{-76,80},
                    {-120,80}},             color={0,0,127}));
            connect(dTEvaCon.u1, TEva) annotation (Line(points={{-62,6},{-70,6},{-70,-80},
                    {-120,-80}},     color={0,0,127}));
            connect(hysLow.y, on.u[1]) annotation (Line(points={{1,30},{10,30},{10,4.66667},
                    {20,4.66667}},          color={255,0,255}));
            connect(hysdTConEva.y, on.u[2])
              annotation (Line(points={{1,0},{20,0}}, color={255,0,255}));
            connect(hysHig.y, on.u[3]) annotation (Line(points={{1,-30},{14,-30},{14,-4},{
                    18,-4},{18,-4.66667},{20,-4.66667}},
                                              color={255,0,255}));
            connect(hysLow.y, notEva.u) annotation (Line(points={{1,30},{10,30},{10,90},{61.6,
                    90}}, color={255,0,255}));
            connect(notEva.y, errLowPre)
              annotation (Line(points={{77.2,90},{94,90},{110,90}}, color={255,0,255}));
            connect(notdT.u, hysdTConEva.y) annotation (Line(points={{61.6,70},{12,70},{12,
                    0},{1,0}}, color={255,0,255}));
            connect(notdT.y, errNegTemDif)
              annotation (Line(points={{77.2,70},{110,70}}, color={255,0,255}));
            connect(notCon.y, errHigPre)
              annotation (Line(points={{77.2,50},{110,50},{110,50}}, color={255,0,255}));
            connect(notCon.u, hysHig.y) annotation (Line(points={{61.6,50},{14,50},{14,-30},
                    {1,-30}}, color={255,0,255}));
            annotation (    Documentation(revisions="<html>
<ul>
<li>
May 30, 2017, by Filip Jorissen:<br/>
First implementation.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
</ul>
</html>", info="<html>
<p>
Temperature protection block for heat pumps.
This block overrides the heat pump control
signal when the condenser temperature is too high,
the evaporator temperature is too low,
or the temperature difference between
the condenser and evaporator is negative.
</p>
<h4>Typical use and important parameters</h4>
<p>
Temperature bounds are set using <code>TConMax</code>
and <code>TEvaMin</code>.
</p>
<h4>Options</h4>
<p>
Parameter <code>dTHys</code> may be used
to change the hysteresis interval.
</p>
</html>"));
          end TemperatureProtection;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.HeatPumps.Compressors\">
IDEAS.Fluid.HeatPumps.Compressors</a>.
</p>
</html>"));
        end BaseClasses;

        model ScrollCompressor
          "Model for a scroll compressor, based on Jin (2002)"
          extends
          IDEAS.Fluid.HeatPumps.Compressors.BaseClasses.PartialCompressor;

          parameter Real volRat(
            min = 1.0,
            final unit = "1")
            "Built-in volume ratio";

          parameter Modelica.SIunits.VolumeFlowRate V_flow_nominal(min=0)
            "Refrigerant volume flow rate at suction at full load conditions";

          parameter Modelica.SIunits.MassFlowRate leaCoe(
            min = 0)
            "Leakage mass flow rate at a pressure ratio of 1";

          parameter Modelica.SIunits.Efficiency etaEle
            "Electro-mechanical efficiency of the compressor";

          parameter Modelica.SIunits.Power PLos(min = 0)
            "Constant part of the compressor power losses";

          parameter Modelica.SIunits.TemperatureDifference dTSup(min = 0)
            "Superheating at compressor suction";

          Modelica.SIunits.MassFlowRate m_flow
            "Refrigerant mass flow rate";

          Modelica.SIunits.MassFlowRate mLea_flow "Refrigerant leakage mass flow rate";

          Modelica.SIunits.Power PThe
            "Theoretical power consumed by the compressor";

          Modelica.SIunits.Efficiency COP(start=5)
            "Heating COP of the compressor";

      protected
          Modelica.SIunits.IsentropicExponent k(start = 1.2)
            "Isentropic exponent of the refrigerant";

          Real v_norm
            "Normalized refrigerant volume flow rate at
     suction at part load conditions";

          Real PRInt(start = 2.0)
            "Built-in pressure ratio";

        equation
          PRInt = volRat^k;

          // Limit compressor speed to the full load speed
          v_norm = IDEAS.Utilities.Math.Functions.smoothLimit(y, 0.0, 1.0, 0.001);

          if isOn then
            // Suction pressure
            pSuc = pEva;
            // Discharge pressure
            pDis = pCon;
            // Refrigerant mass flow rate
            mLea_flow = leaCoe*PR;
            m_flow = v_norm*
              IDEAS.Utilities.Math.Functions.smoothMax(
              V_flow_nominal/vSuc - mLea_flow,
              1e-5*V_flow_nominal/vSuc,
              1e-6*V_flow_nominal/vSuc);

            // Theoretical power of the compressor
            k = ref.isentropicExponentVap_Tv(TSuc, vSuc);
            // If the external pressure ratio does not match the built-in pressure ratio
            PThe = v_norm * k/(k - 1.0) * pSuc * V_flow_nominal
              * (((k - 1.0)/k) * PR/volRat + 1.0/k * PRInt^((k - 1.0)/k) - 1.0);
            // This equation reduces to the  equation for the built-in pressure ratio
            // if the external pressure ratio matches the built-in pressure ratio:
            // PThe = v_norm * k/(k - 1.0) * pSuc*v_flow * ((PRInt)^((k - 1.0)/k) - 1.0)

            // Temperature at suction of the compressor
            TSuc = port_a.T + dTSup;

            // Power consumed by the compressor
            P = (PThe/etaEle + PLos);

            // Energy balance of the compressor
             port_a.Q_flow = m_flow * (hEva - hCon);
             port_b.Q_flow = - (port_a.Q_flow + P);
             -port_b.Q_flow = P * COP;
          else
            // Heat pump is turned off
            k = 1.0;
            pSuc = pEva;
            pDis = pCon;
            mLea_flow = 0.0;
            m_flow = 0.0;
            PThe = 0.0;
            P = 0.0;
            TSuc = port_a.T;
            port_a.Q_flow = 0.0;
            port_b.Q_flow = 0.0;
            COP = 1.0;
          end if;

          annotation (    defaultComponentName="scrCom",
            Documentation(info="<html>
<p>
Model for a scroll processor, as detailed in Jin (2002). The rate of heat transferred to the evaporator is given by:
</p>
<p align=\"center\" style=\"font-style:italic;\">
Q&#775;<sub>Eva</sub> = m&#775;<sub>ref</sub> ( h<sub>Vap</sub>(T<sub>Eva</sub>) - h<sub>Liq</sub>(T<sub>Con</sub>) ).
</p>
<p>
The power consumed by the compressor is given by a linear efficiency relation:
</p>
<p align=\"center\" style=\"font-style:italic;\">
P = P<sub>Theoretical</sub> / &eta; + P<sub>Loss,constant</sub>.
</p>
<p>
Variable speed is achieved by multiplying the full load suction volume flow rate
by the normalized compressor speed. The power and heat transfer rates are forced
to zero if the resulting heat pump state has higher evaporating pressure than
condensing pressure.
</p>
<h4>Assumptions and limitations</h4>
<p>
The compression process is assumed isentropic. The thermal energy
of superheating is ignored in the evaluation of the heat transferred to the refrigerant
in the evaporator. There is no supercooling.
</p>
<h4>References</h4>
<p>
H. Jin.
<i>
Parameter estimation based models of water source heat pumps.
</i>
PhD Thesis. Oklahoma State University. Stillwater, Oklahoma, USA. 2012.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 25, 2019, by Michael Wetter:<br/>
Added start value to avoid warning in JModelica.
</li>
<li>
May 30, 2017, by Filip Jorissen:<br/>
Removed <code>pressure_error</code> as
this is replaced by
<a href=\"modelica://IDEAS.Fluid.HeatPumps.Compressors.BaseClasses.TemperatureProtection\">
IDEAS.Fluid.HeatPumps.Compressors.BaseClasses.TemperatureProtection</a>.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
<li>
November 11, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ScrollCompressor;
        annotation (preferredView="info", Documentation(info="<html>
  <p>
  This package contains components models for compressors.
  </p>
  </html>"));
      end Compressors;

      package Data "Package with model parameters for heat pumps"
        extends Modelica.Icons.MaterialPropertiesPackage;

        package BaseClasses "Base classes for package Data"
          extends Modelica.Icons.BasesPackage;

          partial record HeatPumps
            "Base record for calibrated heat pump models"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.Efficiency etaEle
              "Electro-mechanical efficiency of the compressor"
              annotation (Dialog(group="Compressor"));
            parameter Modelica.SIunits.Power PLos(min = 0)
              "Constant part of the compressor power losses"
              annotation (Dialog(group="Compressor"));
            parameter Modelica.SIunits.TemperatureDifference dTSup(min = 0)
              "Superheating at compressor suction"
              annotation (Dialog(group="Evaporator"));
            parameter Modelica.SIunits.ThermalConductance UACon
              "Thermal conductance of condenser between water and refrigerant"
              annotation (Dialog(group="Condenser"));
            parameter Modelica.SIunits.ThermalConductance UAEva
              "Thermal conductance of evaporator between water and refrigerant"
              annotation (Dialog(group="Evaporator"));
            annotation (
              defaultComponentName="datHeaPum",
              preferredView="info",
            Documentation(info="<html>
<p>
This is the base record for heat pump models.
</p>
</html>", revisions="<html>
<ul>
<li>
December 6, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Text(
                    extent={{-95,53},{-12,-2}},
                    lineColor={0,0,255},
                    textString="etaEle"),
                  Text(
                    extent={{-95,-9},{-48,-48}},
                    lineColor={0,0,255},
                    textString="PLos"),
                  Text(
                    extent={{-95,-49},{-12,-104}},
                    lineColor={0,0,255},
                    textString="dTSup")}));
          end HeatPumps;
          annotation(preferredView="info",
          Documentation(info="<html>
This package contains the common parameters that are used
to specify the heat pump models in
<a href=\"IDEAS.Fluid.HeatPumps\">
IDEAS.Fluid.HeatPumps</a>.
</html>",         revisions="<html>
<ul>
<li>
December 6, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end BaseClasses;

        package ScrollWaterToWater
        "Package with model parameters for scroll water to water heat pumps"
          extends Modelica.Icons.MaterialPropertiesPackage;

          record Generic "Record for scroll water to water heat pump"
            extends BaseClasses.HeatPumps;
            parameter Real volRat(
              min = 1.0,
              unit = "1")
              "Built-in volume ratio"
              annotation (Dialog(group="Compressor"));
            parameter Modelica.SIunits.VolumeFlowRate V_flow_nominal(min=0)
              "Refrigerant volume flow rate at suction"
              annotation (Dialog(group="Compressor"));
            parameter Modelica.SIunits.MassFlowRate leaCoe(min = 0)
              "Leakage coefficient"
              annotation (Dialog(group="Compressor"));
            annotation (
              defaultComponentPrefixes = "parameter",
              defaultComponentName="datHeaPum",
              preferredView="info",
            Documentation(info="<html>
<p>
This is the base record for scroll water to water heat pump models.
</p>
</html>", revisions="<html>
<ul>
<li>
December 6, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
          end Generic;

          package Heating
          "Records for scroll water to water heat pumps in heating mode"
            extends Modelica.Icons.MaterialPropertiesPackage;

            record ClimateMaster_TMW036_12kW_4_90COP_R410A =
              IDEAS.Fluid.HeatPumps.Data.ScrollWaterToWater.Generic (
                volRat = 2.02993657028,
                V_flow_nominal = 0.0017713046171,
                leaCoe = 0.0001,
                etaEle = 1.0,
                PLos = 334.350812253,
                dTSup = 4.68810579482e-16,
                UACon = 2434.90888536,
                UAEva = 925.546637632)
                "Calibrated parameters for ClimateMaster TMW036"
              annotation (
                defaultComponentPrefixes = "parameter",
                defaultComponentName="datHeaPum",
                preferredView="info",
              Documentation(info="<html>
<p>
Calibrated parameters for ClimateMaster TMW036.
</p>
</html>",             revisions="<html>
<ul>
<li>
March 6, 2017, by Massimo Cimmino:<br/>
Calibrated parameters.
</li>
</ul>
</html>"));
          annotation (Documentation(info="<html>
<p>
Package with data for heating performance of water to water heat pump models
<a href=\"modelica://IDEAS.Fluid.HeatPumps.ScrollWaterToWater\">
IDEAS.Fluid.HeatPumps.ScrollWaterToWater</a>
with scroll compressor.
</p>
</html>"));
          end Heating;
        annotation (Documentation(info="<html>
<p>
Package with data for water to water heat pump models
<a href=\"modelica://IDEAS.Fluid.HeatPumps.ScrollWaterToWater\">
IDEAS.Fluid.HeatPumps.ScrollWaterToWater</a>
with scroll compressor.
</p>
</html>"));
        end ScrollWaterToWater;
        annotation (preferredView="info", Documentation(info="<html>
  Package with data for heat pump models.
</html>"));
      end Data;

      model ScrollWaterToWater
        "Model for a scroll water to water heat pump"
        extends IDEAS.Fluid.HeatPumps.BaseClasses.PartialWaterToWater(
          final UAEva=datHeaPum.UAEva*scaling_factor,
          final UACon=datHeaPum.UACon*scaling_factor,
          redeclare HeatPumps.Compressors.ScrollCompressor com(
            redeclare final package ref = ref,
            final volRat=datHeaPum.volRat,
            final V_flow_nominal=datHeaPum.V_flow_nominal*scaling_factor,
            final leaCoe=datHeaPum.leaCoe*scaling_factor,
            final etaEle=datHeaPum.etaEle,
            final PLos=datHeaPum.PLos*scaling_factor,
            final dTSup=datHeaPum.dTSup));
        parameter IDEAS.Fluid.HeatPumps.Data.ScrollWaterToWater.Generic datHeaPum
          "Heat pump data" annotation (choicesAllMatching=true, Placement(
              transformation(extent={{-98,78},{-78,98}})));
          annotation (Placement(transformation(extent={{100,-100},{120,-80}}),
              iconTransformation(extent={{100,-100},{120,-80}})),
                    defaultComponentName="heaPum",
          Documentation(info="<html>
<p>
Model for a water to water heat pump with a scroll compressor, as described
in Jin (2002). The thermodynamic heat pump cycle is represented below.
</p>
<p align=\"center\">
<img  alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/HeatPumps/WaterToWater_Cycle.png\" border=\"1\"/>
</p>
<p>
The rate of heat transferred to the evaporator is given by:
</p>
<p align=\"center\" style=\"font-style:italic;\">
Q&#775;<sub>Eva</sub> = m&#775;<sub>ref</sub> ( h<sub>Vap</sub>(T<sub>Eva</sub>) - h<sub>Liq</sub>(T<sub>Con</sub>) ).
</p>
<p>
The power consumed by the compressor is given by a linear efficiency relation:
</p>
<p align=\"center\" style=\"font-style:italic;\">
P = P<sub>Theoretical</sub> / &eta; + P<sub>Loss,constant</sub>.
</p>
<p>
Heat transfer in the evaporator and condenser is calculated using an
&epsilon;-NTU method, assuming constant refrigerant temperature and constant heat
transfer coefficient between fluid and refrigerant.
</p>
<p>
Variable speed is achieved by multiplying the full load suction volume flow rate
by the normalized compressor speed. The power and heat transfer rates are forced
to zero if the resulting heat pump state has higher evaporating pressure than
condensing pressure.
</p>
<p>
The model parameters are obtained by calibration of the heat pump model to
manufacturer performance data. Calibrated model parameters for various heat
pumps from different manufacturers are found in
<a href=\"modelica://IDEAS.Fluid.HeatPumps.Data.ScrollWaterToWater\">
IDEAS.Fluid.HeatPumps.Data.ScrollWaterToWater</a>. The calibrated model is
located in
<a href=\"modelica://IDEAS.Fluid.HeatPumps.Calibration.ScrollWaterToWater\">
IDEAS.Fluid.HeatPumps.Calibration.ScrollWaterToWater</a>.
</p>
<h4>Options</h4>
<p>
Parameters <code>TConMax</code> and <code>TEvaMin</code>
may be used to set an upper or lower bound for the
condenser and evaporator.
The compressor is disabled when these conditions
are not satisfied, or when the
evaporator temperature is larger
than the condenser temperature.
This mimics the temperature protection
of heat pumps and moreover it avoids
non-converging algebraic loops of equations,
or freezing of evaporator medium.
This option can be disabled by setting
<code>enable_temperature_protection = false</code>.
</p>
<h4>Assumptions and limitations</h4>
<p>
The compression process is assumed isentropic. The thermal energy
of superheating is ignored in the evaluation of the heat transferred to the refrigerant
in the evaporator. There is no supercooling.
</p>
<h4>References</h4>
<p>
H. Jin.
<i>
Parameter estimation based models of water source heat pumps.
</i>
PhD Thesis. Oklahoma State University. Stillwater, Oklahoma, USA. 2012.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 30, 2017, by Filip Jorissen:<br/>
Revised documentation for temperature protection.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
<li>
November 11, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ScrollWaterToWater;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for heat pumps.
</p>
</html>"));
    end HeatPumps;

    package Interfaces "Package with interfaces for fluid models"
      extends Modelica.Icons.InterfacesPackage;

      model ConservationEquation "Lumped volume with mass and energy balance"
        extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations;
        // Constants
        parameter Boolean initialize_p = not Medium.singleState
          "= true to set up initial equations for pressure"
          annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));
        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";
        // Port definitions
        parameter Integer nPorts=0 "Number of ports"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s") if
             use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if
             use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
        // Outputs that are needed in models that use this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=hStart)
          "Leaving specific enthalpy of the component"
           annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));
        Modelica.Blocks.Interfaces.RealOutput UOut(unit="J")
          "Internal energy of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,20})));
        Modelica.Blocks.Interfaces.RealOutput mXiOut[Medium.nXi](each min=0, each unit=
             "kg") "Species mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-20})));
        Modelica.Blocks.Interfaces.RealOutput mOut(min=0, unit="kg")
          "Mass of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,60})));
        Modelica.Blocks.Interfaces.RealOutput mCOut[Medium.nC](each min=0, each unit="kg")
          "Trace substance mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-60})));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each final package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-100})));
        // Set nominal attributes where literal values can be used.
        Medium.BaseProperties medium(
          p(start=p_start),
          h(start=hStart),
          T(start=T_start),
          Xi(start=X_start[1:Medium.nXi]),
          X(start=X_start),
          d(start=rho_start)) "Medium properties";
        Modelica.SIunits.Energy U(start=fluidVolume*rho_start*
          Medium.specificInternalEnergy(Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) +
          (T_start - Medium.reference_T)*CSen,
          nominal = 1E5) "Internal energy of fluid";
        Modelica.SIunits.Mass m(
          start=fluidVolume*rho_start,
          stateSelect=if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
          then StateSelect.default else StateSelect.prefer)
          "Mass of fluid";
        Modelica.SIunits.Mass[Medium.nXi] mXi(
          start=fluidVolume*rho_start*X_start[1:Medium.nXi])
          "Masses of independent components in the fluid";
        Modelica.SIunits.Mass[Medium.nC] mC(
          start=fluidVolume*rho_start*C_start)
          "Masses of trace substances in the fluid";
        // C need to be added here because unlike for Xi, which has medium.Xi,
        // there is no variable medium.C
        Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
          "Trace substance mixture content";
        Modelica.SIunits.MassFlowRate mb_flow "Mass flows across boundaries";
        Modelica.SIunits.MassFlowRate[Medium.nXi] mbXi_flow
          "Substance mass flows across boundaries";
        Medium.ExtraPropertyFlowRate[Medium.nC] mbC_flow
          "Trace substance mass flows across boundaries";
        Modelica.SIunits.EnthalpyFlowRate Hb_flow
          "Enthalpy flow across boundaries or energy source/sink";
        // Parameters that need to be defined by an extending class
        parameter Modelica.SIunits.Volume fluidVolume "Volume";
        final parameter Modelica.SIunits.HeatCapacity CSen=
          (mSenFac - 1)*rho_default*cp_default*fluidVolume
          "Aditional heat capacity for implementing mFactor";
    protected
        Medium.EnthalpyFlowRate ports_H_flow[nPorts];
        Modelica.SIunits.MassFlowRate ports_mXi_flow[nPorts,Medium.nXi];
        Medium.ExtraPropertyFlowRate ports_mC_flow[nPorts,Medium.nC];
        parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
        Medium.specificHeatCapacityCp(state=state_default)
          "Heat capacity, to compute additional dry mass";
        parameter Modelica.SIunits.Density rho_start=Medium.density(
         Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) "Density, used to compute fluid mass";
        // Parameter for avoiding extra overhead calculations when CSen==0
        final parameter Boolean computeCSen = CSen > Modelica.Constants.eps
          annotation(Evaluate=true);
        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.SIunits.Density rho_default=Medium.density(
          state=state_default) "Density, used to compute fluid mass";
        // Parameter that is used to construct the vector mXi_flow
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(
                                                  string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";
        parameter Modelica.SIunits.SpecificEnthalpy hStart=
          Medium.specificEnthalpy_pTX(p_start, T_start, X_start)
          "Start value for specific enthalpy";
        // Set _simplify_mWat_flow == false for Glycol47; otherwise Dymola 2018FD01
        // cannot differentiate the equations.
        constant Boolean _simplify_mWat_flow = simplify_mWat_flow and Medium.nX > 1
         "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";
      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "If Medium.nXi > 1, then substance 'water' must be present for one component.'"
               + Medium.mediumName + "'.\n"
               + "Check medium model.");
        // Make sure that if energyDynamics is SteadyState, then
        // massDynamics is also SteadyState.
        // Otherwise, the system of ordinary differential equations may be inconsistent.
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          assert(massDynamics == energyDynamics, "
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
        end if;
        // initialization of balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
            medium.T = T_start;
        else
          if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
              der(medium.T) = 0;
          end if;
        end if;
        if massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          if initialize_p then
            medium.p = p_start;
          end if;
        else
          if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            if initialize_p then
              der(medium.p) = 0;
            end if;
          end if;
        end if;
        if substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          medium.Xi = X_start[1:Medium.nXi];
        else
          if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(medium.Xi) = zeros(Medium.nXi);
          end if;
        end if;
        if traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          C = C_start[1:Medium.nC];
        else
          if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(C) = zeros(Medium.nC);
          end if;
        end if;
      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;
        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;
        // Total quantities
        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          m = fluidVolume*rho_start;
        else
          if _simplify_mWat_flow then
            // If moisture is neglected in mass balance, assume for computation
            // of the mass of air that the air is at Medium.X_default.
            m = fluidVolume*Medium.density(Medium.setState_phX(
              p = medium.p,
              h = hOut,
              X = Medium.X_default));
          else
            // Use actual density
            m = fluidVolume*medium.d;
          end if;
        end if;
        mXi = m*medium.Xi;
        if computeCSen then
          U = m*medium.u + CSen*(medium.T-Medium.reference_T);
        else
          U = m*medium.u;
        end if;
        mC = m*C;
        hOut = medium.h;
        XiOut = medium.Xi;
        COut = C;
        for i in 1:nPorts loop
          //The semiLinear function should be used for the equations below
          //for allowing min/max simplifications.
          //See https://github.com/ibpsa/modelica-ibpsa/issues/216 for a discussion and motivation
          ports_H_flow[i]     = semiLinear(ports[i].m_flow, inStream(ports[i].h_outflow), ports[i].h_outflow)
            "Enthalpy flow";
          for j in 1:Medium.nXi loop
            ports_mXi_flow[i,j] = semiLinear(ports[i].m_flow, inStream(ports[i].Xi_outflow[j]), ports[i].Xi_outflow[j])
              "Component mass flow";
          end for;
          for j in 1:Medium.nC loop
            ports_mC_flow[i,j]  = semiLinear(ports[i].m_flow, inStream(ports[i].C_outflow[j]),  ports[i].C_outflow[j])
              "Trace substance mass flow";
          end for;
        end for;
        for i in 1:Medium.nXi loop
          mbXi_flow[i] = sum(ports_mXi_flow[:,i]);
        end for;
        for i in 1:Medium.nC loop
          mbC_flow[i]  = sum(ports_mC_flow[:,i]);
        end for;
        mb_flow = sum(ports.m_flow);
        Hb_flow = sum(ports_H_flow);
        // Energy and mass balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = Hb_flow + Q_flow;
        else
          der(U) = Hb_flow + Q_flow;
        end if;
        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        else
          der(m) = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        end if;
        if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nXi) = mbXi_flow + mWat_flow_internal * s;
        else
          der(mXi) = mbXi_flow + mWat_flow_internal * s;
        end if;
        if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nC)  = mbC_flow + C_flow_internal;
        else
          der(mC)  = mbC_flow + C_flow_internal;
        end if;
        // Properties of outgoing flows
        for i in 1:nPorts loop
            ports[i].p          = medium.p;
            ports[i].h_outflow  = medium.h;
            ports[i].Xi_outflow = medium.Xi;
            ports[i].C_outflow  = C;
        end for;
        UOut=U;
        mXiOut=mXi;
        mOut=m;
        mCOut=mC;
        annotation (
          Documentation(info="<html>
<p>
Basic model for an ideally mixed fluid volume with the ability to store mass and energy.
It implements a dynamic or a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code> then adding
moisture does not increase the mass of the volume or the leaving mass flow rate.
It does however change the mass fraction <code>medium.Xi</code>.
This allows to decouple the moisture balance from the pressure drop equations.
If <code>simplify_mWat_flow = false</code>, then
the outlet mass flow rate is
<i>m<sub>out</sub> = m<sub>in</sub>  (1 + &Delta; X<sub>w</sub>)</i>,
where
<i>&Delta; X<sub>w</sub></i> is the change in water vapor mass
fraction across the component. In this case,
this component couples
the energy calculation to the
pressure drop versus mass flow rate calculations.
However, in typical building HVAC systems,
<i>&Delta; X<sub>w</sub></i> &lt; <i>0.005</i> kg/kg.
Hence, by tolerating a relative error of <i>0.005</i> in the mass balance,
one can decouple these equations.
Decoupling these equations avoids having
to compute the energy balance of the humidifier
and its upstream components when solving for the
pressure drop of downstream components.
Therefore, the default value is <code>simplify_mWat_flow = true</code>.
</p>
<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
The model
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling\">
IDEAS.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling</a>
shows that the relative error on the temperature difference between these
two options of <code>simplify_mWat_flow</code> is less than
<i>0.1%</i>.
</p>

<h4>Implementation</h4>
<p>
When extending or instantiating this model, the input
<code>fluidVolume</code>, which is the actual volume occupied by the fluid,
needs to be assigned.
For most components, this can be set to a parameter.
</p>
Input connectors of the model are
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can be used as a dynamic model or as a steady-state model.
However, for a steady-state model with exactly two fluid ports connected,
the model
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
provides a more efficient implementation.
</p>
<p>
For a model that instantiates this model, see
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolume\">
IDEAS.Fluid.MixingVolumes.MixingVolume</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 16, 2018, by Michael Wetter:<br/>
Reformulated mass calculation so that Dymola can differentiate the equations.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/910\">IDEAS, issue 910</a>.
</li>
<li>
November 3, 2017, by Michael Wetter:<br/>
Set <code>start</code> attributes.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/727\">727</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
January 27, 2017, by Michael Wetter:<br/>
Added <code>stateSelect</code> for mass <code>m</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/642\">
Buildings, #642</a>.
</li>
<li>
December 22, 2016, by Michael Wetter:<br/>
Set nominal value for <code>U</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/637\">637</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs UOut, mOut, mXiOut, mCOut for being able to
check conservation of quantities.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Added <code>C_flow</code> to the steady-state trace substance balance,
and removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
</li>
<li>
September 3, 2015, by Filip Jorissen and Michael Wetter:<br/>
Revised implementation for allowing moisture mass flow rate
to be approximated using parameter <code>simplify_mWat_flow</code>.
This may lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
June 5, 2015 by Michael Wetter:<br/>
Removed <code>preferredMediumStates= false</code> in
the instance <code>medium</code> as the default
is already <code>false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015 by Filip Jorissen:<br/>
Removed <pre>
Xi(start=X_start[1:Medium.nXi],
       each stateSelect=if (not (substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
       then StateSelect.prefer else StateSelect.default),
</pre>
and set
<code>preferredMediumStates = false</code>
because the previous declaration led to more equations and
translation problems in large models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> of <code>PartialMixingVolume</code>
to this model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
This revison also renames the protected variable
<code>rho_nominal</code> to <code>rho_start</code>
as it depends on the start values and not the nominal values.
</li>
<li>
May 22, 2015 by Michael Wetter:<br/>
Removed <pre>
p(stateSelect=if not (massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
then StateSelect.prefer else StateSelect.default)
</pre>
because the previous declaration led to the translation error
<pre>
The model requires derivatives of some inputs as listed below:
1 inlet.m_flow
1 inlet.p
</pre>
when translating
<code>Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.HeaterCooler_u</code>
with a dynamic energy balance.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
April 13, 2015, by Filip Jorissen:<br/>
Now using <code>semiLinear()</code> function for calculation of
<code>ports_H_flow</code>. This enables Dymola to simplify based on
the <code>min</code> and <code>max</code> attribute of the mass flow rate.
</li>
<li>
February 16, 2015, by Filip Jorissen:<br/>
Fixed SteadyState massDynamics implementation for compressible media.
Mass <code>m</code> is now constant.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Set start attributes in <code>medium</code> to avoid in OpenModelica the warning
alias set with several free start values.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>
September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.<br/>
Corrected the syntax error
<code>Medium.ExtraProperty C[Medium.nC](each nominal=C_nominal)</code>
to
<code>Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)</code>
because <code>C_nominal</code> is a vector.
This syntax error caused a compilation error in OpenModelica.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
July 31, 2011 by Michael Wetter:<br/>
Added test to stop model translation if the setting for
<code>energyBalance</code> and <code>massBalance</code>
can lead to inconsistent equations.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Removed the option to use <code>h_start</code>, as this
is not needed for building simulation.
Also removed the reference to <code>Modelica.Fluid.System</code>.
Moved parameters and medium to
<a href=\"IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations\">
IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start value for medium density.
</li>
<li>
March 29, 2011 by Michael Wetter:<br/>
Changed default value for <code>substanceDynamics</code> and
<code>traceDynamics</code> from <code>energyDynamics</code>
to <code>massDynamics</code>.
</li>
<li>
September 28, 2010 by Michael Wetter:<br/>
Changed array index for nominal value of <code>Xi</code>.
</li>
<li>
September 13, 2010 by Michael Wetter:<br/>
Set nominal attributes for medium based on default medium values.
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added parameter <code>C_nominal</code> which is used as the nominal attribute for <code>C</code>.
Without this value, the ODE solver gives wrong results for concentrations around 1E-7.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li><i>February 6, 2010</i> by Michael Wetter:<br/>
Added to <code>Medium.BaseProperties</code> the initialization
<code>X(start=X_start[1:Medium.nX])</code>. Previously, the initialization
was only done for <code>Xi</code> but not for <code>X</code>, which caused the
medium to be initialized to <code>reference_X</code>, ignoring the value of <code>X_start</code>.
</li>
<li><i>October 12, 2009</i> by Michael Wetter:<br/>
Implemented first version in <code>Buildings</code> library, based on model from
<code>Modelica.Fluid 1.0</code>.
</li>
</ul>
</html>"),Icon(graphics={            Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-89,17},{-54,34}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-89,52},{-54,69}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-42,-28},{-6,-28},{18,4},{40,12},{66,14}},
                color={255,255,255},
                smooth=Smooth.Bezier),
              Text(
                extent={{-155,-120},{145,-160}},
                lineColor={0,0,255},
                textString="%name")}));
      end ConservationEquation;

      record FourPortFlowResistanceParameters
        "Parameters for flow resistance for models with four ports"
        parameter Boolean computeFlowResistance1 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 1"));
        parameter Boolean from_dp1 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance1,
                      tab="Flow resistance", group="Medium 1"));
        parameter Modelica.SIunits.PressureDifference dp1_nominal(min=0,
                                                                  displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance1 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance1,
                     tab="Flow resistance", group="Medium 1"));
        parameter Real deltaM1 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance1,
                            tab="Flow resistance", group="Medium 1"));
        parameter Boolean computeFlowResistance2 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 2"));
        parameter Boolean from_dp2 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance2,
                      tab="Flow resistance", group="Medium 2"));
        parameter Modelica.SIunits.PressureDifference dp2_nominal(min=0,
                                                                  displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance2 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance2,
                     tab="Flow resistance", group="Medium 2"));
        parameter Real deltaM2 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance2,
                            tab="Flow resistance", group="Medium 2"));
      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in components that have two fluid streams.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://IDEAS.Fluid.Interfaces.PartialFourPortInterface\">
PartialFourPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FourPortFlowResistanceParameters;

      model FourPortHeatMassExchanger
        "Model transporting two fluid streams between four ports with storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialFourPortInterface(
          port_a1(h_outflow(start=h1_outflow_start)),
          port_b1(h_outflow(start=h1_outflow_start)),
          port_a2(h_outflow(start=h2_outflow_start)),
          port_b2(h_outflow(start=h2_outflow_start)));
        extends IDEAS.Fluid.Interfaces.FourPortFlowResistanceParameters(
           final computeFlowResistance1=true, final computeFlowResistance2=true);
        parameter Modelica.SIunits.Time tau1 = 30 "Time constant at nominal flow"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));
        parameter Modelica.SIunits.Time tau2 = 30 "Time constant at nominal flow"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));
        // Advanced
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        // Initialization
        parameter Medium1.AbsolutePressure p1_start = Medium1.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 1"));
        parameter Medium1.Temperature T1_start = Medium1.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 1"));
        parameter Medium1.MassFraction X1_start[Medium1.nX] = Medium1.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nXi > 0));
        parameter Medium1.ExtraProperty C1_start[Medium1.nC](
          final quantity=Medium1.extraPropertiesNames)=fill(0, Medium1.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nC > 0));
        parameter Medium1.ExtraProperty C1_nominal[Medium1.nC](
          final quantity=Medium1.extraPropertiesNames) = fill(1E-2, Medium1.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nC > 0));
        parameter Medium2.AbsolutePressure p2_start = Medium2.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 2"));
        parameter Medium2.Temperature T2_start = Medium2.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 2"));
        parameter Medium2.MassFraction X2_start[Medium2.nX] = Medium2.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nXi > 0));
        parameter Medium2.ExtraProperty C2_start[Medium2.nC](
          final quantity=Medium2.extraPropertiesNames)=fill(0, Medium2.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nC > 0));
        parameter Medium2.ExtraProperty C2_nominal[Medium2.nC](
          final quantity=Medium2.extraPropertiesNames) = fill(1E-2, Medium2.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nC > 0));
        Modelica.SIunits.HeatFlowRate Q1_flow = vol1.heatPort.Q_flow
          "Heat flow rate into medium 1";
        Modelica.SIunits.HeatFlowRate Q2_flow = vol2.heatPort.Q_flow
          "Heat flow rate into medium 2";
        replaceable IDEAS.Fluid.MixingVolumes.BaseClasses.MixingVolumeHeatPort vol1
          constrainedby
        IDEAS.Fluid.MixingVolumes.BaseClasses.MixingVolumeHeatPort(
              redeclare final package Medium = Medium1,
              nPorts = 2,
              V=m1_flow_nominal*tau1/rho1_nominal,
              final allowFlowReversal=allowFlowReversal1,
              final m_flow_nominal=m1_flow_nominal,
              energyDynamics=if tau1 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
              massDynamics=if tau1 > Modelica.Constants.eps
                               then massDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
              final p_start=p1_start,
              final T_start=T1_start,
              final X_start=X1_start,
              final C_start=C1_start,
              final C_nominal=C1_nominal,
              mSenFac=1) "Volume for fluid 1"
          annotation (Placement(transformation(extent={{-10,70}, {10,50}})));
        replaceable IDEAS.Fluid.MixingVolumes.MixingVolume vol2
          constrainedby
        IDEAS.Fluid.MixingVolumes.BaseClasses.MixingVolumeHeatPort(
              redeclare final package Medium = Medium2,
              nPorts = 2,
              V=m2_flow_nominal*tau2/rho2_nominal,
              final allowFlowReversal=allowFlowReversal2,
              mSenFac=1,
              final m_flow_nominal = m2_flow_nominal,
              energyDynamics=if tau2 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
              massDynamics=if tau2 > Modelica.Constants.eps
                               then massDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
              final p_start=p2_start,
              final T_start=T2_start,
              final X_start=X2_start,
              final C_start=C2_start,
              final C_nominal=C2_nominal) "Volume for fluid 2"
         annotation (Placement(transformation(
              origin={2,-60},
              extent={{-10,10},{10,-10}},
              rotation=180)));
        IDEAS.Fluid.FixedResistances.PressureDrop preDro1(
          redeclare final package Medium = Medium1,
          final m_flow_nominal=m1_flow_nominal,
          final deltaM=deltaM1,
          final allowFlowReversal=allowFlowReversal1,
          final show_T=false,
          final from_dp=from_dp1,
          final linearized=linearizeFlowResistance1,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp1_nominal) "Flow resistance of fluid 1"
          annotation (Placement(transformation(extent={{-80,70},{-60,90}})));
        IDEAS.Fluid.FixedResistances.PressureDrop preDro2(
          redeclare final package Medium = Medium2,
          final m_flow_nominal=m2_flow_nominal,
          final deltaM=deltaM2,
          final allowFlowReversal=allowFlowReversal2,
          final show_T=false,
          final from_dp=from_dp2,
          final linearized=linearizeFlowResistance2,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp2_nominal) "Flow resistance of fluid 2"
          annotation (Placement(transformation(extent={{80,-90},{60,-70}})));
    protected
        parameter Medium1.ThermodynamicState sta1_nominal=Medium1.setState_pTX(
            T=Medium1.T_default, p=Medium1.p_default, X=Medium1.X_default);
        parameter Modelica.SIunits.Density rho1_nominal=Medium1.density(sta1_nominal)
          "Density, used to compute fluid volume";
        parameter Medium2.ThermodynamicState sta2_nominal=Medium2.setState_pTX(
            T=Medium2.T_default, p=Medium2.p_default, X=Medium2.X_default);
        parameter Modelica.SIunits.Density rho2_nominal=Medium2.density(sta2_nominal)
          "Density, used to compute fluid volume";
        parameter Medium1.ThermodynamicState sta1_start=Medium1.setState_pTX(
            T=T1_start, p=p1_start, X=X1_start);
        parameter Modelica.SIunits.SpecificEnthalpy h1_outflow_start = Medium1.specificEnthalpy(sta1_start)
          "Start value for outflowing enthalpy";
        parameter Medium2.ThermodynamicState sta2_start=Medium2.setState_pTX(
            T=T2_start, p=p2_start, X=X2_start);
        parameter Modelica.SIunits.SpecificEnthalpy h2_outflow_start = Medium2.specificEnthalpy(sta2_start)
          "Start value for outflowing enthalpy";
      initial equation
        // Check for tau1
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau1 > Modelica.Constants.eps,
      "The parameter tau1, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau1 = "       + String(tau1) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau1 > Modelica.Constants.eps,
      "The parameter tau1, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau1 = "       + String(tau1) + "\n");
       // Check for tau2
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau2 > Modelica.Constants.eps,
      "The parameter tau2, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau2 = "       + String(tau2) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau2 > Modelica.Constants.eps,
      "The parameter tau2, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau2 = "       + String(tau2) + "\n");
      equation
        connect(vol1.ports[2], port_b1) annotation (Line(
            points={{0,70},{20,70},{20,60},{100,60}},
            color={0,127,255}));
        connect(vol2.ports[2], port_b2) annotation (Line(
            points={{2,-70},{-30,-70},{-30,-60},{-100,-60}},
            color={0,127,255}));
        connect(port_a1, preDro1.port_a) annotation (Line(
            points={{-100,60},{-90,60},{-90,80},{-80,80}},
            color={0,127,255}));
        connect(preDro1.port_b, vol1.ports[1]) annotation (Line(
            points={{-60,80},{0,80},{0,70}},
            color={0,127,255}));
        connect(port_a2, preDro2.port_a) annotation (Line(
            points={{100,-60},{90,-60},{90,-80},{80,-80}},
            color={0,127,255}));
        connect(preDro2.port_b, vol2.ports[1]) annotation (Line(
            points={{60,-80},{2,-80},{2,-70}},
            color={0,127,255}));
        annotation (
          Documentation(info="<html>
<p>
This component transports two fluid streams between four ports.
It provides the basic model for implementing a dynamic heat exchanger.
</p>
<p>
The model can be used as-is, although there will be no heat or mass transfer
between the two fluid streams.
To add heat transfer, heat flow can be added to the heat port of the two volumes.
See for example
<a href=\"IDEAS.Fluid.Chillers.Carnot_y\">
IDEAS.Fluid.Chillers.Carnot_y</a>.
To add moisture input into (or moisture output from) volume <code>vol2</code>,
the model can be replaced with
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolumeMoistAir\">
IDEAS.Fluid.MixingVolumes.MixingVolumeMoistAir</a>.
</p>
<h4>Implementation</h4>
<p>
The variable names follow the conventions used in
<a href=\"modelica://Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX\">
Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 23, 2017, by Michael Wetter:<br/>
Made volume <code>vol1</code> replaceable. This is required for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Set <code>quantity</code> attributes.
</li>
<li>
November 13, 2015, by Michael Wetter:<br/>
Changed assignments of start values in <code>extends</code> statement.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/299\">#299</a>.
</li>
<li>
June 2, 2015, by Filip Jorissen:<br/>
Removed final modifier from <code>mSenFac</code> in
<code>vol1</code> and <code>vol2</code>.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/258=\">#258</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Added missing propagation of <code>allowFlowReversal</code> to
instances <code>vol1</code> and <code>vol2</code>.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">#412</a>.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in pressure drop elements to be final.
</li>
<li>
May 28, 2014, by Michael Wetter:<br/>
Removed <code>annotation(Evaluate=true)</code> for parameters <code>tau1</code>
and <code>tau2</code>.
This is needed to allow changing the time constant after translation.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
September 26, 2013, by Michael Wetter:<br/>
Removed unrequired <code>sum</code> operator.
</li>
<li>
February 6, 2012, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Removed assignment of <code>m_flow_small</code> as it is no
longer used in its base class.
</li>
<li>
July 29, 2011, by Michael Wetter:
<ul>
<li>
Changed values of
<code>h_outflow_a1_start</code>,
<code>h_outflow_b1_start</code>,
<code>h_outflow_a2_start</code> and
<code>h_outflow_b2_start</code>, and
declared them as final.
</li>
<li>
Set nominal values for <code>vol1.C</code> and <code>vol2.C</code>.
</li>
</ul>
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Changed parameterization of fluid volume so that steady-state balance is
used when <code>tau = 0</code>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
September 10, 2008 by Michael Wetter:<br/>
Added <code>stateSelect=StateSelect.always</code> for temperature of volume 1.
</li>
<li>
Changed temperature sensor from Celsius to Kelvin.
Unit conversion should be made during output
processing.
</li>
<li>
August 5, 2008, by Michael Wetter:<br/>
Replaced instances of <code>Delays.DelayFirstOrder</code> with instances of
<code>MixingVolumes.MixingVolume</code>. This allows to extract liquid for a condensing cooling
coil model.
</li>
<li>
March 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-99,64},{102,54}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-99,-56},{102,-66}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end FourPortHeatMassExchanger;

      model IdealSource
        "Base class for pressure and mass flow source with optional power input"
        extends IDEAS.Fluid.Movers.BaseClasses.IdealSource(m_flow_small=Modelica.Constants.small);
        annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,60},{100,-60}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,50},{100,-48}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Text(
                visible=not control_m_flow,
                extent={{24,44},{80,24}},
                lineColor={255,255,255},
                textString="dp"),
              Text(
                visible=control_m_flow,
                extent={{-80,44},{-24,24}},
                lineColor={255,255,255},
                textString="m")}),
          Documentation(info="<html>
<p>
Model of a fictitious pipe that is used as a base class
for a pressure source or to prescribe a mass flow rate.
</p>
<p>
Note that for fans and pumps with dynamic balance,
both the heat and the flow work are added to the volume of
air or water. This simplifies the equations compared to 
adding heat to the volume, and flow work to this model.
</p>
</html>",
      revisions="<html>
<ul>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
Removed the option to add power to the medium, as this is dealt with in the volume
that is used in the mover model.
</li>
<li>
July 27, 2010 by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>
April 13, 2010 by Michael Wetter:<br/>
Made heat connector optional.
</li>
<li>
March 23, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                  100,100}}),
                          graphics));
      end IdealSource;

      record LumpedVolumeDeclarations "Declarations for lumped volumes"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=energyDynamics
          "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics traceDynamics=energyDynamics
          "Type of trace substance balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start=Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
             quantity=Medium.substanceNames) = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Medium.ExtraProperty C_nominal[Medium.nC](
             quantity=Medium.extraPropertiesNames) = fill(1E-2, Medium.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Real mSenFac(min=1)=1
          "Factor for scaling the sensible thermal mass of the volume"
          annotation(Dialog(tab="Dynamics"));

      annotation (preferredView="info",
      Documentation(info="<html>
<p>
This class contains parameters and medium properties
that are used in the lumped  volume model, and in models that extend the
lumped volume model.
</p>
<p>
These parameters are used for example by
<a href=\"modelica://IDEAS.Fluid.Interfaces.ConservationEquation\">
IDEAS.Fluid.Interfaces.ConservationEquation</a>,
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolume\">
IDEAS.Fluid.MixingVolumes.MixingVolume</a> and
<a href=\"modelica://IDEAS.Fluid.HeatExchangers.Radiators.RadiatorEN442_2\">
IDEAS.Fluid.HeatExchangers.Radiators.RadiatorEN442_2</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
November 9, 2018 by Michael Wetter:<br/>
Limited choices of media that are displayed in the pull down menu of
graphical editors.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">issue 1050</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
August 2, 2011, by Michael Wetter:<br/>
Set <code>substanceDynamics</code> and <code>traceDynamics</code> to final
and equal to <code>energyDynamics</code>,
as there is no need to make them different from <code>energyDynamics</code>.
</li>
<li>
August 1, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.DynamicFreeInitial</code> because
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code> leads
to high order DAE that Dymola cannot reduce.
</li>
<li>
July 31, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LumpedVolumeDeclarations;

      partial model PartialFourPort "Partial model with four ports"

        replaceable package Medium1 =
          Modelica.Media.Interfaces.PartialMedium "Medium 1 in the component"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));
        replaceable package Medium2 =
          Modelica.Media.Interfaces.PartialMedium "Medium 2 in the component"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal1 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Boolean allowFlowReversal2 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a1(
                           redeclare final package Medium = Medium1,
                           m_flow(min=if allowFlowReversal1 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{-110,50},{-90,70}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b1(
                           redeclare final package Medium = Medium1,
                           m_flow(max=if allowFlowReversal1 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector b1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{110,50},{90,70}})));

        Modelica.Fluid.Interfaces.FluidPort_a port_a2(
                           redeclare final package Medium = Medium2,
                           m_flow(min=if allowFlowReversal2 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector a2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b2(
                           redeclare final package Medium = Medium2,
                           m_flow(max=if allowFlowReversal2 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector b2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{-90,-70},{-110,-50}})));

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model defines an interface for components with four ports.
The parameters <code>allowFlowReversal1</code> and
<code>allowFlowReversal2</code> may be used by models that extend
this model to treat flow reversal.
</p>
<p>
This model is identical to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>, except for the
fowllowing:
</p>
<ol>
<li>it has four ports, and
</li>
<li>
the parameters <code>port_a_exposesState</code>,
<code>port_b_exposesState</code> and
<code>showDesignFlowDirection</code>
are not implemented.
</li>
</ol>
</html>",       revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Renamed model from <code>FourPort</code> to
<code>PartialFourPort</code>.
Removed parameters
<code>h_outflow_a1_start</code>,
<code>h_outflow_b1_start</code>,
<code>h_outflow_a2_start</code> and
<code>h_outflow_b2_start</code>.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/299\">#299</a>.
</li>
<li>
October 30, 2015, by Matthis Thorade:<br/>
Added <code>partial</code> keyword to model declaration.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
September 26, 2013 by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of nominal value for
<code>Xi_outflow</code>.
</li>
<li>
September 17, 2010 by Michael Wetter:<br/>
Fixed bug: The start value for <code>port_b1.h_outflow</code>
was set to <code>h_outflow_b2_start</code> instead of <code>h_outflow_b1_start</code>.
</li>
<li>
February 26, 2010 by Michael Wetter:<br/>
Added start values for outflowing enthalpy because they
are often iteration variables in nonlinear equation systems.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={Text(
                extent={{-151,147},{149,107}},
                lineColor={0,0,255},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                textString="%name")}));
      end PartialFourPort;

      partial model PartialFourPortInterface
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialFourPort;
        parameter Modelica.SIunits.MassFlowRate m1_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m2_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Medium1.MassFlowRate m1_flow_small(min=0) = 1E-4*abs(m1_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium2.MassFlowRate m2_flow_small(min=0) = 1E-4*abs(m2_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
        parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        Medium1.MassFlowRate m1_flow = port_a1.m_flow
          "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp1(displayUnit="Pa") = port_a1.p - port_b1.p
          "Pressure difference between port_a1 and port_b1";
        Medium2.MassFlowRate m2_flow = port_a2.m_flow
          "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp2(displayUnit="Pa") = port_a2.p - port_b2.p
          "Pressure difference between port_a2 and port_b2";
        Medium1.ThermodynamicState sta_a1=
            Medium1.setState_phX(port_a1.p,
                                 noEvent(actualStream(port_a1.h_outflow)),
                                 noEvent(actualStream(port_a1.Xi_outflow))) if
               show_T "Medium properties in port_a1";
        Medium1.ThermodynamicState sta_b1=
            Medium1.setState_phX(port_b1.p,
                                 noEvent(actualStream(port_b1.h_outflow)),
                                 noEvent(actualStream(port_b1.Xi_outflow))) if
               show_T "Medium properties in port_b1";
        Medium2.ThermodynamicState sta_a2=
            Medium2.setState_phX(port_a2.p,
                                 noEvent(actualStream(port_a2.h_outflow)),
                                 noEvent(actualStream(port_a2.Xi_outflow))) if
               show_T "Medium properties in port_a2";
        Medium2.ThermodynamicState sta_b2=
            Medium2.setState_phX(port_b2.p,
                                 noEvent(actualStream(port_b2.h_outflow)),
                                 noEvent(actualStream(port_b2.Xi_outflow))) if
               show_T "Medium properties in port_b2";
    protected
        Medium1.ThermodynamicState state_a1_inflow=
          Medium1.setState_phX(port_a1.p, inStream(port_a1.h_outflow), inStream(port_a1.Xi_outflow))
          "state for medium inflowing through port_a1";
        Medium1.ThermodynamicState state_b1_inflow=
          Medium1.setState_phX(port_b1.p, inStream(port_b1.h_outflow), inStream(port_b1.Xi_outflow))
          "state for medium inflowing through port_b1";
        Medium2.ThermodynamicState state_a2_inflow=
          Medium2.setState_phX(port_a2.p, inStream(port_a2.h_outflow), inStream(port_a2.Xi_outflow))
          "state for medium inflowing through port_a2";
        Medium2.ThermodynamicState state_b2_inflow=
          Medium2.setState_phX(port_b2.p, inStream(port_b2.h_outflow), inStream(port_b2.Xi_outflow))
          "state for medium inflowing through port_b2";
        annotation (
        preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that
transport two fluid streams between four ports.
It is similar to
<a href=\"modelica://IDEAS.Fluid.Interfaces.PartialTwoPortInterface\">
IDEAS.Fluid.Interfaces.PartialTwoPortInterface</a>,
but it has four ports instead of two.
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Removed assignment of <code>min</code> and <code>max</code>
attributes of port mass flow rates, as this is already
done in the base class.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a1</code>,
<code>sta_a2</code>, <code>sta_b1</code> and <code>sta_b2</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definitions of <code>dp1</code> and <code>dp2</code> because they cause some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Replaced the erroneous function call <code>Medium.density</code> with
<code>Medium1.density</code> and <code>Medium2.density</code>.
Changed condition to remove <code>sta_a1</code> and <code>sta_a2</code> to also
compute the states at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialFourPortInterface;

      partial model PartialTwoPort "Partial component with two ports"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a(
          redeclare final package Medium = Medium,
           m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector a (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(
          redeclare final package Medium = Medium,
          m_flow(max=if allowFlowReversal then +Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector b (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{110,-10},{90,10}})));

        annotation (
          Documentation(info="<html>
<p>
This partial model defines an interface for components with two ports.
The treatment of the design flow direction and of flow reversal are predefined based on the parameter <code>allowFlowReversal</code>.
The component may transport fluid and may have internal storage for a given fluid <code>Medium</code>.
</p>
<h4>Implementation</h4>
<p>
This model is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>
but it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>
and
<code>showDesignFlowDirection</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
November 13, 2015, by Michael Wetter:<br/>
Assinged <code>start</code> attribute for leaving
enthalpy at <code>port_a</code> and <code>port_b</code>.
This was done to make the model similar to
<a href=\"modelica://IDEAS.Fluid.Interfaces.PartialFourPort\">
IDEAS.Fluid.Interfaces.PartialFourPort</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Removed import statement.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
Declared medium in ports to be <code>final</code>.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Polygon(
                points={{20,-70},{60,-85},{20,-100},{20,-70}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=not allowFlowReversal),
              Line(
                points={{55,-85},{-60,-85}},
                color={0,128,255},
                visible=not allowFlowReversal),
              Text(
                extent={{-149,-114},{151,-154}},
                lineColor={0,0,255},
                textString="%name")}));
      end PartialTwoPort;

      partial model PartialTwoPortInterface
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialTwoPort(
          port_a(p(start=Medium.p_default)),
          port_b(p(start=Medium.p_default)));
        parameter Modelica.SIunits.MassFlowRate m_flow_nominal
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
         parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        Modelica.SIunits.MassFlowRate m_flow(start=_m_flow_start) = port_a.m_flow
          "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp(start=_dp_start, displayUnit="Pa") = port_a.p - port_b.p
          "Pressure difference between port_a and port_b";
        Medium.ThermodynamicState sta_a=
            Medium.setState_phX(port_a.p,
                                noEvent(actualStream(port_a.h_outflow)),
                                noEvent(actualStream(port_a.Xi_outflow))) if
               show_T "Medium properties in port_a";
        Medium.ThermodynamicState sta_b=
            Medium.setState_phX(port_b.p,
                                noEvent(actualStream(port_b.h_outflow)),
                                noEvent(actualStream(port_b.Xi_outflow))) if
                show_T "Medium properties in port_b";
    protected
        final parameter Modelica.SIunits.MassFlowRate _m_flow_start = 0
        "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window";
        final parameter Modelica.SIunits.PressureDifference _dp_start(displayUnit="Pa") = 0
        "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window";
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that
transports a fluid between two ports. It is similar to
<a href=\"Modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>, but it does not
include the species balance
</p>
<pre>
  port_b.Xi_outflow = inStream(port_a.Xi_outflow);
</pre>
<p>
Thus, it can be used as a base class for a heat <i>and</i> mass transfer component
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations. See for example
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Renamed protected parameter <code>m_flow_start</code> to avoid
a name clash with
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_m_flow\">
IDEAS.Fluid.Movers.FlowControlled_m_flow</a>
which leads to an error as the definition were different,
and also renamed protected parameter <code>dp_start</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>
<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a</code> and <code>sta_b</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definition of <code>dp</code> because it causes some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Changed condition to remove <code>sta_a</code> to also
compute the state at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
March 11, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortInterface;

      partial model PartialTwoPortTransport
        "Partial element transporting fluid between two ports without storage of mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialTwoPort;
        // Advanced
        // Note: value of dp_start shall be refined by derived model,
        // based on local dp_nominal
        parameter Modelica.SIunits.PressureDifference dp_start(displayUnit="Pa") = 0
          "Guess value of dp = port_a.p - port_b.p"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium.MassFlowRate m_flow_start = 0
          "Guess value of m_flow = port_a.m_flow"
          annotation(Dialog(tab = "Advanced"));
        // Note: value of m_flow_small shall be refined by derived model,
        // based on local m_flow_nominal
        parameter Medium.MassFlowRate m_flow_small
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
        parameter Boolean show_T = true
          "= true, if temperatures at port_a and port_b are computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        parameter Boolean show_V_flow = true
          "= true, if volume flow rate at inflowing port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        // Variables
        Medium.MassFlowRate m_flow(
           min=if allowFlowReversal then -Modelica.Constants.inf else 0,
           start = m_flow_start) "Mass flow rate in design flow direction";
        Modelica.SIunits.PressureDifference dp(start=dp_start,
                                               displayUnit="Pa")
          "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
        Modelica.SIunits.VolumeFlowRate V_flow=
            m_flow/Modelica.Fluid.Utilities.regStep(m_flow,
                        Medium.density(
                          Medium.setState_phX(
                            p = port_a.p,
                            h = inStream(port_a.h_outflow),
                            X = inStream(port_a.Xi_outflow))),
                        Medium.density(
                             Medium.setState_phX(
                               p = port_b.p,
                               h = inStream(port_b.h_outflow),
                               X = inStream(port_b.Xi_outflow))),
                        m_flow_small) if show_V_flow
          "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
        Medium.Temperature port_a_T=
            Modelica.Fluid.Utilities.regStep(port_a.m_flow,
                        Medium.temperature(
                          Medium.setState_phX(
                            p = port_a.p,
                            h = inStream(port_a.h_outflow),
                            X = inStream(port_a.Xi_outflow))),
                        Medium.temperature(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_a, if show_T = true";
        Medium.Temperature port_b_T=
            Modelica.Fluid.Utilities.regStep(port_b.m_flow,
                        Medium.temperature(
                          Medium.setState_phX(
                            p = port_b.p,
                            h = inStream(port_b.h_outflow),
                            X = inStream(port_b.Xi_outflow))),
                        Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_b, if show_T = true";
      equation
        // Pressure drop in design flow direction
        dp = port_a.p - port_b.p;
        // Design direction of mass flow rate
        m_flow = port_a.m_flow;
        assert(m_flow > -m_flow_small or allowFlowReversal,
            "Reverting flow occurs even though allowFlowReversal is false");
        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;
        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);
        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);
        annotation (
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without storing mass or energy.
Energy may be exchanged with the environment though, e.g., in the form of work.
<code>PartialTwoPortTransport</code> is intended as base class for devices like orifices, valves and simple fluid machines.</p>
<p>
Three equations need to be added by an extending class using this component:
</p>
<ul>
<li>The momentum balance specifying the relationship between the pressure drop <code>dp</code> and the mass flow rate <code>m_flow</code>,</li>
<li><code>port_b.h_outflow</code> for flow in design direction, and</li>
<li><code>port_a.h_outflow</code> for flow in reverse direction.</li>
</ul>
<p>
Moreover appropriate values shall be assigned to the following parameters:
</p>
<ul>
<li><code>dp_start</code> for a guess of the pressure drop</li>
<li><code>m_flow_small</code> for regularization of zero flow.</li>
</ul>
<h4>Implementation</h4>
<p>
This is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>
except that it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 15, 2016, by Michael Wetter:<br/>
Removed wrong annotation, which caused an error in the pedantic model check
of Dymola 2017 FD01.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/516\">#516</a>.
</li>
<li>
January 22, 2016, by Henning Francke:<br/>
Corrected type declaration of pressure.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignments of parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code> in base class.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/305\">#305</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Removed protected conditional variables <code>state_a</code> and <code>state_b</code>,
as they were used outside of a connect statement, which causes an
error during pedantic model check in Dymola 2016.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/128\">#128</a>.
</li>
<li>
April 1, 2015, by Michael Wetter:<br/>
Made computation of <code>state_a</code> and <code>state_p</code>
conditional on <code>show_T</code> or <code>show_V_flow</code>.
This avoids computing temperature from enthalpy if temperature is
a state of the medium, and the result is not used.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortTransport;

      model StaticFourPortHeatMassExchanger
        "Partial model transporting two fluid streams between four ports without storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialFourPortInterface;
        extends IDEAS.Fluid.Interfaces.FourPortFlowResistanceParameters(
         final computeFlowResistance1=(dp1_nominal > Modelica.Constants.eps),
         final computeFlowResistance2=(dp2_nominal > Modelica.Constants.eps));
        constant Boolean prescribedHeatFlowRate1 = false
          "Set to true if the heat flow rate into fluid 1 is not a function of the component temperature";
        constant Boolean prescribedHeatFlowRate2 = false
          "Set to true if the heat flow rate into fluid 2 is not a function of the component temperature";
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        // Q1_flow is sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q1_flow
          "Heat transferred into the medium 1";
        input Medium1.MassFlowRate mWat1_flow
          "Moisture mass flow rate added to the medium 1";
        // Q2_flow is sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q2_flow
          "Heat transferred into the medium 2";
        input Medium2.MassFlowRate mWat2_flow
          "Moisture mass flow rate added to the medium 2";
        constant Boolean sensibleOnly1
          "Set to true if sensible exchange only for medium 1";
        constant Boolean sensibleOnly2
          "Set to true if sensible exchange only for medium 2";
    protected
        IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal1(
          redeclare final package Medium=Medium1,
          final sensibleOnly = sensibleOnly1,
          final prescribedHeatFlowRate=prescribedHeatFlowRate1,
          final m_flow_nominal = m1_flow_nominal,
          final dp_nominal = dp1_nominal,
          final allowFlowReversal = allowFlowReversal1,
          final m_flow_small = m1_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp1,
          final linearizeFlowResistance = linearizeFlowResistance1,
          final deltaM = deltaM1,
          final Q_flow = Q1_flow,
          final mWat_flow = mWat1_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 1";
        IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal2(
          redeclare final package Medium=Medium2,
          final sensibleOnly = sensibleOnly2,
          final prescribedHeatFlowRate=prescribedHeatFlowRate2,
          final m_flow_nominal = m2_flow_nominal,
          final dp_nominal = dp2_nominal,
          final allowFlowReversal = allowFlowReversal2,
          final m_flow_small = m2_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp2,
          final linearizeFlowResistance = linearizeFlowResistance2,
          final deltaM = deltaM2,
          final Q_flow = Q2_flow,
          final mWat_flow = mWat2_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 2";
      equation
        connect(bal1.port_a, port_a1);
        connect(bal1.port_b, port_b1);
        connect(bal2.port_a, port_a2);
        connect(bal2.port_b, port_b2);
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports two fluid streams between four ports, without
storing mass or energy. It is similar to
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>,
but it has four ports instead of two.
</p>
<p>
If <code>dp<i>N</i>_nominal &gt; Modelica.Constants.eps</code>,
where <code><i>N</i></code> denotes the fluid <i>1</i> or <i>2</i>,
then the model computes
pressure drop due to flow friction in the respective fluid stream.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m<i>N</i>_flow_nominal, dp<i>N</i>_nominal)</code>.
At <code>|m<i>N</i>_flow| &lt; deltaM<i>N</i> * m<i>N</i>_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance<i>N</i></code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>

<h4>Implementation</h4>
<p>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned, where <code><i>N</i></code> denotes <code>1</code> or
<code>2</code>:</p>
<ul>
<li>
<code>Q<i>N</i>_flow</code>, which is the sensible and latent heat flow rate added to the medium <i>N</i>.
</li>
<li>
<code>mWat<i>N</i>_flow</code>, which is the moisture mass flow rate added to the medium <i>N</i>.
</li>
</ul>
<p>
Set the constant <code>sensibleOnly<i>N</i>=true</code> if the model that extends
or instantiates this model sets <code>mWat<i>N</i>_flow = 0</code>.
</p>
<p>
     Note that the model does not implement <code>0 = Q1_flow + Q2_flow</code> or
     <code>0 = mXi1_flow + mXi2_flow</code>. If there is no heat or mass transfer
     with the environment, then a model that extends this model needs to provide these
     equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q1_flow</code> and <code>Q2_flow</code>
include latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constants <code>sensibleOnly1</code> and
<code>sensibleOnly2</code> to
simplify species balance equations.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
March 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,65},{101,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end StaticFourPortHeatMassExchanger;

      model StaticTwoPortConservationEquation
        "Partial model for static energy and mass conservation equations"
        extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface;

        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

        constant Boolean prescribedHeatFlowRate = false
          "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";

        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s") if
             use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if
             use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=Medium.specificEnthalpy_pTX(
                                                           p=Medium.p_default,
                                                           T=Medium.T_default,
                                                           X=Medium.X_default))
          "Leaving specific enthalpy of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));

        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));

    protected
        final parameter Boolean use_m_flowInv=
          (prescribedHeatFlowRate or use_mWat_flow or use_C_flow)
          "Flag, true if m_flowInv is used in the model"
          annotation (Evaluate=true);
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";

        Real m_flowInv(unit="s/kg") "Regularization of 1/m_flow of port_a";

        Modelica.SIunits.MassFlowRate mXi_flow[Medium.nXi]
          "Mass flow rates of independent substances added to the medium";

        // Parameters for inverseXRegularized.
        // These are assigned here for efficiency reason.
        // Otherwise, they would need to be computed each time
        // the function is invocated.
        final parameter Real deltaReg = m_flow_small/1E3
          "Smoothing region for inverseXRegularized";

        final parameter Real deltaInvReg = 1/deltaReg
          "Inverse value of delta for inverseXRegularized";

        final parameter Real aReg = -15*deltaInvReg
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real bReg = 119*deltaInvReg^2
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real cReg = -361*deltaInvReg^3
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real dReg = 534*deltaInvReg^4
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real eReg = -380*deltaInvReg^5
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real fReg = 104*deltaInvReg^6
          "Polynomial coefficient for inverseXRegularized";

        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
          Medium.specificHeatCapacityCp(state=state_default)
          "Specific heat capacity, used to verify energy conservation";
        constant Modelica.SIunits.TemperatureDifference dTMax(min=1) = 200
          "Maximum temperature difference across the StaticTwoPortConservationEquation";
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";
      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "If Medium.nXi > 1, then substance 'water' must be present for one component.'"
               + Medium.mediumName + "'.\n"
               + "Check medium model.");

      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;

        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;

        // Species flow rate from connector mWat_flow
        mXi_flow = mWat_flow_internal * s;

        // Regularization of m_flow around the origin to avoid a division by zero
        // m_flowInv is only used if prescribedHeatFlowRate == true, or
        // if the input connectors mWat_flow or C_flow are enabled.
        if use_m_flowInv then
          m_flowInv = IDEAS.Utilities.Math.Functions.inverseXRegularized(
                             x=port_a.m_flow,
                             delta=deltaReg, deltaInv=deltaInvReg,
                             a=aReg, b=bReg, c=cReg, d=dReg, e=eReg, f=fReg);
        else
          // m_flowInv is not used.
          m_flowInv = 0;
        end if;

        if prescribedHeatFlowRate then
          assert(noEvent( abs(Q_flow) < dTMax*cp_default*max(m_flow_small/1E3, abs(m_flow))),
         "In " + getInstanceName() + ":
   The heat flow rate equals "       + String(Q_flow) +
         " W and the mass flow rate equals " + String(m_flow) + " kg/s,
   which results in a temperature difference "       +
         String(abs(Q_flow)/ (cp_default*max(m_flow_small/1E3, abs(m_flow)))) +
         " K > dTMax=" +String(dTMax) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
        end if;

        if allowFlowReversal then
          // Formulate hOut using spliceFunction. This avoids an event iteration.
          // The introduced error is small because deltax=m_flow_small/1e3
          hOut = IDEAS.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                          y2=port_a.h_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
          XiOut = IDEAS.Utilities.Math.Functions.regStep(y1=port_b.Xi_outflow,
                                                           y2=port_a.Xi_outflow,
                                                           x=port_a.m_flow,
                                                           x_small=m_flow_small/1E3);
          COut = IDEAS.Utilities.Math.Functions.regStep(y1=port_b.C_outflow,
                                                          y2=port_a.C_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
        else
          hOut =  port_b.h_outflow;
          XiOut = port_b.Xi_outflow;
          COut =  port_b.C_outflow;
        end if;

        //////////////////////////////////////////////////////////////////////////////////////////
        // Energy balance and mass balance

          // Mass balance (no storage)
          port_a.m_flow + port_b.m_flow = if simplify_mWat_flow then 0 else -mWat_flow_internal;

          // Substance balance
          // a) forward flow
          if use_m_flowInv then
            port_b.Xi_outflow = inStream(port_a.Xi_outflow) + mXi_flow * m_flowInv;
          else // no water is added
            assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for forward flow.");
            port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          end if;

          // b) backward flow
          if allowFlowReversal then
            if use_m_flowInv then
              port_a.Xi_outflow = inStream(port_b.Xi_outflow) - mXi_flow * m_flowInv;
            else // no water added
              assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for reverse flow.");
              port_a.Xi_outflow = inStream(port_b.Xi_outflow);
            end if;
          else // no  flow reversal
            port_a.Xi_outflow = Medium.X_default[1:Medium.nXi];
          end if;

          // Energy balance.
          // This equation is approximate since m_flow = port_a.m_flow is used for the mass flow rate
          // at both ports. Since mWat_flow_internal << m_flow, the error is small.
          if prescribedHeatFlowRate then
            port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
            if allowFlowReversal then
              port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
            else
              port_a.h_outflow = Medium.h_default;
            end if;
          else
            // Case with prescribedHeatFlowRate == false.
            // port_b.h_outflow is known and the equation needs to be solved for Q_flow.
            // Hence, we cannot use m_flowInv as for m_flow=0, any Q_flow would satisfiy
            // Q_flow * m_flowInv = 0.
            // The same applies for port_b.Xi_outflow and mXi_flow.
            port_a.m_flow * (inStream(port_a.h_outflow) - port_b.h_outflow)     = -Q_flow;
            if allowFlowReversal then
              port_a.m_flow * (inStream(port_b.h_outflow)  - port_a.h_outflow)  = +Q_flow;
            else
              // When allowFlowReversal = false, the downstream enthalpy does not matter.
              // Therefore a dummy value is used to avoid algebraic loops
              port_a.h_outflow = Medium.h_default;
            end if;
          end if;

        // Transport of trace substances
        if use_m_flowInv and use_C_flow then
          port_b.C_outflow =  inStream(port_a.C_outflow) + C_flow_internal * m_flowInv;
        else // no trace substance added.
          assert(not use_C_flow, "In " + getInstanceName() + ": Wrong implementation of trace substance balance for forward flow.");
          port_b.C_outflow =  inStream(port_a.C_outflow);
        end if;

        if allowFlowReversal then
          if use_C_flow then
            port_a.C_outflow = inStream(port_b.C_outflow) - C_flow_internal * m_flowInv;
          else
            port_a.C_outflow = inStream(port_b.C_outflow);
          end if;
        else
          port_a.C_outflow = zeros(Medium.nC);
        end if;

        ////////////////////////////////////////////////////////////////////////////
        // No pressure drop in this model
        port_a.p = port_b.p;

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model transports fluid between its two ports, without storing mass or energy.
It implements a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>

<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
<h4>Implementation</h4>
<p>
Input connectors of the model are
</p>
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can only be used as a steady-state model with two fluid ports.
For a model with a dynamic balance, and more fluid ports, use
<a href=\"modelica://IDEAS.Fluid.Interfaces.ConservationEquation\">
IDEAS.Fluid.Interfaces.ConservationEquation</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
February 12, 2019, by Filip Jorissen:<br/>
Removed obsolete division by <code>TMax</code> in assert.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1097\">#1097</a>.
</li>
<li>
June 23, 2018, by Filip Jorissen:<br/>
Added more details to energy conservation assert to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/962\">#962</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added <code>getInstanceName()</code> in asserts to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/901\">#901</a>.
</li>
<li>
April 24, 2017, by Michael Wetter and Filip Jorissen:<br/>
Reimplemented check for energy conversion.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 24, 2017, by Michael Wetter:<br/>
Reverted change from April 21, 2017.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 21, 2017, by Filip Jorissen:<br/>
Revised test for energy conservation at small mass flow rates.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
October 23, 2016, by Filip Jorissen:<br/>
Added test for energy conservation at small mass flow rates.
</li>
<li>
March 17, 2016, by Michael Wetter:<br/>
Refactored model and implmented <code>regStep</code> instead of <code>spliceFunction</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>
and for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a>.
</li>
<li>
September 3, 2015, by Filip Jorissen:<br/>
Revised implementation of conservation of vapor mass.
Added new variable <code>mFlow_inv_b</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Removed <code>constant sensibleOnly</code> as this is no longer used because
the model uses <code>use_mWat_flow</code>.<br/>
Changed condition that determines whether <code>m_flowInv</code> needs to be
computed because the change from January 20 introduced an error in
<a href=\"modelica://IDEAS.Fluid.MassExchangers.Examples.ConstantEffectiveness\">
IDEAS.Fluid.MassExchangers.Examples.ConstantEffectiveness</a>.
</li>
<li>
January 20, 2016, by Filip Jorissen:<br/>
Removed if-else block in code for parameter <code>sensibleOnly</code>
since this is no longer needed to simplify the equations.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
September 14, 2015, by Filip Jorissen:<br/>
Rewrote some equations for better readability.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
Refactored implementation of
<a href=\"modelica://IDEAS.Utilities.Math.Functions.inverseXRegularized\">
IDEAS.Utilities.Math.Functions.inverseXRegularized</a>
to allow function to be inlined and to factor out the computation
of arguments that only depend on parameters.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Corrected bug for situation with latent heat exchange and flow reversal not
allowed.
The previous formulation was singular.
This caused some models to not translate.
The error was introduced in
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Revised implementation so that equations are always consistent
and do not lead to division by zero,
also when connecting a <code>prescribedHeatFlowRate</code>
to <code>MixingVolume</code> instances.
Renamed <code>use_safeDivision</code> into <code>prescribedHeatFlowRate</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>
for a discussion.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Corrected sign error in the equation that is used if <code>use_safeDivision=false</code>
and <code>sensibleOnly=true</code>.
This only affects internal numerical tests, but not any examples in the library
as the constant <code>use_safeDivision</code> is set to <code>true</code> by default.
</li>
<li>
September 25, 2013 by Michael Wetter:<br/>
Reformulated computation of outlet properties to avoid an event at zero mass flow rate.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.
</li>
<li>
May 7, 2013 by Michael Wetter:<br/>
Removed <code>for</code> loops for species balance and trace substance balance,
as they cause the error <code>Error: Operand port_a.Xi_outflow[1] to operator inStream is not a stream variable.</code>
in OpenModelica.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
June 22, 2012 by Michael Wetter:<br/>
Reformulated implementation with <code>m_flowInv</code> to use <code>port_a.m_flow * ...</code>
if <code>use_safeDivision=false</code>. This avoids a division by zero if
<code>port_a.m_flow=0</code>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IDEAS.Fluid.Interfaces</code>.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-93,72},{-58,89}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Text(
                extent={{-93,37},{-58,54}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-41,103},{-10,117}},
                lineColor={0,0,127},
                textString="hOut"),
              Text(
                extent={{10,103},{41,117}},
                lineColor={0,0,127},
                textString="XiOut"),
              Text(
                extent={{61,103},{92,117}},
                lineColor={0,0,127},
                textString="COut"),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{6,14},{6,-37}},     color={255,255,255}),
              Line(points={{54,14},{6,14}},     color={255,255,255}),
              Line(points={{6,-37},{-42,-37}},  color={255,255,255})}));
      end StaticTwoPortConservationEquation;

      model StaticTwoPortHeatMassExchanger
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface;
        extends IDEAS.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=(abs(dp_nominal) > Modelica.Constants.eps));
        constant Boolean sensibleOnly "Set to true if sensible exchange only";
        constant Boolean prescribedHeatFlowRate
          "Set to true if the heat flow rate is not a function of the component temperature";
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        // Model inputs
        // Q_flow is the sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q_flow "Heat transferred into the medium";
        input Modelica.SIunits.MassFlowRate mWat_flow
          "Moisture mass flow rate added to the medium";
        // Models for conservation equations and pressure drop
        IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation vol(
          redeclare final package Medium = Medium,
          final use_mWat_flow = not sensibleOnly,
          final prescribedHeatFlowRate = prescribedHeatFlowRate,
          final m_flow_nominal = m_flow_nominal,
          final allowFlowReversal=allowFlowReversal,
          final m_flow_small=m_flow_small)
          "Control volume for steady-state energy and mass balance"
          annotation (Placement(transformation(extent={{15,-10}, {35,10}})));
        IDEAS.Fluid.FixedResistances.PressureDrop preDro(
          redeclare final package Medium = Medium,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Flow resistance"
          annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg")
          "Leaving temperature of the component";
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component";
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component";
    protected
        Modelica.Blocks.Sources.RealExpression heaInp(y=Q_flow)
          "Block to set heat input into volume"
          annotation (Placement(transformation(extent={{-20,40},{0,60}})));
        Modelica.Blocks.Sources.RealExpression
          masExc(final y=mWat_flow) "Block to set moisture exchange in volume"
          annotation (Placement(transformation(extent={{-20,20},{0,40}})));
      equation
        connect(vol.hOut, hOut);
        connect(vol.XiOut, XiOut);
        connect(vol.COut, COut);
        connect(port_a,preDro. port_a) annotation (Line(
            points={{-100,0},{-50,0}},
            color={0,127,255}));
        connect(preDro.port_b, vol.port_a) annotation (Line(
            points={{-30,0},{15,0}},
            color={0,127,255}));
        connect(vol.port_b, port_b) annotation (Line(
            points={{35,0},{67,0},{100,5.55112e-16}},
            color={0,127,255}));
        connect(heaInp.y, vol.Q_flow) annotation (Line(
            points={{1,50},{6,50},{6,8},{13,8}},
            color={0,0,127}));
        connect(masExc.y, vol.mWat_flow) annotation (Line(
            points={{1,30},{4,30},{4,4},{13,4}},
            color={0,0,127}));
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without
storing mass or energy. It is based on
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a> but it does
use a different implementation for handling reverse flow because
in this component, mass flow rate can be added or removed from
the medium.
</p>
<p>
If <code>dp_nominal &gt; Modelica.Constants.eps</code>, this component computes
pressure drop due to flow friction.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m_flow_nominal, dp_nominal)</code>. At <code>|m_flow| &lt; deltaM * m_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance</code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>
<h4>Implementation</h4>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned:
<ul>
<li>
<code>Q_flow</code>, which is the sensible and latent heat flow rate added to the medium.
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium.
</li>
</ul>

<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q_flow</code>
includes latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015 by Filip Jorissen:<br/>
Renamed <code>use_safeDivision</code> into
<code>prescribedHeatFlowRate</code>.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to pressure drop calculation, as this model no longer has
that parameter.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
February 8, 2012 by Michael Wetter:<br/>
Changed model to use graphical modeling.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end StaticTwoPortHeatMassExchanger;

      record TwoPortFlowResistanceParameters
        "Parameters for flow resistance for models with two ports"
        parameter Boolean computeFlowResistance = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance"));
        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance,
                      tab="Flow resistance"));
        parameter Modelica.SIunits.PressureDifference dp_nominal(min=0,
                                                                 displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance,
                     tab="Flow resistance"));
        parameter Real deltaM = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance, tab="Flow resistance"));
      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in models that have one fluid stream.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://IDEAS.Fluid.Interfaces.PartialTwoPortInterface\">
PartialTwoPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TwoPortFlowResistanceParameters;

      model TwoPortHeatMassExchanger
        "Partial model transporting one fluid stream with storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
          port_a(h_outflow(start=h_outflow_start)),
          port_b(h_outflow(start=h_outflow_start)));
        extends IDEAS.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=true);
        parameter Modelica.SIunits.Time tau = 30
          "Time constant at nominal flow (if energyDynamics <> SteadyState)"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));
        // Advanced
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        // Dynamics
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start = Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
          final quantity=Medium.substanceNames) = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
          final quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        replaceable IDEAS.Fluid.MixingVolumes.MixingVolume vol
        constrainedby IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          redeclare final package Medium = Medium,
          nPorts = 2,
          V=m_flow_nominal*tau/rho_default,
          final allowFlowReversal=allowFlowReversal,
          final mSenFac=1,
          final m_flow_nominal = m_flow_nominal,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start) "Volume for fluid stream"
           annotation (Placement(transformation(extent={{-9,0},{11,-20}})));
        IDEAS.Fluid.FixedResistances.PressureDrop preDro(
          redeclare final package Medium = Medium,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Flow resistance"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
    protected
        parameter Medium.ThermodynamicState sta_default=Medium.setState_pTX(
            T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.Density rho_default=Medium.density(sta_default)
          "Density, used to compute fluid volume";
        parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
            T=T_start, p=p_start, X=X_start);
        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_start = Medium.specificEnthalpy(sta_start)
          "Start value for outflowing enthalpy";
      initial algorithm
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau > Modelica.Constants.eps,
      "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = "       + String(tau) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau > Modelica.Constants.eps,
      "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = "       + String(tau) + "\n");
      equation
        connect(vol.ports[2], port_b) annotation (Line(
            points={{1,0},{100,0}},
            color={0,127,255}));
        connect(port_a, preDro.port_a) annotation (Line(
            points={{-100,0},{-90,0},{-90,0},{-80,0},{-80,0},{-60,0}},
            color={0,127,255}));
        connect(preDro.port_b, vol.ports[1]) annotation (Line(
            points={{-40,0},{1,0}},
            color={0,127,255}));
        annotation (
          Documentation(info="<html>
<p>
This component transports one fluid stream.
It provides the basic model for implementing dynamic and steady-state
models that exchange heat and water vapor with the fluid stream.
The model also computes the pressure drop due to the flow resistance.
By setting the parameter <code>dp_nominal=0</code>, the computation
of the pressure drop can be avoided.
The variable <code>vol.heatPort.T</code> always has the value of
the temperature of the medium that leaves the component.
For the actual temperatures at the port, the variables <code>sta_a.T</code>
and <code>sta_b.T</code> can be used. These two variables are provided by
the base class
<a href=\"modelica://IDEAS.Fluid.Interfaces.PartialTwoPortInterface\">
IDEAS.Fluid.Interfaces.PartialTwoPortInterface</a>.
</p>

For models that extend this model, see for example
<ul>
<li>
the ideal heater or cooler
<a href=\"modelica://IDEAS.Fluid.HeatExchangers.HeaterCooler_u\">
IDEAS.Fluid.HeatExchangers.HeaterCooler_u</a>, and
</li>
<li>
the ideal humidifier
<a href=\"modelica://IDEAS.Fluid.Humidifiers.Humidifier_u\">
IDEAS.Fluid.Humidifiers.Humidifier_u</a>.
</li>
</ul>

<h4>Implementation</h4>
<p>
The variable names follow the conventions used in
<a href=\"modelica://Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX\">
Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX
</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>final quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Added missing propagation of <code>allowFlowReversal</code> to
instance <code>vol</code>.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">#412</a>.
</li>
<li>
May 1, 2015, by Marcus Fuchs:<br/>
Fixed links in documentation.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in pressure drop element to be final.
</li>
<li>
May 28, 2014, by Michael Wetter:<br/>
Removed <code>annotation(Evaluate=true)</code> for parameter <code>tau</code>.
This is needed to allow changing the time constant after translation.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
October 17, 2012, by Michael Wetter:<br/>
Fixed broken link in documentation.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Removed assignment of <code>m_flow_small</code> as it is no
longer used in the pressure drop model.
</li>
<li>
January 15, 2011, by Michael Wetter:<br/>
Fixed wrong class reference in information section.
</li>
<li>
September 13, 2011, by Michael Wetter:<br/>
Changed assignment of <code>vol(mass/energyDynamics=...)</code> as the
previous assignment caused a non-literal start value that was ignored.
</li>
<li>
July 29, 2011, by Michael Wetter:<br/>
Added start value for outflowing enthalpy.
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Changed parameterization of fluid volume so that steady-state balance is
used when <code>tau = 0</code>.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Removed temperature sensor and changed implementation of fluid volume
to allow use of this model for the steady-state and dynamic humidifier
<a href=\"modelica://IDEAS.Fluid.MassExchangers.HumidifierPrescribed\">
IDEAS.Fluid.MassExchangers.HumidifierPrescribed</a>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
January 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,60},{70,-60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-101,5},{100,-4}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,-4},{100,5}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid)}));
      end TwoPortHeatMassExchanger;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains basic classes that are used to build
component models that change the state of the
fluid. The classes are not directly usable, but can
be extended when building a new model.
</p>
</html>"));
    end Interfaces;

    package MixingVolumes "Package with mixing volumes"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Package with base classes for IDEAS.Fluid.MixingVolumes"
        extends Modelica.Icons.BasesPackage;

        model MixingVolumeHeatPort
          "Mixing volume with heat port and initialize_p not set to final"
          extends IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume;
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
              T(start=T_start)) "Heat port for heat exchange with the control volume"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        equation
            connect(heaFloSen.port_a, heatPort)
              annotation (Line(points={{-90,0},{-100,0},{-100,0}}, color={191,0,0}));
          annotation (
          defaultComonentName="vol",
          Documentation(info="<html>
<p>
Mixing volume with a heat port.
</p>
<p>
This model is identical to
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>,
except that it has a heat port.
</p>
<p>
Note that this model is typically only used to implement new component models that
have staggered volumes.
In contrast to
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolume\">
IDEAS.Fluid.MixingVolumes.MixingVolume</a>, it does
not set <code>initialize_p</code> to <code>final</code> in order
for this model to be usable in staggered volumes which require one
pressure to be set to <code>initialize_p = not Medium.singleState</code>
and all others to <code>false</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
First implementation for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
</ul>
</html>"));
        end MixingVolumeHeatPort;

        model PartialMixingVolume
          "Partial mixing volume with inlet and outlet ports (flow reversal is allowed)"
          extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations;
          parameter Boolean initialize_p = not Medium.singleState
            "= true to set up initial equations for pressure"
            annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));
          // We set prescribedHeatFlowRate=false so that the
          // volume works without the user having to set this advanced parameter,
          // but to get high robustness, a user can set it to the appropriate value
          // as described in the info section.
          constant Boolean prescribedHeatFlowRate = false
            "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";
          constant Boolean simplify_mWat_flow = true
            "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          // Port definitions
          parameter Integer nPorts=0 "Number of ports"
            annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
          parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
            "Small mass flow rate for regularization of zero flow"
            annotation(Dialog(tab = "Advanced"));
          parameter Boolean allowFlowReversal = true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports."
            annotation(Dialog(tab="Assumptions"), Evaluate=true);
          parameter Modelica.SIunits.Volume V "Volume";
          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
              redeclare each package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{-40,-10},{40,10}},
              origin={0,-100})));
          Medium.Temperature T = Medium.temperature_phX(p=p, h=hOut_internal, X=cat(1,Xi,{1-sum(Xi)}))
            "Temperature of the fluid";
          Modelica.Blocks.Interfaces.RealOutput U(unit="J")
            "Internal energy of the component";
          Modelica.SIunits.Pressure p = if nPorts > 0 then ports[1].p else p_start
            "Pressure of the fluid";
          Modelica.Blocks.Interfaces.RealOutput m(unit="kg") "Mass of the component";
          Modelica.SIunits.MassFraction Xi[Medium.nXi] = XiOut_internal
            "Species concentration of the fluid";
          Modelica.Blocks.Interfaces.RealOutput mXi[Medium.nXi](each unit="kg")
            "Species mass of the component";
          Medium.ExtraProperty C[Medium.nC](nominal=C_nominal) = COut_internal
            "Trace substance mixture content";
          Modelica.Blocks.Interfaces.RealOutput mC[Medium.nC](each unit="kg")
            "Trace substance mass of the component";
      protected
          IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation steBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium=Medium,
            final m_flow_nominal = m_flow_nominal,
            final allowFlowReversal = allowFlowReversal,
            final m_flow_small = m_flow_small,
            final prescribedHeatFlowRate=prescribedHeatFlowRate) if
                 useSteadyStateTwoPort "Model for steady-state balance if nPorts=2"
                annotation (Placement(transformation(extent={{20,0},{40,20}})));
          IDEAS.Fluid.Interfaces.ConservationEquation dynBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium = Medium,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final p_start=p_start,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final C_nominal=C_nominal,
            final fluidVolume = V,
            final initialize_p = initialize_p,
            m(start=V*rho_start),
            nPorts=nPorts,
            final mSenFac=mSenFac) if
                 not useSteadyStateTwoPort "Model for dynamic energy balance"
            annotation (Placement(transformation(extent={{60,0},{80,20}})));
          // Density at start values, used to compute initial values and start guesses
          parameter Modelica.SIunits.Density rho_start=Medium.density(
           state=state_start) "Density, used to compute start and guess values";
          final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
          // Density at medium default values, used to compute the size of control volumes
          final parameter Modelica.SIunits.Density rho_default=Medium.density(
            state=state_default) "Density, used to compute fluid mass";
          final parameter Medium.ThermodynamicState state_start = Medium.setState_pTX(
              T=T_start,
              p=p_start,
              X=X_start[1:Medium.nXi]) "Medium state at start values";
          // See info section for why prescribedHeatFlowRate is used here.
          // The condition below may only be changed if StaticTwoPortConservationEquation
          // contains a correct solution for all foreseeable parameters/inputs.
          // See Buildings, issue 282 for a discussion.
          final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
              (prescribedHeatFlowRate or (not allowFlowReversal)) and (
              energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
            "Flag, true if the model has two ports only and uses a steady state balance"
            annotation (Evaluate=true);
          // Outputs that are needed to assign the medium properties
          Modelica.Blocks.Interfaces.RealOutput hOut_internal(unit="J/kg")
            "Internal connector for leaving temperature of the component";
          Modelica.Blocks.Interfaces.RealOutput XiOut_internal[Medium.nXi](each unit="1")
            "Internal connector for leaving species concentration of the component";
          Modelica.Blocks.Interfaces.RealOutput COut_internal[Medium.nC](each unit="1")
            "Internal connector for leaving trace substances of the component";
          Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature preTem
            "Port temperature"
            annotation (Placement(transformation(extent={{-40,-10},{-60,10}})));
          Modelica.Blocks.Sources.RealExpression portT(y=T) "Port temperature"
            annotation (Placement(transformation(extent={{-10,-10},{-30,10}})));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSen
            "Heat flow sensor"
            annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
        equation
          ///////////////////////////////////////////////////////////////////////////
          // asserts
          if not allowFlowReversal then
            assert(ports[1].m_flow > -m_flow_small,
        "Model has flow reversal, but the parameter allowFlowReversal is set to false.
  m_flow_small    = "         + String(m_flow_small) + "
  ports[1].m_flow = "         + String(ports[1].m_flow) + "
");       end if;
          // Actual definition of port variables.
          //
          // If the model computes the energy and mass balances as steady-state,
          // and if it has only two ports,
          // then we use the same base class as for all other steady state models.
          if useSteadyStateTwoPort then
          connect(steBal.port_a, ports[1]) annotation (Line(
              points={{20,10},{10,10},{10,-20},{0,-20},{0,-20},{0,-100}},
              color={0,127,255}));
          connect(steBal.port_b, ports[2]) annotation (Line(
              points={{40,10},{46,10},{46,-20},{0,-20},{0,-100}},
              color={0,127,255}));
            U=0;
            mXi=zeros(Medium.nXi);
            m=0;
            mC=zeros(Medium.nC);
            connect(hOut_internal,  steBal.hOut);
            connect(XiOut_internal, steBal.XiOut);
            connect(COut_internal,  steBal.COut);
          else
              connect(dynBal.ports, ports) annotation (Line(
              points={{70,0},{70,-80},{62,-80},{2.22045e-15,-80},{2.22045e-15,-90},{2.22045e-15,
                    -100}},
              color={0,127,255}));
            connect(U,dynBal.UOut);
            connect(mXi,dynBal.mXiOut);
            connect(m,dynBal.mOut);
            connect(mC,dynBal.mCOut);
            connect(hOut_internal,  dynBal.hOut);
            connect(XiOut_internal, dynBal.XiOut);
            connect(COut_internal,  dynBal.COut);
          end if;
          connect(portT.y, preTem.T)
            annotation (Line(points={{-31,0},{-38,0}},   color={0,0,127}));
          connect(heaFloSen.port_b, preTem.port)
            annotation (Line(points={{-70,0},{-65,0},{-60,0}},    color={191,0,0}));
          connect(heaFloSen.Q_flow, steBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-16},{6,-16},{6,18},{18,18}},
                                             color={0,0,127}));
          connect(heaFloSen.Q_flow, dynBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-10},{-80,-16},{6,-16},{6,24},{50,24},{50,16},{58,16}},
                                                                       color={0,0,127}));
          annotation (
        defaultComponentName="vol",
        Documentation(info="<html>
<p>
This is a partial model of an instantaneously mixed volume.
It is used as the base class for all fluid volumes of the package
<a href=\"modelica://IDEAS.Fluid.MixingVolumes\">
IDEAS.Fluid.MixingVolumes</a>.
</p>


<h4>Typical use and important parameters</h4>
<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
Set the constant <code>simplify_mWat_flow = true</code> to simplify the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
to
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector
for the trace substance flow rate.
</p>
<h4>Implementation</h4>
<p>
If the model is (i) operated in steady-state,
(ii) has two fluid ports connected, and
(iii) <code>prescribedHeatFlowRate=true</code> or <code>allowFlowReversal=false</code>,
then the model uses
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
in order to use
the same energy and mass balance implementation as is used as in
steady-state component models.
In this situation, the functions <code>inStream</code> are used for the two
flow directions rather than the function
<code>actualStream</code>, which is less efficient.
However, the use of <code>inStream</code> has the disadvantage
that <code>hOut</code> has to be computed, in
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>,
using
</p>
<pre>
if allowFlowReversal then
  hOut = IDEAS.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                    y2=port_a.h_outflow,
                                                    x=port_a.m_flow,
                                                    x_small=m_flow_small/1E3);
else
  hOut = port_b.h_outflow;
end if;
</pre>
<p>
Hence, for <code>allowFlowReversal=true</code>, if <code>hOut</code>
were to be used to compute the temperature that
drives heat transfer such as by conduction,
then the heat transfer would depend on upstream and the <i>downstream</i>
temperatures for small mass flow rates.
This can give wrong results. Consider for example a mass flow rate that is positive
but very close to zero. Suppose the upstream temperature is <i>20</i>&circ;C,
the downstream temperature is <i>10</i>&circ;C, and the heat port is
connected through a heat conductor to a boundary condition of <i>20</i>&circ;C.
Then, <code>hOut = (port_b.h_outflow + port_a.h_outflow)/2</code> and hence
the temperature <code>heatPort.T</code>
is <i>15</i>&circ;C. Therefore, heat is added to the component.
As the mass flow rate is by assumption very small, the fluid that leaves the component
will have a very high temperature, violating the 2nd law.
To avoid this situation, if
<code>prescribedHeatFlowRate=false</code>, then the model
<a href=\"modelica://IDEAS.Fluid.Interfaces.ConservationEquation\">
IDEAS.Fluid.Interfaces.ConservationEquation</a>
is used instead of
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://IDEAS.Fluid.MixingVolumes\">
IDEAS.Fluid.MixingVolumes</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
Removed <code>partial</code> keyword as this model is not partial.<br/>
Moved <code>C_flow</code> and <code>use_C_flow</code> to child classes.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Moved heat port to the extending classes to provide better comment.
Otherwise, the mixing volume without water input would have a comment
that says latent heat can be added at this port.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs U, m, mXi, mC for being able to
check conservation of quantities.
This if or <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Updated model to use the new parameter <code>use_mWat_flow</code>
rather than <code>sensibleOnly</code>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added conditional input <code>C_flow</code> for
handling trace substance insertions.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate=prescribedHeatflowRate</code> for
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
This results in equations that are solved more easily.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Set start value for <code>heatPort.T</code> and changed
type of <code>T</code> to <code>Medium.Temperature</code> rather than
<code>Modelica.SIunits.Temperature</code>
to avoid an
error because of conflicting start values if
<code>IDEAS.Fluid.Chillers.Carnot_y</code>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> to the actual model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Improved documentation and changed the test
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 prescribedHeatFlowRate and ...
</pre>
to
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 (prescribedHeatFlowRate or (not allowFlowReversal)) and ...
</pre>
The reason is that if there is no flow reversal, then
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
computes <code>hOut =  port_b.h_outflow;</code>, and hence
it is correct to use <code>hOut</code> to compute
temperature-driven heat flow, such as by conduction or convection.
See also the model documentation.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">
#412</a>.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
October 29, 2014, by Michael Wetter:<br/>
Made assignment of <code>mFactor</code> final, and changed computation of
density to use default medium states as are also used to compute the
specific heat capacity.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Removed <code>Q_flow</code> and added <code>QSen_flow</code>.
This was done to clarify what is sensible and total heat flow rate
as part of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to instance <code>steBal</code> as it has no longer this parameter.
</li>
<li>
September 13, 2013 by Michael Wetter:<br/>
Renamed <code>rho_nominal</code> to <code>rho_start</code>
because this quantity is computed using start values and not
nominal values.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the check of multiple connections to the same element
of a fluid port, as this check required the use of the deprecated
<code>cardinality</code> function.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IDEAS.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations\">
IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
This implementation also simplifies the implementation of
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort\">
IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</a>,
which now uses the same equations as this model.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
IDEAS.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Ellipse(
                  extent={{-100,98},{100,-102}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={170,213,255}), Text(
                  extent={{-58,14},{58,-18}},
                  lineColor={0,0,0},
                  textString="V=%V"),         Text(
                  extent={{-152,100},{148,140}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end PartialMixingVolume;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.MixingVolumes\">IDEAS.Fluid.MixingVolumes</a>.
</p>
</html>"));
      end BaseClasses;

      model MixingVolume
        "Mixing volume with inlet and outlet ports (flow reversal is allowed)"
        extends IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          final initialize_p = not Medium.singleState,
          steBal(final use_C_flow = use_C_flow),
          dynBal(final use_C_flow = use_C_flow));
        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
          T(start=T_start)) "Heat port for heat exchange with the control volume"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
          "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
      equation
        connect(heaFloSen.port_a, heatPort)
          annotation (Line(points={{-90,0},{-96,0},{-100,0}}, color={191,0,0}));
        connect(C_flow, steBal.C_flow) annotation (Line(points={{-120,-60},{-80,-60},
                {12,-60},{12,6},{18,6}}, color={0,0,127}));
        connect(C_flow, dynBal.C_flow) annotation (Line(points={{-120,-60},{-52,-60},
                {52,-60},{52,6},{58,6}}, color={0,0,127}));
        annotation (
      defaultComponentName="vol",
      Documentation(info="<html>
<p>
This model represents an instantaneously mixed volume.
Potential and kinetic energy at the port are neglected,
and there is no pressure drop at the ports.
The volume can exchange heat through its <code>heatPort</code>.
</p>
<p>
The volume can be parameterized as a steady-state model or as
dynamic model.</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<h4>Options</h4>
<p>
The parameter <code>mSenFac</code> can be used to increase the thermal mass of this model
without increasing its volume. This way, species concentrations are still calculated
correctly even though the thermal mass increases. The additional thermal mass is calculated
based on the density and the value of the function <code>HeatCapacityCp</code>
of the medium state <code>state_default</code>. <br/>
This parameter can for instance be useful in a pipe model when the developer wants to
lump the pipe thermal mass to the fluid volume. By default <code>mSenFac = 1</code>, hence
the mass is unchanged. For higher values of <code>mSenFac</code>, the mass will be scaled proportionally.
</p>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector for the trace substance flow rate.
This allows to directly add or subtract trace substances such as
CO2 to the volume.
See
<a href=\"modelica://IDEAS.Fluid.Sensors.Examples.PPM\">IDEAS.Fluid.Sensors.Examples.PPM</a>
for an example.
</p>
<h4>Implementation</h4>
<p>
If the model is operated in steady-state and has two fluid ports connected,
then the same energy and mass balance implementation is used as in
steady-state component models, i.e., the use of <code>actualStream</code>
is not used for the properties at the port.
</p>
<p>
The implementation of these balance equations is done in the instances
<code>dynBal</code> for the dynamic balance and <code>steBal</code>
for the steady-state balance. Both models use the same input variables:
</p>
<ul>
<li>
The variable <code>Q_flow</code> is used to add sensible <i>and</i> latent heat to the fluid.
For example, <code>Q_flow</code> participates in the steady-state energy balance<pre>
    port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
</pre>
where <code>m_flowInv</code> approximates the expression <code>1/m_flow</code>.
</li>
<li>
The variable <code>mXi_flow</code> is used to add a species mass flow rate to the fluid.
</li>
</ul>
<p>
For the rationale of selecting different energy and mass balances, and for the
use of <code>prescribedHeatFlowRate</code>, see the documentation of
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://IDEAS.Fluid.HeatExchangers.HeaterCooler_u\">
IDEAS.Fluid.HeatExchangers.HeaterCooler_u</a> and
<a href=\"modelica://IDEAS.Fluid.Humidifiers.Humidifier_u\">
IDEAS.Fluid.Humidifiers.Humidifier_u</a>.
</p>

</html>",       revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Set <code>initialize_p</code> to <code>final</code> so that it does not
appear as a user-selectable parameter. This is done because
<code>initialize_p</code> has been changed from a <code>constant</code>
to a <code>parameter</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Changed comment of heat port, as this needs to be the total heat flow
rate in order to be able to use this model for modeling steam humidifiers
and adiabatic humidifiers.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 19, 2016, by Michael Wetter:<br/>
Updated documentation due to the addition of an input for trace substance
in the mixing volume.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">
issue 372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Changed code for handling trace substance insertions using input <code>C_flow</code>.
</li>
<li>
May 1, 2015 by Michael Wetter<br/>
Set <code>final</code> keyword for <code>masExc(final k=0)</code>.
This addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/230\">
issue 230</a>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IDEAS.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations\">
IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
IDEAS.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,98},{100,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={170,213,255}), Text(
                extent={{-58,14},{58,-18}},
                lineColor={0,0,0},
                textString="V=%V"),         Text(
                extent={{-152,100},{148,140}},
                textString="%name",
                lineColor={0,0,255})}));
      end MixingVolume;

      model MixingVolumeMoistAir
        "Mixing volume with heat port for latent heat exchange, to be used if moisture is added or removed"
        extends BaseClasses.PartialMixingVolume(
          dynBal(
            final use_mWat_flow = true,
            final use_C_flow = use_C_flow),
          steBal(final use_mWat_flow = true,
            final use_C_flow = use_C_flow),
          final initialize_p = not Medium.singleState);
        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       final unit = "kg/s")
          "Water flow rate added into the medium"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealOutput X_w(final unit="kg/kg")
          "Species composition of medium"
          annotation (Placement(transformation(extent={{100,-60},{140,-20}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
          T(start=T_start))
          "Heat port for sensible plus latent heat exchange with the control volume"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
          "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
    protected
        parameter Real s[Medium.nXi] = {
        if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false) then 1 else 0
                                                  for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";
        Modelica.Blocks.Sources.RealExpression XLiq(y=s*Xi)
          "Species composition of the medium"
          annotation (Placement(transformation(extent={{72,-52},{94,-28}})));
      equation
        connect(mWat_flow, steBal.mWat_flow) annotation (Line(
            points={{-120,80},{-120,80},{4,80},{4,14},{18,14}},
            color={0,0,127}));
        connect(mWat_flow, dynBal.mWat_flow) annotation (Line(
            points={{-120,80},{-50,80},{52,80},{52,12},{58,12}},
            color={0,0,127}));
        connect(XLiq.y, X_w) annotation (Line(
            points={{95.1,-40},{120,-40}},
            color={0,0,127}));
        connect(heaFloSen.port_a, heatPort)
          annotation (Line(points={{-90,0},{-100,0}}, color={191,0,0}));
        connect(C_flow, steBal.C_flow) annotation (Line(points={{-120,-60},{-80,-60},{
                12,-60},{12,6},{18,6}}, color={0,0,127}));
        connect(C_flow, dynBal.C_flow) annotation (Line(points={{-120,-60},{-52,-60},{
                52,-60},{52,6},{58,6}}, color={0,0,127}));
        annotation (defaultComponentName="vol",
      Documentation(info="<html>
<p>
Model for an ideally mixed fluid volume and the ability
to store mass and energy. The volume is fixed,
and latent and sensible heat can be exchanged.
</p>
<p>
This model represents the same physics as
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolume\">
IDEAS.Fluid.MixingVolumes.MixingVolume</a>, but in addition, it allows
adding or subtracting water to the control volume.
The mass flow rate of the added or subtracted water is
specified at the port <code>mWat_flow</code>.
Adding <code>mWat_flow</code> itself does not affect the energy balance
in this model. Hence, the enthalpy that is added or removed with the
flow of <code>mWat_flow</code> needs to be added to the heat port
<code>heatPort</code>.
</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<h4>Options</h4>
<p>
The parameter <code>mSenFac</code> can be used to increase the thermal mass of this model
without increasing its volume. This way, species concentrations are still calculated
correctly even though the thermal mass increases. The additional thermal mass is calculated
based on the density and the value of the function <code>HeatCapacityCp</code>
of the medium state <code>state_default</code>. <br/>
This parameter can for instance be useful in a pipe model when the developer wants to
lump the pipe thermal mass to the fluid volume. By default <code>mSenFac = 1</code>, hence
the mass is unchanged. For higher values of <code>mSenFac</code>, the mass will be scaled proportionally.
</p>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector for the trace substance flow rate.
This allows to directly add or subtract trace substances such as
CO2 to the volume.
See
<a href=\"modelica://IDEAS.Fluid.Sensors.Examples.PPM\">IDEAS.Fluid.Sensors.Examples.PPM</a>
for an example.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Set <code>initialize_p</code> to <code>final</code> so that it does not
appear as a user-selectable parameter. This is done because
<code>initialize_p</code> has been changed from a <code>constant</code>
to a <code>parameter</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Changed comment of heat port, as this needs to be the total heat flow
rate in order to be able to use this model for modeling steam humidifiers
and adiabatic humidifiers.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>steBal</code>
as this constant is no longer used.
</li>
<li>
January 19, 2016, by Michael Wetter:<br/>
Updated documentation due to the addition of an input for trace substance
in the mixing volume.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">
issue 372</a>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
December 18, 2013 by Michael Wetter:<br/>
Changed computation of <code>s</code> to allow this model to also be used
with <code>IDEAS.Media.Water</code>.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Removed dublicate declaration of medium model.
</li>
<li>
September 27, 2013 by Michael Wetter:<br/>
Reformulated assignment of <code>i_w</code> to avoid a warning in OpenModelica.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Changed model to no longer use the obsolete model <code>IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>
in the conservation equation model.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the use of the deprecated
<code>cardinality</code> function.
Therefore, all input signals must be connected.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IDEAS.Fluid.Interfaces</code>.
</li>
<li>
February 22, by Michael Wetter:<br/>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
May 29, 2010 by Michael Wetter:<br/>
Rewrote computation of index of water substance.
For the old formulation, Dymola 7.4 failed to differentiate the
model when trying to reduce the index of the DAE.
</li>
<li>
August 7, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end MixingVolumeMoistAir;
    annotation (Documentation(info="<html>
<p>
This package contains models for completely mixed volumes.
</p>
<p>
For most situations, the model
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolume\">
IDEAS.Fluid.MixingVolumes.MixingVolume</a> should be used.
The other models are only of interest if water should be added to
or subtracted from the fluid volume, such as in a
coil with water vapor condensation.
</p>
</html>"));
    end MixingVolumes;

    package Movers "Package with fan and pump models"
      extends Modelica.Icons.Package;

      package BaseClasses "Package with base classes for IDEAS.Fluid.Movers"
        extends Modelica.Icons.BasesPackage;

        package Characteristics "Functions for fan or pump characteristics"

          function efficiency "Flow vs. efficiency characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per
              "Efficiency performance data";
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real d[:] "Derivatives at support points for spline interpolation";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real delta "Small value for switching implementation around zero rpm";
            output Real eta(unit="1", final quantity="Efficiency") "Efficiency";
        protected
            Integer n = size(per.V_flow, 1) "Number of data points";
            Real rat "Ratio of V_flow/r_N";
            Integer i "Integer to select data interval";
          algorithm
            if n == 1 then
              eta := per.eta[1];
            else
              // The use of the max function to avoids problems for low speeds
              // and turned off pumps
              rat:=V_flow/
                      IDEAS.Utilities.Math.Functions.smoothMax(
                        x1=r_N,
                        x2=0.1,
                        deltaX=delta);
              i :=1;
              for j in 1:n-1 loop
                 if rat > per.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              eta:=IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=rat,
                          x1=per.V_flow[i],
                          x2=per.V_flow[i + 1],
                          y1=per.eta[i],
                          y2=per.eta[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;
            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan or pump efficiency for given normalized volume flow rate
and performance data. The efficiency is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &eta; = s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>&eta;</i> is the efficiency,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate, and
<i>d</i> are performance data for fan or pump efficiency.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>", revisions="<html>
<ul>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Corrected documentation as curve uses <i>V&#775;</i>
as an independent variable.
</li>
<li>
September 30, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>V_flow</code>
instead of <code>r_V</code>.
</li>
<li>
April 19, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>r_V/r_N</code>
instead of <code>r_V</code> to properly account for the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiency;

          record efficiencyParameters "Record for efficiency parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](
              each min=0) "Volumetric flow rate at user-selected operating points";
            parameter Modelica.SIunits.Efficiency eta[size(V_flow,1)](
              each max=1) "Fan or pump efficiency at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
efficiency.
The volume flow rate <code>r_V</code> must be increasing, i.e.,
<code>r_V[i] &lt; r_V[i+1]</code>.
Both vectors, <code>r_V</code> and <code>eta</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiencyParameters;

          record flowParameters "Record for flow parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.PressureDifference dp[size(V_flow,1)](
               each min=0, each displayUnit="Pa")
              "Fan or pump total pressure at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
pressure rise.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>dp</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end flowParameters;

          record flowParametersInternal "Record for flow parameters with prescribed size"
            extends Modelica.Icons.Record;
            parameter Integer n "Number of elements in each array"
             annotation(Evaluate=true);
            parameter Modelica.SIunits.VolumeFlowRate V_flow[n](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.PressureDifference dp[n](
               each min=0, each displayUnit="Pa")
              "Fan or pump total pressure at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
pressure rise.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>dp</code>
must have the same size.
</p>
<p>
This record is identical to
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters\">
IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters</a>,
except that it takes the size of the array as a parameter. This is required
in Dymola 2014. Otherwise, the array size would need to be computed in
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.FlowMachineInterface\">
IDEAS.Fluid.Movers.BaseClasses.FlowMachineInterface</a>
in the <code>initial algorithm</code> section, which is not supported.
</p>
</html>", revisions="<html>
<ul>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
March 22, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end flowParametersInternal;

          function power "Flow vs. electrical power characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input IDEAS.Fluid.Movers.BaseClasses.Characteristics.powerParameters per
              "Pressure performance data";
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real d[:] "Derivatives at support points for spline interpolation";
            input Real delta "Small value for switching implementation around zero rpm";
            output Modelica.SIunits.Power P "Power consumption";
        protected
             Integer n=size(per.V_flow, 1) "Dimension of data vector";
             Modelica.SIunits.VolumeFlowRate rat "Ratio of V_flow/r_N";
             Integer i "Integer to select data interval";
          algorithm
            if n == 1 then
              P := r_N^3*per.P[1];
            else
              i :=1;
              // The use of the max function to avoids problems for low speeds
              // and turned off pumps
              rat:=V_flow/
                      IDEAS.Utilities.Math.Functions.smoothMax(
                        x1=r_N,
                        x2=0.1,
                        deltaX=delta);
              for j in 1:n-1 loop
                 if rat > per.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              P:=r_N^3*IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=rat,
                          x1=per.V_flow[i],
                          x2=per.V_flow[i + 1],
                          y1=per.P[i],
                          y2=per.P[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;
            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan power consumption for given volume flow rate,
speed and performance data. The power consumption is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  P = r<sub>N</sub><sup>3</sup> &nbsp; s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>P</i> is the power consumption,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>V_flow/r_N</code>
instead of <code>V_flow</code> to properly account for the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end power;

          record powerParameters "Record for electrical power parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.Power P[size(V_flow,1)](each min=0)
              "Fan or pump electrical power at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
electrical power.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>P</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
October 10, 2012, by Michael Wetter:<br/>
Fixed wrong <code>displayUnit</code> and
<code>max</code> attribute for power.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end powerParameters;

          function pressure
            "Pump or fan head away from the origin without correction for mover flow resistance"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real d[:] "Derivatives of flow rate vs. pressure at the support points";
            input Modelica.SIunits.PressureDifference dpMax(displayUnit="Pa")
              "Maximum pressure drop at nominal speed, for regularisation";
            input Modelica.SIunits.VolumeFlowRate V_flow_max
              "Maximum flow rate at nominal speed, for regularisation";
            input IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal per
              "Pressure performance data";
            output Modelica.SIunits.PressureDifference dp(displayUnit="Pa") "Pressure raise";
        protected
            constant Real delta = 0.05
              "Small number for r_N below which we don't care about the affinity laws";
            constant Real delta2 = delta/2 "= delta/2";
            Real r_R(unit="1") "Relative revolution, bounded below by delta";
            Integer i "Integer to select data interval";
            Modelica.SIunits.VolumeFlowRate rat "Ratio of V_flow/r_R";
          algorithm
            // For r_N < delta, we restrict r_N in the term V_flow/r_N.
            // This is done using a cubic spline in a region 0.75*delta < r_N < 1.25*r_N
            // We call this restricted value r_R
            if r_N > delta then
              r_R :=r_N;
            elseif r_N < 0 then
              r_R := delta2;
            else
              // Restrict r_N using a spline
              r_R :=Modelica.Fluid.Utilities.cubicHermite(
                x=r_N,
                x1=0,
                x2=delta,
                y1=delta2,
                y2=delta,
                y1d=0,
                y2d=1);
            end if;
            i :=1;
            rat := V_flow/r_R;
            for j in 1:size(d, 1)-1 loop
              if rat > per.V_flow[j] then
                i := j;
              end if;
            end for;
            // In the assignment below,
            // dp -> 0 as r_N -> 0 quadratically, because rat is bounded
            // by the above regularization
            if r_N>=0 then
              dp:=r_N^2*IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                        x=rat,
                        x1=per.V_flow[i],
                        x2=per.V_flow[i + 1],
                        y1=per.dp[i],
                        y2=per.dp[i + 1],
                        y1d=d[i],
                        y2d=d[i+1]);
            else
              dp:=-r_N^2*(dpMax-dpMax/V_flow_max*V_flow);
            end if;
          annotation(smoothOrder=1,
          Documentation(info="<html>
<p>
This function computes the fan static
pressure raise as a function of volume flow rate and revolution in the form
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = r<sub>N</sub><sup>2</sup> &nbsp; s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>&Delta;p</i> is the pressure rise,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
<p>
The function allows <i>r<sub>N</sub></i> to be zero.
</p>
</html>",   revisions="<html>
<ul>
<li>
September 8, 2016, by Michael Wetter and Filip Jorissen:<br/>
Changed implementation to allow <code>r_N = 0</code>.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
September 7, 2016, by Michael Wetter:<br/>
Moved function which was a protected function to make it public, as it
is now called by
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.FlowMachineInterface\">
IDEAS.Fluid.Movers.BaseClasses.FlowMachineInterface</a>.
</li>
</ul>
</html>"));
          end pressure;
          annotation (Documentation(info="<html>
<p>
This package implements performance curves for fans and pumps,
and records for parameter that can be used with these performance
curves.
</p>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a> for information about these performance curves.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 8, 2016, by Michael Wetter:<br/>
Deleted function <code>performanceCurve</code> as it is no longer needed. Instead, the function
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.Characteristics.pressure\">
IDEAS.Fluid.Movers.BaseClasses.Characteristics.pressure</a>
is used for all speeds.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
September 29, 2011, by Michael Wetter:<br/>
New implementation due to changes from polynomial to cubic hermite splines.
</li>
</ul>
</html>"));
        end Characteristics;

        model FlowMachineInterface
          "Partial model with performance curves for fans or pumps"
          extends Modelica.Blocks.Icons.Block;
          import cha = IDEAS.Fluid.Movers.BaseClasses.Characteristics;
          parameter IDEAS.Fluid.Movers.Data.Generic per
            "Record with performance data"
            annotation (choicesAllMatching=true,
              Placement(transformation(extent={{60,-80},{80,-60}})));
          parameter IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable preVar=
            IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed "Type of prescribed variable";
          parameter Boolean computePowerUsingSimilarityLaws
            "= true, compute power exactly, using similarity laws. Otherwise approximate.";
          final parameter Modelica.SIunits.VolumeFlowRate V_flow_nominal=
            per.pressure.V_flow[nOri] "Nominal volume flow rate, used for homotopy";
          parameter Modelica.SIunits.Density rho_default
            "Fluid density at medium default state";
          parameter Boolean haveVMax
            "Flag, true if user specified data that contain V_flow_max";
          parameter Modelica.SIunits.VolumeFlowRate V_flow_max
            "Maximum volume flow rate, used for smoothing";
          parameter Integer nOri(min=1) "Number of data points for pressure curve"
            annotation(Evaluate=true);
          parameter Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
         // Normalized speed
          Modelica.Blocks.Interfaces.RealInput y_in(final unit="1") if preSpe
            "Prescribed mover speed"
            annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,120})));
          Modelica.Blocks.Interfaces.RealOutput y_out(
            final unit="1") "Mover speed (prescribed or computed)"
            annotation (Placement(transformation(extent={{100,90},{120,110}})));
          Modelica.Blocks.Interfaces.RealInput m_flow(
            final quantity="MassFlowRate",
            final unit="kg/s") "Mass flow rate"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput rho(
            final quantity="Density",
            final unit="kg/m3",
            min=0.0) "Medium density"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealOutput V_flow(
            quantity="VolumeFlowRate",
            final unit="m3/s") "Volume flow rate"
            annotation (Placement(transformation(extent={{100,38},{120,58}}),
                iconTransformation(extent={{100,38},{120,58}})));
          Modelica.Blocks.Interfaces.RealInput dp_in(
            quantity="PressureDifference",
            final unit="Pa") if prePre "Prescribed pressure increase"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=270,
                origin={40,120})));
          Modelica.Blocks.Interfaces.RealOutput dp(
            quantity="Pressure",
            final unit="Pa") if not prePre "Pressure increase (computed or prescribed)"
            annotation (Placement(transformation(extent={{100,70},{120,90}})));
          Modelica.Blocks.Interfaces.RealOutput WFlo(
            quantity="Power",
            final unit="W") "Flow work"
            annotation (Placement(transformation(extent={{100,10},{120,30}})));
          Modelica.Blocks.Interfaces.RealOutput PEle(
            quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{100,-20},{120,0}}),
                iconTransformation(extent={{100,-20},{120,0}})));
          Modelica.Blocks.Interfaces.RealOutput eta(
            final quantity="Efficiency",
            final unit="1") "Overall efficiency"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}}),
                iconTransformation(extent={{100,-50},{120,-30}})));
          Modelica.Blocks.Interfaces.RealOutput etaHyd(
            final quantity="Efficiency",
            final unit="1") "Hydraulic efficiency"
            annotation (Placement(transformation(extent={{100,-80},{120,-60}}),
                iconTransformation(extent={{100,-80},{120,-60}})));
          Modelica.Blocks.Interfaces.RealOutput etaMot(
            final quantity="Efficiency",
            final unit="1") "Motor efficiency"
            annotation (Placement(transformation(extent={{100,-110},{120,-90}}),
                iconTransformation(extent={{100,-110},{120,-90}})));
          // "Shaft rotational speed";
          Modelica.Blocks.Interfaces.RealOutput r_N(unit="1")
            "Ratio N_actual/N_nominal";
          Real r_V(start=1, unit="1") "Ratio V_flow/V_flow_max";
      protected
          final parameter Boolean preSpe=
            preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed
            "True if speed is a prescribed variable of this block";
          final parameter Boolean prePre=
            preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.PressureDifference or
            preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate
            "True if pressure head is a prescribed variable of this block";
          // Derivatives for cubic spline
          final parameter Real motDer[size(per.motorEfficiency.V_flow, 1)](each fixed=false)
            "Coefficients for polynomial of motor efficiency vs. volume flow rate";
          final parameter Real hydDer[size(per.hydraulicEfficiency.V_flow,1)](each fixed=false)
            "Coefficients for polynomial of hydraulic efficiency vs. volume flow rate";
          parameter Modelica.SIunits.PressureDifference dpMax(displayUnit="Pa")=
            if haveDPMax then
              per.pressure.dp[1]
            else
              per.pressure.dp[1] - ((per.pressure.dp[2] - per.pressure.dp[1])/(
                per.pressure.V_flow[2] - per.pressure.V_flow[1]))*per.pressure.V_flow[1]
            "Maximum head";
          parameter Real delta = 0.05
            "Small value used to for regularization and to approximate an internal flow resistance of the fan";
          parameter Real kRes(min=0, unit="kg/(s.m4)") =  dpMax/V_flow_max*delta^2/10
            "Coefficient for internal pressure drop of fan or pump";
          parameter Integer curve=
             if (haveVMax and haveDPMax) or (nOri == 2) then 1
             elseif haveVMax or haveDPMax then 2
             else 3
            "Flag, used to pick the right representatio of the fan or pump pressure curve";
          final parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur1(
            final n = nOri,
            final V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                     {per.pressure.V_flow[i] for i in 1:nOri}
                     else
                     zeros(nOri),
            final dp = if (haveVMax and haveDPMax) or (nOri == 2) then
                     {(per.pressure.dp[i] + per.pressure.V_flow[i] * kRes) for i in 1:nOri}
                     else
                     zeros(nOri))
            "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur2(
            final n = nOri + 1,
            V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                        zeros(nOri + 1)
                     elseif haveVMax then
                      cat(1, {0}, {per.pressure.V_flow[i] for i in 1:nOri})
                     elseif haveDPMax then
                      cat(1, { per.pressure.V_flow[i] for i in 1:nOri}, {V_flow_max})
                     else
                      zeros(nOri + 1),
            dp = if (haveVMax and haveDPMax) or (nOri == 2) then
                        zeros(nOri + 1)
                     elseif haveVMax then
                      cat(1, {dpMax}, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri})
                     elseif haveDPMax then
                      cat(1, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri}, {0})
                     else
                       zeros(nOri+1))
            "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur3(
            final n = nOri + 2,
            V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                       zeros(nOri + 2)
                     elseif haveVMax or haveDPMax then
                       zeros(nOri + 2)
                     else
                       cat(1, {0}, {per.pressure.V_flow[i] for i in 1:nOri}, {V_flow_max}),
            dp =     if (haveVMax and haveDPMax) or (nOri == 2) then
                       zeros(nOri + 2)
                     elseif haveVMax or haveDPMax then
                       zeros(nOri + 2)
                     else
                       cat(1, {dpMax}, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri}, {0}))
            "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter Real preDer1[nOri](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer2[nOri+1](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer3[nOri+2](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real powDer[size(per.power.V_flow,1)]=
           if per.use_powerCharacteristic then
             IDEAS.Utilities.Math.Functions.splineDerivatives(
                           x=per.power.V_flow,
                           y=per.power.P,
                           ensureMonotonicity=IDEAS.Utilities.Math.Functions.isMonotonic(x=per.power.P,
                                                                                             strict=false))
           else
             zeros(size(per.power.V_flow,1))
            "Coefficients for polynomial of power vs. flow rate";
          parameter Boolean haveMinimumDecrease=
            Modelica.Math.BooleanVectors.allTrue({(per.pressure.dp[i + 1] -
            per.pressure.dp[i])/(per.pressure.V_flow[i + 1] - per.pressure.V_flow[
            i]) < -kRes for i in 1:nOri - 1}) "Flag used for reporting";
          parameter Boolean haveDPMax = (abs(per.pressure.V_flow[1])  < Modelica.Constants.eps)
            "Flag, true if user specified data that contain dpMax";
          Modelica.Blocks.Interfaces.RealOutput dp_internal
            "If dp is prescribed, use dp_in and solve for r_N, otherwise compute dp using r_N";
        function getPerformanceDataAsString
          input IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters pressure
              "Performance data";
          input Real derivative[:](unit="kg/(s.m4)") "Derivative";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(derivative, 1) loop
            str :=str + "  V_flow[" + String(i) + "]=" + String(
                pressure.V_flow[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\t" + "dp[" + String(i) + "]=" +
                String(
                pressure.dp[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\tResulting derivative dp/dV_flow = "
                 + String(
                derivative[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getPerformanceDataAsString;

        function getArrayAsString
          input Real array[:] "Array to be printed";
          input String varName "Variable name";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(array, 1) loop
            str :=str + "  " + varName + "[" + String(i) + "]=" + String(
                array[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getArrayAsString;
        initial equation
          // Check validity of data
          assert(nOri > 1, "Must have at least two data points for pressure.V_flow.");
          assert(IDEAS.Utilities.Math.Functions.isMonotonic(x=per.pressure.V_flow, strict=true) and
          per.pressure.V_flow[1] > -Modelica.Constants.eps,
          "The fan pressure rise must be a strictly decreasing sequence with respect to the volume flow rate,
  with the first element for the fan pressure raise being non-zero.
The following performance data have been entered:
"         + getArrayAsString(per.pressure.V_flow, "pressure.V_flow"));
          if not haveVMax then
            assert((per.pressure.V_flow[nOri]-per.pressure.V_flow[nOri-1])
                 /((per.pressure.dp[nOri]-per.pressure.dp[nOri-1]))<0,
            "The last two pressure points for the fan or pump performance curve must be decreasing.
    You need to set more reasonable parameters.
Received
"         + getArrayAsString(per.pressure.dp, "dp"));
          end if;
          // Write warning if the volumetric flow rate versus pressure curve does not satisfy
          // the minimum decrease condition
          if (not haveMinimumDecrease) then
            Modelica.Utilities.Streams.print("
Warning:
========
It is recommended that the volume flow rate versus pressure relation
of the fan or pump satisfies the minimum decrease condition

        (per.pressure.dp[i+1]-per.pressure.dp[i])
d[i] = ------------------------------------------------- < "         + String(-kRes) + "
       (per.pressure.V_flow[i+1]-per.pressure.V_flow[i])

 is
"         + getArrayAsString({(per.pressure.dp[i+1]-per.pressure.dp[i])
                /(per.pressure.V_flow[i+1]-per.pressure.V_flow[i]) for i in 1:nOri-1}, "d") + "
Otherwise, a solution to the equations may not exist if the fan or pump speed is reduced.
In this situation, the solver will fail due to non-convergence and
the simulation stops.");
          end if;
          // Correction for flow resistance of pump or fan
          if (haveVMax and haveDPMax) or (nOri == 2) then  // ----- Curve 1
            // V_flow_max and dpMax are provided by the user, or we only have two data points
            preDer1= IDEAS.Utilities.Math.Functions.splineDerivatives(x=pCur1.V_flow,
              y=pCur1.dp);
            preDer2= zeros(nOri + 1);
            preDer3= zeros(nOri + 2);
          elseif haveVMax or haveDPMax then  // ----- Curve 2
            // V_flow_max or dpMax is provided by the user, but not both
            preDer1= zeros(nOri);
            preDer2= IDEAS.Utilities.Math.Functions.splineDerivatives(x=pCur2.V_flow,
              y=pCur2.dp);
            preDer3= zeros(nOri + 2);
          else  // ----- Curve 3
            // Neither V_flow_max nor dpMax are provided by the user
            preDer1= zeros(nOri);
            preDer2= zeros(nOri + 1);
            preDer3= IDEAS.Utilities.Math.Functions.splineDerivatives(x=pCur3.V_flow,
              y=pCur3.dp);
          end if;
         // Compute derivatives for cubic spline
         motDer = if per.use_powerCharacteristic then zeros(size(per.motorEfficiency.V_flow,
            1)) elseif (size(per.motorEfficiency.V_flow, 1) == 1) then {0} else
            IDEAS.Utilities.Math.Functions.splineDerivatives(
            x=per.motorEfficiency.V_flow,
            y=per.motorEfficiency.eta,
            ensureMonotonicity=IDEAS.Utilities.Math.Functions.isMonotonic(x=per.motorEfficiency.eta,
              strict=false));
          hydDer = if per.use_powerCharacteristic then zeros(size(per.hydraulicEfficiency.V_flow,
            1)) elseif (size(per.hydraulicEfficiency.V_flow, 1) == 1) then {0}
             else IDEAS.Utilities.Math.Functions.splineDerivatives(x=per.hydraulicEfficiency.V_flow,
            y=per.hydraulicEfficiency.eta);
        equation
          //assign values of dp and r_N, depending on which variable exists and is prescribed
          connect(dp_internal,dp);
          connect(dp_internal,dp_in);
          connect(r_N, y_in);
          y_out=r_N;
          V_flow = m_flow/rho;
          // Hydraulic equations
          r_V = V_flow/V_flow_max;
          // If the speed is not prescribed and we do not require exact power computations, we set r_N = 1.
          // Similarity laws are then not used, meaning the power computation is less accurate.
          // This however has the advantage that no non-linear algebraic loop is formed and
          // it allows an implementation when the pressure curve is unknown.
          if (computePowerUsingSimilarityLaws == false) and preVar <> IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed then
            r_N=1;
          else
          // For the homotopy method, we approximate dp by an equation
          // that is linear in V_flow, and that goes linearly to 0 as r_N goes to 0.
          // The three branches below are identical, except that we pass either
          // pCur1, pCur2 or pCur3, and preDer1, preDer2 or preDer3
          if (curve == 1) then
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1),
                                                   simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1)
                                       +(V_flow-V_flow_nominal) * (cha.pressure(
                                                             V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1))
                                                            /(2*delta*V_flow_nominal)));
            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                       r_N=r_N,
                                                       dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                       d=preDer1,
                                                       per=pCur1);
            end if;     // end of computation for this branch
           elseif (curve == 2) then
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2),
                                                    simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2)
                                       +(V_flow-V_flow_nominal) * (cha.pressure(
                                                             V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2))
                                                            /(2*delta*V_flow_nominal)));
            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                              r_N=r_N,
                                                              dpMax=dpMax,
                                                              V_flow_max=V_flow_max,
                                                              d=preDer2,
                                                              per=pCur2);
            end if;     // end of computation for this branch
          else
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3),
                                  simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3)
                                       +(V_flow-V_flow_nominal)*
                                               (cha.pressure(V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3))
                                                            /(2*delta*V_flow_nominal)));
            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                              r_N=r_N,
                                                              dpMax=dpMax,
                                                              V_flow_max=V_flow_max,
                                                              d=preDer3,
                                                              per=pCur3);
            end if;
            // end of computation for this branch
          end if;
            // end of if/else choosing between exact/simplified power computation
          end if;
          // Flow work
          WFlo = dp_internal*V_flow;
          // Power consumption
          if per.use_powerCharacteristic then
            // For the homotopy, we want P/V_flow to be bounded as V_flow -> 0 to avoid a very high medium
            // temperature near zero flow.
            if homotopyInitialization then
              PEle = homotopy(actual=cha.power(per=per.power, V_flow=V_flow, r_N=r_N, d=powDer, delta=delta),
                              simplified=V_flow/V_flow_nominal*
                                    cha.power(per=per.power, V_flow=V_flow_nominal, r_N=1, d=powDer, delta=delta));
            else
              PEle = (rho/rho_default)*cha.power(per=per.power, V_flow=V_flow, r_N=r_N, d=powDer, delta=delta);
            end if;
            // To compute the efficiency, we set a lower bound on the electricity consumption.
            // This is needed because WFlo can be close to zero when P is zero, thereby
            // causing a division by zero.
            // Earlier versions of the model computed WFlo = eta * P, but this caused
            // a division by zero.
            eta = WFlo / IDEAS.Utilities.Math.Functions.smoothMax(x1=PEle, x2=1E-5, deltaX=1E-6);
            // In this configuration, we only know the total power consumption.
            // Because nothing is known about etaMot versus etaHyd, we set etaHyd=1. This will
            // cause etaMot=eta, because eta=etaHyd*etaMot.
            // Earlier versions used etaMot=sqrt(eta), but as eta->0, this function has
            // and infinite derivative.
            etaHyd = 1;
            etaMot = eta;
          else
            if homotopyInitialization then
              etaHyd = homotopy(actual=cha.efficiency(per=per.hydraulicEfficiency,     V_flow=V_flow, d=hydDer, r_N=r_N, delta=delta),
                                simplified=cha.efficiency(per=per.hydraulicEfficiency, V_flow=V_flow_max,   d=hydDer, r_N=r_N, delta=delta));
              etaMot = homotopy(actual=cha.efficiency(per=per.motorEfficiency,     V_flow=V_flow, d=motDer, r_N=r_N, delta=delta),
                                simplified=cha.efficiency(per=per.motorEfficiency, V_flow=V_flow_max,   d=motDer, r_N=r_N, delta=delta));
            else
              etaHyd = cha.efficiency(per=per.hydraulicEfficiency, V_flow=V_flow, d=hydDer, r_N=r_N, delta=delta);
              etaMot = cha.efficiency(per=per.motorEfficiency,     V_flow=V_flow, d=motDer, r_N=r_N, delta=delta);
            end if;
            // To compute the electrical power, we set a lower bound for eta to avoid
            // a division by zero.
            PEle = WFlo / IDEAS.Utilities.Math.Functions.smoothMax(x1=eta, x2=1E-5, deltaX=1E-6);
            eta = etaHyd * etaMot;
          end if;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                            graphics={
                Text(extent={{56,66},{106,52}},
                  lineColor={0,0,127},
                  textString="dp"),
                Text(extent={{56,8},{106,-6}},
                  lineColor={0,0,127},
                  textString="PEle"),
                Text(extent={{52,-22},{102,-36}},
                  lineColor={0,0,127},
                  textString="eta"),
                Text(extent={{50,-52},{100,-66}},
                  lineColor={0,0,127},
                  textString="etaHyd"),
                Text(extent={{50,-72},{100,-86}},
                  lineColor={0,0,127},
                  textString="etaMot"),
                Ellipse(
                  extent={{-78,34},{44,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-62,18},{28,-72}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-26,-18},{-8,-36}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-26,-22},{-32,-8},{-30,10},{-8,20},{-6,14},{-24,6},{-24,-8},{
                      -18,-20},{-26,-22}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{-8,-32},{-2,-46},{-4,-64},{-26,-74},{-28,-68},{-10,-60},{-10,
                      -46},{-16,-34},{-8,-32}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{7,21},{13,7},{11,-11},{-11,-21},{-13,-15},{5,-7},{5,7},{-1,19},
                      {7,21}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier,
                  origin={9,-23},
                  rotation=90),
                Polygon(
                  points={{-7,-21},{-13,-7},{-11,11},{11,21},{13,15},{-5,7},{-5,-7},{1,-19},
                      {-7,-21}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier,
                  origin={-43,-31},
                  rotation=90),
                Text(extent={{56,36},{106,22}},
                  lineColor={0,0,127},
                  textString="WFlo"),
                Text(extent={{56,94},{106,80}},
                  lineColor={0,0,127},
                  textString="V_flow"),
                Line(
                  points={{-74,92},{-74,40}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-74,40},{46,40}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-70,86},{-40,84},{8,68},{36,42}},
                  color={0,0,0},
                  smooth=Smooth.Bezier)}),
            Documentation(info="<html>
<p>
This is an interface that implements the functions to compute the head, power draw
and efficiency of fans and pumps.
</p>
<p>
The nominal hydraulic characteristic (volume flow rate versus total pressure)
is given by a set of data points
using the data record <code>per</code>, which is an instance of
<a href=\"modelica://IDEAS.Fluid.Movers.Data.Generic\">
IDEAS.Fluid.Movers.Data.Generic</a>.
A cubic hermite spline with linear extrapolation is used to compute
the performance at other operating points.
</p>
<p>
The fan or pump energy balance can be specified in two alternative ways:
</p>
<ul>
<li>
If <code>per.use_powerCharacteristic = false</code>, then the data points for
normalized volume flow rate versus efficiency is used to determine the efficiency,
and then the power consumption. The default is a constant efficiency of <i>0.7</i>.
</li>
<li>
If <code>per.use_powerCharacteristic = true</code>, then the data points for
normalized volume flow rate versus power consumption
is used to determine the power consumption, and then the efficiency
is computed based on the actual power consumption and the flow work.
</li>
</ul>
<p>
For exceptions to this general rule, check the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>

<h4>Implementation</h4>
<p>
For numerical reasons, the user-provided data points for volume flow rate
versus pressure rise are modified to add a fan internal flow resistance.
Because this flow resistance is subtracted during the simulation when
computing the fan pressure rise, the model reproduces the exact points
that were provided by the user.
</p>
<p>
Also for numerical reasons, the pressure rise at zero flow rate and
the flow rate at zero pressure rise is added to the user-provided data,
unless the user already provides these data points.
Since Modelica 3.2 does not allow dynamic memory allocation, this
implementation required the use of three different arrays for the
situation where no additional point is added, where one additional
point is added and where two additional points are added.
The parameter <code>curve</code> causes the correct data record
to be used during the simulation.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
February 19, 2016, by Michael Wetter and Filip Jorissen:<br/>
Refactored model to make implementation clearer.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference and reformatted code.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 2, 2015, by Michael Wetter:<br/>
Corrected computation of
<code>etaMot = cha.efficiency(per=per.motorEfficiency, V_flow=V_flow, d=motDer, r_N=r_N, delta=1E-4)</code>
which previously used <code>V_flow_max</code> instead of <code>V_flow</code>.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Removed in <code>N_actual</code> and <code>N_filtered</code>
the <code>max</code> attribute to
avoid a translation warning.
</li>
<li>
April 21, 2014, by Filip Jorissen and Michael Wetter:<br/>
Changed model to use
<a href=\"modelica://IDEAS.Fluid.Movers.Data.Generic\">
IDEAS.Fluid.Movers.Data.Generic</a>.
April 19, 2014, by Filip Jorissen:<br/>
Passed extra parameters to power() and efficiency()
to be able to properly evaluate the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 27, 2013, by Michael Wetter:<br/>
Reformulated <code>per=if (curve == 1) then pCur1 elseif (curve == 2) then pCur2 else pCur3</code>
by moving the computation into the idividual logical branches because OpenModelica generates an
error when assign the statement to <code>data</code>
as <code>pCur1</code>, <code>pCur2</code> and <code>pCur3</code> have different dimensions.
</li>
<li>
September 17, 2013, by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of parameters
that are an array.
</li>
<li>
March 20, 2013, by Michael Wetter:<br/>
Removed assignment in declaration of <code>pCur?.V_flow</code> as
these parameters have the attribute <code>fixed=false</code> set.
</li>
<li>
October 11, 2012, by Michael Wetter:<br/>
Added implementation of <code>WFlo = eta * P</code> with
guard against division by zero.
Changed implementation of <code>etaMot=sqrt(eta)</code> to
<code>etaHyd = 1</code> to avoid infinite derivative as <code>eta</code>
converges to zero.
</li>
<li>
February 20, 2012, by Michael Wetter:<br/>
Assigned value to nominal attribute of <code>V_flow</code>.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
October 4 2011, by Michael Wetter:<br/>
Revised the implementation of the pressure drop computation as a function
of speed and volume flow rate.
The new implementation avoids a singularity near zero volume flow rate and zero speed.
</li>
<li>
March 28 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end FlowMachineInterface;

        model IdealSource
          "Base class for pressure and mass flow source with optional power input"
          extends IDEAS.Fluid.Interfaces.PartialTwoPortTransport(show_T=false);
          // Quantity to control
          parameter Boolean control_m_flow
            "if true, then the mass flow rate is equal to the value of m_flow_in"
            annotation(Evaluate = true);
          parameter Boolean control_dp = not control_m_flow
            "if true, then the head is equal to the value of dp_in"
            annotation(Evaluate = true);
          Modelica.Blocks.Interfaces.RealInput m_flow_in(unit="kg/s") if control_m_flow
            "Prescribed mass flow rate"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-60,80})));
          Modelica.Blocks.Interfaces.RealInput dp_in(unit="Pa") if control_dp
            "Prescribed pressure difference port_a.p-port_b.p"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={60,80})));
      protected
          Modelica.Blocks.Interfaces.RealInput m_flow_internal(unit="kg/s")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput dp_internal(unit="Pa")
            "Needed to connect to conditional connector";
        equation
          // Ideal control
          if control_m_flow then
            m_flow = m_flow_internal;
          else
            m_flow_internal = 0;
          end if;
          if control_dp then
            dp = dp_internal;
          else
            dp_internal = 0;
          end if;
          connect(dp_internal, dp_in);
          connect(m_flow_internal, m_flow_in);
          // Energy balance (no storage)
          port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
          port_b.h_outflow = inStream(port_a.h_outflow);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,60},{100,-60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,50},{100,-48}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Text(
                  visible=not control_m_flow,
                  extent={{24,44},{80,24}},
                  lineColor={255,255,255},
                  textString="dp"),
                Text(
                  visible=control_m_flow,
                  extent={{-80,44},{-24,24}},
                  lineColor={255,255,255},
                  textString="m")}),
            Documentation(info="<html>
<p>
Model of a fictitious pipe that is used as a base class
for a pressure source or to prescribe a mass flow rate.
</p>
<p>
Note that for fans and pumps with dynamic balance,
both the heat and the flow work are added to the volume of
air or water. This simplifies the equations compared to
adding heat to the volume, and flow work to this model.
</p>
<p>
Typically either <code>control_m_flow</code> or
<code>control_dp</code> should be <code>true</code> to avoid a
singular system.
If <code>control_m_flow = true</code>, then the mass flow rate
is set to the value of the input connector <code>m_flow_in</code>.
Otherwise, this model does not specify the mass flow rate.
Similarly, if <code>control_dp = true</code>, the head is equal to the
value of the input connector <code>dp_in</code>.
Otherwise, this model does not specify the head.
</p>
</html>",
        revisions="<html>
<ul>
<li>
May 4, 2017, by Filip Jorissen:<br/>
Implemented option to set <code>control_dp</code>
independently from <code>control_m_flow</code>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/770\">#770</a>.
</li>
<li>
March 2, 2017, by Filip Jorissen:<br/>
Implemented simplification when <code>allowFlowReversal=false</code>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/673\">#673</a>.
</li>
<li>
March 20, 2016, by Michael Wetter:<br/>
Corrected documentation for <code>dp_in</code>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Added units to the signal connectors.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
Removed the option to add power to the medium, as this is dealt with in the volume
that is used in the mover model.
</li>
<li>
July 27, 2010 by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>
April 13, 2010 by Michael Wetter:<br/>
Made heat connector optional.
</li>
<li>
March 23, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end IdealSource;

        partial model PartialFlowMachine
          "Partial model to interface fan or pump models with the medium"
          extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations(
            final mSenFac=1);
          extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
            m_flow_nominal(final min=Modelica.Constants.small),
            show_T=false,
            port_a(
              h_outflow(start=h_outflow_start)),
            port_b(
              h_outflow(start=h_outflow_start),
              p(start=p_start),
              final m_flow(max = if allowFlowReversal then +Modelica.Constants.inf else 0)));

          replaceable parameter IDEAS.Fluid.Movers.Data.Generic per
            constrainedby IDEAS.Fluid.Movers.Data.Generic
            "Record with performance data"
            annotation (choicesAllMatching=true,
              Placement(transformation(extent={{52,60},{72,80}})));

          parameter IDEAS.Fluid.Types.InputType inputType = IDEAS.Fluid.Types.InputType.Continuous
            "Control input type"
            annotation(Dialog(
              group="Control"));
          parameter Real constInput = 0 "Constant input set point"
            annotation(Dialog(
              group="Control",
              enable=inputType == IDEAS.Fluid.Types.InputType.Constant));
          parameter Real stageInputs[:]
            "Vector of input set points corresponding to stages"
            annotation(Dialog(
              group="Control",
              enable=inputType == IDEAS.Fluid.Types.InputType.Stages));

          parameter Boolean computePowerUsingSimilarityLaws
            "= true, compute power exactly, using similarity laws. Otherwise approximate.";

          parameter Boolean addPowerToMedium=true
            "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations)";

          parameter Boolean nominalValuesDefineDefaultPressureCurve = false
            "Set to true to avoid warning if m_flow_nominal and dp_nominal are used to construct the default pressure curve";

          parameter Modelica.SIunits.Time tau=1
            "Time constant of fluid volume for nominal flow, used if energy or mass balance is dynamic"
            annotation (Dialog(tab="Dynamics",
                                group="Nominal condition",
                                enable=energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or
                                       massDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState));

          // Classes used to implement the filtered speed
          parameter Boolean use_inputFilter=true
            "= true, if speed is filtered with a 2nd order CriticalDamping filter"
            annotation(Dialog(tab="Dynamics", group="Filtered speed"));
          parameter Modelica.SIunits.Time riseTime=30
            "Rise time of the filter (time to reach 99.6 % of the speed)"
            annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=use_inputFilter));
          parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
            "Type of initialization (no init/steady state/initial state/initial output)"
            annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=use_inputFilter));
          parameter Real y_start(min=0, max=1, unit="1")=0 "Initial value of speed"
            annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=use_inputFilter));

          // Connectors and ports
            Modelica.Blocks.Interfaces.IntegerInput stage if
               inputType == IDEAS.Fluid.Types.InputType.Stages
            "Stage input signal for the pressure head"
            annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,120})));

          Modelica.Blocks.Interfaces.RealOutput y_actual(
            final unit="1")
            "Actual normalised pump speed that is used for computations"
            annotation (Placement(transformation(extent={{100,60},{120,80}}),
                iconTransformation(extent={{100,60},{120,80}})));

          Modelica.Blocks.Interfaces.RealOutput P(
            quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
            "Heat dissipation to environment"
            annotation (Placement(transformation(extent={{-70,-110},{-50,-90}}),
                iconTransformation(extent={{-10,-78},{10,-58}})));

          // Variables
          Modelica.SIunits.VolumeFlowRate VMachine_flow(start=_VMachine_flow) = eff.V_flow "Volume flow rate";
          Modelica.SIunits.PressureDifference dpMachine(displayUnit="Pa")=
              -preSou.dp "Pressure difference";

          Real eta(unit="1", final quantity="Efficiency") =    eff.eta "Global efficiency";
          Real etaHyd(unit="1", final quantity="Efficiency") = eff.etaHyd "Hydraulic efficiency";
          Real etaMot(unit="1", final quantity="Efficiency") = eff.etaMot "Motor efficiency";

          // Quantity to control
      protected
          final parameter Modelica.SIunits.VolumeFlowRate _VMachine_flow = 0
            "Start value for VMachine_flow, used to avoid a warning if not specified";

          parameter Types.PrescribedVariable preVar "Type of prescribed variable";

          // The parameter speedIsInput is required to conditionally remove the instance gain.
          // If the conditional removal of this instance where to use the test
          // preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed,
          // then OpenModelica fails to translate the model with the message
          // .../PartialFlowMachine.mo:185:3-189:70:writable]
          // Error: Variable Types.PrescribedVariable.Speed not found in scope
          // IDEAS.Fluid.Movers.SpeedControlled_y$floMac1.
          final parameter Boolean speedIsInput=
            (preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed)
            "Parameter that is true if speed is the controlled variables";

          final parameter Integer nOri = size(per.pressure.V_flow, 1)
            "Number of data points for pressure curve"
            annotation(Evaluate=true);

          final parameter Boolean haveVMax = (abs(per.pressure.dp[nOri]) < Modelica.Constants.eps)
            "Flag, true if user specified data that contain V_flow_max";

          final parameter Modelica.SIunits.VolumeFlowRate V_flow_max=
            if per.havePressureCurve then
            (if haveVMax then
              per.pressure.V_flow[nOri]
             else
              per.pressure.V_flow[nOri] - (per.pressure.V_flow[nOri] - per.pressure.V_flow[
              nOri - 1])/((per.pressure.dp[nOri] - per.pressure.dp[nOri - 1]))*per.pressure.dp[nOri])
            else
              m_flow_nominal/rho_default "Maximum volume flow rate, used for smoothing";
          final parameter Modelica.SIunits.Density rho_default=
            Medium.density_pTX(
              p=Medium.p_default,
              T=Medium.T_default,
              X=Medium.X_default) "Default medium density";

          final parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
            T=T_start,
            p=p_start,
            X=X_start) "Medium state at start values";

          final parameter Modelica.SIunits.SpecificEnthalpy h_outflow_start = Medium.specificEnthalpy(sta_start)
            "Start value for outflowing enthalpy";

          Modelica.Blocks.Sources.Constant[size(stageInputs, 1)] stageValues(
            final k=stageInputs) if
              inputType == IDEAS.Fluid.Types.InputType.Stages "Stage input values"
            annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
          Modelica.Blocks.Sources.Constant setConst(
            final k=constInput) if
              inputType == IDEAS.Fluid.Types.InputType.Constant
            "Constant input set point"
            annotation (Placement(transformation(extent={{-80,70},{-60,90}})));

          Extractor extractor(final nin=size(stageInputs,1)) if
              inputType == IDEAS.Fluid.Types.InputType.Stages "Stage input extractor"
            annotation (Placement(transformation(extent={{-50,60},{-30,40}})));

          Modelica.Blocks.Routing.RealPassThrough inputSwitch
            "Dummy connection for easy connection of input options"
            annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                origin={-10,50})));

          IDEAS.Fluid.Delays.DelayFirstOrder vol(
            redeclare final package Medium = Medium,
            final tau=tau,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final m_flow_nominal=m_flow_nominal,
            final m_flow_small=m_flow_small,
            final p_start=p_start,
            final prescribedHeatFlowRate=true,
            final allowFlowReversal=allowFlowReversal,
            nPorts=2) "Fluid volume for dynamic model"
            annotation (Placement(transformation(extent={{-70,0},{-90,20}})));

          Modelica.Blocks.Continuous.Filter filter(
             order=2,
             f_cut=5/(2*Modelica.Constants.pi*riseTime),
             final init=init,
             x(each stateSelect=StateSelect.always),
             final analogFilter=Modelica.Blocks.Types.AnalogFilter.CriticalDamping,
             final filterType=Modelica.Blocks.Types.FilterType.LowPass) if
                use_inputFilter
            "Second order filter to approximate valve opening time, and to improve numerics"
            annotation (Placement(transformation(extent={{20,81},{34,95}})));

          Modelica.Blocks.Math.Gain gaiSpe(y(final unit="1")) if
            inputType == IDEAS.Fluid.Types.InputType.Continuous and
            speedIsInput
            "Gain to normalized speed using speed_nominal or speed_rpm_nominal"
            annotation (Placement(transformation(extent={{-4,74},{-16,86}})));

          IDEAS.Fluid.Movers.BaseClasses.IdealSource preSou(
            redeclare final package Medium = Medium,
            final m_flow_small=m_flow_small,
            final allowFlowReversal=allowFlowReversal,
            final control_m_flow= (preVar ==  IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate))
            "Pressure source"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));

          IDEAS.Fluid.Movers.BaseClasses.PowerInterface heaDis(
            final motorCooledByFluid=per.motorCooledByFluid,
            final delta_V_flow=1E-3*V_flow_max) if
              addPowerToMedium "Heat dissipation into medium"
            annotation (Placement(transformation(extent={{20,-80},{40,-60}})));

          Modelica.Blocks.Math.Add PToMed(final k1=1, final k2=1) if
            addPowerToMedium "Heat and work input into medium"
            annotation (Placement(transformation(extent={{50,-90},{70,-70}})));

          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prePow(
            final alpha=0) if
            addPowerToMedium
            "Prescribed power (=heat and flow work) flow for dynamic model"
            annotation (Placement(transformation(extent={{-14,-104},{-34,-84}})));

          Modelica.Blocks.Sources.RealExpression rho_inlet(y=
            Medium.density(
              Medium.setState_phX(port_a.p,
                                  inStream(port_a.h_outflow),
                                  inStream(port_a.Xi_outflow))))
            "Density of the inflowing fluid"
            annotation (Placement(transformation(extent={{-90,-74},{-70,-54}})));

          IDEAS.Fluid.Sensors.MassFlowRate senMasFlo(
            redeclare final package Medium = Medium) "Mass flow rate sensor"
            annotation (Placement(transformation(extent={{-50,10},{-30,-10}})));

          Sensors.RelativePressure senRelPre(
            redeclare final package Medium = Medium) "Head of mover"
            annotation (Placement(transformation(extent={{58,-27},{43,-14}})));

          // Because the speed data are not used by FlowMachineInterface, we set them
          // to zero.
          FlowMachineInterface eff(
            per(
              final hydraulicEfficiency = per.hydraulicEfficiency,
              final motorEfficiency =     per.motorEfficiency,
              final motorCooledByFluid =  per.motorCooledByFluid,
              final speed_nominal =       0,
              final constantSpeed =       0,
              final speeds =              {0},
              final power =               per.power),
            final nOri = nOri,
            final rho_default=rho_default,
            final computePowerUsingSimilarityLaws=computePowerUsingSimilarityLaws,
            final haveVMax=haveVMax,
            final V_flow_max=V_flow_max,
            r_N(start=y_start),
            r_V(start=m_flow_nominal/rho_default),
            final preVar=preVar) "Flow machine"
            annotation (Placement(transformation(extent={{-32,-68},{-12,-48}})));

      protected
          block Extractor
            "Extract scalar signal out of signal vector dependent on IntegerRealInput index"
            extends Modelica.Blocks.Interfaces.MISO;

            Modelica.Blocks.Interfaces.IntegerInput index "Integer input for control input"
            annotation (Placement(
                  transformation(
                  origin={0,-120},
                  extent={{-20,-20},{20,20}},
                  rotation=90)));
          equation
          y = sum({if index == i then u[i] else 0 for i in 1:nin});

          annotation (Icon(graphics={
                  Rectangle(
                    extent={{-80,50},{-40,-50}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-84.4104,1.9079},{-84.4104,-2.09208},{-80.4104,-0.09208},{
                        -84.4104,1.9079}},
                    lineColor={0,0,127},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-62,2},{-50.1395,12.907},{-39.1395,12.907}}, color={0,0,
                        127}),
                  Line(points={{-63,4},{-49,40},{-39,40}}, color={0,0,127}),
                  Line(points={{-102,0},{-65.0373,-0.01802}}, color={0,0,127}),
                  Ellipse(
                    extent={{-70.0437,4.5925},{-60.0437,-4.90745}},
                    lineColor={0,0,127},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-63,-5},{-50,-40},{-39,-40}}, color={0,0,127}),
                  Line(points={{-62,-2},{-50.0698,-12.907},{-39.0698,-12.907}}, color={
                        0,0,127}),
                  Polygon(
                    points={{-38.8808,-11},{-38.8808,-15},{-34.8808,-13},{-38.8808,-11}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-39,42},{-39,38},{-35,40},{-39,42}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-38.8728,-38.0295},{-38.8728,-42.0295},{-34.8728,-40.0295},
                        {-38.8728,-38.0295}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-38.9983,14.8801},{-38.9983,10.8801},{-34.9983,12.8801},{-38.9983,
                        14.8801}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-30,50},{30,-50}},
                    fillColor={235,235,235},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Line(points={{100,0},{0,0}}, color={0,0,127}),
                  Line(points={{0,2},{0,-104}}, color={255,128,0}),
                  Line(points={{-35,40},{-20,40}}, color={0,0,127}),
                  Line(points={{-35,13},{-20,13}}, color={0,0,127}),
                  Line(points={{-35,-13},{-20,-13}}, color={0,0,127}),
                  Line(points={{-35,-40},{-20,-40}}, color={0,0,127}),
                  Polygon(points={{0,0},{-20,13},{-20,13},{0,0},{0,0}}, lineColor={0,0,
                        127}),
                  Ellipse(
                    extent={{-6,6},{6,-6}},
                    lineColor={255,128,0},
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid)}));
          end Extractor;

        initial equation
          // Check incorrect value of m_flow_nominal
          assert(m_flow_nominal >= Modelica.Constants.small, "In "+ getInstanceName()+
          ": The value of parameter m_flow_nominal should be greater or equal than " +
          String(Modelica.Constants.small) + " but it equals " + String(m_flow_nominal));
          // The control signal is dp or m_flow but the user did not provide a pump curve.
          // Hence, the speed is computed using default values, which likely are wrong.
          // Therefore, scaling the power using the speed is inaccurate.
          assert(nominalValuesDefineDefaultPressureCurve or
                 per.havePressureCurve or
                 (preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed),
        "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve.
             This leads to approximate calculations of the electrical power
             consumption. Add the correct pressure curve in the record per
             to obtain an accurate computation.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.",
                 level=AssertionLevel.warning);

          // The control signal is dp or m_flow but the user did not provide a pump curve.
          // Hence, the speed is computed using default values, which likely are wrong.
          // In addition, the user wants to use (V_flow, P) to compute the power.
          // This can lead to using a power that is less than the flow work. We avoid
          // this by ignoring the setting of per.use_powerCharacteristics.
          // The comment is split into two parts since otherwise the JModelica C-compiler
          // throws warnings.
          assert(nominalValuesDefineDefaultPressureCurve or
                 (per.havePressureCurve or
                   (preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed)) or
                 per.use_powerCharacteristic == false,
        "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve and you set use_powerCharacteristic = true.
             Since this can cause wrong power consumption, the model will overwrite
             this setting and use instead use_powerCharacteristic = false."         +
                     "Since this causes the efficiency curve to be used,
             make sure that the efficiency curves in the performance record per
             are correct or add the pressure curve of the mover.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.",
                 level=AssertionLevel.warning);

        equation
          connect(prePow.port, vol.heatPort) annotation (Line(
              points={{-34,-94},{-60,-94},{-60,10},{-70,10}},
              color={191,0,0}));

          connect(vol.heatPort, heatPort) annotation (Line(
              points={{-70,10},{-70,10},{-60,10},{-60,-100}},
              color={191,0,0}));
          connect(preSou.port_b, port_b) annotation (Line(
              points={{60,0},{100,0}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(stageValues.y, extractor.u) annotation (Line(
              points={{-59,50},{-52,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(extractor.y, inputSwitch.u) annotation (Line(
              points={{-29,50},{-22,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(setConst.y, inputSwitch.u) annotation (Line(
              points={{-59,80},{-26,80},{-26,50},{-22,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(extractor.index, stage) annotation (Line(
              points={{-40,62},{-40,90},{0,90},{0,120}},
              color={255,127,0},
              smooth=Smooth.None));

          connect(PToMed.y, prePow.Q_flow) annotation (Line(points={{71,-80},{80,-80},{80,
                  -94},{-14,-94}},                 color={0,0,127}));
          connect(PToMed.u1, heaDis.Q_flow) annotation (Line(points={{48,-74},{44,-74},{
                  44,-72},{44,-70},{41,-70}},
                                     color={0,0,127}));

          connect(senRelPre.port_b, preSou.port_a) annotation (Line(points={{43,-20.5},{
                  20,-20.5},{20,0},{40,0}},
                                       color={0,127,255}));
          connect(senRelPre.port_a, preSou.port_b) annotation (Line(points={{58,-20.5},{
                  80,-20.5},{80,0},{60,0}},
                                       color={0,127,255}));
          connect(heaDis.etaHyd,eff. etaHyd) annotation (Line(points={{18,-60},{10,-60},
                  {10,-65},{-11,-65}},                     color={0,0,127}));
          connect(heaDis.V_flow,eff. V_flow) annotation (Line(points={{18,-66},{14,-66},
                  {14,-53.2},{-6,-53.2},{-11,-53.2}},
                                             color={0,0,127}));
          connect(eff.PEle, heaDis.PEle) annotation (Line(points={{-11,-59},{0,-59},{0,-80},
                  {18,-80}},      color={0,0,127}));
          connect(eff.WFlo, heaDis.WFlo) annotation (Line(points={{-11,-56},{-8,-56},{-8,
                  -74},{18,-74}}, color={0,0,127}));
          connect(rho_inlet.y,eff. rho) annotation (Line(points={{-69,-64},{-69,-64},{-34,
                  -64}},                          color={0,0,127}));
          connect(eff.m_flow, senMasFlo.m_flow) annotation (Line(points={{-34,-54},{-34,
                  -54},{-40,-54},{-40,-11}},               color={0,0,127}));
          connect(eff.PEle, P) annotation (Line(points={{-11,-59},{0,-59},{0,-50},{90,
                  -50},{90,90},{110,90}},
                                     color={0,0,127}));
          connect(eff.WFlo, PToMed.u2) annotation (Line(points={{-11,-56},{-8,-56},{-8,-86},
                  {48,-86}},      color={0,0,127}));
          connect(inputSwitch.y, filter.u) annotation (Line(points={{1,50},{16,50},{16,88},
                  {18.6,88}},     color={0,0,127}));

          connect(senRelPre.p_rel, eff.dp_in) annotation (Line(points={{50.5,-26.35},{50.5,
                  -38},{-18,-38},{-18,-46}},               color={0,0,127}));
          connect(eff.y_out, y_actual) annotation (Line(points={{-11,-48},{92,-48},{92,
                  70},{110,70}},
                             color={0,0,127}));
          connect(port_a, vol.ports[1])
            annotation (Line(points={{-100,0},{-78,0},{-78,0}}, color={0,127,255}));
          connect(vol.ports[2], senMasFlo.port_a)
            annotation (Line(points={{-82,0},{-82,0},{-50,0}}, color={0,127,255}));
          connect(senMasFlo.port_b, preSou.port_a)
            annotation (Line(points={{-30,0},{40,0},{40,0}}, color={0,127,255}));
           annotation(Icon(coordinateSystem(preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}),
            graphics={
                Line(
                  points={{0,70},{100,70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,90},{100,90}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  visible=not use_inputFilter,
                  points={{0,100},{0,40}}),
                Rectangle(
                  extent={{-100,16},{100,-14}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Ellipse(
                  extent={{-58,50},{54,-58}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,100,199}),
                Polygon(
                  points={{0,50},{0,-56},{54,2},{0,50}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={255,255,255}),
                Ellipse(
                  extent={{4,14},{34,-16}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  visible=energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState,
                  fillColor={0,100,199}),
                Text(extent={{64,106},{114,92}},
                  lineColor={0,0,127},
                  textString="P"),
                Text(extent={{42,86},{92,72}},
                  lineColor={0,0,127},
                  textString="y_actual"),
                Line(
                  points={{0,100},{0,50}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>
This is the base model for fans and pumps.
It provides an interface
between the equations that compute head and power consumption,
and the implementation of the energy and pressure balance
of the fluid.
</p>
<p>
Optionally, the fluid volume
is computed using a dynamic balance or a steady-state balance.
</p>
<p>
The parameter <code>addPowerToMedium</code> determines whether
any power is added to the fluid. The default is <code>addPowerToMedium=true</code>,
and hence the outlet enthalpy is higher than the inlet enthalpy if the
flow device is operating.
The setting <code>addPowerToMedium=false</code> is physically incorrect
(since the flow work, the flow friction and the fan heat do not increase
the enthalpy of the medium), but this setting does in some cases lead to simpler equations
and more robust simulation, in particular if the mass flow is equal to zero.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 22, 2019, by Filip Jorissen:<br/>
Split long assert output string into two strings to avoid compiler warnings
in JModelica.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1081\">#1081</a>.
</li>
<li>
January 8, 2019, by Filip Jorissen:<br/>
Added assert for value of <code>m_flow_nominal</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/908\">#908</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Set start value for <code>VMachine_flow</code> to avoid a warning in
<a href=\"modelica://IDEAS.Fluid.Movers.Examples.MoverContinuous\">
IDEAS.Fluid.Movers.Examples.MoverContinuous</a>.
</li>
<li>
July 29, 2016, by Michael Wetter:<br/>
Made <code>Extractor</code> protected so that it can be removed later
with a backwards compatible change.
</li>
<li>
July 19, 2016, by Filip Jorissen:<br/>
Created custom implementation for extractor.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/498\">#498</a>.
</li>
<li>
June 16, 2016, by Filip Jorissen:<br/>
Switched position of mixing volume and mass flow rate sensor.
This is to have a consistent operating point tuple
of <code>dp</code> and <code>m_flow</code> when having
compressible flow.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
February 19, 2016, by Michael Wetter and Filip Jorissen:<br/>
Refactored model to make implementation clearer.
This model now includes code for both speed and flow prescribed models,
eliminating the need for an additional level of partial models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
Removed the parameter <code>dynamicBalance</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/411\">#411</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
Removed assignment of <code>min</code> and <code>max</code> attributes
of the port mass flow rate as this is already done in the base class.
Removed <code>import</code> statement.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
Added code for displaying constant set point in symbol.
</li>
<li>
January 24, 2015, by Michael Wetter:<br/>
Propagated <code>m_flow_small</code> of instance <code>vol</code> and made
all its parameters final.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 29, 2010, by Michael Wetter:<br/>
Reduced fan time constant from 10 to 1 second.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialFlowMachine;

        model PowerInterface
          "Partial model to compute power draw and heat dissipation of fans and pumps"
          extends Modelica.Blocks.Icons.Block;
          parameter Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean motorCooledByFluid
            "Flag, true if the motor is cooled by the fluid stream";
          parameter Modelica.SIunits.VolumeFlowRate delta_V_flow
            "Factor used for setting heat input into medium to zero at very small flows";
          Modelica.Blocks.Interfaces.RealInput etaHyd(
            final quantity="Efficiency",
            final unit="1") "Hydraulic efficiency"
            annotation (Placement(transformation(extent={{-140,80},{-100,120}}),
                iconTransformation(extent={{-140,80},{-100,120}})));
          Modelica.Blocks.Interfaces.RealInput V_flow(
            final quantity="VolumeFlowRate",
            final unit="m3/s") "Volume flow rate"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
                iconTransformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput WFlo(
            final quantity="Power",
            final unit="W") "Flow work"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}}),
                iconTransformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput PEle(
            final quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{-140,-120},{-100,-80}})));
          Modelica.Blocks.Interfaces.RealOutput Q_flow(
            quantity="Power",
            final unit="W") "Heat input from fan or pump to medium"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.SIunits.Power WHyd
            "Hydraulic power input (converted to flow work and heat)";
      protected
          Modelica.SIunits.HeatFlowRate QThe_flow
            "Heat input from fan or pump to medium";
        equation
          // Hydraulic power (transmitted by shaft), etaHyd = WFlo/WHyd
          etaHyd * WHyd   = WFlo;
          // Heat input into medium
          QThe_flow +  WFlo = if motorCooledByFluid then PEle else WHyd;
          // At m_flow = 0, the solver may still obtain positive values for QThe_flow.
          // The next statement sets the heat input into the medium to zero for very small flow rates.
          Q_flow = if homotopyInitialization then
            homotopy(actual=IDEAS.Utilities.Math.Functions.regStep(
                              y1=QThe_flow,
                              y2=0,
                              x=noEvent(abs(V_flow))-2*delta_V_flow,
                              x_small=delta_V_flow),
                    simplified=0)
            else
              IDEAS.Utilities.Math.Functions.regStep(
                              y1=QThe_flow,
                              y2=0,
                              x=noEvent(abs(V_flow))-2*delta_V_flow,
                              x_small=delta_V_flow);
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
            Line( origin={-49.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Line( origin={0.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Line( origin={50.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Polygon(
            origin={48,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0}),
            Polygon(
            origin={-2,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0}),
            Polygon(
            origin={-52,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0})}),
            Documentation(info="<html>
<p>Block that implements the functions to compute the
heat dissipation of fans and pumps. It is used by the model
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.PartialFlowMachine\">
IDEAS.Fluid.Movers.BaseClasses.PartialFlowMachine</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
February 19, 2016, by Michael Wetter:<br/>
First implementation during refactoring of mover models to make implementation clearer.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
</ul>
</html>"));
        end PowerInterface;

        package Types "Package with type definitions"
          extends Modelica.Icons.TypesPackage;

          type PrescribedVariable = enumeration(
            Speed   "Speed is prescribed",
            FlowRate   "Flow rate is prescribed",
            PressureDifference   "Pressure difference is prescribed")
            "Enumeration to choose what variable is prescribed";
         annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions for movers.
</p>
</html>"));
        end Types;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.Movers\">IDEAS.Fluid.Movers</a>.
</p>
</html>"));
      end BaseClasses;

      package Data "Package containing data for real pumps/fans"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Generic data record for movers"
          extends Modelica.Icons.Record;
          // Pressure requires default values to avoid in Dymola the message
          // Failed to expand the variable pressure.V_flow.
          parameter IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters pressure(
            V_flow = {0, 0},
            dp =     {0, 0}) "Volume flow rate vs. total pressure rise"
            annotation(Evaluate=true,
                       Dialog(group="Pressure curve"));
          parameter Boolean use_powerCharacteristic=false
            "Use power data instead of motor efficiency"
            annotation (Dialog(group="Power computation"));
          parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
            hydraulicEfficiency(
              V_flow={0},
              eta={0.7}) "Hydraulic efficiency (used if use_powerCharacteristic=false)"
            annotation (Dialog(group="Power computation",
                               enable=not use_powerCharacteristic));
          parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
            motorEfficiency(
              V_flow={0},
              eta={0.7})
            "Electric motor efficiency (used if use_powerCharacteristic=false)"
            annotation (Dialog(group="Power computation",
                               enable=not use_powerCharacteristic));
          // Power requires default values to avoid in Dymola the message
          // Failed to expand the variable Power.V_flow
          parameter BaseClasses.Characteristics.powerParameters power(
            V_flow={0},
            P={0})
            "Volume flow rate vs. electrical power consumption (used if use_powerCharacteristic=true)"
           annotation (Dialog(group="Power computation",
                              enable=use_powerCharacteristic));
          parameter Boolean motorCooledByFluid=true
            "If true, then motor heat is added to fluid stream"
            annotation(Dialog(group="Motor heat rejection"));
          parameter Real speed_nominal(
            final min=0,
            final unit="1") = 1 "Nominal rotational speed for flow characteristic"
            annotation (Dialog(group="Normalized speeds (used in model, default values assigned from speeds in rpm)"));
          parameter Real constantSpeed(final min=0, final unit="1") = constantSpeed_rpm/speed_rpm_nominal
            "Normalized speed set point, used if inputType = IDEAS.Fluid.Types.InputType.Constant"
            annotation (Dialog(group="Normalized speeds (used in model, default values assigned from speeds in rpm)"));
          parameter Real[:] speeds(each final min = 0, each final unit="1") = speeds_rpm/speed_rpm_nominal
            "Vector of normalized speed set points, used if inputType = IDEAS.Fluid.Types.InputType.Stages"
            annotation (Dialog(group="Normalized speeds (used in model, default values assigned from speeds in rpm)"));
          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm speed_rpm_nominal=1500
            "Nominal rotational speed for flow characteristic"
            annotation (Dialog(group="Speeds in RPM"));
          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm constantSpeed_rpm=speed_rpm_nominal
            "Speed set point, used if inputType = IDEAS.Fluid.Types.InputType.Constant"
            annotation (Dialog(group="Speeds in RPM"));
          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm[:] speeds_rpm = {speed_rpm_nominal}
            "Vector of speed set points, used if inputType = IDEAS.Fluid.Types.InputType.Stages"
            annotation (Dialog(group="Speeds in RPM"));
          // Set a parameter in order for
          // (a) FlowControlled_m_flow and FlowControlled_dp being able to set a reasonable
          //     default pressure curve if it is not specified here, and
          // (b) SpeedControlled_y and SpeedControlled_Nrpm being able to issue an assert
          //     if no pressure curve is specified.
          final parameter Boolean havePressureCurve=
            sum(pressure.V_flow) > Modelica.Constants.eps and
            sum(pressure.dp) > Modelica.Constants.eps
            "= true, if default record values are being used";
          annotation (
          defaultComponentPrefixes = "parameter",
          defaultComponentName = "per",
          Documentation(revisions="<html>
<ul>
<li>
February 19, 2016, by Filip Jorissen:<br/>
Refactored model such that <code>SpeedControlled_Nrpm</code>,
<code>SpeedControlled_y</code> and <code>FlowControlled</code>
are integrated into one record.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
February 17, 2016, by Michael Wetter:<br/>
Changed parameter <code>N_nominal</code> to
<code>speed_rpm_nominal</code> as it is the same quantity as <code>speeds_rmp</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
January 19, 2016, by Filip Jorissen:<br/>
Added parameter <code>speeds_rpm</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
February 13, 2015, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised record for OpenModelica.
</li>
<li>
November 22, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Record containing parameters for pumps or fans.
</p>
<h4>Typical use</h4>
<p>
This record may be used to assign for example fan performance data using
declaration such as
</p>
<pre>
  IDEAS.Fluid.Movers.SpeedControlled_y fan(
    redeclare package Medium = Medium,
      per(pressure(V_flow={0,m_flow_nominal,2*m_flow_nominal}/1.2,
                   dp={2*dp_nominal,dp_nominal,0}))) \"Fan\";
</pre>
<p>
This data record can be used with
<a href=\"modelica://IDEAS.Fluid.Movers.SpeedControlled_Nrpm\">
IDEAS.Fluid.Movers.SpeedControlled_Nrpm</a>,
<a href=\"modelica://IDEAS.Fluid.Movers.SpeedControlled_y\">
IDEAS.Fluid.Movers.SpeedControlled_y</a>,
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_dp\">
IDEAS.Fluid.Movers.FlowControlled_dp</a>,
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_m_flow\">
IDEAS.Fluid.Movers.FlowControlled_m_flow</a>.
</p>
<p>
An example that uses manufacturer data can be found in
<a href=\"modelica://IDEAS.Fluid.Movers.Validation.Pump_Nrpm_stratos\">
IDEAS.Fluid.Movers.Validation.Pump_Nrpm_stratos</a>.
</p>
<h4>Parameters in RPM</h4>
<p>
The parameters <code>speed_rpm_nominal</code>,
<code>constantSpeed_rpm</code> and
<code>speeds_rpm</code> are used to assign the non-dimensional speeds
</p>
<pre>
  parameter Real constantSpeed(final min=0, final unit=\"1\") = constantSpeed_rpm/speed_rpm_nominal;
  parameter Real[:] speeds(each final min = 0, each final unit=\"1\") = speeds_rpm/speed_rpm_nominal;
</pre>
<p>
In addition, <code>speed_rpm_nominal</code> is used in
<a href=\"modelica://IDEAS.Fluid.Movers.SpeedControlled_Nrpm\">
IDEAS.Fluid.Movers.SpeedControlled_Nrpm</a>
to normalize the control input signal.
Otherwise, these speed parameters in RPM are not used in the models.
</p>
</html>"));
        end Generic;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains data for fans and pumps.
</p>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>"));
      end Data;

      model FlowControlled_dp
        "Fan or pump with ideally controlled head dp as input signal"
        extends IDEAS.Fluid.Movers.BaseClasses.PartialFlowMachine(
          final preVar=IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.PressureDifference,
          final computePowerUsingSimilarityLaws=per.havePressureCurve,
          preSou(dp_start=dp_start, control_dp= not prescribeSystemPressure),
          final stageInputs(each final unit="Pa") = heads,
          final constInput(final unit="Pa") = constantHead,
          filter(
            final y_start=dp_start,
            u_nominal=abs(dp_nominal),
            u(final unit="Pa"),
            y(final unit="Pa")),
          eff(
            per(
              final pressure = if per.havePressureCurve then
                per.pressure
              else
                IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters(
                  V_flow = {i/(nOri-1)*2.0*m_flow_nominal/rho_default for i in 0:(nOri-1)},
                  dp =     {i/(nOri-1)*2.0*dp_nominal for i in (nOri-1):-1:0}),
            final use_powerCharacteristic = if per.havePressureCurve then per.use_powerCharacteristic else false)));
        parameter Modelica.SIunits.PressureDifference dp_start(
          min=0,
          displayUnit="Pa")=0 "Initial value of pressure raise"
          annotation(Dialog(tab="Dynamics", group="Filtered speed"));
        // For air, we set dp_nominal = 600 as default, for water we set 10000
        parameter Modelica.SIunits.PressureDifference dp_nominal(
          min=0,
          displayUnit="Pa")=
            if rho_default < 500 then 500 else 10000 "Nominal pressure raise, used to normalized the filter if use_inputFilter=true,
        to set default values of constantHead and heads, and
        and for default pressure curve if not specified in record per"
          annotation(Dialog(group="Nominal condition"));
        parameter Modelica.SIunits.PressureDifference constantHead(
          min=0,
          displayUnit="Pa")=dp_nominal
          "Constant pump head, used when inputType=Constant"
          annotation(Dialog(enable=inputType == IDEAS.Fluid.Types.InputType.Constant));
        // By default, set heads proportional to sqrt(speed/speed_nominal)
        parameter Modelica.SIunits.PressureDifference[:] heads(
          each min=0,
          each displayUnit="Pa")=
          dp_nominal*{(per.speeds[i]/per.speeds[end])^2 for i in 1:size(per.speeds, 1)}
          "Vector of head set points, used when inputType=Stages"
          annotation(Dialog(enable=inputType == IDEAS.Fluid.Types.InputType.Stages));
        parameter Boolean prescribeSystemPressure = false
          "=true, to control mover such that pressure difference is obtained across two remote points in system"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        Modelica.Blocks.Interfaces.RealInput dpMea(
          final quantity="PressureDifference",
          final displayUnit="Pa",
          final unit="Pa")=gain.u if prescribeSystemPressure
          "Measurement of pressure difference between two points where the set point should be obtained"
          annotation (Placement(transformation(
              extent={{20,-20},{-20,20}},
              rotation=90,
              origin={-80,120})));
        Modelica.Blocks.Interfaces.RealInput dp_in(final unit="Pa") if
          inputType == IDEAS.Fluid.Types.InputType.Continuous
          "Prescribed pressure rise"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120})));
        Modelica.Blocks.Interfaces.RealOutput dp_actual(final unit="Pa")
          "Pressure difference between the mover inlet and outlet"
          annotation (Placement(transformation(extent={{100,40},{120,60}}),
              iconTransformation(extent={{100,40},{120,60}})));
    protected
        Modelica.Blocks.Math.Gain gain(final k=-1)
          annotation (Placement(transformation(extent={{10,-10},{-10,10}},
              rotation=90,
              origin={36,30})));
      equation
        assert(inputSwitch.u >= -1E-3,
          "Pressure set point for mover cannot be negative. Obtained dp = " + String(inputSwitch.u));
        if use_inputFilter then
          connect(filter.y, gain.u) annotation (Line(
            points={{34.7,88},{36,88},{36,42}},
            color={0,0,127},
            smooth=Smooth.None));
        else
          connect(inputSwitch.y, gain.u) annotation (Line(
            points={{1,50},{36,50},{36,42}},
            color={0,0,127},
            smooth=Smooth.None));
        end if;
        connect(inputSwitch.u, dp_in) annotation (Line(
            points={{-22,50},{-26,50},{-26,80},{0,80},{0,120}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(preSou.dp_in, gain.y) annotation (Line(
            points={{56,8},{56,14},{36,14},{36,19}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(senRelPre.p_rel, dp_actual) annotation (Line(points={{50.5,-26.35},{
                50.5,-38},{74,-38},{74,50},{110,50}},
                                                 color={0,0,127}));
        annotation (defaultComponentName="fan",
        Documentation(info="<html>
<p>
This model describes a fan or pump with prescribed head.
The input connector provides the difference between
outlet minus inlet pressure.
The efficiency of the device is computed based
on the efficiency and pressure curves that are defined
in record <code>per</code>, which is of type
<a href=\"modelica://IDEAS.Fluid.Movers.SpeedControlled_Nrpm\">
IDEAS.Fluid.Movers.SpeedControlled_Nrpm</a>.
</p>
<h4>Main equations</h4>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a>.
</p>
<h4>Typical use and important parameters</h4>
<p>
If <code>use_inputFilter=true</code>, then the parameter <code>dp_nominal</code> is
used to normalize the filter. This is used to improve the numerics of the transient response.
The actual pressure raise of the mover at steady-state is independent
of the value of <code>dp_nominal</code>. It is recommended to set
<code>dp_nominal</code> to approximately the pressure raise that the mover has during
full speed.
</p>
<h4>Options</h4>
<p>
Parameter <code>prescribeSystemPressure</code>
can be used to control the mover such that the pressure
difference set point is obtained across two points
in the system, instead of across the fan.
This allows an efficient implementation of
static pressure reset controllers.
A measurement of the pressure difference between the
two points in system then needs to be connected
to <code>RealInput dpMea</code>.
This functionality is demonstrated in
<a href=\"modelica://IDEAS.Fluid.Movers.Validation.FlowControlled_dpSystem\">
IDEAS.Fluid.Movers.Validation.FlowControlled_dpSystem</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
May 5, 2017, by Filip Jorissen:<br/>
Added parameters, documentation and functionality for
<code>prescribeSystemPressure</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/770\">#770</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 14, 2016, by Michael Wetter:<br/>
Changed default values for <code>heads</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/583\">#583</a>.
</li>
<li>
March 2, 2016, by Filip Jorissen:<br/>
Refactored model such that it directly extends <code>PartialFlowMachine</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 5, 2015, by Michael Wetter:<br/>
Removed the parameters <code>use_powerCharacteristics</code> and <code>power</code>
from the performance data record <code>per</code>
because
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_dp\">
IDEAS.Fluid.Movers.FlowControlled_dp</a>
and
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_m_flow\">
IDEAS.Fluid.Movers.FlowControlled_m_flow</a>
fix the flow rate or head, which can give a flow work that is higher
than the power consumption specified in this record.
Hence, users should use the efficiency data for this model.
The record has been moved to
<a href=\"modelica://IDEAS.Fluid.Movers.Data.SpeedControlled_y\">
IDEAS.Fluid.Movers.Data.SpeedControlled_y</a>
as it makes sense to use it for the movers
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_Nrpm\">
IDEAS.Fluid.Movers.FlowControlled_Nrpm</a>
and
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_y\">
IDEAS.Fluid.Movers.FlowControlled_y</a>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/457\">
issue 457</a>.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>July 5, 2010, by Michael Wetter:<br/>
Changed <code>assert(dp_in >= 0, ...)</code> to <code>assert(dp_in >= -0.1, ...)</code>.
The former implementation triggered the assert if <code>dp_in</code> was solved for
in a nonlinear equation since the solution can be slightly negative while still being
within the solver tolerance.
</li>
<li>March 24, 2010, by Michael Wetter:<br/>
Revised implementation to allow zero flow rate.
</li>
<li>October 1, 2009,
    by Michael Wetter:<br/>
       Added model to the IDEAS library.
</ul>
</html>"),Icon(graphics={
              Line(
                points={{2,50},{100,50}},
                color={0,0,0},
                smooth=Smooth.None),
              Text(
                visible = inputType == IDEAS.Fluid.Types.InputType.Continuous,
                extent={{20,142},{104,108}},
                textString="dp_in"),
              Text(extent={{60,66},{110,52}},
                lineColor={0,0,127},
                textString="dp"),
              Rectangle(
                visible=use_inputFilter,
                extent={{-34,40},{32,100}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                visible=use_inputFilter,
                extent={{-34,100},{32,40}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Text(
                visible=use_inputFilter,
                extent={{-22,92},{20,46}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                textString="M",
                textStyle={TextStyle.Bold})}));
      end FlowControlled_dp;

      model FlowControlled_m_flow
        "Fan or pump with ideally controlled mass flow rate as input signal"
        extends IDEAS.Fluid.Movers.BaseClasses.PartialFlowMachine(
          final preVar=IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate,
          final computePowerUsingSimilarityLaws=per.havePressureCurve,
          final stageInputs(each final unit="kg/s")=massFlowRates,
          final constInput(final unit="kg/s")=constantMassFlowRate,
          filter(
            final y_start=m_flow_start,
            u_nominal=m_flow_nominal,
            u(final unit="kg/s"),
            y(final unit="kg/s")),
          eff(
            per(
              final pressure = if per.havePressureCurve then
                per.pressure
              else
                IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters(
                  V_flow = {i/(nOri-1)*2.0*m_flow_nominal/rho_default for i in 0:(nOri-1)},
                  dp =     {i/(nOri-1)*2.0*dp_nominal for i in (nOri-1):-1:0}),
            final use_powerCharacteristic = if per.havePressureCurve then per.use_powerCharacteristic else false)),
          preSou(m_flow_start=m_flow_start));
        // For air, we set dp_nominal = 600 as default, for water we set 10000
        parameter Modelica.SIunits.PressureDifference dp_nominal(min=0, displayUnit="Pa")=
          if rho_default < 500 then 500 else 10000
          "Nominal pressure raise, used for default pressure curve if not specified in record per"
          annotation(Dialog(group="Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m_flow_start(min=0)=0
          "Initial value of mass flow rate"
          annotation(Dialog(tab="Dynamics", group="Filtered speed"));
        parameter Modelica.SIunits.MassFlowRate constantMassFlowRate=m_flow_nominal
          "Constant pump mass flow rate, used when inputType=Constant"
          annotation(Dialog(enable=inputType == IDEAS.Fluid.Types.InputType.Constant));
        // By default, set massFlowRates proportional to (speed/speed_nominal)
        parameter Modelica.SIunits.MassFlowRate[:] massFlowRates=
          m_flow_nominal*{per.speeds[i]/per.speeds[end] for i in 1:size(per.speeds, 1)}
          "Vector of mass flow rate set points, used when inputType=Stage"
          annotation(Dialog(enable=inputType == IDEAS.Fluid.Types.InputType.Stages));
        Modelica.Blocks.Interfaces.RealInput m_flow_in(
          final unit="kg/s",
          nominal=m_flow_nominal) if
             inputType == IDEAS.Fluid.Types.InputType.Continuous
          "Prescribed mass flow rate"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120})));
        Modelica.Blocks.Interfaces.RealOutput m_flow_actual(
          final unit="kg/s",
          nominal=m_flow_nominal) "Actual mass flow rate"
          annotation (Placement(transformation(extent={{100,40},{120,60}}),
              iconTransformation(extent={{100,40},{120,60}})));
      equation
        if use_inputFilter then
          connect(filter.y, m_flow_actual) annotation (Line(
            points={{34.7,88},{44,88},{44,50},{110,50}},
            color={0,0,127},
            smooth=Smooth.None));
        else
          connect(inputSwitch.y, preSou.m_flow_in) annotation (Line(
            points={{1,50},{44,50},{44,8}},
            color={0,0,127},
            smooth=Smooth.None));
        end if;
         connect(m_flow_actual, preSou.m_flow_in) annotation (Line(
            points={{110,50},{44,50},{44,8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(inputSwitch.u, m_flow_in) annotation (Line(
            points={{-22,50},{-26,50},{-26,80},{0,80},{0,120}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (defaultComponentName="fan",
        Documentation(
         info="<html>
<p>
This model describes a fan or pump with prescribed mass flow rate.
The efficiency of the device is computed based
on the efficiency and pressure curves that are defined
in record <code>per</code>, which is of type
<a href=\"modelica://IDEAS.Fluid.Movers.SpeedControlled_Nrpm\">
IDEAS.Fluid.Movers.SpeedControlled_Nrpm</a>.
</p>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>",   revisions="<html>
<ul>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
November 10, 2016, by Michael Wetter:<br/>
Changed default values for <code>massFlowRates</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/583\">#583</a>.
</li>
<li>
March 2, 2016, by Filip Jorissen:<br/>
Refactored model such that it directly extends <code>PartialFlowMachine</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24, 2010, by Michael Wetter:<br/>
Revised implementation to allow zero flow rate.
</li>
<li>October 1, 2009
    by Michael Wetter:<br/>
       Model added to the IDEAS library.
</ul>
</html>"),Icon(graphics={
              Text(
                visible = inputType == IDEAS.Fluid.Types.InputType.Continuous,
                extent={{22,146},{114,102}},
                textString="m_flow_in"),
              Line(
                points={{2,50},{100,50}},
                color={0,0,0},
                smooth=Smooth.None),
              Text(extent={{50,66},{100,52}},
                lineColor={0,0,127},
                textString="m_flow"),
              Rectangle(
                visible=use_inputFilter,
                extent={{-34,40},{32,100}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                visible=use_inputFilter,
                extent={{-34,100},{32,40}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Text(
                visible=use_inputFilter,
                extent={{-22,92},{20,46}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                textString="M",
                textStyle={TextStyle.Bold})}));
      end FlowControlled_m_flow;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models for fans and pumps.
</html>"),
      Icon(graphics={Ellipse(
            extent={{-66,66},{68,-68}},
            lineColor={0,0,0},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid), Polygon(
            points={{0,66},{0,-68},{68,0},{0,66}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
    end Movers;

    package Sensors "Package with sensor models"
      extends Modelica.Icons.SensorsPackage;

      package BaseClasses "Package with base classes for IDEAS.Fluid.Sensors"
        extends Modelica.Icons.BasesPackage;

        partial model PartialAbsoluteSensor
          "Partial component to model a sensor that measures a potential variable"

          replaceable package Medium=Modelica.Media.Interfaces.PartialMedium
            "Medium in the sensor"
            annotation (choices(
                choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
                choice(redeclare package Medium = IDEAS.Media.Water "Water"),
                choice(redeclare package Medium =
                    IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                      property_T=293.15,
                      X_a=0.40)
                      "Propylene glycol water, 40% mass fraction")));

          Modelica.Fluid.Interfaces.FluidPort_a port(redeclare package Medium=Medium, m_flow(min=0))
            annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90)));

        equation
          port.m_flow = 0;
          port.h_outflow = 0;
          port.Xi_outflow = zeros(Medium.nXi);
          port.C_outflow = zeros(Medium.nC);
          annotation (Documentation(info="<html>
<p>
Partial component to model an absolute sensor.
The component can be used for pressure sensor models.
Use for other properties such as temperature or density is discouraged, because the enthalpy at the connector can have different meanings, depending on the connection topology. For these properties, use
<a href=\"modelica://IDEAS.Fluid.Sensors.BaseClasses.PartialFlowSensor\">
IDEAS.Fluid.Sensors.BaseClasses.PartialFlowSensor</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
September 7, 2018, by Michael Wetter:<br/>
Changed
<code>port(redeclare package Medium=Medium, m_flow(min=0, max=0))</code>
to
<code>port(redeclare package Medium=Medium, m_flow(min=0))</code>
to avoid in Dymola 2019FD01 beta1 the message
\"port.m_flow has the range [0,0] - which is suspicious since the max-value should be above the min-value\"
which causes an error in pedantic mode.
Note that the MSL also uses only a <code>min</code> value.
</li>
<li>
March 22, 2017, by Filip Jorissen:<br/>
Set <code>m_flow(max=0)</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/687\">#687</a>.
</li>
<li>
February 12, 2011, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
        end PartialAbsoluteSensor;

        partial model PartialDynamicFlowSensor
          "Partial component to model sensors that measure flow properties using a dynamic model"
          extends PartialFlowSensor;
          parameter Modelica.SIunits.Time tau(min=0) = 1
            "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
          parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState
            "Type of initialization (InitialState and InitialOutput are identical)"
          annotation(Evaluate=true, Dialog(group="Initialization"));
      protected
          Real k(start=1)
            "Gain to take flow rate into account for sensor time constant";
          final parameter Boolean dynamic = tau > 1E-10 or tau < -1E-10
            "Flag, true if the sensor is a dynamic sensor"
            annotation(Evaluate=true);
          Real mNor_flow "Normalized mass flow rate";
          final parameter Real tauInv(final unit="s-1")= if dynamic then 1/tau else 0
            "Inverse of tau";
        equation
          if dynamic then
            mNor_flow = port_a.m_flow/m_flow_nominal;
            k = Modelica.Fluid.Utilities.regStep(x=port_a.m_flow,
                                                 y1= mNor_flow,
                                                 y2=-mNor_flow,
                                                 x_small=m_flow_small);
          else
            mNor_flow = 1;
            k = 1;
          end if;
          annotation (Icon(graphics={
                Line(visible=(tau <> 0),
                points={{52,60},{58,74},{66,86},{76,92},{88,96},{98,96}}, color={0,
                      0,127})}), Documentation(info="<html>
<p>
Partial component to model a sensor that measures any intensive properties
of a flow, e.g., to get temperature or density in the flow
between fluid connectors.</p>
<p>
The sensor computes a gain that is zero at zero mass flow rate.
This avoids fast transients if the flow is close to zero, thereby
improving the numerical efficiency.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 9, 2016, by Michael Wetter:<br/>
Improved documentation for <code>tau</code>.
</li>
<li>
January 12, 2016, by Filip Jorissen:<br/>
Added optional parameter <code>tauInv</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 29, 2013, by Michael Wetter:<br/>
Changed the parameter <code>initType</code> to
<code>Modelica.Blocks.Types.Init.InitialState</code>.
This allows a pedantic model check in Dymola 2014 of models that instanciate sensors
but do not set this parameter. It also ensures that different Modelica simulators solve
the same initialization problem.
</li>
<li>
July 7, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialDynamicFlowSensor;

        partial model PartialFlowSensor
          "Partial component to model sensors that measure flow properties"
          extends IDEAS.Fluid.Interfaces.PartialTwoPort;
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate, used for regularization near zero flow"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*m_flow_nominal
            "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)"
            annotation(Dialog(tab="Advanced"));
        equation
          // mass balance
          port_b.m_flow = -port_a.m_flow;
          // momentum equation (no pressure loss)
          port_a.p = port_b.p;
          // isenthalpic state transformation (no storage and no loss of energy)
          port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
          port_b.h_outflow = inStream(port_a.h_outflow);
          port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
          port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
          port_b.C_outflow = inStream(port_a.C_outflow);
          annotation (Documentation(info="<html>
<p>
Partial component to model a sensor.
The sensor is ideal. It does not influence mass, energy,
species or substance balance, and it has no flow friction.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
June 19, 2015, by Michael Wetter:<br/>
Moved <code>m_flow_small</code> to the <code>Advanced</code> tab
as it usually need not be changed by the user.
Other models such as heat exchangers also have this parameter
on the <code>Advanced</code> tab.
</li>
<li>
February 12, 2011, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
        end PartialFlowSensor;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.Sensors\">IDEAS.Fluid.Sensors</a>.
</p>
</html>"));
      end BaseClasses;

      model MassFlowRate "Ideal sensor for mass flow rate"
        extends IDEAS.Fluid.Sensors.BaseClasses.PartialFlowSensor(
          final m_flow_nominal = 0,
          final m_flow_small = 0);
        extends Modelica.Icons.RotationalSensor;
        Modelica.Blocks.Interfaces.RealOutput m_flow(quantity="MassFlowRate",
                                                     final unit="kg/s")
          "Mass flow rate from port_a to port_b" annotation (Placement(
              transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));
      equation
        m_flow = port_a.m_flow;
      annotation (defaultComponentName="senMasFlo",
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Line(points={{70,0},{100,0}}, color={0,128,255}),
              Text(
                extent={{162,120},{2,90}},
                lineColor={0,0,0},
                textString="m_flow"),
              Line(points={{0,100},{0,70}}, color={0,0,127}),
              Line(points={{-100,0},{-70,0}}, color={0,128,255})}),
        Documentation(info="<html>
<p>
This model outputs the mass flow rate flowing from
<code>port_a</code> to <code>port_b</code>.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end MassFlowRate;

      model PPM
        "Ideal one port trace substances sensor outputting in parts per million"
        extends IDEAS.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor(
          port(C_outflow(each final quantity="MassFraction",
                         each final unit="1",
                         each min=0,
                         each max=1)));
        extends Modelica.Icons.RotationalSensor;
        parameter String substanceName = "CO2" "Name of trace substance";
        parameter Modelica.SIunits.MolarMass MM=
          Modelica.Media.IdealGases.Common.SingleGasesData.CO2.MM
          "Molar mass of the trace substance";
        Modelica.Blocks.Interfaces.RealOutput ppm(min=0)
          "Trace substance in port medium in ppm"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        parameter Real s[:]= {
          if ( Modelica.Utilities.Strings.isEqual(string1=Medium.extraPropertiesNames[i],
                                                  string2=substanceName,
                                                  caseSensitive=false))
          then 1 else 0 for i in 1:Medium.nC}
          "Vector with zero everywhere except where species is";
        final parameter Modelica.SIunits.MolarMass MMBul=Medium.molarMass(
          Medium.setState_phX(
            p=Medium.p_default,
            h=Medium.h_default,
            X=Medium.X_default)) "Molar mass of bulk medium";
        final parameter Real MMFraction(
          min=0,
          max=1,
          final unit="1",
          final quantity="MassFraction")=MMBul/MM
          "Molar mass of the medium divided by the molar mass of the trace substance";
        final parameter Real coeff = MMFraction*1e6
          "Conversion from mass fraction to ppm";
      initial equation
        assert(max(s) > 0.9, "Trace substance '" + substanceName + "' is not present in medium '"
               + Medium.mediumName + "'.\n"
               + "Check sensor parameter and medium model.");
      equation
        // We obtain the species concentration with a vector multiplication
        // because Dymola 7.3 cannot find the derivative in the model
        // Buildings.Examples.VAVSystemCTControl.mo
        // if we set C = CVec[ind];
        ppm = s*inStream(port.C_outflow)*coeff;
      annotation (defaultComponentName="senPPM",
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Line(points={{0,-70},{0,-100}}, color={0,0,127}),
              Text(
                extent={{-150,80},{150,120}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{160,-30},{60,-60}},
                lineColor={0,0,0},
                textString="ppm"),
              Line(points={{70,0},{100,0}}, color={0,0,127})}),
        Documentation(info="<html>
<p>
This model outputs the trace substance concentration in ppm contained in the fluid connected to its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
<p>
The parameter <code>MM</code> is the molar mass of the trace substance.
For a list of molar masses, see
<a href=\"modelica://Modelica.Media.IdealGases.Common.SingleGasesData\">
Modelica.Media.IdealGases.Common.SingleGasesData</a>
and
<a href=\"modelica://Modelica.Media.IdealGases.Common.FluidData\">
Modelica.Media.IdealGases.Common.FluidData</a>.
</p>
<p>
Read the
<a href=\"modelica://IDEAS.Fluid.Sensors.UsersGuide\">
IDEAS.Fluid.Sensors.UsersGuide</a>
prior to using this model with one fluid port.
</p>
<h4>Assumptions</h4>
<p>
This sensor assumes that the concentration <i>C</i> of the medium
is in mass fraction. Otherwise, the conversion to <i>ppm</i> will be
wrong.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 16, 2015, by Michael Wetter:<br/>
Revised implementation, corrected error in the molar fraction which
used the inverse ratio.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PPM;

      model RelativeHumidity "Ideal one port relative humidity sensor"
        extends IDEAS.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor;
        extends Modelica.Icons.RotationalSensor;
        Modelica.Blocks.Interfaces.RealOutput phi(final unit="1", min=0)
          "Relative humidity in port medium"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        Modelica.SIunits.Temperature T "Temperature of the medium";
        Medium.MassFraction Xi[Medium.nXi](
          quantity=Medium.substanceNames[1:Medium.nXi]) "Mass fraction of the medium";
      equation
        Xi = inStream(port.Xi_outflow);
        T=Medium.temperature_phX(
            p=port.p,
            h=inStream(port.h_outflow),
            X=Xi);
        phi = IDEAS.Utilities.Psychrometrics.Functions.phi_pTX(
          p=port.p,
          T=T,
          X_w=Xi[1]);
      annotation (defaultComponentName="senRelHum",
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Line(points={{0,-70},{0,-100}}, color={0,0,127}),
              Text(
                extent={{-150,80},{150,120}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{160,-30},{60,-60}},
                lineColor={0,0,0},
                textString="phi"),
              Line(points={{70,0},{100,0}}, color={0,0,127})}),
        Documentation(info="<html>
<p>
This model outputs the relative humidity of the fluid connected to its port.
The sensor is ideal, i.e. it does not influence the fluid.
</p>
<p>
Note that this sensor can only be used with media that contain the variable <code>phi</code>,
which is typically the case for moist air models.
</p>
<p>
Read the
<a href=\"modelica://IDEAS.Fluid.Sensors.UsersGuide\">
IDEAS.Fluid.Sensors.UsersGuide</a>
prior to using this model with one fluid port.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 26, 2016 by Michael Wetter:<br/>
Added <code>quantity</code> attribute for mass fraction variables.<br/>
Made unit assignment of output signal final.
</li>
<li>
May 12, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end RelativeHumidity;

      model RelativePressure "Ideal relative pressure sensor"
        extends Modelica.Icons.TranslationalSensor;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the sensor"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        Modelica.Fluid.Interfaces.FluidPort_a port_a(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          "Fluid connector of stream a"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          "Fluid connector of stream b"
          annotation (Placement(transformation(extent={{110,-12},{90,8}}), iconTransformation(extent={{110,-10},{90,10}})));

        Modelica.Blocks.Interfaces.RealOutput p_rel(final quantity="PressureDifference",
                                                    final unit="Pa",
                                                    displayUnit="Pa")
          "Relative pressure of port_a minus port_b" annotation (Placement(transformation(
              origin={0,-90},
              extent={{10,-10},{-10,10}},
              rotation=90)));
      equation
        // Zero flow equations for connectors
        port_a.m_flow = 0;
        port_b.m_flow = 0;

        // No contribution of specific quantities
        port_a.h_outflow = 0;
        port_b.h_outflow = 0;
        port_a.Xi_outflow = zeros(Medium.nXi);
        port_b.Xi_outflow = zeros(Medium.nXi);
        port_a.C_outflow  = zeros(Medium.nC);
        port_b.C_outflow  = zeros(Medium.nC);

        // Relative pressure
        p_rel = port_a.p - port_b.p;
        annotation (defaultComponentName="senRelPre",
          Icon(graphics={
              Line(points={{-100,0},{-70,0}}, color={0,127,255}),
              Line(points={{70,0},{100,0}}, color={0,127,255}),
              Line(points={{0,-30},{0,-80}}, color={0,0,127}),
              Text(
                extent={{-150,40},{150,80}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{130,-70},{4,-100}},
                lineColor={0,0,0},
                textString="p_rel"),
              Line(
                points={{32,3},{-58,3}},
                color={0,128,255}),
              Polygon(
                points={{22,18},{62,3},{22,-12},{22,18}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
The relative pressure <code>port_a.p - port_b.p</code> is determined between
the two ports of this component and is provided as output signal. The
sensor should be connected in parallel with other equipment, no flow
through the sensor is allowed.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
February 19, 2016, by Michael Wetter:<br/>
Corrected the quantity of the output signal from <code>Pressure</code>
to <code>PressureDifference</code>.
This was needed for the model
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_m_flow\">
IDEAS.Fluid.Movers.FlowControlled_m_flow</a>
when revising it for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">
issue 417</a>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation, based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end RelativePressure;

      model Temperature "Ideal one port temperature sensor"
          extends IDEAS.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor;
        Modelica.Blocks.Interfaces.RealOutput T(final quantity="ThermodynamicTemperature",
                                                final unit = "K",
                                                min=0,
                                                displayUnit = "degC")
          "Temperature in port medium"
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));
      equation
        T = Medium.temperature(state=Medium.setState_phX(
              p=port.p, h=inStream(port.h_outflow), X=inStream(port.Xi_outflow)));
      annotation (defaultComponentName="senTem",
          Documentation(info="<html>
<p>
This model outputs the temperature of the fluid connected to its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
<p>
Read the
<a href=\"modelica://IDEAS.Fluid.Sensors.UsersGuide\">
IDEAS.Fluid.Sensors.UsersGuide</a>
prior to using this model with one fluid port.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"),
        Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}),
                              graphics={
              Line(points={{0,-70},{0,-100}}, color={0,0,127}),
              Ellipse(
                extent={{-20,-98},{20,-60}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-12,40},{12,-68}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{
                    12,80},{12,40},{-12,40}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Line(
                points={{-12,40},{-12,-64}},
                thickness=0.5),
              Line(
                points={{12,40},{12,-64}},
                thickness=0.5),
              Line(points={{-40,-20},{-12,-20}}),
              Line(points={{-40,20},{-12,20}}),
              Line(points={{-40,60},{-12,60}}),
              Line(points={{12,0},{60,0}}, color={0,0,127})}),
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={
              Ellipse(
                extent={{-20,-88},{20,-50}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-12,50},{12,-58}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,50},{-12,90},{-10,96},{-6,98},{0,100},{6,98},{10,96},{12,
                    90},{12,50},{-12,50}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Line(
                points={{-12,50},{-12,-54}},
                thickness=0.5),
              Line(
                points={{12,50},{12,-54}},
                thickness=0.5),
              Line(points={{-40,-10},{-12,-10}}),
              Line(points={{-40,30},{-12,30}}),
              Line(points={{-40,70},{-12,70}}),
              Text(
                extent={{126,-30},{6,-60}},
                lineColor={0,0,0},
                textString="T"),
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}),
              Line(points={{12,0},{60,0}}, color={0,0,127})}));
      end Temperature;

      model TemperatureTwoPort "Ideal two port temperature sensor"
        extends IDEAS.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor;
        Modelica.Blocks.Interfaces.RealOutput T(final quantity="ThermodynamicTemperature",
                                                final unit="K",
                                                displayUnit = "degC",
                                                min = 0,
                                                start=T_start)
          "Temperature of the passing fluid"
          annotation (Placement(transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));
        parameter Modelica.SIunits.Temperature T_start=Medium.T_default
          "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        parameter Boolean transferHeat = false
          "if true, temperature T converges towards TAmb when no flow"
          annotation(Evaluate=true, Dialog(group="Heat transfer"));
        parameter Modelica.SIunits.Temperature TAmb=Medium.T_default
          "Fixed ambient temperature for heat transfer"
          annotation(Dialog(enable=transferHeat, group="Heat transfer"));
        parameter Modelica.SIunits.Time tauHeaTra(min=1)=1200
          "Time constant for heat transfer, default 20 minutes"
          annotation(Dialog(enable=transferHeat, group="Heat transfer"));
    protected
        parameter Real tauHeaTraInv(final unit = "1/s")=
          if tauHeaTra<1E-10 then 0 else 1/tauHeaTra
          "Dummy parameter to avoid division by tauHeaTra";
        parameter Real ratTau = if dynamic then tauHeaTra/tau else 1
          "Ratio of tau";
        Medium.Temperature TMed(start=T_start)
          "Medium temperature to which the sensor is exposed";
        Medium.Temperature T_a_inflow "Temperature of inflowing fluid at port_a";
        Medium.Temperature T_b_inflow
          "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow";
      initial equation
        if dynamic then
          if initType == Modelica.Blocks.Types.Init.SteadyState then
            der(T) = 0;
           elseif initType == Modelica.Blocks.Types.Init.InitialState or
                 initType == Modelica.Blocks.Types.Init.InitialOutput then
            T = T_start;
          end if;
        end if;
      equation
        if allowFlowReversal then
           T_a_inflow = Medium.temperature(state=
                          Medium.setState_phX(p=port_b.p, h=port_b.h_outflow, X=port_b.Xi_outflow));
           T_b_inflow = Medium.temperature(state=
                          Medium.setState_phX(p=port_a.p, h=port_a.h_outflow, X=port_a.Xi_outflow));
           TMed = Modelica.Fluid.Utilities.regStep(
                    x=port_a.m_flow,
                    y1=T_a_inflow,
                    y2=T_b_inflow,
                    x_small=m_flow_small);
        else
           TMed = Medium.temperature(state=
                    Medium.setState_phX(p=port_b.p, h=port_b.h_outflow, X=port_b.Xi_outflow));
           T_a_inflow = TMed;
           T_b_inflow = TMed;
        end if;
        // Output signal of sensor
        if dynamic then
          if transferHeat then
            der(T) = (TMed-T)*k*tauInv + (TAmb-T)*tauHeaTraInv/(ratTau*k+1);
          else
            der(T) = (TMed-T)*k*tauInv;
          end if;
        else
          T = TMed;
        end if;
      annotation (defaultComponentName="senTem",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={
              Line(points={{-100,0},{92,0}}, color={0,128,255}),
              Ellipse(
                extent={{-20,-58},{20,-20}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Line(points={{-40,60},{-12,60}}),
              Line(points={{-40,30},{-12,30}}),
              Line(points={{-40,0},{-12,0}}),
              Rectangle(
                extent={{-12,60},{12,-24}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,60},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{12,
                    80},{12,60},{-12,60}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Text(
                extent={{102,140},{-18,90}},
                lineColor={0,0,0},
                textString="T"),
              Line(
                points={{-12,60},{-12,-25}},
                thickness=0.5),
              Line(
                points={{12,60},{12,-24}},
                thickness=0.5),
              Line(points={{0,100},{0,50}}, color={0,0,127}),
          Line(
          origin={-77.5,-22.3333},
          points={{43.5,8.3333},{37.5,0.3333},{21.5,-3.6667},{37.5,-17.6667},{7.5,-17.6667},
                    {19.5,-37.6667},{3.5,-38.3333},{-2.5,-48.3333}},
            smooth=Smooth.Bezier,
            visible=transferHeat),
              Polygon(
                points={{-90,-80},{-84,-66},{-76,-74},{-90,-80}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={0,0,0},
                visible=transferHeat)}),
          Documentation(info="<html>
<p>
This model outputs the temperature of the medium in the flow
between its fluid ports. The sensor does not influence the fluid.
</p>
<h4>Typical use and important parameters</h4>
<p>
If the parameter <code>tau</code> is non-zero, then its output <i>T</i>
converges to the temperature of the incoming fluid using
a first order differential equation.
Setting <code>tau=0</code> is <i>not</i> recommend. See
<a href=\"modelica://IDEAS.Fluid.Sensors.UsersGuide\">
IDEAS.Fluid.Sensors.UsersGuide</a> for an explanation.
</p>
<p>
If <code>transferHeat = true</code>, then heat transfer with the ambient is
approximated and <i>T</i> converges towards the fixed ambient
temperature <i>T<sub>Amb</sub></i> using a first order approximation
with a time constant of <code>tauHeaTra</code>
when the flow rate is small.
Note that no energy is exchanged with the fluid as the
sensor does not influence the fluid temperature.
</p>
<p>
Setting <code>transferHeat = true</code> is useful, for example,
if the sensor is used to measure the fluid temperature in
a system with on/off control on the mass flow rate.
If <code>transferHeat</code> were <code>false</code>, then the sensor output <i>T</i>
would remain constant if the mass flow rate is set to zero, and hence
the controller may never switch the mass flow rate on again.
</p>
<p>
In general, applications in which the sensor output is not used to switch
the mass flow rate on should set <code>transferHeat=false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 23, 2017 by Filip Jorissen:<br/>
Revised implementation of equations 
when <code>transferHeat=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/840\">#840</a>.
</li>
<li>
January 12, 2016 by Filip Jorissen:<br/>
Removed parameter <code>tauInv</code>
since this now exists in
<a href=\"modelica://IDEAS.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor\">IDEAS.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor</a>.
</li>
<li>
June 19, 2015 by Michael Wetter:<br/>
Revised model and documentation.
</li>
<li>
June 18, 2015 by Filip Jorissen:<br/>
Added option for simulating thermal losses.
</li>
<li>
June 3, 2011 by Michael Wetter:<br/>
Revised implementation to add dynamics in such a way that
the time constant increases as the mass flow rate tends to zero.
This significantly improves the numerics.
</li>
<li>
February 26, 2010 by Michael Wetter:<br/>
Set start attribute for temperature output. Prior to this change,
the output was 0 at initial time, which caused the plot of the output to
use 0 Kelvin as the lower value of the ordinate.
</li>
<li>
September 10, 2008, by Michael Wetter:<br/>
First implementation, based on
<a href=\"modelica://IDEAS.Fluid.Sensors.Temperature\">IDEAS.Fluid.Sensors.Temperature</a>.
</li>
</ul>
</html>"));
      end TemperatureTwoPort;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Package <code>Sensors</code> consists of idealized sensor components that
provide variables of a medium as
output signals. These signals can be, e.g., further processed
with components of the
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>
library.
</p>
</html>", revisions="<html>
<ul>
<li><i>22 Dec 2008</i>
    by R&uuml;diger Franke
    <ul>
    <li>flow sensors based on Modelica.Fluid.Interfaces.PartialTwoPort</li>
    <li>adapted documentation to stream connectors, i.e. less need for two port sensors</li>
    </ul>
</li>
<li><i>4 Dec 2008</i>
    by Michael Wetter<br/>
       included sensors for trace substance</li>
<li><i>31 Oct 2007</i>
    by Carsten Heinrich<br/>
       updated sensor models, included one and two port sensors for thermodynamic state variables</li>
</ul>
</html>"));
    end Sensors;

    package Sources "Package with boundary condition models"
      extends Modelica.Icons.SourcesPackage;

      package BaseClasses "Package with base classes for IDEAS.Fluid.Sources"
        extends Modelica.Icons.BasesPackage;

        partial model PartialSource
          "Partial component source with one fluid connector"

          replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choices(
                choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
                choice(redeclare package Medium = IDEAS.Media.Water "Water"),
                choice(redeclare package Medium =
                    IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                      property_T=293.15,
                      X_a=0.40)
                      "Propylene glycol water, 40% mass fraction")));

          parameter Integer nPorts=0 "Number of ports" annotation(Dialog(connectorSizing=true));
          parameter Boolean verifyInputs = false
            "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range"
            annotation(Dialog(tab="Advanced"));

          Modelica.Fluid.Interfaces.FluidPorts_b ports[nPorts](
            redeclare each package Medium = Medium,
            m_flow(each max=if flowDirection == Modelica.Fluid.Types.PortFlowDirection.Leaving
                     then 0 else +Modelica.Constants.inf,
                   each min=if flowDirection == Modelica.Fluid.Types.PortFlowDirection.Entering
                   then 0 else -Modelica.Constants.inf))
            annotation (Placement(transformation(extent={{90,40},{110,-40}})));

      protected
          parameter Modelica.Fluid.Types.PortFlowDirection flowDirection=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
            "Allowed flow direction" annotation (Evaluate=true, Dialog(tab="Advanced"));
          Modelica.Blocks.Interfaces.RealInput p_in_internal(final unit="Pa")
            "Needed to connect to conditional connector";
          Medium.BaseProperties medium if verifyInputs "Medium in the source";
          Modelica.Blocks.Interfaces.RealInput Xi_in_internal[Medium.nXi](
            each final unit = "kg/kg")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput X_in_internal[Medium.nX](
            each final unit = "kg/kg")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput C_in_internal[Medium.nC](
            final quantity=Medium.extraPropertiesNames)
            "Needed to connect to conditional connector";


        initial equation
          // Only one connection allowed to a port to avoid unwanted ideal mixing
          for i in 1:nPorts loop
            assert(cardinality(ports[i]) <= 1,"
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");       end for;

        equation
          connect(medium.p, p_in_internal);

          annotation (defaultComponentName="bou",
          Documentation(info="<html>
<p>
Partial model for a fluid source that either prescribes
pressure or mass flow rate.
Models that extend this partial model need to prescribe the outflowing
specific enthalpy, composition and trace substances.
This partial model only declares the <code>ports</code>
and ensures that the pressures at all ports are equal.
</p>
<h4>Implementation</h4>
<p>
If the parameter <code>verifyInputs</code> is set to <code>true</code>,
then a protected instance of medium base properties is enabled.
This instance verifies that the
medium temperature is within the bounds <code>T_min</code> and <code>T_max</code>,
where <code>T_min</code> and <code>T_max</code> are constants of the <code>Medium</code>.
If the temperature is outside these bounds, the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
May 30, 2018, by Michael Wetter:<br/>
Improved documentation.
</li>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Initial version for refactoring inputs of sources.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
</ul>
</html>"));
        end PartialSource;

        model PartialSource_p "Partial source with prescribed pressure"
          extends IDEAS.Fluid.Sources.BaseClasses.PartialSource;
          parameter Boolean use_p_in = false
            "Get the pressure from the input connector"
            annotation(Evaluate=true, HideResult=true, Dialog(group="Conditional inputs"));
          parameter Medium.AbsolutePressure p = Medium.p_default
            "Fixed value of pressure"
            annotation (Dialog(enable = not use_p_in, group="Fixed inputs"));
          Modelica.Blocks.Interfaces.RealInput p_in(final unit="Pa") if use_p_in
            "Prescribed boundary pressure"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        equation
          connect(p_in, p_in_internal);
          if not use_p_in then
            p_in_internal = p;
          end if;
          for i in 1:nPorts loop
            ports[i].p = p_in_internal;
          end for;
          annotation (Documentation(revisions="<html>
<ul>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Initial version for refactoring inputs of sources.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
</ul>
</html>",         info="<html>
<p>
Partial model that defines
<code>ports.p</code> using an optional input for
the pressure.
Otherwise the parameter value is used.
</p>
</html>"),         Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Text(
                  visible=use_p_in,
                  extent={{-152,134},{-68,94}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="p"),
                Ellipse(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,127,255}),
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end PartialSource_p;

        model PartialSource_T "Boundary with prescribed temperature"
          extends IDEAS.Fluid.Sources.BaseClasses.PartialSource;
          parameter Boolean use_T_in= false
            "Get the temperature from the input connector"
            annotation(Evaluate=true, HideResult=true,Dialog(group="Conditional inputs"));
          parameter Medium.Temperature T = Medium.T_default
            "Fixed value of temperature"
            annotation (Dialog(enable = not use_T_in,group="Fixed inputs"));
          Modelica.Blocks.Interfaces.RealInput T_in(final unit="K",
                                                    displayUnit="degC") if use_T_in
            "Prescribed boundary temperature"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
      protected
          Modelica.Blocks.Interfaces.RealInput T_in_internal(final unit="K",
                                                             displayUnit="degC")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput h_internal = Medium.specificEnthalpy(Medium.setState_pTX(p_in_internal, T_in_internal, X_in_internal));
        equation
          connect(T_in, T_in_internal);
          if not use_T_in then
            T_in_internal = T;
          end if;
          for i in 1:nPorts loop
             ports[i].h_outflow  = h_internal;
          end for;
          connect(medium.h, h_internal);
          annotation (
            Documentation(info="<html>
<p>
Partial model that defines
<code>ports.h_outflow</code> using an optional input for
the temperature.
Otherwise the parameter value is used.
</p>
</html>",
        revisions="<html>
<ul>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Initial version for refactoring inputs of sources.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
</ul>
</html>"),         Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Text(
                  visible=use_T_in,
                  extent={{-162,34},{-60,-6}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="T")}));
        end PartialSource_T;

        partial model PartialSource_Xi_C
          "Partial component source with parameter definitions for Xi and C"
          extends IDEAS.Fluid.Sources.BaseClasses.PartialSource;
          parameter Boolean use_X_in = false
            "Get the composition (all fractions) from the input connector"
            annotation(Evaluate=true, HideResult=true, Dialog(tab="Advanced"));
          parameter Boolean use_Xi_in = false
            "Get the composition (independent fractions) from the input connector"
            annotation(Evaluate=true, HideResult=true, Dialog(group="Conditional inputs"));
          parameter Boolean use_C_in = false
            "Get the trace substances from the input connector"
            annotation(Evaluate=true, HideResult=true, Dialog(group="Conditional inputs"));
          parameter Medium.MassFraction X[Medium.nX](
            final quantity=Medium.substanceNames) = Medium.X_default
            "Fixed value of composition"
            annotation (Dialog(enable = (not use_X_in) and Medium.nXi > 0, group="Fixed inputs"));
          parameter Medium.ExtraProperty C[Medium.nC](
            final quantity=Medium.extraPropertiesNames) = fill(0, Medium.nC)
            "Fixed values of trace substances"
            annotation (Dialog(enable = (not use_C_in) and Medium.nC > 0, group="Fixed inputs"));
          Modelica.Blocks.Interfaces.RealInput X_in[Medium.nX](
            each final unit = "kg/kg",
            final quantity=Medium.substanceNames) if use_X_in
            "Prescribed boundary composition"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput Xi_in[Medium.nXi](
            each final unit = "kg/kg",
            final quantity=Medium.substanceNames[1:Medium.nXi]) if use_Xi_in
            "Prescribed boundary composition"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput C_in[Medium.nC](
            final quantity=Medium.extraPropertiesNames) if use_C_in
            "Prescribed boundary trace substances"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
        initial equation
          assert(not use_X_in or not use_Xi_in,
            "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");
          if not use_X_in and not use_Xi_in then
            Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
              Medium.singleState, true, X_in_internal, "Boundary_pT");
          end if;
        equation
          if use_X_in or use_Xi_in then
            Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
              Medium.singleState, true, X_in_internal, "Boundary_pT");
          end if;
          connect(X_in[1:Medium.nXi], Xi_in_internal);
          connect(X_in,X_in_internal);
          connect(Xi_in, Xi_in_internal);
          connect(C_in, C_in_internal);
          connect(medium.Xi, Xi_in_internal);
          if not use_X_in and not use_Xi_in then
            Xi_in_internal = X[1:Medium.nXi];
          end if;
          if not use_X_in then
            X_in_internal[1:Medium.nXi] = Xi_in_internal[1:Medium.nXi];
            X_in_internal[Medium.nX] = 1-sum(X_in_internal[1:Medium.nXi]);
          end if;
          if not use_C_in then
            C_in_internal = C;
          end if;
          for i in 1:nPorts loop
            ports[i].Xi_outflow = Xi_in_internal;
            ports[i].C_outflow = C_in_internal;
          end for;
          annotation (defaultComponentName="boundary",
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Text(
                  visible=use_X_in,
                  extent={{-164,4},{-62,-36}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="X"),
                Text(
                  visible=use_Xi_in,
                  extent={{-164,4},{-62,-36}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Xi"),
                Text(
                  visible=use_C_in,
                  extent={{-164,-90},{-62,-130}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="C")}),
                  Documentation(info="<html>
<p>
Partial model that defines outflowing properties
<code>ports.Xi_outflow</code> and <code>ports.C_outflow</code>
using an optional input for both.
Otherwise the parameter value is used.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 13, 2018, by Michael Wetter:<br/>
Corrected error in quantity assignment for <code>Xi_in</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Initial version for refactoring inputs of sources.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
</ul>
</html>"));
        end PartialSource_Xi_C;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.Sources\">IDEAS.Fluid.Sources</a>.
</p>
</html>"));
      end BaseClasses;

      model Boundary_pT
        "Boundary with prescribed pressure, temperature, composition and trace substances"
        extends IDEAS.Fluid.Sources.BaseClasses.PartialSource_p;
        extends IDEAS.Fluid.Sources.BaseClasses.PartialSource_T;
        extends IDEAS.Fluid.Sources.BaseClasses.PartialSource_Xi_C;
        annotation (defaultComponentName="bou",
          Documentation(info="<html>
<p>
Defines prescribed values for boundary conditions:
</p>
<ul>
<li> Prescribed boundary pressure.</li>
<li> Prescribed boundary temperature.</li>
<li> Boundary composition (only for multi-substance or trace-substance flow).</li>
</ul>
<h4>Typical use and important parameters</h4>
<p>
If <code>use_p_in</code> is false (default option),
the <code>p</code> parameter is used as boundary pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code>
parameter is ignored, and the value provided by the
input connector is used instead.
</p>
<p>
The same applies to the temperature <i>T</i>, composition <i>X<sub>i</sub></i> or <i>X</i> and trace substances <i>C</i>.
</p>
<h4>Options</h4>
<p>
Instead of using <code>Xi_in</code> (the <i>independent</i> composition fractions),
the advanced tab provides an option for setting all
composition fractions using <code>X_in</code>.
<code>use_X_in</code> and <code>use_Xi_in</code> cannot be used
at the same time.
</p>
<p>
Parameter <code>verifyInputs</code> can be set to <code>true</code>
to enable a check that verifies the validity of the used temperatures
and pressures.
This removes the corresponding overhead from the model, which is
a substantial part of the overhead of this model.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>
for more information.
</p>
<p>
Note, that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>",
      revisions="<html>
<ul>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Made <code>medium</code> conditional and refactored inputs.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
<li>
April 18, 2017, by Filip Jorissen:<br/>
Changed <code>checkBoundary</code> implementation
such that it is run as an initial equation
when it depends on parameters only.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/728\">#728</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>unit</code> and <code>quantity</code> attributes.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end Boundary_pT;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Package <b>Sources</b> contains generic sources for fluid connectors
to define fixed or prescribed ambient conditions.
</p>
</html>"));
    end Sources;

    package Storage "Package with thermal energy storage models"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses "Package with base classes for IDEAS.Fluid.Storage"
        extends Modelica.Icons.BasesPackage;

        model Buoyancy
          "Model to add buoyancy if there is a temperature inversion in the tank"
          extends Modelica.Blocks.Icons.Block;
          replaceable package Medium = Modelica.Media.Interfaces.PartialMedium "Medium model"  annotation (
              choicesAllMatching = true);
          parameter Modelica.SIunits.Volume V "Volume";
          parameter Integer nSeg(min=2) = 2 "Number of volume segments";
          parameter Modelica.SIunits.Time tau(min=0) "Time constant for mixing";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSeg] heatPort
            "Heat input into the volumes"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Modelica.SIunits.HeatFlowRate[nSeg-1] Q_flow
            "Heat flow rate from segment i+1 to i";
      protected
           parameter Medium.ThermodynamicState sta_default = Medium.setState_pTX(T=Medium.T_default,
                 p=Medium.p_default, X=Medium.X_default[1:Medium.nXi])
            "Medium state at default properties";
           parameter Modelica.SIunits.Density rho_default=Medium.density(sta_default)
            "Density, used to compute fluid mass";
           parameter Modelica.SIunits.SpecificHeatCapacity cp_default=Medium.specificHeatCapacityCp(sta_default)
            "Specific heat capacity";
           parameter Real k(unit="W/K") = V*rho_default*cp_default/tau/nSeg
            "Proportionality constant, since we use dT instead of dH";
           Modelica.SIunits.TemperatureDifference dT[nSeg-1]
            "Temperature difference between adjoining volumes";
        equation
          for i in 1:nSeg-1 loop
            dT[i] = heatPort[i+1].T-heatPort[i].T;
            Q_flow[i] = k*noEvent(smooth(1, if dT[i]>0 then dT[i]^2 else 0));
          end for;
          heatPort[1].Q_flow = -Q_flow[1];
          for i in 2:nSeg-1 loop
               heatPort[i].Q_flow = -Q_flow[i]+Q_flow[i-1];
          end for;
          heatPort[nSeg].Q_flow = Q_flow[nSeg-1];
          annotation (Documentation(info="<html>
<p>
This model outputs a heat flow rate that can be added to fluid volumes
in order to emulate buoyancy during a temperature inversion.
For simplicity, this model does not compute a buoyancy induced mass flow rate,
but rather a heat flow that has the same magnitude as the enthalpy flow
associated with the buoyancy induced mass flow rate.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 7, 2018 by Filip Jorissen:<br/>
Copied model from Buildings and update the model accordingly.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/314\">#314</a>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with naming convention.
</li>
<li>
October 8, 2011 by Michael Wetter:<br/>
Added <code>noEvent(...)</code> to
<code>Q_flow[i] = k*smooth(1, if dT[i]>0 then dT[i]^2 else 0);</code>
since the equation returns the same value to the left and right of
<code>dT[i]>0</code>.
</li>
<li>
September 16, 2011 by Michael Wetter:<br/>
Changed the implementation from <code>Q_flow[i] = k*max(heatPort[i+1].T-heatPort[i].T, 0);</code> to
<code>Q_flow[i] = k*smooth(1, if dT[i]>0 then dT[i]^2 else 0);</code>.
The previous implementation was not differentiable. In modeling a solar system, this
change reduced the computing time by a factor of 20 during the time when the pumps
were almost switched off and colder temperature was fed from the collector to the tank.
</li>
<li>
October 28, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                graphics={
                Rectangle(
                  extent={{-44,68},{36,28}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-42,-26},{38,-66}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{26,10},{32,-22}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{28,22},{22,10},{36,10},{36,10},{28,22}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-32,22},{-26,-10}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-28,-18},{-36,-6},{-22,-6},{-22,-6},{-28,-18}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid)}));
        end Buoyancy;

        model PartialStratified
          "Partial model of a stratified tank for thermal energy storage"
          extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface;
          import Modelica.Fluid.Types;
          import Modelica.Fluid.Types.Dynamics;
          parameter Modelica.SIunits.Volume VTan "Tank volume";
          parameter Modelica.SIunits.Length hTan "Height of tank (without insulation)";
          parameter Modelica.SIunits.Length dIns "Thickness of insulation";
          parameter Modelica.SIunits.ThermalConductivity kIns = 0.04
            "Specific heat conductivity of insulation";
          parameter Integer nSeg(min=2) = 2 "Number of volume segments";
          ////////////////////////////////////////////////////////////////////
          // Assumptions
          parameter Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial
            "Formulation of energy balance"
            annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
          parameter Types.Dynamics massDynamics=energyDynamics
            "Formulation of mass balance"
            annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
          // Initialization
          parameter Medium.AbsolutePressure p_start = Medium.p_default
            "Start value of pressure"
            annotation(Dialog(tab = "Initialization"));
          parameter Medium.Temperature T_start=Medium.T_default
            "Start value of temperature"
            annotation(Dialog(tab = "Initialization"));
          parameter Medium.MassFraction X_start[Medium.nX] = Medium.X_default
            "Start value of mass fractions m_i/m"
            annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
          parameter Medium.ExtraProperty C_start[Medium.nC](
               quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
            "Start value of trace substances"
            annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
          // Dynamics
          parameter Modelica.SIunits.Time tau=1 "Time constant for mixing";
          ////////////////////////////////////////////////////////////////////
          // Connectors
          Modelica.Blocks.Interfaces.RealOutput Ql_flow
            "Heat loss of tank (positive if heat flows from tank to ambient)"
            annotation (Placement(transformation(extent={{100,62},{120,82}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSeg] heaPorVol
            "Heat port that connects to the control volumes of the tank"
            annotation (Placement(transformation(extent={{-6,-6},{6,6}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorSid
            "Heat port tank side (outside insulation)"
            annotation (Placement(transformation(extent={{50,-6},{62,6}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorTop
            "Heat port tank top (outside insulation)"
            annotation (Placement(transformation(extent={{14,68},{26,80}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorBot
            "Heat port tank bottom (outside insulation). Leave unconnected for adiabatic condition"
            annotation (Placement(transformation(extent={{14,-80},{26,-68}})));
          // Models
          IDEAS.Fluid.MixingVolumes.MixingVolume[nSeg] vol(
            redeclare each package Medium = Medium,
            each energyDynamics=energyDynamics,
            each massDynamics=massDynamics,
            each p_start=p_start,
            each T_start=T_start,
            each X_start=X_start,
            each C_start=C_start,
            each V=VTan/nSeg,
            each m_flow_nominal=m_flow_nominal,
            each final mSenFac=1,
            each final m_flow_small=m_flow_small,
            each final allowFlowReversal=allowFlowReversal) "Tank segment"
            annotation (Placement(transformation(extent={{6,-16},{26,4}})));
      protected
          parameter Medium.ThermodynamicState sta_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default properties";
          parameter Modelica.SIunits.Length hSeg = hTan / nSeg
            "Height of a tank segment";
          parameter Modelica.SIunits.Area ATan = VTan/hTan
            "Tank cross-sectional area (without insulation)";
          parameter Modelica.SIunits.Length rTan = sqrt(ATan/Modelica.Constants.pi)
            "Tank diameter (without insulation)";
          parameter Modelica.SIunits.ThermalConductance conFluSeg = ATan*Medium.thermalConductivity(sta_default)/hSeg
            "Thermal conductance between fluid volumes";
          parameter Modelica.SIunits.ThermalConductance conTopSeg = ATan*kIns/dIns
            "Thermal conductance from center of top (or bottom) volume through tank insulation at top (or bottom)";
          BaseClasses.Buoyancy buo(
            redeclare final package Medium = Medium,
            final V=VTan,
            final nSeg=nSeg,
            final tau=tau) "Model to prevent unstable tank stratification"
            annotation (Placement(transformation(extent={{-60,50},{-40,70}})));
          Modelica.Thermal.HeatTransfer.Components.ThermalConductor[nSeg - 1] conFlu(
            each G=conFluSeg) "Thermal conductance in fluid between the segments"
            annotation (Placement(transformation(extent={{-56,4},{-42,18}})));
          Modelica.Thermal.HeatTransfer.Components.ThermalConductor[nSeg] conWal(
             each G=2*Modelica.Constants.pi*kIns*hSeg/Modelica.Math.log((rTan+dIns)/rTan))
            "Thermal conductance through tank wall"
            annotation (Placement(transformation(extent={{10,34},{20,46}})));
          Modelica.Thermal.HeatTransfer.Components.ThermalConductor conTop(
             G=conTopSeg) "Thermal conductance through tank top"
            annotation (Placement(transformation(extent={{10,54},{20,66}})));
          Modelica.Thermal.HeatTransfer.Components.ThermalConductor conBot(
             G=conTopSeg) "Thermal conductance through tank bottom"
            annotation (Placement(transformation(extent={{10,14},{20,26}})));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloTop
            "Heat flow at top of tank (outside insulation)"
            annotation (Placement(transformation(extent={{30,54},{42,66}})));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloBot
            "Heat flow at bottom of tank (outside insulation)"
            annotation (Placement(transformation(extent={{30,14},{42,26}})));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSid[nSeg]
            "Heat flow at wall of tank (outside insulation)"
            annotation (Placement(transformation(extent={{30,34},{42,46}})));
          Modelica.Blocks.Routing.Multiplex3 mul(
            n1=1,
            n2=nSeg,
            n3=1) "Multiplex to collect heat flow rates"
            annotation (Placement(transformation(extent={{62,44},{70,54}})));
          Modelica.Blocks.Math.Sum sum1(nin=nSeg + 2)
          annotation (Placement(transformation(extent={{78,42},{90,56}})));
          Modelica.Thermal.HeatTransfer.Components.ThermalCollector theCol(m=nSeg)
            "Connector to assign multiple heat ports to one heat port"
            annotation (Placement(transformation(extent={{46,20},{58,32}})));
        equation
          connect(buo.heatPort, vol.heatPort)    annotation (Line(
              points={{-40,60},{6,60},{6,-6}},
              color={191,0,0}));
          for i in 1:nSeg-1 loop
          // heat conduction between fluid nodes
             connect(vol[i].heatPort, conFlu[i].port_a)    annotation (Line(points={{6,-6},{
                    6,-6},{-60,-6},{-60,10},{-56,10},{-56,11}},    color={191,0,0}));
            connect(vol[i+1].heatPort, conFlu[i].port_b)    annotation (Line(points={{6,-6},{
                    -40,-6},{-40,11},{-42,11}},  color={191,0,0}));
          end for;
          connect(vol[1].heatPort, conTop.port_a)    annotation (Line(points={{6,-6},{6,
                  60},{-4,60},{10,60}},              color={191,0,0}));
          connect(vol.heatPort, conWal.port_a)    annotation (Line(points={{6,-6},{6,40},
                  {10,40}},                      color={191,0,0}));
          connect(conBot.port_a, vol[nSeg].heatPort)    annotation (Line(points={{10,20},
                  {10,20},{6,20},{6,-6}},
                                       color={191,0,0}));
          connect(vol.heatPort, heaPorVol)    annotation (Line(points={{6,-6},{6,-6},{
                  -2.22045e-16,-6},{-2.22045e-16,-2.22045e-16}},
                color={191,0,0}));
          connect(conWal.port_b, heaFloSid.port_a)
            annotation (Line(points={{20,40},{30,40}}, color={191,0,0}));
          connect(conTop.port_b, heaFloTop.port_a)
            annotation (Line(points={{20,60},{30,60}}, color={191,0,0}));
          connect(conBot.port_b, heaFloBot.port_a)
            annotation (Line(points={{20,20},{30,20}}, color={191,0,0}));
          connect(heaFloTop.port_b, heaPorTop) annotation (Line(points={{42,60},{52,60},
                  {52,74},{20,74}}, color={191,0,0}));
          connect(heaFloBot.port_b, heaPorBot) annotation (Line(points={{42,20},{44,20},
                  {44,-74},{20,-74}}, color={191,0,0}));
          connect(heaFloTop.Q_flow, mul.u1[1]) annotation (Line(points={{36,54},{50,54},
                  {50,52.5},{61.2,52.5}}, color={0,0,127}));
          connect(heaFloSid.Q_flow, mul.u2) annotation (Line(points={{36,34},{50,34},{
                  50,49},{61.2,49}}, color={0,0,127}));
          connect(heaFloBot.Q_flow, mul.u3[1]) annotation (Line(points={{36,14},{36,10},
                  {58,10},{58,45.5},{61.2,45.5}}, color={0,0,127}));
          connect(mul.y, sum1.u) annotation (Line(points={{70.4,49},{76.8,49}}, color={
                  0,0,127}));
          connect(sum1.y, Ql_flow) annotation (Line(points={{90.6,49},{98,49},{98,72},{
                  110,72}}, color={0,0,127}));
          connect(heaFloSid.port_b, theCol.port_a) annotation (Line(
              points={{42,40},{52,40},{52,32}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(theCol.port_b, heaPorSid) annotation (Line(
              points={{52,20},{52,-2.22045e-16},{56,-2.22045e-16}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (
        Documentation(info="<html>
<p>
This is a partial model of a stratified storage tank.
</p>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Storage.UsersGuide\">
IDEAS.Fluid.Storage.UsersGuide</a>
for more information.
</p>
<h4>Implementation</h4>
<p>
This model does not include the ports that connect to the fluid from
the outside, because these ports cannot be used for the models that
contain the
<a href=\"modelica://IDEAS.Fluid.Storage.BaseClasses.ThirdOrderStratifier\">
IDEAS.Fluid.Storage.BaseClasses.ThirdOrderStratifier</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 7, 2018 by Filip Jorissen:<br/>
Copied model from Buildings and update the model accordingly.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/314\">#314</a>.
</li>
<li>
June 1, 2018, by Michael Wetter:<br/>
Refactored model to allow a fluid port in the tank that do not have
the enhanced stratification model.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1182\">
issue 1182</a>.
</li>
<li>
July 29, 2017, by Michael Wetter:<br/>
Removed medium declaration, which is not needed and inconsistent with
the declaration in the base class.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/544\">
issue 544</a>.
</li>
<li>
March 28, 2015, by Filip Jorissen:<br/>
Propagated <code>allowFlowReversal</code> and <code>m_flow_small</code>
and set <code>mSenFac=1</code>.
</li>
<li>
January 26, 2015, by Michael Wetter:<br/>
Renamed
<code>hA_flow</code> to <code>H_a_flow</code>,
<code>hB_flow</code> to <code>H_b_flow</code> and
<code>hVol_flow</code> to <code>H_vol_flow</code>
as they output enthalpy flow rate, and not specific enthalpy.
Made various models <code>protected</code>.
</li>
<li>
January 25, 2015, by Michael Wetter:<br/>
Added <code>final</code> to <code>tau = 0</code> in <code>EnthalpyFlowRate</code>.
These sensors do not need dynamics as the enthalpy flow rate
is used to compute a heat flow which is then added to the volume of the tank.
Thus, if there were high frequency oscillations of small mass flow rates,
then they have a small effect on <code>H_flow</code>, and they are
not used in any control loop. Rather, the oscillations are further damped
by the differential equation of the fluid volume.
</li>
<li>
January 25, 2015, by Filip Jorissen:<br/>
Set <code>tau = 0</code> in <code>EnthalpyFlowRate</code>
sensors for increased simulation speed.
</li>
<li>
August 29, 2014, by Michael Wetter:<br/>
Replaced the use of <code>Medium.lambda_const</code> with
<code>Medium.thermalConductivity(sta_default)</code> as
<code>lambda_const</code> is not declared for all media.
This avoids a translation error if certain media are used.
</li>
<li>
June 18, 2014, by Michael Wetter:<br/>
Changed the default value for the energy balance initialization to avoid
a dependency on the global <code>system</code> declaration.
</li>
<li>
July 29, 2011, by Michael Wetter:<br/>
Removed <code>use_T_start</code> and <code>h_start</code>.
</li>
<li>
February 18, 2011, by Michael Wetter:<br/>
Changed default start values for temperature and pressure.
</li>
<li>
October 25, 2009 by Michael Wetter:<br/>
Changed computation of heat transfer through top (and bottom) of tank. Now,
the thermal resistance of the fluid is not taken into account, i.e., the
top (and bottom) element is assumed to be mixed.
<li>
October 23, 2009 by Michael Wetter:<br/>
Fixed bug in computing heat conduction of top and bottom segment.
In the previous version,
for computing the heat conduction between the top (or bottom) segment and
the outside,
the whole thickness of the water volume was used
instead of only half the thickness.
</li>
<li>
February 19, 2009 by Michael Wetter:<br/>
Changed declaration that constrains the medium. The earlier
declaration caused the medium model to be not shown in the parameter
window.
</li>
<li>
October 31, 2008 by Michael Wetter:<br/>
Added heat conduction.
</li>
<li>
October 23, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(graphics={
                Rectangle(
                  extent={{-40,60},{40,20}},
                  lineColor={255,0,0},
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-40,-20},{40,-60}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-76,2},{-90,-2}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{0,84},{-80,80}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-76,84},{-80,-2}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{82,0},{78,-86}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{0,84},{-4,60}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{82,-84},{2,-88}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{6,-60},{2,-84}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{92,2},{78,-2}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-40,20},{40,-20}},
                  lineColor={255,0,0},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.CrossDiag),
                Text(
                  extent={{100,106},{134,74}},
                  lineColor={0,0,127},
                  textString="QLoss"),
                Rectangle(
                  extent={{-10,10},{10,-10}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={255,255,255}),
                Rectangle(
                  extent={{50,68},{40,-66}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-40,66},{-50,-68}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-48,68},{50,60}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-48,-60},{50,-68}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{26,72},{102,72},{100,72}},
                  color={127,0,0},
                  pattern=LinePattern.Dot),
                Line(
                  points={{56,6},{56,72},{58,72}},
                  color={127,0,0},
                  pattern=LinePattern.Dot),
                Line(
                  points={{22,-74},{70,-74},{70,72}},
                  color={127,0,0},
                  pattern=LinePattern.Dot)}));
        end PartialStratified;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.Storage\">IDEAS.Fluid.Storage</a>.
</p>
</html>"));
      end BaseClasses;

      model Stratified "Model of a stratified tank for thermal energy storage"
        extends IDEAS.Fluid.Storage.BaseClasses.PartialStratified(vol(each nPorts=3));
        Modelica.Fluid.Interfaces.FluidPort_a fluPorVol[nSeg](
          redeclare each final package Medium = Medium)
          "Fluid port that connects to the control volumes of the tank"
          annotation (Placement(transformation(extent={{-30,-10},{-10,10}}),
              iconTransformation(extent={{-36,-10},{-16,10}})));
      equation
        connect(port_a, vol[1].ports[1]) annotation (Line(points={{-100,0},{-88,0},{
                -88,-20},{16,-20},{16,-16}}, color={0,127,255}));
        connect(vol[nSeg].ports[2], port_b) annotation (Line(points={{16,-16},{20,-16},
                {20,-20},{90,-20},{90,0},{100,0}}, color={0,127,255}));
        for i in 1:(nSeg-1) loop
          connect(vol[i].ports[2], vol[i + 1].ports[1]) annotation (Line(points={{16,-16},
                  {16,-32},{14,-32},{14,-16},{16,-16}}, color={0,127,255}));
        end for;
        for i in 1:nSeg loop
          connect(fluPorVol[i], vol[i].ports[3]) annotation (Line(points={{-20,0},{-20,-36},
                {16,-36},{16,-16}}, color={0,127,255}));
        end for;
        annotation (
      defaultComponentName="tan",
      Documentation(info="<html>
<p>
This is a model of a stratified storage tank.
</p>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Storage.UsersGuide\">
IDEAS.Fluid.Storage.UsersGuide</a>
for more information.
</p>
<p>
For a model with enhanced stratification, use
<a href=\"modelica://IDEAS.Fluid.Storage.StratifiedEnhanced\">
IDEAS.Fluid.Storage.StratifiedEnhanced</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 7, 2018 by Filip Jorissen:<br/>
Copied model from Buildings and update the model accordingly.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/314\">#314</a>.
</li>
<li>
June 1, 2018, by Michael Wetter:<br/>
Refactored model to allow a fluid port in the tank that do not have
the enhanced stratification model.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1182\">
issue 1182</a>.
</li>
<li>
July 29, 2017, by Michael Wetter:<br/>
Removed medium declaration, which is not needed and inconsistent with
the declaration in the base class.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/544\">
issue 544</a>.
</li>
<li>
March 28, 2015, by Filip Jorissen:<br/>
Propagated <code>allowFlowReversal</code> and <code>m_flow_small</code>
and set <code>mSenFac=1</code>.
</li>
<li>
January 26, 2015, by Michael Wetter:<br/>
Renamed
<code>hA_flow</code> to <code>H_a_flow</code>,
<code>hB_flow</code> to <code>H_b_flow</code> and
<code>hVol_flow</code> to <code>H_vol_flow</code>
as they output enthalpy flow rate, and not specific enthalpy.
Made various models <code>protected</code>.
</li>
<li>
January 25, 2015, by Michael Wetter:<br/>
Added <code>final</code> to <code>tau = 0</code> in <code>EnthalpyFlowRate</code>.
These sensors do not need dynamics as the enthalpy flow rate
is used to compute a heat flow which is then added to the volume of the tank.
Thus, if there were high frequency oscillations of small mass flow rates,
then they have a small effect on <code>H_flow</code>, and they are
not used in any control loop. Rather, the oscillations are further damped
by the differential equation of the fluid volume.
</li>
<li>
January 25, 2015, by Filip Jorissen:<br/>
Set <code>tau = 0</code> in <code>EnthalpyFlowRate</code>
sensors for increased simulation speed.
</li>
<li>
August 29, 2014, by Michael Wetter:<br/>
Replaced the use of <code>Medium.lambda_const</code> with
<code>Medium.thermalConductivity(sta_default)</code> as
<code>lambda_const</code> is not declared for all media.
This avoids a translation error if certain media are used.
</li>
<li>
June 18, 2014, by Michael Wetter:<br/>
Changed the default value for the energy balance initialization to avoid
a dependency on the global <code>system</code> declaration.
</li>
<li>
July 29, 2011, by Michael Wetter:<br/>
Removed <code>use_T_start</code> and <code>h_start</code>.
</li>
<li>
February 18, 2011, by Michael Wetter:<br/>
Changed default start values for temperature and pressure.
</li>
<li>
October 25, 2009 by Michael Wetter:<br/>
Changed computation of heat transfer through top (and bottom) of tank. Now,
the thermal resistance of the fluid is not taken into account, i.e., the
top (and bottom) element is assumed to be mixed.
<li>
October 23, 2009 by Michael Wetter:<br/>
Fixed bug in computing heat conduction of top and bottom segment.
In the previous version,
for computing the heat conduction between the top (or bottom) segment and
the outside,
the whole thickness of the water volume was used
instead of only half the thickness.
</li>
<li>
February 19, 2009 by Michael Wetter:<br/>
Changed declaration that constrains the medium. The earlier
declaration caused the medium model to be not shown in the parameter
window.
</li>
<li>
October 31, 2008 by Michael Wetter:<br/>
Added heat conduction.
</li>
<li>
October 23, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
      Icon(graphics={
              Rectangle(
                extent={{-40,60},{40,20}},
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-40,-20},{40,-60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-76,2},{-90,-2}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,84},{-80,80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-76,84},{-80,-2}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{82,0},{78,-86}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,84},{-4,60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{82,-84},{2,-88}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{6,-60},{2,-84}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{92,2},{78,-2}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-40,20},{40,-20}},
                lineColor={255,0,0},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.CrossDiag),
              Text(
                extent={{100,106},{134,74}},
                lineColor={0,0,127},
                textString="QLoss"),
              Rectangle(
                extent={{-10,10},{10,-10}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={255,255,255}),
              Rectangle(
                extent={{50,68},{40,-66}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-40,66},{-50,-68}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-48,68},{50,60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-48,-60},{50,-68}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{26,72},{102,72},{100,72}},
                color={127,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{56,6},{56,72},{58,72}},
                color={127,0,0},
                pattern=LinePattern.Dot),
              Line(
                points={{22,-74},{70,-74},{70,72}},
                color={127,0,0},
                pattern=LinePattern.Dot)}));
      end Stratified;
    annotation (preferredView="info", Documentation(info="<html>
This package contains thermal energy storage models.
</html>"));
    end Storage;

    package Types "Package with type definitions"
      extends Modelica.Icons.TypesPackage;

      type CvTypes = enumeration(
        OpPoint   "flow coefficient defined by m_flow_nominal/sqrt(dp_nominal)",
        Kv   "Kv (metric) flow coefficient",
        Cv   "Cv (US) flow coefficient",
        Av   "Av (metric) flow coefficient")
        "Enumeration to define the choice of valve flow coefficient" annotation (
          Documentation(info="<html>

<p>
Enumeration to define the choice of valve flow coefficient
(to be selected via choices menu):
</p>

<table summary=\"summary\"  border=\"1\">
<tr><th>Enumeration</th>
    <th>Description</th></tr>

<tr><td>OpPoint</td>
    <td>flow coefficient defined by ratio m_flow_nominal/sqrt(dp_nominal)</td></tr>

<tr><td>Kv</td>
    <td>Kv (metric) flow coefficient</td></tr>

<tr><td>Cv</td>
    <td>Cv (US) flow coefficient</td></tr>

<tr><td>Av</td>
    <td>Av (metric) flow coefficient</td></tr>

</table>

<p>
The details of the coefficients are explained in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">
Users Guide</a>.
</p>

</html>"));

      type HeatExchangerFlowRegime = enumeration(
        ParallelFlow   "Parallel flow",
        CounterFlow   "Counter flow",
        CrossFlowUnmixed   "Cross flow, both streams unmixed",
        CrossFlowCMinMixedCMaxUnmixed   "Cross flow, CMin mixed,   CMax unmixed",
        CrossFlowCMinUnmixedCMaxMixed   "Cross flow, CMin unmixed, CMax mixed",
        ConstantTemperaturePhaseChange   "Constant temperature phase change in one stream")
        "Enumeration for heat exchanger flow configuration"
      annotation(Documentation(info="<html>
<p>
 Enumeration to define the heat exchanger flow regime.
</p>
<p>
This enumeration defines for the current capacity flow rate the kind of
heat transfer relation that will be used to compute the relation between
effectiveness and Number of Transfer Units.
</p>
<p>
The following heat exchanger flow regimes are available in this enumeration:
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Enumeration</th><th>Description</th></tr>
<tr><td>ParallelFlow</td><td>Parallel flow</td></tr>
<tr><td>CounterFlow</td><td>Counter flow</td></tr>
<tr><td>CrossFlowUnmixed</td><td>Cross flow, both streams unmixed</td></tr>
<tr><td>CrossFlowCMinMixedCMaxUnmixed</td><td>Cross flow, CMin mixed,   CMax unmixed</td></tr>
<tr><td>CrossFlowCMinUnmixedCMaxMixed</td><td>Cross flow, CMin unmixed, CMax mixed</td></tr>
<tr><td>ConstantTemperaturePhaseChange</td><td>Constant temperature phase change in one stream</td></tr>
</table>
</html>",     revisions="<html>
<ul>
<li>
March 27, 2017, by Michael Wetter:<br/>
Added <code>ConstantTemperaturePhaseChange</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/694\">
IDEAS #694</a>.
</li>
<li>
February 18, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type InputType = enumeration(
        Constant   "Use parameter to set stage",
        Stages   "Use integer input to select stage",
        Continuous   "Use continuous, real input") "Input options for movers"
        annotation (Documentation(info="<html>
<p>
This type allows defining which type of input should be used for movers.
This can either be
</p>
<ol>
<li>
a constant set point declared by a parameter,
</li>
<li>
a series of possible set points that can be switched using an integer input, or
</li>
<li>
a continuously variable set point.
</li>
</ol>
</html>",     revisions="<html>
<ul>
<li>
April 2, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
     annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>"));
    end Types;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains components for fluid flow systems such as
pumps, valves and sensors. For other fluid flow models, see
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a>.
</html>"),
  Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}},
              lineColor={0,0,0}),
          Line(points={{2,42},{2,-10}}),
          Rectangle(
            extent={{-18,50},{22,42}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
  end Fluid;

  package Media "Package with medium models"
    extends Modelica.Icons.Package;

    package Air
      "Package with moist air model that decouples pressure and temperature"
      extends Modelica.Media.Interfaces.PartialCondensingGases(
         mediumName="Air",
         final substanceNames={"water", "air"},
         final reducedX=true,
         final singleState = false,
         reference_X={0.01,0.99},
         final fluidConstants = {Modelica.Media.IdealGases.Common.FluidData.H2O,
                                 Modelica.Media.IdealGases.Common.FluidData.N2},
         reference_T=273.15,
         reference_p=101325,
         AbsolutePressure(start=p_default),
         Temperature(start=T_default));
      extends Modelica.Icons.Package;

      constant Integer Water=1
        "Index of water (in substanceNames, massFractions X, etc.)";
      constant Integer Air=2
        "Index of air (in substanceNames, massFractions X, etc.)";

      constant AbsolutePressure pStp = reference_p
        "Pressure for which fluid density is defined";
      constant Density dStp = 1.2 "Fluid density at pressure pStp";

      // Redeclare ThermodynamicState to avoid the warning
      // "Base class ThermodynamicState is replaceable"
      // during model check
      redeclare record extends ThermodynamicState
        "ThermodynamicState record for moist air"
      end ThermodynamicState;
      // There must not be any stateSelect=StateSelect.prefer for
      // the pressure.
      // Otherwise, translateModel("Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ResistanceVolume")
      // will fail as Dymola does an index reduction and outputs
      //   Differentiated the equation
      //   vol.dynBal.medium.p+res.dp-inlet.p = 0.0;
      //   giving
      //   der(vol.dynBal.medium.p)+der(res.dp) = der(inlet.p);
      //
      //   The model requires derivatives of some inputs as listed below:
      //   1 inlet.m_flow
      //   1 inlet.p
      // Therefore, the statement
      //   p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
      // has been removed.
      redeclare replaceable model extends BaseProperties(
        Xi(each stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
        T(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
        final standardOrderComponents=true) "Base properties"

    protected
        constant Modelica.SIunits.MolarMass[2] MMX = {steam.MM,dryair.MM}
          "Molar masses of components";

        MassFraction X_steam "Mass fraction of steam water";
        MassFraction X_air "Mass fraction of air";
        Modelica.SIunits.TemperatureDifference dT(start=T_default-reference_T)
          "Temperature difference used to compute enthalpy";
      equation
        assert(T >= 200.0, "
In "       + getInstanceName() + ": Temperature T exceeded its minimum allowed value of -73.15 degC (200 Kelvin)
as required from medium model \""     + mediumName + "\".");
        assert(T <= 423.15, "
In "       + getInstanceName() + ": Temperature T exceeded its maximum allowed value of 150 degC (423.15 Kelvin)
as required from medium model \""     + mediumName + "\".");

        MM = 1/(Xi[Water]/MMX[Water]+(1.0-Xi[Water])/MMX[Air]);

        X_steam  = Xi[Water]; // There is no liquid in this medium model
        X_air    = 1-Xi[Water];

        dT = T - reference_T;
        h = dT*dryair.cp * X_air +
           (dT * steam.cp + h_fg) * X_steam;
        R = dryair.R*X_air + steam.R*X_steam;

        // Equation for ideal gas, from h=u+p*v and R*T=p*v, from which follows that  u = h-R*T.
        // u = h-R*T;
        // However, in this medium, the gas law is d/dStp=p/pStp, from which follows using h=u+pv that
        // u= h-p*v = h-p/d = h-pStp/dStp
        u = h-pStp/dStp;

        // In this medium model, the density depends only
        // on temperature, but not on pressure.
        //  d = p/(R*T);
        d/dStp = p/pStp;

        state.p = p;
        state.T = T;
        state.X = X;
      end BaseProperties;

    redeclare function density "Gas density"
      extends Modelica.Icons.Function;
      input ThermodynamicState state;
      output Density d "Density";
    algorithm
      d :=state.p*dStp/pStp;
      annotation(smoothOrder=5,
      Inline=true,
      Documentation(info="<html>
Density is computed from pressure, temperature and composition in the thermodynamic state record applying the ideal gas law.
</html>"));
    end density;

    redeclare function extends dynamicViscosity
        "Return the dynamic viscosity of dry air"
    algorithm
      eta := 4.89493640395e-08 * state.T + 3.88335940547e-06;
      annotation (
      smoothOrder=99,
      Inline=true,
    Documentation(info="<html>
<p>
This function returns the dynamic viscosity.
</p>
<h4>Implementation</h4>
<p>
The function is based on the 5th order polynomial
of
<a href=\"modelica://Modelica.Media.Air.MoistAir.dynamicViscosity\">
Modelica.Media.Air.MoistAir.dynamicViscosity</a>.
However, for the typical range of temperatures encountered
in building applications, a linear function sufficies.
This implementation is therefore the above 5th order polynomial,
linearized around <i>20</i>&deg;C.
The relative error of this linearization is
<i>0.4</i>% at <i>-20</i>&deg;C,
and less then
<i>0.2</i>% between  <i>-5</i>&deg;C and  <i>+50</i>&deg;C.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 19, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end dynamicViscosity;

    redeclare function enthalpyOfCondensingGas
        "Enthalpy of steam per unit mass of steam"
      extends Modelica.Icons.Function;

      input Temperature T "temperature";
      output SpecificEnthalpy h "steam enthalpy";
    algorithm
      h := (T-reference_T) * steam.cp + h_fg;
      annotation(smoothOrder=5,
      Inline=true,
      derivative=der_enthalpyOfCondensingGas);
    end enthalpyOfCondensingGas;

    redeclare replaceable function extends enthalpyOfGas
        "Enthalpy of gas mixture per unit mass of gas mixture"
    algorithm
      h := enthalpyOfCondensingGas(T)*X[Water]
           + enthalpyOfDryAir(T)*(1.0-X[Water]);
    annotation (
      Inline=true);
    end enthalpyOfGas;

    redeclare replaceable function extends enthalpyOfLiquid
        "Enthalpy of liquid (per unit mass of liquid) which is linear in the temperature"
    algorithm
      h := (T - reference_T)*cpWatLiq;
      annotation (
        smoothOrder=5,
        Inline=true,
        derivative=der_enthalpyOfLiquid);
    end enthalpyOfLiquid;

    redeclare function enthalpyOfNonCondensingGas
        "Enthalpy of non-condensing gas per unit mass of steam"
      extends Modelica.Icons.Function;

      input Temperature T "temperature";
      output SpecificEnthalpy h "enthalpy";
    algorithm
      h := enthalpyOfDryAir(T);
      annotation (
      smoothOrder=5,
      Inline=true,
      derivative=der_enthalpyOfNonCondensingGas);
    end enthalpyOfNonCondensingGas;

    redeclare function extends enthalpyOfVaporization
        "Enthalpy of vaporization of water"
    algorithm
      r0 := h_fg;
      annotation (
        Inline=true);
    end enthalpyOfVaporization;

    redeclare function extends gasConstant
        "Return ideal gas constant as a function from thermodynamic state, only valid for phi<1"

    algorithm
        R := dryair.R*(1 - state.X[Water]) + steam.R*state.X[Water];
      annotation (
        smoothOrder=2,
        Inline=true,
        Documentation(info="<html>
The ideal gas constant for moist air is computed from <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state</a> assuming that all water is in the gas phase.
</html>"));
    end gasConstant;

    redeclare function extends pressure
        "Returns pressure of ideal gas as a function of the thermodynamic state record"

    algorithm
      p := state.p;
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
Pressure is returned from the thermodynamic state record input as a simple assignment.
</html>"));
    end pressure;

    redeclare function extends isobaricExpansionCoefficient
        "Isobaric expansion coefficient beta"
    algorithm
      beta := 0;
      annotation (
        smoothOrder=5,
        Inline=true,
    Documentation(info="<html>
<p>
This function returns the isobaric expansion coefficient at constant pressure,
which is zero for this medium.
The isobaric expansion coefficient at constant pressure is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&beta;<sub>p</sub> = - 1 &frasl; v &nbsp; (&part; v &frasl; &part; T)<sub>p</sub> = 0,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isobaricExpansionCoefficient;

    redeclare function extends isothermalCompressibility
        "Isothermal compressibility factor"
    algorithm
      kappa := -1/state.p;
      annotation (
        smoothOrder=5,
        Inline=true,
        Documentation(info="<html>
<p>
This function returns the isothermal compressibility coefficient.
The isothermal compressibility is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&kappa;<sub>T</sub> = -1 &frasl; v &nbsp; (&part; v &frasl; &part; p)<sub>T</sub>
  = -1 &frasl; p,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isothermalCompressibility;

    redeclare function extends saturationPressure
        "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"

    algorithm
      psat := IDEAS.Utilities.Psychrometrics.Functions.saturationPressure(Tsat);
      annotation (
      smoothOrder=5,
      Inline=true);
    end saturationPressure;

    redeclare function extends specificEntropy
        "Return the specific entropy, only valid for phi<1"

    protected
        Modelica.SIunits.MoleFraction[2] Y "Molar fraction";
    algorithm
        Y := massToMoleFractions(
             state.X, {steam.MM,dryair.MM});
        s := specificHeatCapacityCp(state) * Modelica.Math.log(state.T/reference_T)
             - Modelica.Constants.R *
             sum(state.X[i]/MMX[i]*
                 Modelica.Math.log(max(Y[i], Modelica.Constants.eps)*state.p/reference_p) for i in 1:2);
      annotation (
      Inline=true,
        Documentation(info="<html>
<p>
This function computes the specific entropy.
</p>
<p>
The specific entropy of the mixture is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s = s<sub>s</sub> + s<sub>m</sub>,
</p>
<p>
where
<i>s<sub>s</sub></i> is the entropy change due to the state change
(relative to the reference temperature) and
<i>s<sub>m</sub></i> is the entropy change due to mixing
of the dry air and water vapor.
</p>
<p>
The entropy change due to change in state is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(v/v<sub>0</sub>) <br/>
= c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(&rho;<sub>0</sub>/&rho;)
</p>
<p>If we assume <i>&rho; = p<sub>0</sub>/(R T)</i>,
and because <i>c<sub>p</sub> = c<sub>v</sub> + R</i>,
we can write
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(T/T<sub>0</sub>) <br/>
=c<sub>p</sub> ln(T/T<sub>0</sub>).
</p>
<p>
Next, the entropy of mixing is obtained from a reversible isothermal
expansion process. Hence,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  s<sub>m</sub> = -R &sum;<sub>i</sub>( X<sub>i</sub> &frasl; M<sub>i</sub>
  ln(Y<sub>i</sub> p/p<sub>0</sub>)),
</p>
<p>
where <i>R</i> is the gas constant,
<i>X</i> is the mass fraction,
<i>M</i> is the molar mass, and
<i>Y</i> is the mole fraction.
</p>
<p>
To obtain the state for a given pressure, entropy and mass fraction, use
<a href=\"modelica://IDEAS.Media.Air.setState_psX\">
IDEAS.Media.Air.setState_psX</a>.
</p>
<h4>Limitations</h4>
<p>
This function is only valid for a relative humidity below 100%.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end specificEntropy;

    redeclare function extends density_derp_T
        "Return the partial derivative of density with respect to pressure at constant temperature"
    algorithm
      ddpT := dStp/pStp;
      annotation (
      Inline=true,
    Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to pressure at constant temperature.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derp_T;

    redeclare function extends density_derT_p
        "Return the partial derivative of density with respect to temperature at constant pressure"
    algorithm
      ddTp := 0;

      annotation (
      smoothOrder=99,
      Inline=true,
      Documentation(info=
    "<html>
<p>
This function computes the derivative of density with respect to temperature
at constant pressure.
</p>
</html>",     revisions=
    "<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derT_p;

    redeclare function extends density_derX
        "Return the partial derivative of density with respect to mass fractions at constant pressure and temperature"
    algorithm
      dddX := fill(0, nX);
    annotation (
      smoothOrder=99,
      Inline=true,
      Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to mass fraction.
This value is zero because in this medium, density is proportional
to pressure, but independent of the species concentration.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derX;

    redeclare replaceable function extends specificHeatCapacityCp
        "Specific heat capacity of gas mixture at constant pressure"
    algorithm
      cp := dryair.cp*(1-state.X[Water]) +steam.cp*state.X[Water];
        annotation (
      smoothOrder=99,
      Inline=true,
      derivative=der_specificHeatCapacityCp);
    end specificHeatCapacityCp;

    redeclare replaceable function extends specificHeatCapacityCv
        "Specific heat capacity of gas mixture at constant volume"
    algorithm
      cv:= dryair.cv*(1-state.X[Water]) +steam.cv*state.X[Water];
      annotation (
        smoothOrder=99,
        Inline=true,
        derivative=der_specificHeatCapacityCv);
    end specificHeatCapacityCv;

    redeclare function setState_dTX
        "Return thermodynamic state as function of density d, temperature T and composition X"
      extends Modelica.Icons.Function;
      input Density d "Density";
      input Temperature T "Temperature";
      input MassFraction X[:]=reference_X "Mass fractions";
      output ThermodynamicState state "Thermodynamic state";

    algorithm
        // Note that d/dStp = p/pStp, hence p = d*pStp/dStp
        state := if size(X, 1) == nX then
                   ThermodynamicState(p=d*pStp/dStp, T=T, X=X)
                 else
                   ThermodynamicState(p=d*pStp/dStp,
                                      T=T,
                                      X=cat(1, X, {1 - sum(X)}));
        annotation (
        smoothOrder=2,
        Inline=true,
        Documentation(info="<html>
<p>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">thermodynamic state record</a>
    is computed from density <code>d</code>, temperature <code>T</code> and composition <code>X</code>.
</p>
</html>"));
    end setState_dTX;

    redeclare function extends setState_phX
        "Return thermodynamic state as function of pressure p, specific enthalpy h and composition X"
    algorithm
      state := if size(X, 1) == nX then
        ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=X)
     else
        ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=cat(1, X, {1 - sum(X)}));
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>"));
    end setState_phX;

    redeclare function extends setState_pTX
        "Return thermodynamic state as function of p, T and composition X or Xi"
    algorithm
        state := if size(X, 1) == nX then
                    ThermodynamicState(p=p, T=T, X=X)
                 else
                    ThermodynamicState(p=p, T=T, X=cat(1, X, {1 - sum(X)}));
        annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, temperature T and composition X.
</html>"));
    end setState_pTX;

    redeclare function extends setState_psX
        "Return the thermodynamic state as function of p, s and composition X or Xi"
    protected
        Modelica.SIunits.MassFraction[2] X_int "Mass fraction";
        Modelica.SIunits.MoleFraction[2] Y "Molar fraction";
        Modelica.SIunits.Temperature T "Temperature";
    algorithm
        if size(X, 1) == nX then
          X_int:=X;
        else
          X_int :=cat(
            1,
            X,
            {1 - sum(X)});
        end if;
       Y := massToMoleFractions(
             X_int, {steam.MM,dryair.MM});
        // The next line is obtained from symbolic solving the
        // specificEntropy function for T.
        // In this formulation, we can set T to any value when calling
        // specificHeatCapacityCp as cp does not depend on T.
        T := 273.15 * Modelica.Math.exp((s + Modelica.Constants.R *
               sum(X_int[i]/MMX[i]*
                 Modelica.Math.log(max(Y[i], Modelica.Constants.eps)) for i in 1:2))
                 / specificHeatCapacityCp(setState_pTX(p=p,
                                                       T=273.15,
                                                       X=X_int)));

        state := ThermodynamicState(p=p,
                                    T=T,
                                    X=X_int);

    annotation (
    Inline=true,
    Documentation(info="<html>
<p>
This function returns the thermodynamic state based on pressure,
specific entropy and mass fraction.
</p>
<p>
The state is computed by symbolically solving
<a href=\"modelica://IDEAS.Media.Air.specificEntropy\">
IDEAS.Media.Air.specificEntropy</a>
for temperature.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end setState_psX;

    redeclare replaceable function extends specificEnthalpy
        "Compute specific enthalpy from pressure, temperature and mass fraction"
    algorithm
      h := (state.T - reference_T)*dryair.cp * (1 - state.X[Water]) +
           ((state.T-reference_T) * steam.cp + h_fg) * state.X[Water];
      annotation (
       smoothOrder=5,
       Inline=true);
    end specificEnthalpy;

    redeclare replaceable function specificEnthalpy_pTX "Specific enthalpy"
      extends Modelica.Icons.Function;
      input Modelica.SIunits.Pressure p "Pressure";
      input Modelica.SIunits.Temperature T "Temperature";
      input Modelica.SIunits.MassFraction X[:] "Mass fractions of moist air";
      output Modelica.SIunits.SpecificEnthalpy h "Specific enthalpy at p, T, X";

    algorithm
      h := specificEnthalpy(setState_pTX(p, T, X));
      annotation(smoothOrder=5,
                 Inline=true,
                 inverse(T=temperature_phX(p, h, X)),
                 Documentation(info="<html>
Specific enthalpy as a function of temperature and species concentration.
The pressure is input for compatibility with the medium models, but the specific enthalpy
is independent of the pressure.
</html>",
    revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
    end specificEnthalpy_pTX;

    redeclare replaceable function extends specificGibbsEnergy
        "Specific Gibbs energy"
    algorithm
      g := specificEnthalpy(state) - state.T*specificEntropy(state);
      annotation (
        Inline=true);
    end specificGibbsEnergy;

    redeclare replaceable function extends specificHelmholtzEnergy
        "Specific Helmholtz energy"
    algorithm
      f := specificEnthalpy(state) - gasConstant(state)*state.T - state.T*specificEntropy(state);
      annotation (
        Inline=true);
    end specificHelmholtzEnergy;

    redeclare function extends isentropicEnthalpy "Return the isentropic enthalpy"
    algorithm
      h_is := specificEnthalpy(setState_psX(
                p=p_downstream,
                s=specificEntropy(refState),
                X=refState.X));
    annotation (
      Inline=true,
      Documentation(info="<html>
<p>
This function computes the specific enthalpy for
an isentropic state change from the temperature
that corresponds to the state <code>refState</code>
to <code>reference_T</code>.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isentropicEnthalpy;

    redeclare function extends specificInternalEnergy "Specific internal energy"
      extends Modelica.Icons.Function;
    algorithm
      u := specificEnthalpy(state) - pStp/dStp;
      annotation (
        Inline=true);
    end specificInternalEnergy;

    redeclare function extends temperature
        "Return temperature of ideal gas as a function of the thermodynamic state record"
    algorithm
      T := state.T;
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
Temperature is returned from the thermodynamic state record input as a simple assignment.
</html>"));
    end temperature;

    redeclare function extends molarMass "Return the molar mass"
    algorithm
        MM := 1/(state.X[Water]/MMX[Water]+(1.0-state.X[Water])/MMX[Air]);
        annotation (
    Inline=true,
    smoothOrder=99,
    Documentation(info="<html>
<p>
This function returns the molar mass.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end molarMass;

    redeclare replaceable function temperature_phX
        "Compute temperature from specific enthalpy and mass fraction"
        extends Modelica.Icons.Function;
      input AbsolutePressure p "Pressure";
      input SpecificEnthalpy h "specific enthalpy";
      input MassFraction[:] X "mass fractions of composition";
      output Temperature T "temperature";
    algorithm
      T := reference_T + (h - h_fg * X[Water])
           /((1 - X[Water])*dryair.cp + X[Water] * steam.cp);
      annotation(smoothOrder=5,
                 Inline=true,
                 inverse(h=specificEnthalpy_pTX(p, T, X)),
                 Documentation(info="<html>
Temperature as a function of specific enthalpy and species concentration.
The pressure is input for compatibility with the medium models, but the temperature
is independent of the pressure.
</html>",
    revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
    end temperature_phX;

    redeclare function extends thermalConductivity
        "Thermal conductivity of dry air as a polynomial in the temperature"
    algorithm
      lambda := Modelica.Media.Incompressible.TableBased.Polynomials_Temp.evaluate(
          {(-4.8737307422969E-008), 7.67803133753502E-005, 0.0241814385504202},
       Modelica.SIunits.Conversions.to_degC(state.T));
    annotation(LateInline=true);
    end thermalConductivity;
    //////////////////////////////////////////////////////////////////////
    // Protected classes.
    // These classes are only of use within this medium model.
    // Models generally have no need to access them.
    // Therefore, they are made protected. This also allows to redeclare the
    // medium model with another medium model that does not provide an
    // implementation of these classes.
  protected
      record GasProperties
        "Coefficient data record for properties of perfect gases"
        extends Modelica.Icons.Record;

        Modelica.SIunits.MolarMass MM "Molar mass";
        Modelica.SIunits.SpecificHeatCapacity R "Gas constant";
        Modelica.SIunits.SpecificHeatCapacity cp
          "Specific heat capacity at constant pressure";
        Modelica.SIunits.SpecificHeatCapacity cv = cp-R
          "Specific heat capacity at constant volume";
        annotation (
          preferredView="info",
          defaultComponentName="gas",
          Documentation(info="<html>
<p>
This data record contains the coefficients for perfect gases.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 12, 2014, by Michael Wetter:<br/>
Corrected the wrong location of the <code>preferredView</code>
and the <code>revisions</code> annotation.
</li>
<li>
November 21, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end GasProperties;
      // In the assignments below, we compute cv as OpenModelica
      // cannot evaluate cv=cp-R as defined in GasProperties.
      constant GasProperties dryair(
        R =    Modelica.Media.IdealGases.Common.SingleGasesData.Air.R,
        MM =   Modelica.Media.IdealGases.Common.SingleGasesData.Air.MM,
        cp =   IDEAS.Utilities.Psychrometrics.Constants.cpAir,
        cv =   IDEAS.Utilities.Psychrometrics.Constants.cpAir
                 -Modelica.Media.IdealGases.Common.SingleGasesData.Air.R)
        "Dry air properties";
      constant GasProperties steam(
        R =    Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R,
        MM =   Modelica.Media.IdealGases.Common.SingleGasesData.H2O.MM,
        cp =   IDEAS.Utilities.Psychrometrics.Constants.cpSte,
        cv =   IDEAS.Utilities.Psychrometrics.Constants.cpSte
                 -Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R)
        "Steam properties";

      constant Real k_mair =  steam.MM/dryair.MM "Ratio of molar weights";

      constant Modelica.SIunits.MolarMass[2] MMX={steam.MM,dryair.MM}
        "Molar masses of components";

      constant Modelica.SIunits.SpecificEnergy h_fg=
        IDEAS.Utilities.Psychrometrics.Constants.h_fg
        "Latent heat of evaporation of water";
      constant Modelica.SIunits.SpecificHeatCapacity cpWatLiq=
        IDEAS.Utilities.Psychrometrics.Constants.cpWatLiq
        "Specific heat capacity of liquid water";

    replaceable function der_enthalpyOfLiquid
        "Temperature derivative of enthalpy of liquid per unit mass of liquid"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of liquid enthalpy";
    algorithm
      der_h := cpWatLiq*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfLiquid;

    function der_enthalpyOfCondensingGas
        "Derivative of enthalpy of steam per unit mass of steam"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of steam enthalpy";
    algorithm
      der_h := steam.cp*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfCondensingGas;

    replaceable function enthalpyOfDryAir
        "Enthalpy of dry air per unit mass of dry air"
      extends Modelica.Icons.Function;

      input Temperature T "Temperature";
      output SpecificEnthalpy h "Dry air enthalpy";
    algorithm
      h := (T - reference_T)*dryair.cp;
      annotation (
        smoothOrder=5,
        Inline=true,
        derivative=der_enthalpyOfDryAir);
    end enthalpyOfDryAir;

    replaceable function der_enthalpyOfDryAir
        "Derivative of enthalpy of dry air per unit mass of dry air"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of dry air enthalpy";
    algorithm
      der_h := dryair.cp*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfDryAir;

    replaceable function der_enthalpyOfNonCondensingGas
        "Derivative of enthalpy of non-condensing gas per unit mass of steam"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of steam enthalpy";
    algorithm
      der_h := der_enthalpyOfDryAir(T, der_T);
      annotation (
        Inline=true);
    end der_enthalpyOfNonCondensingGas;

    replaceable function der_specificHeatCapacityCp
        "Derivative of specific heat capacity of gas mixture at constant pressure"
      extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        input ThermodynamicState der_state "Derivative of thermodynamic state";
        output Real der_cp(unit="J/(kg.K.s)")
          "Derivative of specific heat capacity";
    algorithm
      der_cp := (steam.cp-dryair.cp)*der_state.X[Water];
      annotation (
        Inline=true);
    end der_specificHeatCapacityCp;

    replaceable function der_specificHeatCapacityCv
        "Derivative of specific heat capacity of gas mixture at constant volume"
      extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        input ThermodynamicState der_state "Derivative of thermodynamic state";
        output Real der_cv(unit="J/(kg.K.s)")
          "Derivative of specific heat capacity";
    algorithm
      der_cv := (steam.cv-dryair.cv)*der_state.X[Water];
      annotation (
        Inline=true);
    end der_specificHeatCapacityCv;
      annotation(preferredView="info", Documentation(info="<html>
<p>
This medium package models moist air using a gas law in which pressure and temperature
are independent, which often leads to significantly faster and more robust computations.
The specific heat capacities at constant pressure and at constant volume are constant.
The air is assumed to be not saturated.
</p>
<p>
This medium uses the gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho;/&rho;<sub>stp</sub> = p/p<sub>stp</sub>,
</p>
<p>
where
<i>p<sub>std</sub></i> and <i>&rho;<sub>stp</sub></i> are constant reference
temperature and density, rathern than the ideal gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho; = p &frasl;(R T),
</p>
<p>
where <i>R</i> is the gas constant and <i>T</i> is the temperature.
</p>
<p>
This formulation often leads to smaller systems of nonlinear equations
because equations for pressure and temperature are decoupled.
Therefore, if air inside a control volume such as room air is heated, it
does not increase its specific volume. Consequently, merely heating or cooling
a control volume does not affect the air flow calculations in a duct network
that may be connected to that volume.
Note that multizone air exchange simulation in which buoyancy drives the
air flow is still possible as the models in
<a href=\"modelica://IDEAS.Airflow.Multizone\">
IDEAS.Airflow.Multizone</a> compute the mass density using the function
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Functions.density_pTX\">
IDEAS.Utilities.Psychrometrics.Functions.density_pTX</a> in which density
is a function of temperature.
</p>
<p>
Note that models in this package implement the equation for the internal energy as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p<sub>stp</sub> &frasl; &rho;<sub>stp</sub>,
</p>
<p>
where
<i>u</i> is the internal energy per unit mass,
<i>h</i> is the enthalpy per unit mass,
<i>p<sub>stp</sub></i> is the static pressure and
<i>&rho;<sub>stp</sub></i> is the mass density at standard pressure and temperature.
The reason for this implementation is that in general,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  h = u + p v,
</p>
<p>
from which follows that
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p v = h - p &frasl; &rho; = h - p<sub>stp</sub> &frasl; &rho;<sub>std</sub>,
</p>
<p>
because <i>p &frasl; &rho; = p<sub>stp</sub> &frasl; &rho;<sub>stp</sub></i> in this medium model.
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C and no water vapor is present.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 11, 2019 by Michael Wetter:<br/>
Reforulated assignment of <code>X_int</code> in <code>setState_psX</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1079\">#1079</a>.
</li>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
November 4, 2016, by Michael Wetter:<br/>
Set default value for <code>dT.start</code> in base properties.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/575\">#575</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://IDEAS.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
IDEAS.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>.
Note that the default is <code>preferredMediumState=false</code>
and hence the same states are used as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
May 11, 2015, by Michael Wetter:<br/>
Removed
<code>p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)</code>
in declaration of <code>BaseProperties</code>.
Otherwise, when models that contain a fluid volume
are exported as an FMU, their pressure would be
differentiated with respect to time. This would require
the time derivative of the inlet pressure, which is not available,
causing the translation to stop with an error.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
March 20, 2015, by Michael Wetter:<br/>
Added missing term <code>state.p/reference_p</code> in function
<code>specificEntropy</code>.
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/193\">#193</a>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
Changed implementation to use
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Constants\">
IDEAS.Utilities.Psychrometrics.Constants</a>.
This was done to use consistent values throughout the library.
</li>
<li>
November 16, 2013, by Michael Wetter:<br/>
Revised and simplified the implementation.
</li>
<li>
November 14, 2013, by Michael Wetter:<br/>
Removed function
<code>HeatCapacityOfWater</code>
which is neither needed nor implemented in the
Modelica Standard Library.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed non-used computations in <code>specificEnthalpy_pTX</code> and
in <code>temperature_phX</code>.
</li>
<li>
March 29, 2013, by Michael Wetter:<br/>
Added <code>final standardOrderComponents=true</code> in the
<code>BaseProperties</code> declaration. This avoids an error
when models are checked in Dymola 2014 in the pedenatic mode.
</li>
<li>
April 12, 2012, by Michael Wetter:<br/>
Added keyword <code>each</code> to <code>Xi(stateSelect=...)</code>.
</li>
<li>
April 4, 2012, by Michael Wetter:<br/>
Added redeclaration of <code>ThermodynamicState</code> to avoid a warning
during model check and translation.
</li>
<li>
August 3, 2011, by Michael Wetter:<br/>
Fixed bug in <code>u=h-R*T</code>, which is only valid for ideal gases.
For this medium, the function is <code>u=h-pStd/dStp</code>.
</li>
<li>
January 27, 2010, by Michael Wetter:<br/>
Fixed bug in <code>else</code> branch of function <code>setState_phX</code>
that lead to a run-time error when the constructor of this function was called.
</li>
<li>
January 22, 2010, by Michael Wetter:<br/>
Added implementation of function
<a href=\"modelica://IDEAS.Media.GasesPTDecoupled.MoistAirUnsaturated.enthalpyOfNonCondensingGas\">
enthalpyOfNonCondensingGas</a> and its derivative.
</li>
<li>
January 13, 2010, by Michael Wetter:<br/>
Fixed implementation of derivative functions.
</li>
<li>
August 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(graphics={
            Ellipse(
              extent={{-78,78},{-34,34}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-18,86},{26,42}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{48,58},{92,14}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-22,32},{22,-12}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{36,-32},{80,-76}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-36,-30},{8,-74}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-90,-6},{-46,-50}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120})}));
    end Air;

    package Refrigerants "Package with functions for refrigerant properties"
      extends Modelica.Icons.Package;

      package R410A "Refrigerant R410A"
        extends Modelica.Icons.VariantsPackage;
        final constant Modelica.SIunits.SpecificEntropy R = 114.55
          "Gas constant for use in Martin-Hou equation of state";
        final constant Modelica.SIunits.Temperature TCri = 345.25
          "Critical temperature";
        final constant Modelica.SIunits.Temperature T_min = 173.15
          "Minimum temperature for correlated properties";
        final constant Modelica.SIunits.AbsolutePressure pCri = 4926.1e3
          "Critical pressure";

        function dPressureVap_dSpecificVolume_Tv
          "Derivative of the Martin-Hou equation of state with regards to specific volume"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Real dpdv(
            final unit="Pa.kg/m3")
             "Derivative of pressure with regards to specific volume";
      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";
          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";
          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";
          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";
          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";
          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";
          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";
          Modelica.SIunits.SpecificVolume v_abs
            "Smoothed specific volume";
          parameter Integer n = size(A, 1);
        algorithm
          v_abs := IDEAS.Utilities.Math.Functions.smoothMax(v, 1.01*b, 0.01*b);
          dpdv := -R*T/(v_abs-b)^2;
          for i in 1:n loop
            dpdv := dpdv - (i+1)*(A[i] + B[i]*T + C[i]*Modelica.Math.exp(-k*T/TCri))/(v_abs - b)^(i+2);
          end for;
        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the derivative of the Martin-Hou equation of for R410A
state with regards to specific volume.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",           revisions="<html>
<ul>
<li>
November 30, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end dPressureVap_dSpecificVolume_Tv;

        function dPressureVap_dTemperature_Tv
          "Derivative of the Martin-Hou equation of state with regards to temperature"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Real dpdT(
            final unit="Pa/K")
             "Derivative of pressure with regards to temperature";
      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";
          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";
          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";
          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";
          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";
          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";
          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";
          Modelica.SIunits.SpecificVolume v_abs
            "Smoothed specific volume";
          parameter Integer n = size(A, 1);
        algorithm
          v_abs := IDEAS.Utilities.Math.Functions.smoothMax(v, 1.01*b, 0.01*b);
          dpdT := R/(v_abs-b);
          for i in 1:n loop
            dpdT := dpdT + (B[i] - C[i]*k/TCri*Modelica.Math.exp(-k*T/TCri))/(v_abs - b)^(i+1);
          end for;
        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the derivative of the Martin-Hou equation of for R410A
state with regards to temperature.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",           revisions="<html>
<ul>
<li>
November 30, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end dPressureVap_dTemperature_Tv;

        function dSpecificVolumeVap_pT
          "Function that calculates the Jacobian of specific volume R410A vapor based on pressure and temperature"
          input Modelica.SIunits.AbsolutePressure p
            "Pressure of refrigerant vapor";
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Real dp(
            final unit="Pa/s")
            "Delta of pressure of refrigerant vapor";
          input Real dT(
            final unit="K/s")
            "Delta of temperature of refrigerant";
          output Real dv(
            final unit="m3/(kg.s)")
            "Delta of specific volume of refrigerant";
      protected
          Real dpdT(
            final unit="Pa/K")
             "Derivative of pressure with regards to temperature";
          Real dpdv(
            final unit="Pa.kg/m3")
             "Derivative of pressure with regards to specific volume";
          Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
        algorithm
          v := IDEAS.Media.Refrigerants.R410A.specificVolumeVap_pT(p, T);
          dpdT := IDEAS.Media.Refrigerants.R410A.dPressureVap_dTemperature_Tv(T, v);
          dpdv := IDEAS.Media.Refrigerants.R410A.dPressureVap_dSpecificVolume_Tv(T, v);
          dv := dp/dpdv + dT*(dpdT/dpdv);
        annotation (preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the derivatives of
<a href=\"modelica://IDEAS.Media.Refrigerants.R410A.specificVolumeVap_pT\">
IDEAS.Media.Refrigerants.R410A.specificVolumeVap_pT</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
November 30, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end dSpecificVolumeVap_pT;

        function enthalpySatLiq_T
          "Function that calculates the enthalpy of saturated liquid R410A based on temperature"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          output Modelica.SIunits.SpecificEnthalpy h
            "Specific enthalpy of saturated liquid refrigerant";
      protected
          final Real a[:] = {221.1749, -514.9668, -631.625, -262.2749, 1052.0, 1596.0}
            "Coefficients for polynomial equation";
          final Real x0 = 0.5541498
            "x0 for saturation pressure of liquid refrigerant";
          final Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";
          Real x
            "Independent variable";
        algorithm
          // Independent variable
          x := IDEAS.Utilities.Math.Functions.smoothMax(1-T/TCri, 1e-4, 5e-3)^(1/3) - x0;
          // Pressure of saturated liquid refrigerant
          h := 1000*IDEAS.Utilities.Math.Functions.polynomial(a = a, x = x);
        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the enthalpy of saturated liquid R410A based on
temperature.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end enthalpySatLiq_T;

        function enthalpySatVap_T
          "Function that calculates the specific enthalpy of saturated R410A vapor based on temperature"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          output Modelica.SIunits.SpecificEnthalpy h
            "Specific enthalpy of saturated liquid refrigerant";
      protected
          final Real a[:] = {406.0598, -34.78156, 262.8079, 223.8549, -1162.627, 570.6635}
            "Coefficients for polynomial equation";
          final Real x0 = 0
            "x0 for saturation pressure of liquid refrigerant";
          final Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";
          Real x
            "Independent variable";
        algorithm
          // Independent variable
          x := IDEAS.Utilities.Math.Functions.smoothMax(1-T/TCri, 1e-4, 5e-3)^(1/3) - x0;
          // Pressure of saturated liquid refrigerant
          h := 1000*IDEAS.Utilities.Math.Functions.polynomial(a = a, x = x);
        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the specific enthalpy of saturated R410A vapor based
on temperature.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end enthalpySatVap_T;

        function isentropicExponentVap_Tv
          "Function that calculates the isentropic exponent of R410A vapor based on temperature and specific volume"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Modelica.SIunits.IsentropicExponent k
            "Specific isobaric heat capacity";
      protected
          Modelica.SIunits.SpecificHeatCapacity cp
            "Specific isobaric heat capacity";
          Modelica.SIunits.SpecificHeatCapacity cv
            "Specific isochoric heat capacity";
        algorithm
          // Evaluate the specific isobaric and isochoric heat capacities
          cp := IDEAS.Media.Refrigerants.R410A.specificIsobaricHeatCapacityVap_Tv(T, v);
          cv := IDEAS.Media.Refrigerants.R410A.specificIsochoricHeatCapacityVap_Tv(T, v);
          k := cp / cv;
        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the isentropic exponent of R410A vapor based on temperature and specific volume. The isentropic exponent is equal to the ratio of specific heat capacities:
</p>
<p align=\"center\" style=\"font-style:italic;\">
k = c<sub>p</sub>/c<sub>v</sub>
</p>
<h4>References</h4>
<p>
F. de Monte. (2002).
Calculation of thermodynamic properties of R407C and
R410A by the Martin-Hou equation of state, part I:
theoretical development.
<i>
International Journal of Refrigeration.
</i>
25. 306-313.
</p>
<p>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 31, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isentropicExponentVap_Tv;

        function pressureSatVap_T
          "Function that calculates the pressure of saturated R410A vapor based on temperature"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          output Modelica.SIunits.AbsolutePressure p
            "Pressure of saturated refrigerant vapor";
      protected
          final Real a[:] = {-1.440004, -6.865265, -0.5354309, -3.749023, -3.521484, -7.75}
            "Coefficients for polynomial equation";
          final Real x0 = 0.2086902
            "x0 for saturation pressure of refrigerant vapor";
          final Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";
          final Modelica.SIunits.AbsolutePressure pCri = 4925.1e3
            "Critical pressure of refrigerant";
          Real x
            "Independent variable";
        algorithm
          // Independent variable
          x := IDEAS.Utilities.Math.Functions.smoothMax(1-T/TCri, 1e-4, 5e-3) - x0;
          // Pressure of saturated refrigerant vapor
          p := pCri*Modelica.Math.exp(TCri/T*IDEAS.Utilities.Math.Functions.polynomial(a = a, x = x));
        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the pressure of saturated R410A vapor based on temperature.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end pressureSatVap_T;

        function pressureVap_Tv
        "Function that calculates the pressure R410A vapor based on temperature and specific volume"
        input Modelica.SIunits.Temperature T
           "Temperature of refrigerant";
        input Modelica.SIunits.SpecificVolume v
           "Specific volume of refrigerant";
        output Modelica.SIunits.AbsolutePressure p
           "Pressure of refrigerant vapor";
      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";
          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";
          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";
          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";
          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";
          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";
          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";
          Modelica.SIunits.SpecificVolume v_abs
            "Smoothed specific volume";
          parameter Integer n = size(A, 1);
        algorithm
          v_abs := IDEAS.Utilities.Math.Functions.smoothMax(v, 1.01*b, 0.01*b);
          p := R*T/(v_abs-b);
          for i in 1:n loop
            p := p + (A[i] + B[i]*T + C[i]*Modelica.Math.exp(-k*T/TCri))/(v_abs - b)^(i+1);
          end for;
        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the pressure R410A vapor based on temperature and
specific volume. The pressure is calculated from the Martin-Hou equation of
state.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",           revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end pressureVap_Tv;

        function specificIsobaricHeatCapacityVap_Tv
          "Function that calculates the specific isobaric heat capacity of R410A vapor based on temperature and specific volume"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Modelica.SIunits.SpecificHeatCapacity cp
            "Specific isobaric heat capacity";
      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";
          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";
          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";
          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";
          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";
          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";
          Real dpdT
            "First derivative w.r.t. temperature of the Martin-Hou equation";
          Real dpdv
            "First derivative w.r.t. specific volume of the Martin-Hou equation";
          Modelica.SIunits.SpecificHeatCapacity cv
            "Specific isochoric heat capacity";
          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";
          parameter Integer n = size(A, 1);
        algorithm
          cv := IDEAS.Media.Refrigerants.R410A.specificIsochoricHeatCapacityVap_Tv(T, v);
          dpdT := IDEAS.Media.Refrigerants.R410A.dPressureVap_dTemperature_Tv(T, v);
          dpdv := IDEAS.Media.Refrigerants.R410A.dPressureVap_dSpecificVolume_Tv(T, v);
          cp := cv - T * dpdT^2 / dpdv;
        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the specific isobaric heat capacity (<i>c<sub>p</sub></i>) of R410A vapor based on temperature and specific volume.
</p>
<p>
The specific isobaric heat capacity is evaluated from the partial derivatives of the Martin-Hou equation of state.
</p>
<h4>References</h4>
<p>
F. de Monte. (2002).
Calculation of thermodynamic properties of R407C and
R410A by the Martin-Hou equation of state, part I:
theoretical development.
<i>
International Journal of Refrigeration.
</i>
25. 306-313.
</p>
<p>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 31, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end specificIsobaricHeatCapacityVap_Tv;

        function specificIsochoricHeatCapacityVap_Tv
          "Function that calculates the specific isochoric heat capacity of R410A vapor
  based on temperature and specific volume"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Modelica.SIunits.SpecificHeatCapacity cv
            "Specific isochoric heat capacity";
      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";
          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";
          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";
          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";
          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";
          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";
          Real a[:] = {2.676087e-1, 2.115353e-3, -9.848184e-7, 6.493781e-11}
            "Coefficients for ideal gas specific isobaric heat capacity";
          Real integral_of_d2pdT2
            "Integral over v of the second derivative w.r.t. temperature of the Martin-Hou equation";
          Modelica.SIunits.SpecificHeatCapacity cpo
            "Ideal gas specific isobaric heat capacity";
          Modelica.SIunits.SpecificHeatCapacity cvo
            "Ideal gas specific isochoric heat capacity";
          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";
          parameter Integer n = size(A, 1);
        algorithm
          // Ideal gas isobaric heat capacity from polynomial equation
          cpo := 1.0e3*IDEAS.Utilities.Math.Functions.polynomial(a = a, x = T);
          cvo := cpo - R;
          // Integral of second derivative of pressure w.r.t. temperature
          integral_of_d2pdT2 := 0.0;
          for i in 1:n loop
            integral_of_d2pdT2 := integral_of_d2pdT2 + C[i]*Modelica.Math.exp(-k*T/TCri)/(i*(v - b)^(i));
          end for;
          integral_of_d2pdT2 := integral_of_d2pdT2 * (k/TCri)^2;
          cv := cvo - T * integral_of_d2pdT2;
        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the specific isochoric heat capacity
(<i>c<sub>v</sub></i>) of R410A vapor based on temperature and specific volume.
</p>
<p>
The specific isochoric heat capacity is evaluated from the partial derivatives
of the Martin-Hou equation of state.
</p>
<h4>References</h4>
<p>
F. de Monte. (2002).
Calculation of thermodynamic properties of R407C and
R410A by the Martin-Hou equation of state, part I:
theoretical development.
<i>
International Journal of Refrigeration.
</i>
25. 306-313.
</p>
<p>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 31, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end specificIsochoricHeatCapacityVap_Tv;

        function specificVolumeVap_pT
          "Function that calculates the specific volume R410A vapor based on pressure and temperature"
          input Modelica.SIunits.AbsolutePressure p
            "Pressure of refrigerant vapor";
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          output Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";
          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";
          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";
          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";
          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";
          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";
          Modelica.SIunits.SpecificVolume dv
            "Error on specific volume of refrigerant";
          Modelica.SIunits.Pressure dp
            "Error on pressure of refrigerant";
          Real dpdv( final unit = "(Pa.kg)/m3");
          Integer m;
          parameter Integer n = size(A, 1);
        algorithm
          // Initial guess of specific volume
          v := R*T/p + b;
          dv := 1e99;
          m := 0;
          while abs(dv/v) > 1e-10 loop
            assert(m < 1E3,
              "Failed to converge in IDEAS.Media.Refrigerants.R410A.specificVolumeVap_pT");
            m := m + 1;
            // Evaluate first derivative of pressure w.r.t. specific volume
            dpdv := IDEAS.Media.Refrigerants.R410A.dPressureVap_dSpecificVolume_Tv(T, v);
            // Error on pressure
            dp := p - IDEAS.Media.Refrigerants.R410A.pressureVap_Tv(T, v);
            // Corresponding linear adjustment of specific volume
            dv := dp/dpdv;
            v := v + dv;
        end while;
        annotation (derivative=IDEAS.Media.Refrigerants.R410A.dSpecificVolumeVap_pT,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the specific volume R410A vapor based on pressure and
temperature. The specific volume is evaluated iteratively by succesive
evaluations of the vapor pressure.
</p>
<p>
The initial guess is estimated by the first term in the Martin-Hou equation of
state.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end specificVolumeVap_pT;
      annotation (preferredView="info",Documentation(info="<HTML>
<p>
This package contains function definitions for thermodynamic properties of R410A
based on data for commercial refrigerant Dupont Suva 410A. The methodology used
to evaluate the isentropic exponent is taken from de Monte (2002).
</p>
<h4>References</h4>
<p>
F. de Monte. (2002).
Calculation of thermodynamic properties of R407C and
R410A by the Martin-Hou equation of state, part I:
theoretical development.
<i>
International Journal of Refrigeration.
</i>
25. 306-313.
</p>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
      end R410A;
    annotation (preferredView="info",Documentation(info="<HTML>
<p>
This library contains function definitions for refrigerant properties used in
compressor models contained in package
<a href=\"modelica://IDEAS.Fluid.HeatPumps.Compressors\">
IDEAS.Fluid.HeatPumps.Compressors</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={
            Line(
              points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
              color={64,64,64},
              smooth=Smooth.Bezier),
            Line(
              points={{-40,20},{68,20}},
              color={175,175,175}),
            Line(
              points={{-40,20},{-44,88},{-44,88}},
              color={175,175,175}),
            Line(
              points={{68,20},{86,-58}},
              color={175,175,175}),
            Line(
              points={{-60,-28},{56,-28}},
              color={175,175,175}),
            Line(
              points={{-60,-28},{-74,84},{-74,84}},
              color={175,175,175}),
            Line(
              points={{56,-28},{70,-80}},
              color={175,175,175}),
            Line(
              points={{-76,-80},{38,-80}},
              color={175,175,175}),
            Line(
              points={{-76,-80},{-94,-16},{-94,-16}},
              color={175,175,175})}));
    end Refrigerants;

    package Water "Package with model for liquid water with constant density"
       extends Modelica.Media.Water.ConstantPropertyLiquidWater(
         final cv_const=cp_const,
         p_default=300000,
         reference_p=300000,
         reference_T=273.15,
         reference_X={1},
         AbsolutePressure(start=p_default),
         Temperature(start=T_default),
         Density(start=d_const));
      extends Modelica.Icons.Package;

      redeclare model BaseProperties "Base properties"
        Temperature T(stateSelect=
          if preferredMediumStates then StateSelect.prefer else StateSelect.default)
          "Temperature of medium";
        InputAbsolutePressure p "Absolute pressure of medium";
        InputMassFraction[nXi] Xi=fill(0, 0)
          "Structurally independent mass fractions";
        InputSpecificEnthalpy h "Specific enthalpy of medium";
        Modelica.SIunits.SpecificInternalEnergy u
          "Specific internal energy of medium";
        Modelica.SIunits.Density d=d_const "Density of medium";
        Modelica.SIunits.MassFraction[nX] X={1}
          "Mass fractions (= (component mass)/total mass  m_i/m)";
        final Modelica.SIunits.SpecificHeatCapacity R=0
          "Gas constant (of mixture if applicable)";
        final Modelica.SIunits.MolarMass MM=MM_const
          "Molar mass (of mixture or single fluid)";
        ThermodynamicState state
          "Thermodynamic state record for optional functions";
        parameter Boolean preferredMediumStates=false
          "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        final parameter Boolean standardOrderComponents=true
          "If true, and reducedX = true, the last element of X will be computed from the other ones";
        Modelica.SIunits.Conversions.NonSIunits.Temperature_degC T_degC=
            Modelica.SIunits.Conversions.to_degC(T)
          "Temperature of medium in [degC]";
        Modelica.SIunits.Conversions.NonSIunits.Pressure_bar p_bar=
            Modelica.SIunits.Conversions.to_bar(p)
          "Absolute pressure of medium in [bar]";

        // Local connector definition, used for equation balancing check
        connector InputAbsolutePressure = input
          Modelica.SIunits.AbsolutePressure
          "Pressure as input signal connector";
        connector InputSpecificEnthalpy = input
          Modelica.SIunits.SpecificEnthalpy
          "Specific enthalpy as input signal connector";
        connector InputMassFraction = input Modelica.SIunits.MassFraction
          "Mass fraction as input signal connector";

      equation
      assert(T >= T_min, "
In "       + getInstanceName() + ": Temperature T exceeded its minimum allowed value of " + String(T_min-273.15)
        + " degC (" + String(T_min) + " Kelvin)
as required from medium model \""     + mediumName + "\".");
      assert(T <= T_max, "
In "       + getInstanceName() + ": Temperature T exceeded its maximum allowed value of " + String(T_max-273.15)
        + " degC (" + String(T_max) + " Kelvin)
as required from medium model \""     + mediumName + "\".");

        h = cp_const*(T-reference_T);
        u = h;
        state.T = T;
        state.p = p;
        annotation(Documentation(info="<html>
    <p>
    This base properties model is identical to
    <a href=\"modelica://Modelica.Media.Water.ConstantPropertyLiquidWater\">
    Modelica.Media.Water.ConstantPropertyLiquidWater</a>,
    except that the equation
    <code>u = cv_const*(T - reference_T)</code>
    has been replaced by <code>u=h</code> because
    <code>cp_const=cv_const</code>.
    </p>
</html>"));
      end BaseProperties;
      annotation(preferredView="info", Documentation(info="<html>
<p>
This medium package models liquid water.
</p>
<p>
The mass density is computed using a constant value of <i>995.586</i> kg/s.
For a medium model in which the density is a function of temperature, use
<a href=\"modelica://IDEAS.Media.Specialized.Water.TemperatureDependentDensity\">
IDEAS.Media.Specialized.Water.TemperatureDependentDensity</a> which may have considerably higher computing time.
</p>
<p>
For the specific heat capacities at constant pressure and at constant volume,
a constant value of <i>4184</i> J/(kg K), which corresponds to <i>20</i>&deg;C
is used.
The figure below shows the relative error of the specific heat capacity that
is introduced by this simplification.
</p>
<p align=\"center\">
<img src=\"modelica://IDEAS/Resources/Images/Media/Water/plotCp.png\" border=\"1\"
alt=\"Relative variation of specific heat capacity with temperature\"/>
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C.
</p>
<h4>Limitations</h4>
<p>
Density, specific heat capacity, thermal conductivity and viscosity are constant.
Water is modeled as an incompressible liquid.
There are no phase changes.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://IDEAS.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
IDEAS.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
(if used with water instead of air)
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure and density.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Changed type of <code>BaseProperties.T</code> from
<code>Modelica.SIunits.Temperature</code> to <code>Temperature</code>.
Otherwise, it has a different start value than <code>Medium.T</code>, which
causes an error if
<a href=\"IDEAS.Media.Examples.WaterProperties\">
IDEAS.Media.Examples.WaterProperties</a>
is translated in pedantic mode.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>,
and set <code>preferredMediumState=false</code>
to keep the same states as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Removed <code>ThermodynamicState</code> declaration as this lead to
the error
\"Attempting to redeclare record ThermodynamicState when the original was not replaceable.\"
in Dymola 2016 using the pedantic model check.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
February 25, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect</code> attribute on pressure as this caused
<a href=\"modelica://IDEAS.Examples.Tutorial.SpaceCooling.System3\">
IDEAS.Examples.Tutorial.SpaceCooling.System3</a>
to fail with the error message
\"differentiated if-then-else was not continuous\".
</li>
<li>
October 15, 2014, by Michael Wetter:<br/>
Reimplemented media based on
<a href=\"https://github.com/ibpsa/modelica-ibpsa/blob/446aa83720884052476ad6d6d4f90a6a29bb8ec9/IDEAS/Media/Water.mo\">446aa83</a>.
</li>
<li>
November 15, 2013, by Michael Wetter:<br/>
Complete new reimplementation because the previous version
had the option to add a compressibility to the medium, which
has never been used.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={
            Polygon(
              points={{16,-28},{32,-42},{26,-48},{10,-36},{16,-28}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Polygon(
              points={{10,34},{26,44},{30,36},{14,26},{10,34}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Ellipse(
              extent={{-82,52},{24,-54}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={0,0,0}),
            Ellipse(
              extent={{22,82},{80,24}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Ellipse(
              extent={{20,-30},{78,-88}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95})}));
    end Water;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains media models for water and moist air.
The media models in this package are
compatible with
<a href=\"modelica://Modelica.Media\">
Modelica.Media</a>
but the implementation is in general simpler, which often
leads to more efficient simulation.
Due to the simplifications, the media model of this package
are generally accurate for a smaller temperature range than the
models in <a href=\"modelica://Modelica.Media\">
Modelica.Media</a>, but the smaller temperature range may often be
sufficient for building HVAC applications.
</p>
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175}),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175}),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175}),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175})}));
  end Media;

  package Types "Package with type definitions"
    extends Modelica.Icons.TypesPackage;

    type Reset = enumeration(
      Disabled   "Disabled",
      Parameter   "Use parameter value",
      Input   "Use input signal")
      "Options for integrator reset"
      annotation (
      Documentation(info="<html>
<p>
Enumeration to define the choice of integrator reset
(to be selected via choices menu):
</p>
<table border=\"1\" summary=\"Explanation of the enumeration\">
<tr>
<th>Enumeration</th>
<th>Description</th></tr>
<tr><td>Disabled</td>
<td>
Use this setting to disable the integrator reset.
</td></tr>
<tr><td>Parameter</td>
<td>
Use this setting to use reset the integrator to the value of the parameter.
</td></tr>
<tr><td>Input</td>
<td>Use this setting to reset the integrator to the value obtained
from the input signal.
</td></tr>
 </table>
</html>",   revisions="<html>
<ul>
<li>
September 29, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

    package Azimuth "List of possible constant values for surface azimuth"
       extends Modelica.Icons.TypesPackage;

       constant Modelica.SIunits.Angle E = -Modelica.Constants.pi/2
      "Azimuth for an exterior wall whose outer surface faces east";

       constant Modelica.SIunits.Angle N = Modelica.Constants.pi
      "Azimuth for an exterior wall whose outer surface faces north";

       constant Modelica.SIunits.Angle S = 0
      "Azimuth for an exterior wall whose outer surface faces south";

       constant Modelica.SIunits.Angle W = +Modelica.Constants.pi/2
      "Azimuth for an exterior wall whose outer surface faces west";
      annotation(preferredView="info",
    Documentation(info="<html>
<p>
Possible constant values to define the azimuth of a surface.
For example, if an exterior wall is South oriented, i.e., its outside-facing
surface is towards South, use
 <code>IDEAS.Types.Azimuth.S</code>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end Azimuth;

    package Tilt "List of possible constant values for surface tilt"
      extends Modelica.Icons.TypesPackage;

      constant Modelica.SIunits.Angle Ceiling = 0 "Tilt for ceiling";

      constant Modelica.SIunits.Angle Floor =   Modelica.Constants.pi
      "Tilt for floor";

      constant Modelica.SIunits.Angle Other=10e6 "Dummy tilt for unspecified cases";

      constant Modelica.SIunits.Angle Wall =    Modelica.Constants.pi/2
      "Tilt for wall";
    annotation(preferredView="info", Documentation(info="<html>
<p>
Possible constant values to define the tilt of a surface.
For example, for a construction that is a floor, use
<code>IDEAS.Types.Tilt.Floor</code>.
</p>
<p>
Note that a ceiling has a tilt of <i>0</i>, and also the solar collector models
in
<a href=\"IDEAS.Fluid.SolarCollectors\">IDEAS.Fluid.SolarCollectors</a>
require a tilt of <i>0</i> if they are facing straight upwards.
This is correct because
the solar irradiation on a ceiling construction is on the other-side surface,
which faces upwards toward the sky. Hence, a construction is considered
a ceiling from the view point of a person standing inside a room.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end Tilt;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>",   revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
  end Types;

  package Utilities "Package with utility functions such as for I/O"
    extends Modelica.Icons.Package;

    package Cryptographics "Package with cryptographic functions"
      extends Modelica.Icons.VariantsPackage;

      function sha
        "SHA1 encryption of a String"
        extends Modelica.Icons.Function;
        input String str "String to be encrypted";
        output String sha1 "SHA1-encrypted string";
      external "C" sha1 = cryptographicsHash(str)
        annotation (
        Include="#include <cryptographicsHash.c>",
        IncludeDirectory="modelica://IDEAS/Resources/C-Sources");
      annotation (
          Documentation(info="<html>
<p>
This function takes a String input and, using an external function written in C,
outputs its SHA1 encryption. The input string can be of any length, though the output
will always be 40 hexadecimal characters.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 31, 2018 by Alex Laferri&egrave;re:<br/>
Changed the encryption to a SHA1 with a string array input (rather than a file
input).
</li>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Revised sha implementation to avoid buffer overflow in borefield.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/755\">
#755</a>.
</li>
</ul>
</html>"));
      end sha;
      annotation (
    preferredView="info", Documentation(info="<html>
<p>
This package contains utility models for performing cryptographic operations.
</p>
</html>"));
    end Cryptographics;

    package Math "Library with functions such as for smoothing"
      extends Modelica.Icons.Package;

      block Average "Average of a vector"
        extends Modelica.Blocks.Interfaces.MISO;
      equation
       y = IDEAS.Utilities.Math.Functions.average(u=u, nin=nin);
      annotation (defaultComponentName="ave",
      Documentation(info="<html>
<p>This block outputs the average of the vector. </p>
</html>",
      revisions="<html>
<ul>
<li>November 28, 2013, by Marcus Fuchs:<br/>
Changed block to use function average.
</li>
<li>
April 3, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={Text(
                extent={{-74,46},{66,-58}},
                lineColor={0,0,255},
                textString="ave")}));
      end Average;

      package Functions "Package with mathematical functions"
        extends Modelica.Icons.VariantsPackage;

        function average "Average of a vector"
          extends Modelica.Icons.Function;
          input Integer nin "Number of inputs";
          input Real u[nin] "Input vector";
          output Real y "Result";
        algorithm
          y := sum(u)/nin;
          annotation (Documentation(info="<html>
<p>This function outputs the average of the vector. </p>
</html>",         revisions="<html>
<ul>
<li>November 28, 2013, by Marcus Fuchs:<br/>
Implementation based on Michael Wetter&apos;s block
<a href=\"modelica://IDEAS.Utilities.Math.Average\">
IDEAS.Utilities.Math.Average</a>.
</li>
</ul>
</html>"));
        end average;

        package BaseClasses
        "Package with base classes for IDEAS.Utilities.Math.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_2_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           input Real der_2_x;
           output Real der_2_y "Function value";
        protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_2_y := n*(abs(x)^(n-1)*sign(x)*der_2_x
                        + (n-1)*abs(x)^(n-2)*der_x^2);
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;
             der_2_y := (12*a1*x2+2*a3)*der_x^2
                        +x * ( 4 * a1 * x2 + 2 * a3)*der_2_x;
            end if;
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the second derivative of the function
<a href=\"modelica://IDEAS.Utilities.Math.Functions.regNonZeroPower\">
IDEAS.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
August 17, 2015 by Michael Wetter:<br/>
Corrected wrong derivative implementation which omitted the <code>der_x</code> term.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/303\">issue 303</a>.
</li>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_regNonZeroPower;

          function der_2_smoothTransition
            "Second order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";
            input Real x_der "Derivative of x";
            input Real x_der2 "Second order derivative of x";
            output Real y_der2 "Second order derivative of function value";
        protected
            Real aX "Absolute value of x";
            Real ex "Intermediate expression";
          algorithm
           aX:= abs(x);
           ex     := 2*c + aX*(6*d + aX*(12*e + aX*20*f));
           y_der2 := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der2
                   + x_der*x_der*( if x > 0 then ex else -ex);
          annotation (
          Documentation(info="<html>
<p>
This function is the 2nd order derivative of
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_smoothTransition;

          function der_inverseXRegularized "Derivative of inverseXRegularised function"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
           input Real deltaInv = 1/delta "Inverse value of delta";
           input Real a = -15*deltaInv "Polynomial coefficient";
           input Real b = 119*deltaInv^2 "Polynomial coefficient";
           input Real c = -361*deltaInv^3 "Polynomial coefficient";
           input Real d = 534*deltaInv^4 "Polynomial coefficient";
           input Real e = -380*deltaInv^5 "Polynomial coefficient";
           input Real f = 104*deltaInv^6 "Polynomial coefficient";
           input Real x_der "Abscissa value";
           output Real y_der "Function value";
          algorithm
            y_der :=if (x > delta or x < -delta) then -x_der/x/x elseif (x < delta/2 and x > -delta/2) then x_der/(delta*delta) else
              IDEAS.Utilities.Math.Functions.BaseClasses.der_smoothTransition(
                 x=x,
                 x_der=x_der,
                 delta=delta,
                 deltaInv=deltaInv,
                 a=a, b=b, c=c, d=d, e=e, f=f);
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://IDEAS.Utilities.Math.Functions.inverseXRegularized\">
IDEAS.Utilities.Math.Functions.inverseXRegularized</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
June 22, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_inverseXRegularized;

          function der_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           output Real der_y "Function value";
        protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_y := sign(x)*n*abs(x)^(n-1)*der_x;
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;
             der_y := x * ( 4 * a1 * x * x + 2 * a3) * der_x;
            end if;
           annotation(derivative(order=2, zeroDerivative=n, zeroDerivative=delta)=der_2_regNonZeroPower,
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://IDEAS.Utilities.Math.Functions.regNonZeroPower\">
IDEAS.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
August 17, 2015 by Michael Wetter:<br/>
Corrected wrong derivative implementation which omitted the <code>der_x</code> term.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/303\">issue 303</a>.
</li>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_regNonZeroPower;

          function der_smoothTransition
            "First order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";
            input Real x_der "Derivative of x";
            output Real y_der "Derivative of function value";
        protected
            Real aX "Absolute value of x";
          algorithm
           aX:= abs(x);
           y_der := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der;
           annotation(smoothOrder=1,
                    derivative(order=2,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=IDEAS.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition,
          Documentation(info="<html>
<p>
This function is the 1st order derivative of
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
its derivative is provided in
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_smoothTransition;

          function der_spliceFunction "Derivative of splice function"
            extends Modelica.Icons.Function;
              input Real pos;
              input Real neg;
              input Real x;
              input Real deltax=1;
              input Real dpos;
              input Real dneg;
              input Real dx;
              input Real ddeltax=0;
              output Real out;
        protected
              Real scaledX;
              Real scaledX1;
              Real dscaledX1;
              Real y;
              constant Real asin1 = Modelica.Math.asin(1);
          algorithm
              scaledX1 := x/deltax;
              if scaledX1 <= -0.99999999999 then
                out := dneg;
              elseif scaledX1 >= 0.9999999999 then
                out := dpos;
              else
                scaledX := scaledX1*asin1;
                dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
                y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
                out := dpos*y + (1 - y)*dneg;
                out := out + (pos - neg)*dscaledX1*asin1/2/(
                  Modelica.Math.cosh(Modelica.Math.tan(scaledX))*Modelica.Math.cos(
                  scaledX))^2;
              end if;
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://IDEAS.Utilities.Math.Functions.spliceFunction\">
IDEAS.Utilities.Math.Functions.spliceFunction</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 7, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_spliceFunction;

          function smoothTransition
            "Twice continuously differentiable transition between the regions"
            extends Modelica.Icons.Function;
            // The function that transitions between the regions is implemented
            // using its own function. This allows Dymola 2016 to inline the function
            // inverseXRegularized.
          input Real x "Abscissa value";
          input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
          input Real deltaInv = 1/delta "Inverse value of delta";
          input Real a = -15*deltaInv "Polynomial coefficient";
          input Real b = 119*deltaInv^2 "Polynomial coefficient";
          input Real c = -361*deltaInv^3 "Polynomial coefficient";
          input Real d = 534*deltaInv^4 "Polynomial coefficient";
          input Real e = -380*deltaInv^5 "Polynomial coefficient";
          input Real f = 104*deltaInv^6 "Polynomial coefficient";
          output Real y "Function value";
        protected
            Real aX "Absolute value of x";
          algorithm
           aX:= abs(x);
           y := (if x >= 0 then 1 else -1) * (a + aX*(b + aX*(c + aX*(d + aX*(e + aX*f)))));
          annotation(smoothOrder=2,
            derivative(order=1,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=IDEAS.Utilities.Math.Functions.BaseClasses.der_smoothTransition,
              Documentation(info="<html>
<p>
This function is used by
<a href=\"modelica://IDEAS.Utilities.Math.Functions.inverseXRegularized\">
IDEAS.Utilities.Math.Functions.inverseXRegularized</a>
to provide a twice continuously differentiable transition between
the different regions.
The code has been implemented in a function as this allows
to implement the function
<a href=\"modelica://IDEAS.Utilities.Math.Functions.inverseXRegularized\">
IDEAS.Utilities.Math.Functions.inverseXRegularized</a>
in such a way that Dymola inlines it.
However, this function will not be inlined as its body is too large.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
derivatives are provided in
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.der_smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.der_smoothTransition</a>
and in
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 12, 2018, by David Blum:<br/>
Change if-statement to if-expression.  
For issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1019\">#1019</a>.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end smoothTransition;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Utilities.Math.Functions\">IDEAS.Utilities.Math.Functions</a>.
</p>
</html>"));
        end BaseClasses;

        function besselJ0 "Bessel function of the first kind of order 0, J0"
          extends Modelica.Icons.Function;
          input Real x "Independent variable";
          output Real J0 "Bessel function J0(x)";
      protected
          constant Real P[5] = {1.0,
                    -0.1098628627e-2,
                    0.2734510407e-4,
                    -0.2073370639e-5,
                    0.2093887211e-6};
          constant Real Q[5] = {-0.1562499995e-1,
                    0.1430488765e-3,
                    -0.6911147651e-5,
                    0.7621095161e-6,
                    -0.934945152e-7};
          constant Real R[6] = {57568490574.0,
                    -13362590354.0,
                    651619640.7,
                    -11214424.18,
                    77392.33017,
                    -184.9052456};
          constant Real S[6] = {57568490411.0,
                    1029532985.0,
                    9494680.718,
                    59272.64853,
                    267.8532712,
                    1.0};
          Real ax = abs(x);
          Real xx;
          Real y;
          Real z;
          Real coeff1;
          Real coeff2;
        algorithm
          if ax < 8.0 then
            y := x^2;
            coeff1 := R[6];
            coeff2 := S[6];
            for i in 1:5 loop
              coeff1 := R[6-i] + y*coeff1;
              coeff2 := S[6-i] + y*coeff2;
            end for;
            J0 := coeff1/coeff2;
          else
            z := 8/ax;
            y := z^2;
            xx := ax - 0.785398164;
            coeff1 := P[5];
            coeff2 := Q[5];
            for i in 1:4 loop
              coeff1 := P[5-i] + y*coeff1;
              coeff2 := Q[5-i] + y*coeff2;
            end for;
            J0 := sqrt(0.636619772/ax)*(cos(xx)*coeff1 - z*sin(xx)*coeff2);
          end if;
        annotation (
        Documentation(info="<html>
<p>
Evaluates the Bessel function of the first kind of order 0 (<i>J<sub>0</sub></i>), based
on the implementations of Press et al. (1986).
</p>
<h4>References</h4>
<p>
Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T.
Vetterling. Numerical Recipes - The Art of Scientific Computing. Cambridge
University Press (1986): 988 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end besselJ0;

        function besselJ1 "Bessel function of the first kind of order 1, J1"
          extends Modelica.Icons.Function;
          input Real x "Independent variable";
          output Real J1 "Bessel function J1(x)";
      protected
          constant Real P[5] = {1.0,
                    0.183105e-2,
                    -0.3516396496e-4,
                    0.2457520174e-5,
                    -0.240337019e-6};
          constant Real Q[5] = {0.04687499995,
                    -0.2002690873e-3,
                    0.8449199096e-5,
                    -0.88228987e-6,
                    0.105787412e-6};
          constant Real R[6] = {72362614232.0,
                    -7895059235.0,
                    242396853.1,
                    -2972611.439,
                    15704.48260,
                    -30.16036606};
          constant Real S[6] = {144725228442.0,
                    2300535178.0,
                    18583304.74,
                    99447.43394,
                    376.9991397,
                    1.0};
          Real ax = abs(x);
          Real xx;
          Real y;
          Real z;
          Real coeff1;
          Real coeff2;
        algorithm
          if ax < 8.0 then
            y := x^2;
            coeff1 := R[6];
            coeff2 := S[6];
            for i in 1:5 loop
              coeff1 := R[6-i] + y*coeff1;
              coeff2 := S[6-i] + y*coeff2;
            end for;
            J1 := x*coeff1/coeff2;
          else
            z := 8/ax;
            y := z^2;
            xx := ax - 2.356194491;
            coeff1 := P[5];
            coeff2 := Q[5];
            for i in 1:4 loop
              coeff1 := P[5-i] + y*coeff1;
              coeff2 := Q[5-i] + y*coeff2;
            end for;
            J1 := sqrt(0.636619772/ax)*(cos(xx)*coeff1 - z*sin(xx)*coeff2)*sign(x);
          end if;
        annotation (
        Documentation(info="<html>
<p>
Evaluates the Bessel function of the first kind of order 1 (<i>J<sub>1</sub></i>), based
on the implementations of Press et al. (1986).
</p>
<h4>References</h4>
<p>
Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T.
Vetterling. Numerical Recipes - The Art of Scientific Computing. Cambridge
University Press (1986): 988 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end besselJ1;

        function besselY0 "Bessel function of the second kind of order 0, Y0"
          extends Modelica.Icons.Function;
          input Real x "Independent variable";
          output Real Y0 "Bessel function Y0(x)";
      protected
          constant Real P[5] = {1.0,
                    -0.1098628627e-2,
                    0.2734510407e-4,
                    -0.2073370639e-5,
                    0.2093887211e-6};
          constant Real Q[5] = {-0.1562499995e-1,
                    0.1430488765e-3,
                    -0.6911147651e-5,
                    0.7621095161e-6,
                    -0.934945152e-7};
          constant Real R[6] = {-2957821389.0,
                    7062834065.0,
                    -512359803.6,
                    10879881.29,
                    -86327.92757,
                    228.5622733};
          constant Real S[6] = {40076544269.0,
                    745249964.8,
                    7189466.438,
                    47447.26470,
                    226.1030244,
                    1.0};
          Real ax = abs(x);
          Real xx;
          Real y;
          Real z;
          Real coeff1;
          Real coeff2;
        algorithm
          if ax < 8.0 then
            y := x^2;
            coeff1 := R[6];
            coeff2 := S[6];
            for i in 1:5 loop
              coeff1 := R[6-i] + y*coeff1;
              coeff2 := S[6-i] + y*coeff2;
            end for;
            Y0 := coeff1/coeff2 + 0.636619772*IDEAS.Utilities.Math.Functions.besselJ0(x)*log(x);
          else
            z := 8/ax;
            y := z^2;
            xx := ax - 0.785398164;
            coeff1 := P[5];
            coeff2 := Q[5];
            for i in 1:4 loop
              coeff1 := P[5-i] + y*coeff1;
              coeff2 := Q[5-i] + y*coeff2;
            end for;
            Y0 := sqrt(0.636619772/ax)*(sin(xx)*coeff1 + z*cos(xx)*coeff2);
          end if;
        annotation (
        Documentation(info="<html>
<p>
Evaluates the Bessel function of the second kind of order 0 (<i>Y<sub>0</sub></i>), based
on the implementations of Press et al. (1986).
</p>
<h4>References</h4>
<p>
Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T.
Vetterling. Numerical Recipes - The Art of Scientific Computing. Cambridge
University Press (1986): 988 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end besselY0;

        function besselY1 "Bessel function of the second kind of order 1, Y1"
          extends Modelica.Icons.Function;
          input Real x "Independent variable";
          output Real Y1 "Bessel function J1(x)";
      protected
          constant Real P[5] = {1.0,
                    0.183105e-2,
                    -0.3516396496e-4,
                    0.2457520174e-5,
                    -0.240337019e-6};
          constant Real Q[5] = {0.04687499995,
                    -0.2002690873e-3,
                    0.8449199096e-5,
                    -0.88228987e-6,
                    0.105787412e-6};
          constant Real R[6] = {-0.4900604943e13,
                    0.1275274390e13,
                    -0.5153438139e11,
                    0.7349264551e9,
                    -0.4237922726e7,
                    0.8511937935e4};
          constant Real S[7] = {0.2499580570e14,
                    0.4244419664e12,
                    0.3733650367e10,
                    0.2245904002e8,
                    0.1020426050e6,
                    0.3549632885e3,
                    1.0};
          Real ax = abs(x);
          Real xx;
          Real y;
          Real z = 8/ax;
          Real coeff1;
          Real coeff2;
        algorithm
          if ax < 8.0 then
            y := x^2;
            coeff1 := R[6];
            coeff2 := S[6] + y*S[7];
            for i in 1:5 loop
              coeff1 := R[6-i] + y*coeff1;
              coeff2 := S[6-i] + y*coeff2;
            end for;
            Y1 := x*coeff1/coeff2 + 0.636619772*(IDEAS.Utilities.Math.Functions.besselJ1(x)*log(x) - 1.0/x);
          else
            y := z^2;
            xx := ax - 2.356194491;
            coeff1 := P[5];
            coeff2 := Q[5];
            for i in 1:4 loop
              coeff1 := P[5-i] + y*coeff1;
              coeff2 := Q[5-i] + y*coeff2;
            end for;
            Y1 := sqrt(0.636619772/ax)*(sin(xx)*coeff1 + z*cos(xx)*coeff2)*sign(x);
          end if;
        annotation (
        Documentation(info="<html>
<p>
Evaluates the Bessel function of the second kind of order 1 (<i>Y<sub>1</sub></i>), based
on the implementations of Press et al. (1986).
</p>
<h4>References</h4>
<p>
Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T.
Vetterling. Numerical Recipes - The Art of Scientific Computing. Cambridge
University Press (1986): 988 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end besselY1;

        function binomial "Returns the binomial coefficient"
          extends Modelica.Icons.Function;
          input Integer n "Size of set";
          input Integer k(min=0) "Size of subsets";
          output Integer binom "Binomial coefficient";
        algorithm
          assert(n >= k, "n must be k or greater.");
          assert(k >= 0, "k must be 0 or greater.");
          if k <= 0.5*n then
            binom := integer(IDEAS.Utilities.Math.Functions.fallingFactorial(n,k)/IDEAS.Utilities.Math.Functions.factorial(k));
          else
            binom := integer(IDEAS.Utilities.Math.Functions.fallingFactorial(n,n-k)/IDEAS.Utilities.Math.Functions.factorial(n-k));
          end if;
        annotation (Documentation(info="<html>
<p>
Function that evaluates the binomial coefficient \"n choose k\".
</p>
</html>",         revisions="<html>
<ul>
<li>
February 9, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end binomial;

        function cubicHermiteLinearExtrapolation
          "Interpolate using a cubic Hermite spline with linear extrapolation"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower gradient";
          input Real y2d "Upper gradient";
          output Real y "Interpolated ordinate value";
        algorithm
          if (x > x1 and x < x2) then
            y:=Modelica.Fluid.Utilities.cubicHermite(
              x=x,
              x1=x1,
              x2=x2,
              y1=y1,
              y2=y2,
              y1d=y1d,
              y2d=y2d);
          elseif x <= x1 then
            // linear extrapolation
            y:=y1 + (x - x1)*y1d;
          else
            y:=y2 + (x - x2)*y2d;
          end if;
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
For <i>x<sub>1</sub> &lt; x &lt; x<sub>2</sub></i>, this function interpolates
using cubic hermite spline. For <i>x</i> outside this interval, the function
linearly extrapolates.
</p>
<p>
For how to use this function, see
<a href=\"modelica://IDEAS.Utilities.Math.Functions.Examples.CubicHermite\">
IDEAS.Utilities.Math.Functions.Examples.CubicHermite</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end cubicHermiteLinearExtrapolation;

        function exponentialIntegralE1 "Exponential integral, E1"
          extends Modelica.Icons.Function;
          input Real x "Independent variable";
          output Real E1 "Exponential integral E1(x)";
      protected
          constant Real a1[6] = {-0.57721566, 0.99999193, -0.24991055, 0.05519968, -0.00976004, 0.00107857};
          constant Real a2[5] = {0.2677737343, 8.6347608925, 18.0590169730, 8.5733287401, 1.0};
          constant Real b2[5] = {3.9584969228, 21.0996530827, 25.6329561486, 9.5733223454, 1.0};
        algorithm
            E1 := if x < 1 then
                    IDEAS.Utilities.Math.Functions.polynomial(x, a1) - log(x)
                  else
                   IDEAS.Utilities.Math.Functions.polynomial(x, a2)/(IDEAS.Utilities.Math.Functions.polynomial(x, b2)*x*exp(x));
        annotation (
        Inline=true,
        Documentation(info="<html>
<p>
Evaluates the exponential integral (E<sub>1</sub>), based
on the polynomial and rational approximations of Abramowitz and Stegun (1964).
</p>
<h4>References</h4>
<p>
Abramowitz, Milton, and Irene A. Stegun. Handbook of Mathematical Functions
with Formulas, Graphs, and Mathematical Tables. National Bureau of Standards.
(1964): 1046 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 16, 2018 by Michael Wetter:<br/>
Inlined function.
</li>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end exponentialIntegralE1;

        function factorial "Returns the value n! as an integer"
          extends Modelica.Icons.Function;
          input Integer n(min=0, max=12) "Integer number";
          output Integer f "Factorial of n";
        algorithm
          assert(n >= 0, "n must be 0 or greater.");
          assert(n <= 12, "n must be 12 or less.");
          f := 1;
          for k in 1:n loop
            f := k*f;
          end for;
        annotation (Documentation(info="<html>
<p>
Function that returns the factorial <i>n!</i> for <i>0 &le; n &le; 12</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 9, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end factorial;

        function fallingFactorial "Returns the k-th falling factorial of n"
          extends Modelica.Icons.Function;
          input Integer n "Integer number";
          input Integer k "Falling factorial power";
          output Integer f "k-th falling factorial of n";
      protected
          Integer maxInt = 2147483647 "Max 32-bit integer";
        algorithm
          if k > n then
            f := 0;
          else
            f := 1;
            for i in 0:(k-1) loop
              assert(f <= maxInt/(n-i), "Integer overflow");
              f := f*(n-i);
            end for;
          end if;
        annotation (Documentation(info="<html>
<p>
Function that evaluates the falling factorial \"k-permutations of n\".
</p>
</html>",         revisions="<html>
<ul>
<li>
February 9, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end fallingFactorial;

        function inverseXRegularized
          "Function that approximates 1/x by a twice continuously differentiable function"
          extends Modelica.Icons.Function;
         input Real x "Abscissa value";
         input Real delta(min=Modelica.Constants.eps)
            "Abscissa value below which approximation occurs";
         input Real deltaInv = 1/delta "Inverse value of delta";
         input Real a = -15*deltaInv "Polynomial coefficient";
         input Real b = 119*deltaInv^2 "Polynomial coefficient";
         input Real c = -361*deltaInv^3 "Polynomial coefficient";
         input Real d = 534*deltaInv^4 "Polynomial coefficient";
         input Real e = -380*deltaInv^5 "Polynomial coefficient";
         input Real f = 104*deltaInv^6 "Polynomial coefficient";
         output Real y "Function value";
        algorithm
          y :=if (x > delta or x < -delta) then 1/x elseif (x < delta/2 and x > -delta/2) then x/(delta*delta) else
            IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition(
               x=x,
               delta=delta, deltaInv=deltaInv,
               a=a, b=b, c=c, d=d, e=e, f=f);
          annotation (smoothOrder=2,
          derivative(order=1,
                  zeroDerivative=delta,
                  zeroDerivative=deltaInv,
                  zeroDerivative=a,
                  zeroDerivative=b,
                  zeroDerivative=c,
                  zeroDerivative=d,
                  zeroDerivative=e,
                  zeroDerivative=f)=IDEAS.Utilities.Math.Functions.BaseClasses.der_inverseXRegularized,
                      Inline=true,
        Documentation(info="<html>
<p>
Function that approximates <i>y=1 &frasl; x</i>
inside the interval <i>-&delta; &le; x &le; &delta;</i>.
The approximation is twice continuously differentiable with a bounded derivative on the whole
real line.
</p>
<p>
See the plot of
<a href=\"modelica://IDEAS.Utilities.Math.Functions.Examples.InverseXRegularized\">
IDEAS.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for the graph.
</p>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Typically, these coefficients only depend on parameters and hence
can be computed once.
They must be equal to their default values, otherwise the function
is not twice continuously differentiable.
By exposing these coefficients as function arguments, models
that call this function can compute them as parameters, and
assign these parameter values in the function call.
This avoids that the coefficients are evaluated for each time step,
as they would otherwise be if they were to be computed inside the
body of the function. However, assigning the values is optional
as otherwise, at the expense of efficiency, the values will be
computed each time the function is invoked.
See
<a href=\"modelica://IDEAS.Utilities.Math.Functions.Examples.InverseXRegularized\">
IDEAS.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for how to efficiently call this function.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 10, 2015, by Michael Wetter:<br/>
Removed dublicate entry <code>smoothOrder = 1</code>
and reimplmented the function so it is twice continuously differentiable.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 18, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end inverseXRegularized;

        function isAngle
          "Return true if angles are mathematically equivalent up to a certain precision"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Angle ang1;
          input Modelica.SIunits.Angle ang2;
          input Real precision = 0.01;
          output Boolean result;
        algorithm
          result :=abs(mod(ang1, 2*Modelica.Constants.pi) - mod(ang2, 2*Modelica.Constants.pi)) < precision;
          annotation(Inline=true, Documentation(revisions="<html>
<ul>
<li>
August 9, 2018, by Filip Jorissen:<br/>
Revised implementation to be more intuitive.
</li>
</ul>
</html>"));
        end isAngle;

        function isMonotonic "Returns true if the argument is a monotonic sequence"
          extends Modelica.Icons.Function;
          input Real x[:] "Sequence to be tested";
          input Boolean strict=false "Set to true to test for strict monotonicity";
          output Boolean monotonic "True if x is monotonic increasing or decreasing";
      protected
          Integer n=size(x, 1) "Number of data points";
        algorithm
          if n == 1 then
            monotonic := true;
          else
            monotonic := true;
            if strict then
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] > x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] < x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            else
              // not strict
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] >= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] <= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            end if;
            // strict
          end if;
          annotation (Documentation(info="<html>
<p>
This function returns <code>true</code> if its argument is
monotonic increasing or decreasing, and <code>false</code> otherwise.
If <code>strict=true</code>, then strict monotonicity is tested,
otherwise weak monotonicity is tested.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isMonotonic;

        function polynomial "Polynomial function"
          extends Modelica.Icons.Function;
         input Real x "Independent variable";
         input Real a[:] "Coefficients";
         output Real y "Result";
      protected
         parameter Integer n = size(a, 1)-1;
         Real xp[n+1] "Powers of x";
        algorithm
          xp[1] :=1;
          for i in 1:n loop
             xp[i+1] :=xp[i]*x;
          end for;
          y :=a*xp;
          annotation (Documentation(info="<html>
This function computes a polynomial of arbitrary order.
The polynomial has the form
<p align=\"center\" style=\"font-style:italic;\">
  y = a<sub>1</sub> + a<sub>2</sub> x + a<sub>3</sub> x<sup>2</sup> + ...
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 14, 2016, by Michael Wetter:<br/>
Removed derivative annotation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/602\">issue 602</a>.
</li>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
March 2, by Michael Wetter:<br/>
Removed redundant <code>smoothOrder</code> annotation.
</li>
<li>
February 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        smoothOrder=999);
        end polynomial;

        function quinticHermite
          "Quintic Hermite spline function for interpolation between two functions with a continuous second derivative"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower derivative";
          input Real y2d "Upper derivative";
          input Real y1dd "Lower second derivative";
          input Real y2dd "Upper second derivative";
          output Real y "Interpolated ordinate value";
      protected
          Real h = x2 - x1;
          Real hpow2 = h*h;
          Real t = (x - x1)/h;
          Real tpow2 = t*t;
          Real tpow3 = tpow2*t;
          Real tpow4 = tpow3*t;
          Real tpow5 = tpow4*t;
          Real H0 = 1 - 10*tpow3 + 15*tpow4 - 6*tpow5;
          Real H1 = t -  6*tpow3 +  8*tpow4 - 3*tpow5;
          Real H2 = 0.5*(tpow2 - 3*tpow3 + 3 *tpow4 - tpow5);
          Real H3 = 0.5*tpow3 - tpow4 + 0.5*tpow5;
          Real H4 = -4*tpow3 +7*tpow4 -3*tpow5;
          Real H5 = 1-H0;
        algorithm
          y :=H0*y1 + H1*y1d*h  + H2*y1dd*hpow2 + H3*y2dd*hpow2 + H4*y2d*h + H5*y2;
        annotation (smoothOrder=99,
        Documentation(revisions="<html>
<ul>
<li>
April 19, 2017, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Returns the result y of a quintic Hermite spline,
which is a C<sup>2</sup> continuous interpolation between two functions.
The abscissa value <code>x</code> has to be between <code>x1</code> and <code>x2</code>.
Variables <code>y1</code>, <code>y1d</code>, <code>y1dd</code> are the ordinate,
ordinate derivative and ordinate second derivative of the function at <code>x1</code>.
Variables <code>y2</code>, <code>y2d</code>, <code>y2dd</code> are respectively the ordinate,
ordinate derivative and ordinate second derivative of the function at <code>x2</code>.
</p>
</html>"));
        end quinticHermite;

        function regNonZeroPower
          "Power function, regularized near zero, but nonzero value for x=0"
          extends Modelica.Icons.Function;
         input Real x "Abscissa value";
         input Real n "Exponent";
         input Real delta = 0.01 "Abscissa value where transition occurs";
         output Real y "Function value";
      protected
          Real a1;
          Real a3;
          Real a5;
          Real delta2;
          Real x2;
          Real y_d "=y(delta)";
          Real yP_d "=dy(delta)/dx";
          Real yPP_d "=d^2y(delta)/dx^2";
        algorithm
          if abs(x) > delta then
           y := abs(x)^n;
          else
           delta2 :=delta*delta;
           x2 :=x*x;
           y_d :=delta^n;
           yP_d :=n*delta^(n - 1);
           yPP_d :=n*(n - 1)*delta^(n - 2);
           a1 := -(yP_d/delta - yPP_d)/delta2/8;
           a3 := (yPP_d - 12 * a1 * delta2)/2;
           a5 := (y_d - delta2 * (a3 + delta2 * a1));
           y := a5 + x2 * (a3 + x2 * a1);
           assert(a5>0, "Delta is too small for this exponent.");
          end if;
          annotation (
            Documentation(info="<html>

Function that approximates <i>y=|x|<sup>n</sup></i> where <i>n &gt; 0</i>
so that
<ul>
<li><i>y(0)</i> is not equal to zero.</li>
<li><i>dy/dx</i> is bounded and continuous everywhere.</li>
</ul>

<p>
This function replaces <i>y=|x|<sup>n</sup></i> in the interval
<i>-&delta;...+&delta;</i> by a 4-th order polynomial that has the same
function value and the first and second derivative at <i>x=&plusmn; &delta;</i>.
</p>
<p>
A typical use of this function is to replace the
function for the convective heat transfer
coefficient for forced or free convection that is of the form
<i>h=c |dT|<sup>n</sup></i> for some constant <i>c</i> and exponent
<i>0 &le; n &le; 1</i>.
By using this function, the original function
that has an infinite derivative near zero and that takes on zero
at the origin is replaced by a function with a bounded derivative and
a non-zero value at the origin. Physically,
the region <i>-&delta;...+&delta;</i> may be interpreted as the region
where heat conduction dominates convection in the boundary layer.
</p>
See the package <code>Examples</code> for the graph.
</html>",         revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 14, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Inline=true,
                   smoothOrder=2,
                   derivative(zeroDerivative=n, zeroDerivative=delta)=BaseClasses.der_regNonZeroPower);
        end regNonZeroPower;

        function regStep
          "Approximation of a general step, such that the approximation is continuous and differentiable"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real y1 "Ordinate value for x > 0";
          input Real y2 "Ordinate value for x < 0";
          input Real x_small(min=0) = 1e-5
            "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
          output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
        algorithm
          y := smooth(1, if x >  x_small then y1 else
                         if x < -x_small then y2 else
                         if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);
          annotation(Inline=true,
          Documentation(revisions="<html>
<ul>
<li><i>February 18, 2016</i>
    by Marcus Fuchs:<br/>
    Add function with <code>Inline = true</code> in annotations to package for better performance,
    as suggested in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a> .</li>
<li><i>April 29, 2008</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br/>
    Designed and implemented.</li>
<li><i>August 12, 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",         info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <b>if</b> x &gt; 0 <b>then</b> y1 <b>else</b> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> y1 <b>else</b>
                 <b>if</b> x &lt; -x_small <b>then</b> y2 <b>else</b> f(y1, y2));
</pre>

<p>
In the region <code>-x_small &lt; x &lt; x_small</code> a 2nd order polynomial is used
for a smooth transition from <code>y1</code> to <code>y2</code>.
</p>
</html>"));
        end regStep;

        function smoothLimit
          "Once continuously differentiable approximation to the limit function"
          extends Modelica.Icons.Function;
          input Real x "Variable";
          input Real l "Low limit";
          input Real u "Upper limit";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
      protected
          Real cor;
        algorithm
          cor :=deltaX/10;
          y := IDEAS.Utilities.Math.Functions.smoothMax(x,l+deltaX,cor);
          y := IDEAS.Utilities.Math.Functions.smoothMin(y,u-deltaX,cor);
          annotation (smoothOrder = 1,
          Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>limit(.,.)</code> function.
The output is bounded to be in <i>[l, u]</i>.
</p>
<p>
Note that the limit need not be respected, such as illustrated in
<a href=\"modelica://IDEAS.Utilities.Math.Examples.SmoothMin\">
IDEAS.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
Sept 1, 2010, by Michael Wetter:<br/>
Changed scaling to make sure that bounds are never violated.
</li>
<li>
July 14, 2010, by Wangda Zuo, Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothLimit;

        function smoothMax
          "Once continuously differentiable approximation to the maximum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := IDEAS.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x1-x2, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>max(.,.)</code> function.
</p>
<p>
Note that the maximum need not be respected, such as illustrated in
<a href=\"modelica://IDEAS.Utilities.Math.Examples.SmoothMin\">
IDEAS.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMax;

        function smoothMin
          "Once continuously differentiable approximation to the minimum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := IDEAS.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x2-x1, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>min(.,.)</code> function.
</p>
<p>
Note that the minimum need not be respected, such as illustrated in
<a href=\"modelica://IDEAS.Utilities.Math.Examples.SmoothMin\">
IDEAS.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMin;

        function spliceFunction
          extends Modelica.Icons.Function;
            input Real pos "Argument of x > 0";
            input Real neg "Argument of x < 0";
            input Real x "Independent value";
            input Real deltax "Half width of transition interval";
            output Real out "Smoothed value";
      protected
            Real scaledX1;
            Real y;
            constant Real asin1 = Modelica.Math.asin(1);
        algorithm
            scaledX1 := x/deltax;
            if scaledX1 <= -0.999999999 then
              out := neg;
            elseif scaledX1 >= 0.999999999 then
              out := pos;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX1*asin1)) + 1)/2;
              out := pos*y + (1 - y)*neg;
            end if;
            annotation (
        smoothOrder=1,
        derivative=BaseClasses.der_spliceFunction,
        Documentation(info="<html>
<p>
Function to provide a once continuously differentiable transition between
to arguments.
</p><p>
The function is adapted from
<a href=\"modelica://Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">
Modelica.Media.Air.MoistAir.Utilities.spliceFunction</a> and provided here
for easier accessability to model developers.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
May 11, 2010, by Michael Wetter:<br/>
Removed default value for transition interval as this is problem dependent.
</li>
<li>
May 20, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end spliceFunction;

        function splineDerivatives
          "Function to compute the derivatives for cubic hermite spline interpolation"
          extends Modelica.Icons.Function;
          input Real x[:] "Support point, strict monotone increasing";
          input Real y[size(x, 1)] "Function values at x";
          input Boolean ensureMonotonicity=isMonotonic(y, strict=false)
            "Set to true to ensure monotonicity of the cubic hermite";
          output Real d[size(x, 1)] "Derivative at the support points";
      protected
          Integer n=size(x, 1) "Number of data points";
          Real delta[n - 1] "Slope of secant line between data points";
          Real alpha "Coefficient to ensure monotonicity";
          Real beta "Coefficient to ensure monotonicity";
          Real tau "Coefficient to ensure monotonicity";
        algorithm
          if (n>1) then
            assert(x[1] < x[n], "x must be strictly increasing.
  Received x[1] = "         + String(x[1]) + "
           x["         + String(n) + "] = " + String(x[n]));
          // Check data
            assert(isMonotonic(x, strict=true),
              "x-values must be strictly monontone increasing or decreasing.");
            if ensureMonotonicity then
              assert(isMonotonic(y, strict=false),
                "If ensureMonotonicity=true, y-values must be monontone increasing or decreasing.");
            end if;
          end if;
          // Compute derivatives at the support points
          if n == 1 then
            // only one data point
            d[1] :=0;
          elseif n == 2 then
            // linear function
            d[1] := (y[2] - y[1])/(x[2] - x[1]);
            d[2] := d[1];
          else
            // Slopes of the secant lines between i and i+1
            for i in 1:n - 1 loop
              delta[i] := (y[i + 1] - y[i])/(x[i + 1] - x[i]);
            end for;
            // Initial values for tangents at the support points.
            // End points use one-sided derivatives
            d[1] := delta[1];
            d[n] := delta[n - 1];
            for i in 2:n - 1 loop
              d[i] := (delta[i - 1] + delta[i])/2;
            end for;
          end if;
          // Ensure monotonicity
          if n > 2 and ensureMonotonicity then
            for i in 1:n - 1 loop
              if (abs(delta[i]) < Modelica.Constants.small) then
                d[i] := 0;
                d[i + 1] := 0;
              else
                alpha := d[i]/delta[i];
                beta := d[i + 1]/delta[i];
                // Constrain derivative to ensure monotonicity in this interval
                if (alpha^2 + beta^2) > 9 then
                  tau := 3/(alpha^2 + beta^2)^(1/2);
                  d[i] := delta[i]*alpha*tau;
                  d[i + 1] := delta[i]*beta*tau;
                end if;
              end if;
            end for;
          end if;
          annotation (Documentation(info="<html>
<p>
This function computes the derivatives at the support points <i>x<sub>i</sub></i>
that can be used as input for evaluating a cubic hermite spline.
</p>
<p>
If <code>ensureMonotonicity=true</code>, then the support points <i>y<sub>i</sub></i>
need to be monotone increasing (or increasing), and the computed derivatives
<i>d<sub>i</sub></i> are such that the cubic hermite is monotone increasing (or decreasing).
The algorithm to ensure monotonicity is based on the method described in Fritsch and Carlson (1980) for
<i>&rho; = &rho;<sub>2</sub></i>.
</p>
<p>
This function is typically used with
<a href=\"modelica://IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation\">
IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation</a>
which is used to evaluate the cubic spline.
Because in many applications, the shape of the spline depends on parameters,
this function has been implemented in such a way that all derivatives can be
computed at once and then stored for use during the time stepping,
in which the above function may be called.
</p>
<h4>References</h4>
<p>
F.N. Fritsch and R.E. Carlson, <a href=\"http://dx.doi.org/10.1137/0717021\">Monotone piecewise cubic interpolation</a>.
<i>SIAM J. Numer. Anal.</i>, 17 (1980), pp. 238-246.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 26, 2016 by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
September 29, 2011 by Michael Wetter:<br/>
Added special case for one data point and two data points.
</li>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end splineDerivatives;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for commonly used
mathematical operations. The functions are used in
the blocks
<a href=\"modelica://IDEAS.Utilities.Math\">
IDEAS.Utilities.Math</a>.
</p>
</html>"));
      end Functions;

      block IntegratorWithReset "Output the integral of the input signal"
        extends Modelica.Blocks.Interfaces.SISO(y(start=y_start));
        parameter Real k(unit="1")=1 "Integrator gain";
        /* InitialState is the default, because it was the default in Modelica 2.2
     and therefore this setting is backward compatible
  */
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.InitialState
          "Type of initialization (1: no init, 2: steady state, 3,4: initial output)"
          annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        parameter IDEAS.Types.Reset reset = IDEAS.Types.Reset.Disabled
          "Type of integrator reset";
        parameter Real y_reset = 0
          "Value to which integrator is reset, used if reset = IDEAS.Types.Reset.Parameter"
          annotation(Evaluate=true,
                     Dialog(
                       enable=reset == IDEAS.Types.Reset.Parameter,
                       group="Integrator reset"));
        Modelica.Blocks.Interfaces.RealInput y_reset_in if
             reset == IDEAS.Types.Reset.Input
          "Input signal for state to which integrator is reset, enabled if reset = IDEAS.Types.Reset.Input"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Modelica.Blocks.Interfaces.BooleanInput trigger if
             reset <> IDEAS.Types.Reset.Disabled
          "Resets the integrator output when trigger becomes true"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}}, rotation=90,
              origin={0,-120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={0,-120})));
    protected
        Modelica.Blocks.Interfaces.RealInput y_reset_internal
         "Internal connector for integrator reset"
         annotation(Evaluate=true);
        Modelica.Blocks.Interfaces.BooleanInput trigger_internal
          "Needed to use conditional connector trigger";
      initial equation
        if initType == Modelica.Blocks.Types.Init.SteadyState then
           der(y) = 0;
        elseif initType == Modelica.Blocks.Types.Init.InitialState or
               initType == Modelica.Blocks.Types.Init.InitialOutput then
          y = y_start;
        end if;
      equation
        der(y) = k*u;
        // Equations for integrator reset
        connect(trigger, trigger_internal);
        connect(y_reset_in, y_reset_internal);
        if reset <> IDEAS.Types.Reset.Input then
          y_reset_internal = y_reset;
        end if;
        if reset == IDEAS.Types.Reset.Disabled then
          trigger_internal = false;
        else
          when trigger_internal then
            reinit(y, y_reset_internal);
          end when;
        end if;
        annotation (
      defaultComponentName="intWitRes",
          Documentation(info="<html>
<p>
This model is similar to
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
except that it optionally allows to reset the output <code>y</code>
of the integrator.
</p>
<p>
The output of the integrator can be reset as follows:
</p>
<ul>
<li>
If <code>reset = IDEAS.Types.Reset.Disabled</code>, which is the default,
then the integrator is never reset.
</li>
<li>
If <code>reset = IDEAS.Types.Reset.Parameter</code>, then a boolean
input signal <code>trigger</code> is enabled. Whenever the value of
this input changes from <code>false</code> to <code>true</code>,
the integrator is reset by setting <code>y</code>
to the value of the parameter <code>y_reset</code>.
</li>
<li>
If <code>reset = IDEAS.Types.Reset.Input</code>, then a boolean
input signal <code>trigger</code> is enabled. Whenever the value of
this input changes from <code>false</code> to <code>true</code>,
the integrator is reset by setting <code>y</code>
to the value of the input signal <code>y_reset_in</code>.
</li>
</ul>
<p>
See <a href=\"modelica://IDEAS.Utilities.Math.Examples.IntegratorWithReset\">
IDEAS.Utilities.Math.Examples.IntegratorWithReset</a> for an example.
</p>
<h4>Implementation</h4>
<p>
To adjust the icon layer, the code of
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
has been copied into this model rather than extended.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 1, 2016, by Michael Wetter:<br/>
Corrected wrong annotation for <code>y_reset</code>,
and made rendering of <code>y_reset_in</code> conditional.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/562\">#562</a>.
</li>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model to use a <code>type</code> for configuration
of the integrator reset.
</li>
<li>
August 9, 2016, by Michael Wetter:<br/>
Reformulated model using a conditional connector to use the same
design pattern as is used in other models.
</li>
<li>
August 9, 2016, by Michael Wetter:<br/>
Revised model.
</li>
<li>
July 18, 2016, by Philipp Mehrfeld:<br/>
First implementation.
</li>
</ul>
</html>"),
      Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Text(
                  extent={{-88,-94},{212,-54}},
                lineColor={0,0,0},
                textString="y_reset_in",
                visible=reset == IDEAS.Types.Reset.Input,
                horizontalAlignment=TextAlignment.Left),
              Bitmap(extent={{-54,-50},{60,50}}, fileName=
                    "modelica://IDEAS/Resources/Images/Utilities/Math/int.png"),
                Text(
                  extent={{-88,56},{206,92}},
                lineColor={0,0,0},
                textString="k=%k",
                horizontalAlignment=TextAlignment.Left),
                Text(
                  extent={{-92,-12},{208,28}},
                lineColor={0,0,0},
                horizontalAlignment=TextAlignment.Left,
                textString="u"),
                Text(
                  extent={{70,-14},{370,26}},
                lineColor={0,0,0},
                horizontalAlignment=TextAlignment.Left,
                textString="y")}));
      end IntegratorWithReset;

      block MovingAverage "Calculates the moving average of a Real input"
        extends Modelica.Blocks.Interfaces.SISO;
        parameter Modelica.SIunits.Time period=1
          "Period over wich running average is to be computed";
        parameter Real resetIntegral(min=10) = 1000000
          "Number of period before reseting the integral of the moving average"
          annotation(Dialog(tab = "Advanced"));
    protected
        Real iDelay "delayed integration";
        Real iStop(start=0, fixed=true) "integrator until stop time";
      initial algorithm
        iDelay := -u*period;
      equation
        der(iStop) = u;
        der(iDelay) = delay(
          u,
          period,
          period);
        when sample(resetIntegral*period,resetIntegral*period) then
          reinit(iStop,iStop - iDelay);
          reinit(iDelay,0);
        end when;
        if time >= 0.1 and time <= period then
          y = iStop/time;
        elseif time > period then
          y = (iStop - iDelay)/period;
        else
          y = u;
        end if;
      end MovingAverage;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for commonly used
mathematical operations.
The classes in this package augment the classes
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</p>
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
              {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
                {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
                -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
                -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
                {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
                0,0,0}, smooth=Smooth.Bezier)}));
    end Math;

    package Psychrometrics "Library with psychrometric functions"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Package with base classes for IDEAS.Utilities.Psychrometrics"
        extends Modelica.Icons.BasesPackage;

        partial block HumidityRatioVaporPressure
          "Humidity ratio for given water vapor pressure"
          extends Modelica.Blocks.Icons.Block;
          parameter Boolean use_p_in = true "Get the pressure from the input connector"
            annotation(Evaluate=true, HideResult=true);
          parameter Modelica.SIunits.Pressure p = 101325 "Fixed value of pressure"
            annotation (Dialog(enable = not use_p_in));
          Modelica.Blocks.Interfaces.RealInput p_in(final quantity="Pressure",
                                                 final unit="Pa",
                                                 displayUnit="Pa",
                                                 min = 0) if  use_p_in
            "Atmospheric Pressure"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
      protected
          Modelica.Blocks.Interfaces.RealInput p_in_internal
            "Needed to connect to conditional connector";
        equation
          connect(p_in, p_in_internal);
          if not use_p_in then
            p_in_internal = p;
          end if;
          annotation (
            Documentation(info="<html>
<p>
Partial Block to compute the relation between humidity ratio and water vapor partial pressure.
</p>
<p>If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored,
and the value provided by the input connector is used instead.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
April 14, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-96,96},{96,-96}},
                  fillPattern=FillPattern.Sphere,
                  pattern=LinePattern.None,
                  lineColor={255,255,255},
                  fillColor={170,213,255}),
                Text(
                  visible=use_p_in,
                  extent={{-90,108},{-34,16}},
                  lineColor={0,0,0},
                  textString="p_in")}));
        end HumidityRatioVaporPressure;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Utilities.Psychrometrics\">IDEAS.Utilities.Psychrometrics</a>.
</p>
</html>"));
      end BaseClasses;

      package Constants "Library of constants for psychometric functions"
        extends Modelica.Icons.Package;

        constant Modelica.SIunits.Temperature T_ref = 273.15
          "Reference temperature for psychrometric calculations";

        constant Modelica.SIunits.SpecificHeatCapacity cpAir=1006
          "Specific heat capacity of air";

        constant Modelica.SIunits.SpecificHeatCapacity cpSte=1860
          "Specific heat capacity of water vapor";

        constant Modelica.SIunits.SpecificHeatCapacity cpWatLiq = 4184
          "Specific heat capacity of liquid water";

        constant Modelica.SIunits.SpecificEnthalpy h_fg = 2501014.5
          "Enthalpy of evaporation of water at the reference temperature";

        constant Real k_mair = 0.6219647130774989 "Ratio of molar weights";
        annotation (
          Documentation(info="<html>
<p>
This package provides constants for functions used
in the calculation of thermodynamic properties of moist air.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Added reference temperature.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
            Polygon(
              origin={-9.2597,25.6673},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={-19.9923,-8.3993},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={23.753,-11.5422},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
              smooth=Smooth.Bezier)}));
      end Constants;

      package Functions "Package with psychrometric functions"
        extends Modelica.Icons.Package;

        package BaseClasses
        "Package with base classes for IDEAS.Utilities.Psychrometrics.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_saturationPressureLiquid
            "Derivative of the function saturationPressureLiquid"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.Temperature Tsat "Saturation temperature";
            input Real dTsat(unit="K/s") "Saturation temperature derivative";
            output Real psat_der(unit="Pa/s") "Differential of saturation pressure";
          algorithm
            psat_der:=611.657*Modelica.Math.exp(17.2799 - 4102.99
                      /(Tsat - 35.719))*4102.99*dTsat/(Tsat - 35.719)^2;
            annotation(Inline=false,
              smoothOrder=5,
              Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid\">
IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
          end der_saturationPressureLiquid;

          function der_sublimationPressureIce
            "Derivative of function sublimationPressureIce"
              extends Modelica.Icons.Function;
              input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                      nominal=300)
              "Saturation temperature";
              input Real dTsat(unit="K/s") "Sublimation temperature derivative";
              output Real psat_der(unit="Pa/s") "Sublimation pressure derivative";
        protected
              Modelica.SIunits.Temperature TTriple=273.16 "Triple point temperature";
              Modelica.SIunits.AbsolutePressure pTriple=611.657 "Triple point pressure";
              Real r1=TSat/TTriple "Common subexpression 1";
              Real r1_der=dTsat/TTriple "Derivative of common subexpression 1";
              Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
              Real n[2]={-1.5,-1.25} "Coefficients n[:]";
          algorithm
              psat_der := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple*(-(a[1]
                *(r1^(n[1] - 1)*n[1]*r1_der)) - (a[2]*(r1^(n[2] - 1)*n[2]*r1_der)));
              annotation (
                Inline=false,
                smoothOrder=5,
                Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Functions.sublimationPressureIce\">
IDEAS.Utilities.Psychrometrics.Functions.sublimationPressureIce</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
          end der_sublimationPressureIce;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Functions\">IDEAS.Utilities.Psychrometrics.Functions</a>.
</p>
</html>"));
        end BaseClasses;

        function phi_pTX
          "Relative humidity for given pressure, dry bulb temperature and moisture mass fraction"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Pressure p "Absolute pressure of the medium";
          input Modelica.SIunits.Temperature T "Dry bulb temperature";
          input Modelica.SIunits.MassFraction X_w
            "Water vapor mass fraction per unit mass total air";
          output Real phi(unit="1") "Relative humidity";
        algorithm
          phi :=p/saturationPressure(T)*X_w/(X_w +
            IDEAS.Utilities.Psychrometrics.Constants.k_mair*(1-X_w));
          annotation (
            smoothOrder=1,
            Documentation(info="<html>
<p>
Relative humidity of air for given
pressure, temperature and water vapor mass fraction.
</p>
<p>
Note that the water vapor mass fraction must be in <i>kg/kg</i>
total air, and not dry air.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 17, 2014 by Michael Wetter:<br/>
Removed test that constrains the saturation pressure to be
lower than <code>p</code>.
I do not see any numerical problems without this test.
</li>
<li>
November 13, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end phi_pTX;

        function saturationPressure
          "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300) "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                                  displayUnit="Pa",
                                                  nominal=1000) "Saturation pressure";
        algorithm
          pSat := IDEAS.Utilities.Math.Functions.regStep(
                     y1=IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TSat),
                     y2=IDEAS.Utilities.Psychrometrics.Functions.sublimationPressureIce(TSat),
                     x=TSat-273.16,
                     x_small=1.0);
          annotation(Inline=true,
            smoothOrder=1,
            Documentation(info="<html>
<p>
Saturation pressure of water, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://www.nist.gov/data/PDFfiles/jpcrd477.pdf\">
http://www.nist.gov/data/PDFfiles/jpcrd477.pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
August 19, 2015 by Michael Wetter:<br/>
Changed <code>smoothOrder</code> from <i>5</i> to <i>1</i> as
<a href=\"modelica://IDEAS.Utilities.Math.Functions.spliceFunction\">
IDEAS.Utilities.Math.Functions.spliceFunction</a> is only once
continuously differentiable.
Inlined the function.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
        end saturationPressure;

        function saturationPressureLiquid
          "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300) "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                              displayUnit="Pa",
                                              nominal=1000) "Saturation pressure";
        algorithm
          pSat := 611.657*Modelica.Math.exp(17.2799 - 4102.99/(TSat - 35.719));
          annotation (
            smoothOrder=99,
            derivative=IDEAS.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid,
            Inline=true,
            Documentation(info="<html>
<p>
Saturation pressure of water above the triple point temperature computed from temperature
according to Wagner <i>et al.</i> (1993). The range of validity is between
<i>273.16</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://www.nist.gov/data/PDFfiles/jpcrd477.pdf\">
http://www.nist.gov/data/PDFfiles/jpcrd477.pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
        end saturationPressureLiquid;

        function sublimationPressureIce
          "Return sublimation pressure of water as a function of temperature T between 190 and 273.16 K"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300) "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                              displayUnit="Pa",
                                              nominal=1000) "Saturation pressure";
      protected
          Modelica.SIunits.Temperature TTriple=273.16 "Triple point temperature";
          Modelica.SIunits.AbsolutePressure pTriple=611.657 "Triple point pressure";
          Real r1=TSat/TTriple "Common subexpression";
          Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
          Real n[2]={-1.5,-1.25} "Coefficients n[:]";
        algorithm
          pSat := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple;
          annotation (
            Inline=false,
            smoothOrder=5,
            derivative=IDEAS.Utilities.Psychrometrics.Functions.BaseClasses.der_sublimationPressureIce,
            Documentation(info="<html>
<p>
Sublimation pressure of water below the triple point temperature, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>273.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://www.nist.gov/data/PDFfiles/jpcrd477.pdf\">
http://www.nist.gov/data/PDFfiles/jpcrd477.pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
        end sublimationPressureIce;

        function X_pSatpphi "Humidity ratio for given water vapor pressure"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.AbsolutePressure pSat "Saturation pressure";
          input Modelica.SIunits.Pressure p "Pressure of the fluid";
          input Real phi(min=0, max=1) "Relative humidity";
          output Modelica.SIunits.MassFraction X_w(
            min=0,
            max=1,
            nominal=0.01) "Water vapor concentration per total mass of air";
      protected
          constant Real k = 0.621964713077499 "Ratio of molar masses";
        algorithm
          X_w := phi*k/(k*phi+p/pSat-phi);
          annotation (
            smoothOrder=99,
            Inline=true,
            Documentation(info="<html>
<p>
Function to compute the water vapor concentration based on
saturation pressure, absolute pressure and relative humidity.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 21, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end X_pSatpphi;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for psychrometric calculations.
</p>

The nomenclature used in this package is described at
<a href=\"modelica://IDEAS.UsersGuide.Conventions\">
IDEAS.UsersGuide.Conventions</a>.
</html>"));
      end Functions;

      block TWetBul_TDryBulPhi
        "Model to compute the wet bulb temperature based on relative humidity"
        extends Modelica.Blocks.Icons.Block;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialCondensingGases "Medium model"
          annotation (choicesAllMatching = true);
        parameter Boolean approximateWetBulb=false
          "Set to true to approximate wet bulb temperature" annotation (Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          start=Medium.T_default,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Dry bulb temperature"
          annotation (Placement(transformation(extent={{-120,70},{-100,90}})));
        Modelica.Blocks.Interfaces.RealInput phi(min=0, max=1)
          "Relative air humidity"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));
        Modelica.Blocks.Interfaces.RealInput p(final quantity="Pressure",
                                               final unit="Pa",
                                               min = 0) "Pressure"
          annotation (Placement(transformation(extent={{-120,-90},{-100,-70}})));
        Modelica.Blocks.Interfaces.RealOutput TWetBul(
          start=Medium.T_default-2,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Wet bulb temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        Modelica.SIunits.Conversions.NonSIunits.Temperature_degC TDryBul_degC
          "Dry bulb temperature in degree Celsius";
        Real rh_per(min=0) "Relative humidity in percentage";
        Modelica.SIunits.MassFraction XiDryBul
          "Water vapor mass fraction at dry bulb state";
        Modelica.SIunits.MassFraction XiSat "Water vapor mass fraction at saturation";
        Modelica.SIunits.MassFraction XiSatRefIn
          "Water vapor mass fraction at saturation, referenced to inlet mass flow rate";
      equation
        if approximateWetBulb then
          TDryBul_degC = TDryBul - 273.15;
          rh_per       = 100*phi;
          TWetBul      = 273.15 + TDryBul_degC
             * Modelica.Math.atan(0.151977 * sqrt(rh_per + 8.313659))
             + Modelica.Math.atan(TDryBul_degC + rh_per)
             - Modelica.Math.atan(rh_per-1.676331)
             + 0.00391838 * rh_per^(1.5) * Modelica.Math.atan( 0.023101 * rh_per)  - 4.686035;
          XiSat    = 0;
          XiDryBul = 0;
          XiSatRefIn=0;
        else
          XiSatRefIn=(1-XiDryBul)*XiSat/(1-XiSat);
          XiSat  = IDEAS.Utilities.Psychrometrics.Functions.X_pSatpphi(
            pSat = IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TWetBul),
            p =    p,
            phi =  1);
          XiDryBul =IDEAS.Utilities.Psychrometrics.Functions.X_pSatpphi(
            p =    p,
            pSat = IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TDryBul),
            phi =  phi);
          (TWetBul-IDEAS.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-XiDryBul) * IDEAS.Utilities.Psychrometrics.Constants.cpAir +
                    XiSatRefIn * IDEAS.Utilities.Psychrometrics.Constants.cpSte +
                    (XiDryBul-XiSatRefIn) * IDEAS.Utilities.Psychrometrics.Constants.cpWatLiq)
          =
          (TDryBul-IDEAS.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-XiDryBul) * IDEAS.Utilities.Psychrometrics.Constants.cpAir +
                    XiDryBul * IDEAS.Utilities.Psychrometrics.Constants.cpSte)  +
          (XiDryBul-XiSatRefIn) * IDEAS.Utilities.Psychrometrics.Constants.h_fg;
          TDryBul_degC = 0;
          rh_per       = 0;
        end if;
      annotation (
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-92,100},{-62,56}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                extent={{-92,14},{-72,-12}},
                lineColor={0,0,127},
                textString="phi"),
              Text(
                extent={{-90,-72},{-72,-90}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                extent={{62,22},{92,-22}},
                lineColor={0,0,127},
                textString="TWetBul"),
              Line(points={{78,-74},{-48,-74}}),
              Text(
                extent={{76,-78},{86,-94}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="T"),
              Line(
                points={{76,-46},{26,-4}},
                color={255,0,0},
                thickness=0.5),
              Line(points={{-48,-48},{-2,-30},{28,-4},{48,32},{52,72}},
                color={0,0,0},
                smooth=Smooth.Bezier),
              Line(points={{-48,84},{-48,-74}}),
              Text(
                extent={{-44,82},{-22,64}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="X"),
              Polygon(
                points={{86,-74},{76,-72},{76,-76},{86,-74}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-48,88},{-46,74},{-50,74},{-48,88}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
          defaultComponentName="wetBul",
          Documentation(info="<html>
<p>
This block computes the wet bulb temperature for a given dry bulb temperature, relative air humidity
and atmospheric pressure.
</p>
<p>
If the constant <code>approximateWetBulb</code> is <code>true</code>,
then the block uses the approximation of Stull (2011) to compute
the wet bulb temperature without requiring a nonlinear equation.
Otherwise, the model will introduce one nonlinear equation.
The approximation by Stull is valid for a relative humidity of <i>5%</i> to <i>99%</i>,
a temperature range from <i>-20</i>&deg;C to <i>50</i>&deg;C
and standard sea level pressure.
For this range of data, the approximation error is <i>-1</i> Kelvin to <i>+0.65</i> Kelvin,
with a mean error of less than <i>0.3</i> Kelvin.
</p>
<p>
Otherwise a calculation based on an energy balance is used.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a> for a discussion.
The model is validated in
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Examples.TWetBul_TDryBulPhi\">
IDEAS.Utilities.Psychrometrics.Examples.TWetBul_TDryBulPhi</a>.
</p>
<p>
For a model that takes the mass fraction instead of the relative humidity as an input, see
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.TWetBul_TDryBulXi\">
IDEAS.Utilities.Psychrometrics.TWetBul_TDryBulXi</a>.
</p>
<h4>References</h4>
<p>
Stull, Roland.
<i><a href=\"http://dx.doi.org/10.1175/JAMC-D-11-0143.1\">
Wet-Bulb Temperature from Relative Humidity and Air Temperature
Roland Stull.</a></i>
Journal of Applied Meteorology and Climatology.
Volume 50, Issue 11, pp. 2267-2269. November 2011
DOI: 10.1175/JAMC-D-11-0143.1
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Changed icon.
</li>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Corrected exact implementation.
See  <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a>
for a discussion.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
Updated model to use
<code>IDEAS.Utilities.Psychrometrics.Functions.saturationPressure()</code>
and
<code>IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid()</code>
as these functions have been moved from the medium to the psychrometrics package.
</li>
<li>
October 1, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TWetBul_TDryBulPhi;

      block X_pTphi
        "Return steam mass fraction as a function of relative humidity phi and temperature T"
        extends
        IDEAS.Utilities.Psychrometrics.BaseClasses.HumidityRatioVaporPressure;
        package Medium = IDEAS.Media.Air "Medium model";
        Modelica.Blocks.Interfaces.RealInput T(final unit="K",
                                                 displayUnit="degC",
                                                 min = 0) "Temperature"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealInput phi(min = 0, max=1)
          "Relative humidity (0...1)"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
        Modelica.Blocks.Interfaces.RealOutput X[Medium.nX](each min=0, each max=1)
          "Steam mass fraction"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        Modelica.SIunits.AbsolutePressure pSat "Saturation pressure";
        parameter Integer i_w=
         sum({(
           if Modelica.Utilities.Strings.isEqual(
             string1=Medium.substanceNames[i],
             string2="Water",
             caseSensitive=false)
           then i else 0)
           for i in 1:Medium.nX});
        parameter Integer i_nw = if i_w == 1 then 2 else 1 "Index for non-water substance";
        parameter Boolean found = i_w > 0 "Flag, used for error checking";
      initial equation
        assert(Medium.nX==2, "The implementation is only valid if Medium.nX=2.");
        assert(found, "Did not find medium species 'water' in the medium model. Change medium model.");
      equation
        pSat =  IDEAS.Media.Air.saturationPressure(T);
        X[i_w] =  IDEAS.Utilities.Psychrometrics.Functions.X_pSatpphi(
           pSat=pSat,
           p=p_in_internal,
           phi=phi);
        //sum(X[:]) = 1; // The formulation with a sum in an equation section leads to a nonlinear equation system
        X[i_nw] =  1 - X[i_w];
        annotation (Documentation(info="<html>
<p>
Block to compute the water vapor concentration based on
pressure, temperature and relative humidity.
</p>
<p>
If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored,
and the value provided by the input connector is used instead.
</p>
</html>",       revisions="<html>
<ul>
<li>November 3, 2017 by Filip Jorissen:<br/>
Converted (initial) algorithm section into (initial) equation section.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/847\">#847</a>.
</li>
<li>July 24, 2014 by Michael Wetter:<br/>
Added <code>assert</code> to verify that <code>Medium.nX==2</code>
as the implementation is only valid for such media.
</li>
<li>April 26, 2013 by Michael Wetter:<br/>
Set the medium model to <code>IDEAS.Media.Air</code>.
This was required to allow a pedantic model check in Dymola 2014.
</li>
<li>August 21, 2012 by Michael Wetter:<br/>
Added function call to compute water vapor content.
</li>
<li>
February 22, 2010 by Michael Wetter:<br/>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
February 17, 2010 by Michael Wetter:<br/>
Renamed block from <code>MassFraction_pTphi</code> to <code>X_pTphi</code>
</li>
<li>
February 4, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Text(
                extent={{-96,16},{-54,-22}},
                lineColor={0,0,0},
                textString="T"),
              Text(
                extent={{-86,-18},{-36,-100}},
                lineColor={0,0,0},
                textString="phi"),
              Text(
                extent={{26,56},{90,-54}},
                lineColor={0,0,0},
                textString="X_steam")}));
      end X_pTphi;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for psychrometric calculations.
</p>
<p>
The nomenclature used in this package is described at
<a href=\"modelica://IDEAS.UsersGuide.Conventions\">
IDEAS.UsersGuide.Conventions</a>.
</p>
</html>"));
    end Psychrometrics;

    package Time "Package with models for time"
      extends Modelica.Icons.Package;

      model CalendarTime
        "Computes the unix time stamp and calendar time from the simulation time"
        extends Modelica.Blocks.Icons.DiscreteBlock;
        parameter IDEAS.Utilities.Time.Types.ZeroTime zerTim
          "Enumeration for choosing how reference time (time = 0) should be defined";
        parameter Integer yearRef(min=firstYear, max=lastYear) = 2016
          "Year when time = 0, used if zerTim=Custom"
          annotation(Dialog(enable=zerTim==IDEAS.Utilities.Time.Types.ZeroTime.Custom));
        parameter Modelica.SIunits.Time offset = 0
          "Offset that is added to 'time', may be used for computing time in different time zone"
          annotation(Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealOutput unixTimeStamp(final unit="s")
          "Unix time stamp at local time"
              annotation (Placement(transformation(extent={{100,-90},{120,-70}}),
              iconTransformation(extent={{100,-90},{120,-70}})));
        discrete Modelica.Blocks.Interfaces.IntegerOutput year(start=2010) "Year"
          annotation (Placement(transformation(extent={{100,-32},{120,-12}}),
              iconTransformation(extent={{100,-32},{120,-12}})));
        discrete Modelica.Blocks.Interfaces.IntegerOutput month(start=1) "Month of the year"
          annotation (Placement(transformation(extent={{100,-4},{120,16}}),
              iconTransformation(extent={{100,-4},{120,16}})));
        Modelica.Blocks.Interfaces.IntegerOutput day(fixed=false) "Day of the month"
          annotation (Placement(transformation(extent={{100,24},{120,44}}),
              iconTransformation(extent={{100,24},{120,44}})));
        Modelica.Blocks.Interfaces.IntegerOutput hour(fixed=false) "Hour of the day"
          annotation (Placement(transformation(extent={{100,52},{120,72}}),
              iconTransformation(extent={{100,52},{120,72}})));
        Modelica.Blocks.Interfaces.RealOutput minute "Minute of the hour"
          annotation (Placement(transformation(extent={{100,80},{120,100}}),
              iconTransformation(extent={{100,80},{120,100}})));
        Modelica.Blocks.Interfaces.IntegerOutput weekDay(fixed=false)
          "Integer output representing week day (monday = 1, sunday = 7)"
          annotation (Placement(transformation(extent={{100,-60},{120,-40}}),
              iconTransformation(extent={{100,-60},{120,-40}})));

    protected
        final constant Integer firstYear = 2010
          "First year that is supported, i.e. the first year in timeStampsNewYear[:]";
        final constant Integer lastYear = firstYear + size(timeStampsNewYear,1) - 1;
        constant Modelica.SIunits.Time timeStampsNewYear[12] = {
          1262304000.0, 1293840000.0, 1325376000.0,
          1356998400.0, 1388534400.0, 1420070400.0,
          1451606400.0, 1483228800.0, 1514764800.0,
          1546300800.0, 1577836800.0, 1609459200.0}
          "Epoch time stamps for new years day 2010 to 2021";
        constant Boolean isLeapYear[11] = {
          false, false, true, false,
          false, false, true, false,
          false, false, true}
          "List of leap years starting from firstYear (2010), up to and including 2020";
        final constant Integer dayInMonth[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
          "Number of days in each month";
        parameter Modelica.SIunits.Time timOff(fixed=false) "Time offset";
        // final parameters since the user may wrongly assume that this model shifts the
        // actual time of the simulation
        final constant Integer monthRef(min=1, max=12) = 1 "Month when time = 0"
          annotation(Dialog(enable=zerTim==IDEAS.Utilities.Time.Types.ZeroTime.Custom));
        final constant Integer dayRef(min=1, max=31) = 1 "Day when time = 0"
          annotation(Dialog(enable=zerTim==IDEAS.Utilities.Time.Types.ZeroTime.Custom));
        Integer daysSinceEpoch(fixed=false) "Number of days that passed since 1st of January 1970";
        discrete Integer yearIndex "Index of the current year in timeStampsNewYear";
        discrete Real epochLastMonth
          "Unix time stamp of the beginning of the current month";

        final parameter Modelica.SIunits.Time hourSampleStart(fixed=false)
          "Time when the sampling every hour starts";
        final parameter Modelica.SIunits.Time daySampleStart(fixed=false)
          "Time when the sampling every day starts";


        Boolean hourSampleTrigger "True, if hourly sample time instant";
        Boolean daySampleTrigger "True, if daily sample time instant";

        Boolean firstHourSampling(fixed=true, start=true)
          "=true if the hour is sampled the first time";
        Boolean firstDaySampling(fixed=true, start=true)
          "=true if the day is sampled the first time";
      initial equation
        hourSampleStart = integer(time/3600)*3600 - offset;
        daySampleStart  = integer(time/(3600*24))*3600*24 - offset;

        hour = integer(floor(rem(unixTimeStamp,3600*24)/3600));
        daysSinceEpoch = integer(floor(unixTimeStamp/3600/24));

        day = integer(1+floor((unixTimeStamp-epochLastMonth)/3600/24));
        weekDay = integer(rem(4+daysSinceEpoch-1,7)+1);
      initial algorithm
        // check if yearRef is in the valid range
        assert(not zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom
               or yearRef>=firstYear and yearRef<=lastYear,
          "The value you chose for yearRef (=" + String(yearRef) + ") is outside of
   the validity range of "       + String(firstYear) + " to " + String(lastYear) + ".");

        // check if the day number exists for the chosen month and year
        assert(not zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom
               or dayInMonth[monthRef] + (if monthRef==2 and isLeapYear[yearRef-firstYear + 1] then 1 else 0) >=dayRef,
          "The day number you chose is larger than the number of days contained by the month you chose.");

        // compute the offset to be added to time based on the parameters specified by the user
        if zerTim == IDEAS.Utilities.Time.Types.ZeroTime.UnixTimeStamp then
          timOff :=0;
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2010 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2010 then
            timOff :=timeStampsNewYear[1];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2011 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2011 then
            timOff :=timeStampsNewYear[2];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2012 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2012 then
            timOff :=timeStampsNewYear[3];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2013 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2013 then
            timOff :=timeStampsNewYear[4];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2014 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2014 then
            timOff :=timeStampsNewYear[5];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2015 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2015 then
            timOff :=timeStampsNewYear[6];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2016 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2016 then
            timOff :=timeStampsNewYear[7];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2017 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2017 then
            timOff :=timeStampsNewYear[8];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2018 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2018 then
            timOff :=timeStampsNewYear[9];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2019 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2019 then
            timOff :=timeStampsNewYear[10];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2020 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2020 then
            timOff :=timeStampsNewYear[11];
        else
          timOff :=0;
          // this code should not be reachable
          assert(false, "No valid ZeroTime could be identified.
   This is a bug, please submit a bug report.");
        end if;

        // add additional offset when using a custom date and time
        if zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom then
          timOff :=timOff + ((dayRef - 1) + sum({dayInMonth[i] for i in 1:(monthRef - 1)})
           + (if monthRef > 2 and isLeapYear[yearRef - firstYear + 1] then 1 else 0))*3600*24;
        end if;

         // input data range checks at initial time
        assert(time + offset + timOff >= timeStampsNewYear[1],
          if zerTim == IDEAS.Utilities.Time.Types.ZeroTime.UnixTimeStamp then
            "Could not initialize date in the CalendarTime block.
   You selected 1970 as the time=0 reference.
   Therefore the simulation startTime must be at least "       + String(timeStampsNewYear[1]) + "."
          elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom then
            if yearRef <firstYear then
              "Could not initialize date in the CalendarTime block.
   You selected a custom time=0 reference.
   The minimum value for yearRef is then "       + String(firstYear) + " but your value is " + String(yearRef) + "."
            else
              "Could not initialize date in the CalendarTime block.
   You selected a custom time=0 reference.
   Possibly your startTime is too small."
            else
              "Could not initialize date in the CalendarTime block.
   Possibly your startTime is negative?");

        assert(time + offset + timOff < timeStampsNewYear[size(timeStampsNewYear,1)],
          if zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef >= lastYear then
            "Could not initialize date in the CalendarTime block.
   You selected a custom time=0 reference.
   The maximum value for yearRef is then "       + String(lastYear) +
         " but your value is " + String(yearRef) + "."
          else
             "Could not initialize date in the CalendarTime block.
       Possibly your startTime is too large.");

        // iterate to find the year at initialization
      initial algorithm
        year :=0;
        for i in 1:size(timeStampsNewYear,1) loop
          // may be reformulated using break if JModelica fixes bug
          if unixTimeStamp < timeStampsNewYear[i]
            and (if i == 1 then true else unixTimeStamp >= timeStampsNewYear[i-1]) then
            yearIndex :=i - 1;
            year :=firstYear + i - 2;
          end if;
        end for;

        // iterate to find the month at initialization
        epochLastMonth := timeStampsNewYear[yearIndex];
        month:=13;
        for i in 1:12 loop
          if (unixTimeStamp-epochLastMonth)/3600/24 <
            (if i==2 and isLeapYear[yearIndex] then 1 + dayInMonth[i] else dayInMonth[i]) then
            // construction below avoids the need of a break, which bugs out JModelica
            month :=min(i,month);
          else
            epochLastMonth :=epochLastMonth + (if i == 2 and isLeapYear[yearIndex]
               then 1 + dayInMonth[i] else dayInMonth[i])*3600*24;
          end if;
        end for;

      equation
        // compute unix time step based on found offset
        unixTimeStamp = time + offset + timOff;

        // update the year when passing the epoch time stamp of the next year
        when unixTimeStamp >= timeStampsNewYear[pre(yearIndex)+1] then
          yearIndex=pre(yearIndex)+1;
          assert(yearIndex<=size(timeStampsNewYear,1),
            "Index out of range for epoch vector: timeStampsNewYear needs to be extended beyond the year "
              + String(firstYear+size(timeStampsNewYear,1)));
          year = pre(year) + 1;
        end when;

        // update the month when passing the last day of the current month
        when unixTimeStamp >= pre(epochLastMonth) +
            (if pre(month)==2 and isLeapYear[yearIndex]
              then 1 + dayInMonth[pre(month)] else dayInMonth[pre(month)])*3600*24 then
          month = if pre(month) == 12 then 1 else pre(month) + 1;
          epochLastMonth = pre(epochLastMonth) +
            (if pre(month)==2 and isLeapYear[yearIndex]
              then 1 + dayInMonth[pre(month)] else dayInMonth[pre(month)])*3600*24;
        end when;

        // compute other variables that can be computed without using when() statements
        hourSampleTrigger =sample(hourSampleStart, 3600);
        when hourSampleTrigger then
          if pre(firstHourSampling) then
            hour = integer(floor(rem(unixTimeStamp,3600*24)/3600));
          else
            hour = if (pre(hour) == 23) then 0 else (pre(hour) + 1);
          end if;
          firstHourSampling = false;
        end when;

        daySampleTrigger =sample(daySampleStart, 86400);
        when daySampleTrigger then
          if pre(firstDaySampling) then
            daysSinceEpoch = integer(floor(unixTimeStamp/3600/24));
            weekDay=integer(rem(4+daysSinceEpoch-1,7)+1);

          else
            daysSinceEpoch = pre(daysSinceEpoch) + 1;
            weekDay = if (pre(weekDay) == 7) then 1 else (pre(weekDay) + 1);
          end if;
          day = integer(1+floor((unixTimeStamp-epochLastMonth)/3600/24));

          firstDaySampling = false;
        end when;

        // using Real variables and operations for minutes since otherwise too many events are generated
        minute = (unixTimeStamp/60-daysSinceEpoch*60*24-hour*60);

        annotation (
          defaultComponentName="calTim",
        Documentation(revisions="<html>
<ul>
<li>
February 14, 2019, by Damien Picard:<br/>
Fix bug when non-zero offset by substracting the offset from hourSampleStart and daySampleStart
(see <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1099\">#1099</a>).
</li>
<li>
August 3, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",       info="<html>
<p>
This blocks computes the unix time stamp, date and time
and the day of the week based on the Modelica
variable <code>time</code>.
</p>
<h4>Main equations</h4>
<p>
First the unix time stamp corresponding to the current time is computed.
From this variables the corresponding, year, date and time are computed using functions
such as <code>floor()</code> and <code>ceil()</code>.
</p>
<h4>Assumption and limitations</h4>
<p>
The implementation only supports date computations from year 2010 up to and including 2020.
Daylight saving and time zones are not supported.
</p>
<h4>Typical use and important parameters</h4>
<p>
The user must define which time and date correspond to <code>time = 0</code>
using the model parameters <code>zerTim</code>, and, if
<code>zerTim==IDEAS.Utilities.Time.Types.ZeroTime.Custom</code>,
the parameter <code>yearRef</code>.

The user can choose from new year, midnight for a number of years:
2010 to 2020 and also 1970.
The latter corresponds to a unix stamp of <i>0</i>.
(Note that when choosing the reference time equal to 0 at 1970,
the actual simulation time must be within the 2010-2020 range.
For instance <code>startTime = 1262304000</code> corresponds
to the simulation starting on the 1st of January 2010
when setting <code>zerTim = ZeroTime.UnixTimeStamp</code>.
This is within the 2010-2020 range and is therefore allowed.)
</p>
<h4>Implementation</h4>
<p>
The model was implemented such that no events are being generated for computing the minute of the day.
The model also contains an implementation for setting <code>time=0</code>
for any day and month other than January first.
This is however not activated in the current model since these options may wrongly give the impression
that it changes the time based on which the solar position is computed and TMY3 data are read.
</p>
</html>"),Icon(graphics={
              Text(
                extent={{-34,90},{96,80}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Minute"),
              Text(
                extent={{-28,66},{96,56}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Hour"),
              Text(
                extent={{-38,40},{96,28}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Day"),
              Text(
                extent={{-50,12},{96,2}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Month"),
              Text(
                extent={{-70,-16},{96,-26}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Year"),
              Text(
                extent={{-68,-40},{96,-52}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Weekday"),
              Text(
                extent={{-102,-72},{94,-84}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Unix timestamp"),
              Ellipse(
                extent={{-94,94},{16,-16}},
                lineColor={160,160,164},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-40,38},{-64,62}},
                thickness=0.5),
              Line(
                points={{-40,38},{-14,38}},
                thickness=0.5)}));
      end CalendarTime;

      block ModelTime "Model time"
        extends Modelica.Blocks.Interfaces.SO;
      equation
        y = time;
        annotation (
          defaultComponentName="modTim",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Line(points={{0,80},{0,60}}, color={160,160,164}),
              Line(points={{80,0},{60,0}}, color={160,160,164}),
              Line(points={{0,-80},{0,-60}}, color={160,160,164}),
              Line(points={{-80,0},{-60,0}}, color={160,160,164}),
              Line(points={{37,70},{26,50}}, color={160,160,164}),
              Line(points={{70,38},{49,26}}, color={160,160,164}),
              Line(points={{71,-37},{52,-27}}, color={160,160,164}),
              Line(points={{39,-70},{29,-51}}, color={160,160,164}),
              Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
              Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
              Line(points={{-71,37},{-54,28}}, color={160,160,164}),
              Line(points={{-38,70},{-28,51}}, color={160,160,164}),
              Line(
                points={{0,0},{-50,50}},
                thickness=0.5),
              Line(
                points={{0,0},{40,0}},
                thickness=0.5)}),
          Documentation(info="<html>
<p>This component outputs the model time, which starts at the value at which the simulation starts. For example, if a simulation starts at <i>t=-1</i>, then this block outputs first <i>t=-1</i>, and its output is advanced at the same rate as the simulation time. </p>
<p>The model is used to allow the simulation to start from any time without having to set the parameters for the clock, as would be necessary for the model <a href=\"modelica://Modelica.Blocks.Sources.Clock\">Modelica.Blocks.Sources.Clock</a>. </p>
</html>",       revisions="<html>
<ul>
<li>
January 16, 2015, by Michael Wetter:<br/>
Moved block from
<code>IDEAS.Utilities.SimulationTime</code>
to
<code>IDEAS.Utilities.Time.ModelTime</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ModelTime;

      package Types "Package with type definitions"
       extends Modelica.Icons.TypesPackage;

        type ZeroTime = enumeration(
          UnixTimeStamp   "Thu, 01 Jan 1970 00:00:00 local time",
          Custom   "User specified local time",
          NY2010   "New year 2010, 00:00:00 local time",
          NY2011   "New year 2011, 00:00:00 local time",
          NY2012   "New year 2012, 00:00:00 local time",
          NY2013   "New year 2013, 00:00:00 local time",
          NY2014   "New year 2014, 00:00:00 local time",
          NY2015   "New year 2015, 00:00:00 local time",
          NY2016   "New year 2016, 00:00:00 local time",
          NY2017   "New year 2017, 00:00:00 local time",
          NY2018   "New year 2018, 00:00:00 local time",
          NY2019   "New year 2019, 00:00:00 local time",
          NY2020   "New year 2020, 00:00:00 local time")
          "Use this to set the date corresponding to time = 0"
          annotation (Documentation(info="<html>
<p>
Type for choosing how to set the reference time in
<a href=\"modelica://IDEAS.Utilities.Time.CalendarTime\">
IDEAS.Utilities.Time.CalendarTime</a>.
</p>
<p>
For example, <code>IDEAS.Utilities.Time.Types.TimeReference.NY2016</code>
means that if the Modelica built-in variable <code>time=0</code>, it is
January 1, 2016, 0:00:00 local time.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 10, 2016, by Michael Wetter:<br/>
Revised implementation and moved to new package
<a href=\"modelica://IDEAS.Utilities.Time.CalendarTime.Types\">
IDEAS.Utilities.Time.CalendarTime.Types</a>.
</li>
<li>
August 3, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
      annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
      end Types;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models for time.
</p>
</html>"),
      Icon(graphics={
            Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Line(points={{0,80},{0,60}}, color={160,160,164}),
            Line(points={{80,0},{60,0}}, color={160,160,164}),
            Line(points={{0,-80},{0,-60}}, color={160,160,164}),
            Line(points={{-80,0},{-60,0}}, color={160,160,164}),
            Line(points={{37,70},{26,50}}, color={160,160,164}),
            Line(points={{70,38},{49,26}}, color={160,160,164}),
            Line(points={{71,-37},{52,-27}}, color={160,160,164}),
            Line(points={{39,-70},{29,-51}}, color={160,160,164}),
            Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
            Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
            Line(points={{-71,37},{-54,28}}, color={160,160,164}),
            Line(points={{-38,70},{-28,51}}, color={160,160,164}),
            Line(
              points={{0,0},{-50,50}},
              thickness=0.5),
            Line(
              points={{0,0},{40,0}},
              thickness=0.5)}));
    end Time;
  annotation (
  preferredView="info", Documentation(info="<html>
<p>
This package contains utility models such as for thermal comfort calculation, input/output, co-simulation, psychrometric calculations and various functions that are used throughout the library.
</p>
</html>"),
  Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
  end Utilities;
annotation (
  uses(Modelica(version="3.2.3")),
  Icon(graphics),
  version="2.1.0",
  versionDate="2019-02-28",
  dateModified = "2019-02-28",
  conversion(
 from(version={"0.2"},
      script="modelica://IDEAS/Resources/Scripts/convertIdeas030to100.mos")),
  Documentation(info="<html>
<p>Licensed by KU Leuven and 3E</p>
<p>Copyright &copy; 2013-2023, KU Leuven and 3E. </p>
<p>
This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>;
For license information, view our <a href=\"https://github.com/open-ideas/IDEAS\">github page</a>.
</p>
</html>"));
end IDEAS;

package TheSysConExe "Thermal systems control exercise"

  package BaseClases "Base clases for thermal systems exercise"
    extends Modelica.Icons.BasesPackage;

    model Occupancy "Occupancy schedule"
      extends IDEAS.Buildings.Components.Occupants.BaseClasses.PartialOccupants(final useInput=false);

      parameter Modelica.SIunits.Temperature setHeaOcc=21+273.15
          "Heating setpoint when occupied";
      parameter Modelica.SIunits.Temperature setHeaUno=18+273.15
          "Heating setpoint when unoccupied";

      parameter Modelica.SIunits.Temperature setCooOcc=23+273.15
          "Cooling setpoint when occupied";
      parameter Modelica.SIunits.Temperature setCooUno=26+273.15
          "Cooling setpoint when unoccupied";

      parameter Real k "Number of occupants per zone";
      IDEAS.Utilities.Time.CalendarTime calTim(zerTim=IDEAS.Utilities.Time.Types.ZeroTime.NY2019)
        annotation (Placement(transformation(extent={{-20,20},{0,40}})));
      Modelica.Blocks.Sources.RealExpression occ(y=if calTim.weekDay < 6 and (
            calTim.hour > 7 and calTim.hour < 18) then k else 0)
        "Number of occupants present"
        annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
      Modelica.Blocks.Logical.Switch switch1
        annotation (Placement(transformation(extent={{72,54},{84,66}})));
      Modelica.Blocks.Sources.Constant setHeaOccCnt(k=setHeaOcc)
        "Heating setpoint when occupied"
        annotation (Placement(transformation(extent={{48,-70},{56,-62}})));
      Modelica.Blocks.Sources.Constant setHeaUnoCnt(k=setHeaUno)
        "Heating setpoint when unoccupied"
        annotation (Placement(transformation(extent={{48,-96},{56,-88}})));
      Modelica.Blocks.Logical.Switch switch2
        annotation (Placement(transformation(extent={{72,-86},{84,-74}})));
      Modelica.Blocks.Sources.Constant setCooOccCnt(k=setCooOcc)
        "Cooling setpoint when occupied"
        annotation (Placement(transformation(extent={{46,68},{54,76}})));
      Modelica.Blocks.Sources.Constant setCooUnoCnt(k=setCooUno)
        "Cooling setpoint when unoccupied"
        annotation (Placement(transformation(extent={{46,44},{54,52}})));
      Modelica.Blocks.Interfaces.RealOutput setHea(
        final quantity="ThermodynamicTemperature",
        final unit="K",
        displayUnit="degC") "Heating setpoint"
        annotation (Placement(transformation(extent={{100,-100},{140,-60}}),
            iconTransformation(extent={{100,-80},{140,-40}})));
      Modelica.Blocks.Interfaces.RealOutput setCoo(
        final quantity="ThermodynamicTemperature",
        final unit="K",
        displayUnit="degC") "Cooling setpoint"
        annotation (Placement(transformation(extent={{100,40},{140,80}}),
            iconTransformation(extent={{100,40},{140,80}})));
      Modelica.Blocks.Logical.GreaterThreshold greaterThreshold
        annotation (Placement(transformation(extent={{-60,-90},{-40,-70}})));
    equation
      connect(occ.y, nOcc)
        annotation (Line(points={{1,0},{120,0}}, color={0,0,127}));
      connect(setCooOccCnt.y, switch1.u1) annotation (Line(points={{54.4,72},{62,72},
              {62,64.8},{70.8,64.8}}, color={0,0,127}));
      connect(setCooUnoCnt.y, switch1.u3) annotation (Line(points={{54.4,48},{62,48},
              {62,55.2},{70.8,55.2}}, color={0,0,127}));
      connect(setHeaUnoCnt.y, switch2.u3) annotation (Line(points={{56.4,-92},{64,-92},
              {64,-84.8},{70.8,-84.8}}, color={0,0,127}));
      connect(setHeaOccCnt.y, switch2.u1) annotation (Line(points={{56.4,-66},{64,-66},
              {64,-75.2},{70.8,-75.2}}, color={0,0,127}));
      connect(occ.y, greaterThreshold.u) annotation (Line(points={{1,0},{20,0},
              {20,-20},{-80,-20},{-80,-80},{-62,-80}}, color={0,0,127}));
      connect(greaterThreshold.y, switch1.u2) annotation (Line(points={{-39,-80},
              {28,-80},{28,60},{70.8,60}}, color={255,0,255}));
      connect(greaterThreshold.y, switch2.u2)
        annotation (Line(points={{-39,-80},{70.8,-80}}, color={255,0,255}));
      connect(switch1.y,setCoo)
        annotation (Line(points={{84.6,60},{120,60}}, color={0,0,127}));
      connect(switch2.y,setHea)
        annotation (Line(points={{84.6,-80},{120,-80}}, color={0,0,127}));
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Rectangle(
              extent={{-94,34},{-26,40}},
              fillColor={255,0,0},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Rectangle(
              extent={{-30,34},{-24,90}},
              fillColor={255,0,0},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Rectangle(
              extent={{-30,84},{32,90}},
              fillColor={255,0,0},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Rectangle(
              extent={{32,34},{38,90}},
              fillColor={255,0,0},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Rectangle(
              extent={{32,34},{76,40}},
              fillColor={255,0,0},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Rectangle(
              extent={{-94,-34},{-24,-28}},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-30,-34},{-24,22}},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-30,16},{32,22}},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{32,-34},{38,22}},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Rectangle(
              extent={{34,-34},{76,-28}},
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None,
              lineColor={0,0,0})}),                                  Diagram(
            coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                100,100}})));
    end Occupancy;

    model BuildingEnvelope "Building envelope with 2 coupled zones"
      extends Modelica.Icons.Example;
      replaceable package Medium = IDEAS.Media.Air "Air medium";

      parameter Modelica.SIunits.Length l = 8 "Zone length";
      parameter Modelica.SIunits.Length w = 4 "Zone width";
      parameter Modelica.SIunits.Length h = 2.7 "Zone height";

      inner IDEAS.BoundaryConditions.SimInfoManager sim
        annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
      IDEAS.Buildings.Components.RectangularZoneTemplate zonNor(
        redeclare package Medium = Medium,
        aziA=IDEAS.Types.Azimuth.N,
        h=h,
        bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
        bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
        bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyWall conTypA,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyWall conTypB,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyWall conTypC,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyWall conTypD,
        bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
        bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
        bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
        l=w,
        w=l/2,
        hasWinA=true,
        A_winA=2*1.3,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.LightRoof conTypCei,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
          conTypFlo,
        redeclare IDEAS.Examples.TwinHouses.BaseClasses.Data.Materials.Glazing
          glazingA)  "North part of the zone"
        annotation (Placement(transformation(extent={{-10,20},{10,40}})));

      IDEAS.Buildings.Components.RectangularZoneTemplate zonSou(
        redeclare package Medium = Medium,
        aziA=IDEAS.Types.Azimuth.N,
        h=h,
        bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
        bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
        bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
        bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
        bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyWall conTypB,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyWall conTypC,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyWall conTypD,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.LightRoof conTypCei,
        redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
          conTypFlo,
        bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
        l=w,
        w=l/2,
        hasWinC=true,
        A_winC=2*1.3,
        redeclare IDEAS.Examples.TwinHouses.BaseClasses.Data.Materials.Glazing
          glazingC) "South part of the zone"
        annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));

    equation
      connect(zonSou.proBusA, zonNor.proBusC) annotation (Line(
          points={{-6,-21},{-6,2},{6.8,2},{6.8,20.2}},
          color={255,204,51},
          thickness=0.5));
      annotation (Documentation(revisions="<html>
<ul>
<li>
September 18, 2019 by Filip Jorissen:<br/>
First implementation for the IDEAS crash course.
</li>
</ul>
</html>",     info="<html>
<p>
This example demonstrates the use of the RectangularZoneTemplate.
The one-zone implementation with one window of example 1 is repeated here as 
a two-zone implementation with two windows that are north and south oriented.
Note the different temperature responses of the zones. 
</p>
</html>"),     experiment(
          StartTime=10000000,
          StopTime=11000000,
          __Dymola_NumberOfIntervals=5000,
          Tolerance=1e-06,
          __Dymola_Algorithm="Lsodar"));
    end BuildingEnvelope;
  end BaseClases;

  package GEOTABS

    package Exercises

      model GEOTABS
        extends TheSysConExe.GEOTABS.BaseClasses.Envelope;
        package MediumWater = IDEAS.Media.Water "Water media";
        parameter Real valLea = 1e-10 "valve leakage";
        IDEAS.Fluid.Movers.FlowControlled_dp pumEmi(
        massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        addPowerToMedium=false,
        use_inputFilter=true,
        riseTime=120,
        dp_nominal=20000,
        inputType=IDEAS.Fluid.Types.InputType.Continuous,
        m_flow_nominal=max(mFlowEmiCoo.k, mFlowEmiHea.k),
        redeclare package Medium = MediumWater,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
          "Circulation pump for emission system"
          annotation (Placement(transformation(extent={{126,50},{106,70}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort senTemSup(
        redeclare package Medium = MediumWater,
        m_flow_nominal=pumEmi.m_flow_nominal,
        tau=300) "Supply water temperature sensor"
          annotation (Placement(transformation(extent={{150,70},{130,50}})));
        IDEAS.Fluid.Sources.Boundary_pT bou(redeclare package Medium =
            MediumWater,
          nPorts=1)        "Expansion vessel" annotation (Placement(
              transformation(
              extent={{10,10},{-10,-10}},
              rotation=270,
              origin={128,20})));
        IDEAS.Fluid.FixedResistances.Junction jun1(
        redeclare package Medium = MediumWater,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        m_flow_nominal={embNor.m_flow_nominal,-embNor.m_flow_nominal - embSou.m_flow_nominal,
            -embSou.m_flow_nominal},
        portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
        portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
        dp_nominal={0,0,0})       "Junction"
          annotation (Placement(transformation(extent={{80,-40},{100,-60}})));
        IDEAS.Fluid.HeatExchangers.RadiantSlab.EmbeddedPipe embNor(
        redeclare package Medium = MediumWater,
        redeclare IDEAS.Fluid.HeatExchangers.RadiantSlab.BaseClasses.FH_Standard1
          RadSlaCha,
        allowFlowReversal=true,
        m_flow_nominal=pumEmi.m_flow_nominal/2,
        computeFlowResistance=false,
          dp_nominal=0,
        A_floor=zonNor.AZone)   "Embedded pipe of floor heating in north zone"
          annotation (Placement(transformation(extent={{40,-10},{60,10}})));
        IDEAS.Fluid.HeatExchangers.RadiantSlab.EmbeddedPipe embSou(
        redeclare package Medium = MediumWater,
        redeclare IDEAS.Fluid.HeatExchangers.RadiantSlab.BaseClasses.FH_Standard1
          RadSlaCha,
        allowFlowReversal=true,
        m_flow_nominal=pumEmi.m_flow_nominal/2,
        computeFlowResistance=false,
          dp_nominal=0,
        A_floor=zonNor.AZone)   "Embedded pipe of floor heating in south zone"
          annotation (Placement(transformation(extent={{80,-10},{100,10}})));
        IDEAS.Fluid.FixedResistances.Junction jun(
        redeclare package Medium = MediumWater,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        from_dp=false,
        m_flow_nominal={embNor.m_flow_nominal + embSou.m_flow_nominal,-embNor.m_flow_nominal,
            -embSou.m_flow_nominal},
        portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
        portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        dp_nominal={0,0,0})      "Junction"
          annotation (Placement(transformation(extent={{100,50},{80,70}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort senTemRet(
        redeclare package Medium = MediumWater,
        m_flow_nominal=pumEmi.m_flow_nominal,
        tau=0)   "Return water temperature sensor"
          annotation (Placement(transformation(extent={{130,-40},{110,-60}})));
        IDEAS.Fluid.HeatPumps.ScrollWaterToWater heaPum(
        m2_flow_nominal=pumSou.m_flow_nominal,
        enable_variable_speed=false,
        m1_flow_nominal=pumSin.m_flow_nominal,
        redeclare package Medium1 = MediumWater,
        redeclare package Medium2 = MediumWater,
        TEvaMin=273.15,
        datHeaPum=
            IDEAS.Fluid.HeatPumps.Data.ScrollWaterToWater.Heating.ClimateMaster_TMW036_12kW_4_90COP_R410A(),
        scaling_factor=1,
          dp1_nominal=0,
          dp2_nominal=0)
          "Heat pump model, rescaled for low thermal powers" annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={246,-8})));

        IDEAS.Fluid.Sources.Boundary_pT
                                  bou1(redeclare package Medium = MediumWater,
          nPorts=1) "Cold water source for heat pump"
                    annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={326,-8})));
        IDEAS.Fluid.Movers.FlowControlled_m_flow
                                             pumSou(
        massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        inputType=IDEAS.Fluid.Types.InputType.Continuous,
        addPowerToMedium=false,
        use_inputFilter=false,
        dp_nominal=heaPum.dp2_nominal,
        m_flow_nominal=max(mFlowSouCoo.k, mFlowSouHea.k),
        redeclare package Medium = MediumWater,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
          "Circulation pump at source side"
          annotation (Placement(transformation(extent={{302,32},{282,52}})));
        IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent
                                               valNor(
        m_flow_nominal=pumEmi.m_flow_nominal/2,
        dpValve_nominal=pumEmi.dp_nominal,
        redeclare package Medium = MediumWater,
        use_inputFilter=false,
        l=valLea)     "Thermostatic valve for north zone"
                                              annotation (Placement(
              transformation(
              extent={{10,-10},{-10,10}},
              rotation=90,
              origin={50,30})));
        IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent valSou(
        dpValve_nominal=pumEmi.dp_nominal,
        m_flow_nominal=pumEmi.m_flow_nominal/2,
        redeclare package Medium = MediumWater,
        use_inputFilter=false,
        from_dp=true,
        l=valLea) "Thermostatic valve for south zone" annotation (Placement(
            transformation(
            extent={{10,-10},{-10,10}},
            rotation=90,
            origin={90,30})));
        IDEAS.Fluid.Storage.Stratified tan(
        redeclare package Medium = MediumWater,
        m_flow_nominal=pumEmi.m_flow_nominal,
        VTan=vBufTan.k,
        hTan=2,
        dIns=0.1)   "Buffer tank for avoiding excessive heat pump on/off switches"
          annotation (Placement(transformation(extent={{200,-10},{180,10}})));
        IDEAS.Fluid.Movers.FlowControlled_m_flow
                                             pumSin(
        massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        addPowerToMedium=false,
        use_inputFilter=false,
        dp_nominal=heaPum.dp1_nominal,
        inputType=IDEAS.Fluid.Types.InputType.Stages,
        m_flow_nominal=mFlowSin.k,
        redeclare package Medium = MediumWater,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
          "Circulation pump at sink side"
          annotation (Placement(transformation(extent={{236,50},{216,70}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor senTan
          "Temperature sensor of tank volume"
          annotation (Placement(transformation(extent={{200,-28},{220,-8}})));
      IDEAS.Fluid.Geothermal.Borefields.OneUTube borFie(
        redeclare package Medium = MediumWater,
        borFieDat=borFieDat,
        dT_dz=0)
        annotation (Placement(transformation(extent={{280,-52},{300,-32}})));

        IDEAS.Utilities.Math.MovingAverage movingAverage6h(period=6*3600)
          annotation (Placement(transformation(extent={{-64,-86},{-44,-66}})));
        Modelica.Blocks.Sources.RealExpression outTem(y=sim.Te)
          annotation (Placement(transformation(extent={{-94,-86},{-74,-66}})));
        Modelica.Blocks.Tables.CombiTable1D heaCur(table=[273.15 - 8,273.15 + 28;
            273.15 + 0,273.15 + 25; 273.15 + 5,273.15 + 23.5; 273.15 + 15,273.15 +
            20.5; 273.15 + 16,273.15 + 20.5])
        "heating curve"
          annotation (Placement(transformation(extent={{-36,-86},{-16,-66}})));
        IDEAS.Controls.Continuous.LimPID conPIhea(
        controllerType=Modelica.Blocks.Types.SimpleController.PI,
        k=1,
        Ti(displayUnit="s") = 30)
        annotation (Placement(transformation(extent={{-8,-86},{12,-66}})));
        Modelica.Blocks.Sources.Constant TemTan(k=30 + 273.15)
          "Buffer tank reference"
          annotation (Placement(transformation(extent={{36,156},{56,176}})));
        Modelica.Blocks.Math.BooleanToInteger booToInt
          "Convert boolean signal into integer "
          annotation (Placement(transformation(extent={{108,150},{128,170}})));
      parameter IDEAS.Fluid.Geothermal.Borefields.Data.Borefield.Example borFieDat(
        filDat=IDEAS.Fluid.Geothermal.Borefields.Data.Filling.Bentonite(kFil=1.5),
        soiDat=IDEAS.Fluid.Geothermal.Borefields.Data.Soil.SandStone(kSoi=1.8),
          conDat=IDEAS.Fluid.Geothermal.Borefields.Data.Configuration.Example(
              use_Rb=true,
              Rb=0.144,
              mBor_flow_nominal=0.1,
              dp_nominal=0,
              hBor=hBor.k,
              dBor=0,
              cooBor=[0,0; 0,6; 0,12; 0,18; 6,0; 6,6; 6,12; 6,18; 12,0; 12,6; 12,12; 12,
                18]))
        annotation (Placement(transformation(extent={{-96,126},{-76,146}})));
        Modelica.Blocks.Sources.RealExpression valNorCon(y=zonNor.slaOnGro.layMul.monLay[
              3].monLayDyn.T[2])
        annotation (Placement(transformation(extent={{-100,-54},{-80,-34}})));
        Modelica.Blocks.Sources.RealExpression valSouCon(y=zonSou.slaOnGro.layMul.monLay[
            3].monLayDyn.T[2])
        annotation (Placement(transformation(extent={{-100,-6},{-80,14}})));
        IDEAS.Fluid.Actuators.Valves.Simplified.ThreeWayValveMotor
                                                    threeWayValveMotor(
          tau=300,
        l=valLea,
        m_flow_nominal=pumEmi.m_flow_nominal,
        redeclare package Medium = MediumWater)
                               "3-way mixing valve" annotation (Placement(
            transformation(
            extent={{10,-10},{-10,10}},
            rotation=0,
            origin={190,60})));
        IDEAS.Fluid.FixedResistances.Junction jun2(
        redeclare package Medium = MediumWater,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        m_flow_nominal={embNor.m_flow_nominal + embSou.m_flow_nominal,-(embNor.m_flow_nominal
             + embSou.m_flow_nominal),-(embNor.m_flow_nominal + embSou.m_flow_nominal)},
        portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
        portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        dp_nominal={0,0,0})       "Junction"
          annotation (Placement(transformation(extent={{158,-40},{178,-60}})));
      IDEAS.Controls.ControlHeating.RunningMeanTemperatureEN15251 rmot
        annotation (Placement(transformation(extent={{-96,156},{-76,176}})));
      IDEAS.Fluid.Actuators.Valves.Simplified.ThreeWayValveSwitch
        threeWayValveSwitch(
        redeclare package Medium = MediumWater,
        tau=300,
        l=valLea,
        m_flow_nominal=pumSou.m_flow_nominal)
        annotation (Placement(transformation(extent={{256,52},{276,32}})));
        IDEAS.Fluid.FixedResistances.Junction jun3(
        redeclare package Medium = MediumWater,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        from_dp=false,
        m_flow_nominal={embNor.m_flow_nominal,-embNor.m_flow_nominal - embSou.m_flow_nominal,
            -embSou.m_flow_nominal},
        portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
        portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
        dp_nominal={0,0,0})       "Junction"
          annotation (Placement(transformation(extent={{258,-50},{274,-34}})));
      IDEAS.Fluid.HeatExchangers.ConstantEffectiveness hex(
        redeclare package Medium1 = MediumWater,
        redeclare package Medium2 = MediumWater,
        m1_flow_nominal=pumEmi.m_flow_nominal,
        m2_flow_nominal=pumSou.m_flow_nominal,
        from_dp1=true,
          dp1_nominal=0,
        from_dp2=true,
          dp2_nominal=0)
        annotation (Placement(transformation(extent={{302,88},{282,108}})));
        Modelica.Blocks.Sources.BooleanExpression cooMode(y=mode.y)
        annotation (Placement(transformation(extent={{-94,-106},{-74,-86}})));
      IDEAS.Fluid.Actuators.Valves.Simplified.ThreeWayValveSwitch
        threeWayValveSwitch1(
        redeclare package Medium = MediumWater,
        tau=300,
        l=valLea,
        m_flow_nominal=pumEmi.m_flow_nominal)
        annotation (Placement(transformation(extent={{176,70},{156,50}})));
        IDEAS.Fluid.FixedResistances.Junction jun4(
        redeclare package Medium = MediumWater,
        energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
        m_flow_nominal={embNor.m_flow_nominal + embSou.m_flow_nominal,-(embNor.m_flow_nominal
             + embSou.m_flow_nominal),-(embNor.m_flow_nominal + embSou.m_flow_nominal)},
        portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
        portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
        dp_nominal={0,0,0})       "Junction"
          annotation (Placement(transformation(extent={{136,-40},{156,-60}})));
        Modelica.Blocks.Sources.RealExpression dpEmi(y=if cooMode.y then 20000
             elseif heaMode.y then 20000*(mFlowEmiHea.y/mFlowEmiCoo.y)^2 else 20000)
        annotation (Placement(transformation(extent={{-94,-140},{-74,-120}})));
        Modelica.Blocks.Sources.RealExpression mFlowSouCon(y=if cooMode.y then
            conPIcoo.y*mFlowSouCoo.y elseif heaMode.y then mFlowSouHea.y else 0)
        annotation (Placement(transformation(extent={{-20,-140},{0,-120}})));
      Modelica.Blocks.Sources.RealExpression valMixCon(y=if cooMode.y then 1
             elseif heaMode.y then conPIhea.y else 0)
        annotation (Placement(transformation(extent={{-56,-140},{-36,-120}})));
        Modelica.Blocks.Tables.CombiTable1D cooCur(table=[273.15 + 15,273.15 +
            21; 273.15 + 16,273.15 + 21; 273.15 + 20,273.15 + 20; 273.15 + 24,
            273.15 + 19; 273.15 + 30,273.15 + 18])
                                            "heating curve"
        annotation (Placement(transformation(extent={{-36,-112},{-16,-92}})));
        IDEAS.Controls.Continuous.LimPID conPIcoo(
        controllerType=Modelica.Blocks.Types.SimpleController.PI,
        k=1,
        Ti(displayUnit="s") = 30,
        reverseAction=true)
        annotation (Placement(transformation(extent={{-8,-112},{12,-92}})));
        Modelica.Blocks.Sources.RealExpression QBorFie(y=borFie.groTemRes.QBor_flow)
        annotation (Placement(transformation(extent={{350,148},{370,168}})));
        Modelica.Blocks.Continuous.Integrator ene(k=1/3600000)
          "Electrical energy meter with conversion to kWh"
          annotation (Placement(transformation(extent={{382,148},{402,168}})));
        Modelica.Blocks.Sources.Constant mFlowSin(k=0.6)
        "nominal mass flow in the sink pump"
          annotation (Placement(transformation(extent={{-8,156},{12,176}})));
        Modelica.Blocks.Sources.Constant mFlowSouHea(k=0.8)
        "nominal mass flow on the source pump in heating mode"
          annotation (Placement(transformation(extent={{-68,156},{-48,176}})));
        Modelica.Blocks.Sources.Constant mFlowEmiHea(k=1)
          "nominal mass flow in the emission side in heating mode"
          annotation (Placement(transformation(extent={{-68,124},{-48,144}})));
        Modelica.Blocks.Sources.Constant mFlowSouCoo(k=2)
        "nominal mass flow in the source side in cooling mode"
          annotation (Placement(transformation(extent={{-38,156},{-18,176}})));
        Modelica.Blocks.Sources.Constant mFlowEmiCoo(k=2)
        "nominal mass flow in the emission side in cooling mode"
          annotation (Placement(transformation(extent={{-38,124},{-18,144}})));
        Modelica.Blocks.Sources.Constant vBufTan(k=0.5)         "buffer tank volume"
          annotation (Placement(transformation(extent={{-8,124},{12,144}})));
        Modelica.Blocks.Sources.BooleanExpression heaMode(y=not mode.y)
        annotation (Placement(transformation(extent={{-94,-120},{-74,-100}})));
        Modelica.Blocks.Sources.Constant hBor(k=91.8) "borefield height per borehole"
          annotation (Placement(transformation(extent={{-68,92},{-48,112}})));
        IDEAS.Controls.Continuous.LimPID conPIvalNorHea(
        controllerType=Modelica.Blocks.Types.SimpleController.PI,
        k=1,
        Ti(displayUnit="s") = 30,
        yMin=0.01)
        annotation (Placement(transformation(extent={{-68,-28},{-48,-8}})));
        Modelica.Blocks.Sources.Constant conSP(k=273.15 + 22) "concrete setpoint"
          annotation (Placement(transformation(extent={{-100,-28},{-80,-8}})));
        IDEAS.Controls.Continuous.LimPID conPIvalSouHea(
        controllerType=Modelica.Blocks.Types.SimpleController.PI,
        k=1,
        Ti(displayUnit="s") = 30,
        yMin=0.01)
        annotation (Placement(transformation(extent={{-68,10},{-48,30}})));
      IDEAS.Utilities.Math.Average conAvg(nin=2) "concrete average temperature"
        annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
        IDEAS.Controls.Continuous.LimPID conPIvalSouCoo(
        controllerType=Modelica.Blocks.Types.SimpleController.PI,
        k=1,
        Ti(displayUnit="s") = 30,
        yMin=0.01,
        reverseAction=true)
        annotation (Placement(transformation(extent={{-36,10},{-16,30}})));
        IDEAS.Controls.Continuous.LimPID conPIvalNorCoo(
        controllerType=Modelica.Blocks.Types.SimpleController.PI,
        k=1,
        Ti(displayUnit="s") = 30,
        yMin=0.01,
        reverseAction=true)
        annotation (Placement(transformation(extent={{-36,-28},{-16,-8}})));
        Modelica.Blocks.Sources.RealExpression yValSou(y=if heaMode.y then
            conPIvalSouHea.y elseif cooMode.y then conPIvalSouCoo.y else 0.2)
        annotation (Placement(transformation(extent={{48,64},{68,84}})));
        Modelica.Blocks.Sources.RealExpression yValNor(y=if heaMode.y then
            conPIvalNorHea.y elseif cooMode.y then conPIvalNorCoo.y else 0.2)
        annotation (Placement(transformation(extent={{12,46},{32,66}})));
      Modelica.Blocks.Logical.Hysteresis mode(uLow=273.15 + 22 - 0.5, uHigh=
            273.15 + 22 + 1)
        annotation (Placement(transformation(extent={{64,-122},{84,-102}})));
    protected
        Modelica.Blocks.Logical.OnOffController onOffCon(bandwidth=4)
        "On off controller for switching on and off the pump of the production system"
          annotation (Placement(transformation(extent={{74,148},{94,168}})));
      equation
        connect(senTemSup.port_b,pumEmi. port_a)
          annotation (Line(points={{130,60},{126,60}}, color={0,127,255}));
        connect(embNor.port_b,jun1. port_1) annotation (Line(points={{60,0},{66,0},{66,
                -50},{80,-50}}, color={0,127,255}));
        connect(embSou.port_b,jun1. port_3) annotation (Line(points={{100,0},{104,0},{
                104,-20},{90,-20},{90,-40}}, color={0,127,255}));
        connect(zonSou.gainEmb[1],embSou. heatPortEmb[1]) annotation (Line(points={{
                10,-39},{74,-39},{74,10},{90,10}}, color={191,0,0}));
        connect(zonNor.gainEmb[1],embNor. heatPortEmb[1]) annotation (Line(points={{
                10,21},{28,21},{28,10},{50,10}}, color={191,0,0}));
        connect(pumEmi.port_b,jun. port_1)
          annotation (Line(points={{106,60},{100,60}}, color={0,127,255}));
        connect(bou.ports[1],pumEmi. port_a)
          annotation (Line(points={{128,30},{128,60},{126,60}}, color={0,127,255}));
        connect(jun1.port_2,senTemRet. port_b)
          annotation (Line(points={{100,-50},{110,-50}}, color={0,127,255}));
      connect(jun.port_3, valSou.port_a)
        annotation (Line(points={{90,50},{90,40}}, color={0,127,255}));
      connect(valSou.port_b, embSou.port_a) annotation (Line(points={{90,20},{90,14},
              {76,14},{76,0},{80,0}}, color={0,127,255}));
        connect(valNor.port_a,jun. port_2)
          annotation (Line(points={{50,40},{50,60},{80,60}}, color={0,127,255}));
        connect(valNor.port_b,embNor. port_a) annotation (Line(points={{50,20},{
                50,16},{34,16},{34,0},{40,0}}, color={0,127,255}));
        connect(pumSin.port_a,heaPum. port_b1)
          annotation (Line(points={{236,60},{240,60},{240,2}}, color={0,127,255}));
        connect(tan.heaPorVol[1],senTan. port)
          annotation (Line(points={{190,0},{190,-18},{200,-18}}, color={191,0,0}));
      connect(borFie.port_b,pumSou. port_a) annotation (Line(points={{300,-42},{306,
              -42},{306,42},{302,42}}, color={0,127,255}));
      connect(bou1.ports[1],pumSou. port_a) annotation (Line(points={{316,-8},{306,
              -8},{306,42},{302,42}}, color={0,127,255}));
        connect(outTem.y, movingAverage6h.u)
          annotation (Line(points={{-73,-76},{-66,-76}},
                                                       color={0,0,127}));
        connect(movingAverage6h.y, heaCur.u[1])
          annotation (Line(points={{-43,-76},{-38,-76}},
                                                       color={0,0,127}));
      connect(heaCur.y[1], conPIhea.u_s)
        annotation (Line(points={{-15,-76},{-10,-76}},
                                                   color={0,0,127}));
      connect(senTemSup.T, conPIhea.u_m) annotation (Line(points={{140,49},{140,-116},
                {2,-116},{2,-88}},
                                color={0,0,127},
            visible=false));
        connect(tan.port_a,pumSin. port_b) annotation (Line(points={{200,0},{208,0},{208,
                60},{216,60}}, color={0,127,255}));
        connect(tan.port_b, heaPum.port_a1) annotation (Line(points={{180,0},{186,0},
              {186,-50},{240,-50},{240,-18}},  color={0,127,255}));
        connect(TemTan.y, onOffCon.reference)
          annotation (Line(points={{57,166},{64,166},{64,164},{72,164}},
                                                       color={0,0,127}));
        connect(onOffCon.u, senTan.T) annotation (Line(points={{72,152},{68,152},
              {68,122},{290,122},{290,-2},{304,-2},{304,-18},{220,-18}},
                                                                       color={0,0,127},
            visible=false));

        connect(onOffCon.y,booToInt. u)
          annotation (Line(points={{95,158},{100,158},{100,160},{106,160}},
                                                     color={255,0,255}));
        connect(booToInt.y, heaPum.stage) annotation (Line(points={{129,160},{338,160},
                {338,-78},{243,-78},{243,-20}},                color={255,127,0},
            visible=false));
      connect(tan.port_b, jun2.port_2)
        annotation (Line(points={{180,0},{180,-50},{178,-50}},
                                                             color={0,127,255}));
      connect(heaPum.port_a2, threeWayValveSwitch.port_a1)
        annotation (Line(points={{252,2},{252,42},{256,42}}, color={0,127,255}));
      connect(threeWayValveSwitch.port_b,pumSou. port_b)
        annotation (Line(points={{276,42},{282,42}}, color={0,127,255}));
      connect(heaPum.port_b2, jun3.port_1) annotation (Line(points={{252,-18},{252,
              -42},{258,-42}}, color={0,127,255}));
      connect(jun3.port_2, borFie.port_a)
        annotation (Line(points={{274,-42},{280,-42}}, color={0,127,255}));
      connect(threeWayValveSwitch.port_a2, hex.port_a2)
        annotation (Line(points={{266,52},{266,92},{282,92}}, color={0,127,255}));
      connect(hex.port_b2, jun3.port_3) annotation (Line(points={{302,92},{344,92},{344,
                -64},{266,-64},{266,-50}},    color={0,127,255}));
      connect(cooMode.y, threeWayValveSwitch.switch) annotation (Line(points={{-73,-96},
              {266,-96},{266,34}},      color={255,0,255},
          visible=false));
      connect(threeWayValveSwitch1.port_b, senTemSup.port_a)
        annotation (Line(points={{156,60},{150,60}}, color={0,127,255}));
      connect(jun2.port_1, jun4.port_2)
        annotation (Line(points={{158,-50},{156,-50}}, color={0,127,255}));
      connect(jun4.port_1, senTemRet.port_a)
        annotation (Line(points={{136,-50},{130,-50}}, color={0,127,255}));
      connect(threeWayValveSwitch1.switch, threeWayValveSwitch.switch) annotation (
          Line(points={{166,52},{166,-80},{266,-80},{266,34}}, color={255,0,255},
            visible=false));
      connect(pumEmi.dp_in, dpEmi.y)
        annotation (Line(points={{116,72},{116,-130},{-73,-130}},
                                                             color={0,0,127},
            visible=false));
      connect(threeWayValveSwitch1.port_a2, hex.port_b1) annotation (Line(points={{
              166,70},{166,104},{282,104}}, color={0,127,255}));
      connect(jun4.port_3, hex.port_a1) annotation (Line(points={{146,-40},{146,130},
              {314,130},{314,104},{302,104}}, color={0,127,255}));
      connect(mFlowSouCon.y, pumSou.m_flow_in) annotation (Line(
          points={{1,-130},{292,-130},{292,54}},
          color={0,0,127},
          visible=false));
      connect(booToInt.y,pumSin. stage) annotation (Line(points={{129,160},{192,160},{
                192,158},{226,158},{226,72}},
                                            color={255,127,0},
            visible=false));
      connect(senTemSup.T, conPIcoo.u_m)
        annotation (Line(points={{140,49},{140,-114},{2,-114}},
                                                             color={0,0,127},
            visible=false));
      connect(cooCur.y[1], conPIcoo.u_s)
        annotation (Line(points={{-15,-102},{-10,-102}},
                                                   color={0,0,127}));
      connect(cooCur.u[1], movingAverage6h.y) annotation (Line(points={{-38,-102},{-42,
                -102},{-42,-76},{-43,-76}},
                                          color={0,0,127}));
      connect(QBorFie.y, ene.u)
        annotation (Line(points={{371,158},{380,158}}, color={0,0,127}));
        connect(threeWayValveMotor.port_b, threeWayValveSwitch1.port_a1)
          annotation (Line(points={{180,60},{176,60}}, color={0,127,255}));
        connect(threeWayValveMotor.port_a1, tan.port_a)
          annotation (Line(points={{200,60},{200,0},{200,0}}, color={0,127,255}));
        connect(threeWayValveMotor.port_a2, jun2.port_3) annotation (Line(points={{190,50},
              {190,28},{168,28},{168,-40}},       color={0,127,255}));
        connect(valMixCon.y, threeWayValveMotor.ctrl) annotation (Line(
            points={{-35,-130},{190,-130},{190,70.8}},
            color={0,0,127},
            visible=false));
      connect(valNorCon.y, conPIvalNorHea.u_m) annotation (Line(points={{-79,
              -44},{-58,-44},{-58,-30}}, color={0,0,127}));
      connect(conSP.y, conPIvalNorHea.u_s)
        annotation (Line(points={{-79,-18},{-70,-18}}, color={0,0,127}));
      connect(conSP.y, conPIvalSouHea.u_s) annotation (Line(points={{-79,-18},{
              -76,-18},{-76,20},{-70,20}}, color={0,0,127}));
      connect(valSouCon.y, conPIvalSouHea.u_m)
        annotation (Line(points={{-79,4},{-58,4},{-58,8}}, color={0,0,127}));
      connect(valNorCon.y, conAvg.u[1]) annotation (Line(
          points={{-79,-44},{-62,-44},{-62,49},{-42,49}},
          color={0,0,127},
          visible=false));
      connect(valSouCon.y, conAvg.u[2]) annotation (Line(
          points={{-79,4},{-79,27},{-42,27},{-42,51}},
          color={0,0,127},
          visible=false));
      connect(conSP.y, conPIvalNorCoo.u_s) annotation (Line(points={{-79,-18},{
              -76,-18},{-76,-2},{-38,-2},{-38,-18}}, color={0,0,127}));
      connect(conSP.y, conPIvalSouCoo.u_s) annotation (Line(points={{-79,-18},{
              -76,-18},{-76,-2},{-38,-2},{-38,20}}, color={0,0,127}));
      connect(valNorCon.y, conPIvalNorCoo.u_m) annotation (Line(points={{-79,
              -44},{-26,-44},{-26,-30}}, color={0,0,127}));
      connect(valSouCon.y, conPIvalSouCoo.u_m)
        annotation (Line(points={{-79,4},{-26,4},{-26,8}}, color={0,0,127}));
      connect(yValNor.y, valNor.y) annotation (Line(points={{33,56},{34,56},{34,
              30},{38,30}}, color={0,0,127}));
      connect(yValSou.y, valSou.y) annotation (Line(points={{69,74},{74,74},{74,
              30},{78,30}}, color={0,0,127}));
      connect(mode.u, conAvg.y) annotation (Line(points={{62,-112},{62,-31},{
              -19,-31},{-19,50}}, color={0,0,127}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-140},
                  {420,180}})),                                        Diagram(
              coordinateSystem(preserveAspectRatio=false, extent={{-100,-140},{420,180}})),
        experiment(
          StopTime=31536000,
          Interval=3600,
          Tolerance=0.001,
          __Dymola_fixedstepsize=10,
          __Dymola_Algorithm="Euler"));
      end GEOTABS;

      model GEOTABS_LowC
      extends GEOTABS(zonNor(redeclare
            TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSCeiling_lowC
            conTypCei, redeclare
            TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSFloor_lowC
            conTypFlo), zonSou(redeclare
            TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSCeiling_lowC
            conTypCei, redeclare
            TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSFloor_lowC
            conTypFlo));
      end GEOTABS_LowC;
    end Exercises;

    package BaseClasses

      model Envelope
        extends BaseClases.BuildingEnvelope(zonNor(
            n50=1.3,
            T_start=22 + 273.15,
            redeclare IDEAS.Buildings.Components.InterzonalAirFlow.n50Tight
              interzonalAirFlow,
          redeclare IDEAS.Buildings.Components.Occupants.Fixed occNum(nOccFix=
                occ.k),
          occTyp(QlatPp=0),
            l=2*sqrt(occ.A),
            w=sqrt(occ.A)/2,
            A_winA=0.4*zonNor.l*zonNor.h,
            fracA=0,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSWall
              conTypA,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSWall
              conTypB,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSWall
              conTypD,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSCeiling
              conTypCei,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSFloor
              conTypFlo), zonSou(
            n50=1.3,
            T_start=22 + 273.15,
            redeclare IDEAS.Buildings.Components.InterzonalAirFlow.n50Tight
              interzonalAirFlow,
          redeclare IDEAS.Buildings.Components.Occupants.Fixed occNum(nOccFix=
                occ.k),
          occTyp(QlatPp=0),
            l=2*sqrt(occ.A),
            w=sqrt(occ.A)/2,
            A_winC=0.4*zonSou.l*zonSou.h,
            fracC=0,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSWall
              conTypB,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSWall
              conTypC,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSWall
              conTypD,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSCeiling
              conTypCei,
            redeclare TheSysConExe.GEOTABS.BaseClasses.Constructions.GEOTABSFloor
              conTypFlo));
        BaseClases.Occupancy occ(
          linearise=false,
          A=500,
          setHeaOcc=21 + 273.15,
          setHeaUno=21 + 273.15,
          setCooOcc=24.5 + 273.15,
          setCooUno=24.5 + 273.15,
          k=30)
          "Occupancy schedule and setpoints for each of the zones in the building"
          annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
        annotation (experiment(
            StopTime=31536000,
            Interval=3600,
            __Dymola_fixedstepsize=15,
            __Dymola_Algorithm="Euler"));
      end Envelope;

      package Constructions

        record GEOTABSWall
          "GEOTABS wall"
          extends IDEAS.Buildings.Data.Interfaces.Construction(
            mats={IDEAS.Buildings.Data.Materials.BrickMe(d=0.10),
                  IDEAS.Buildings.Data.Insulation.Rockwool(d=0.16),
                  IDEAS.Buildings.Data.Materials.BrickMi(d=0.15)});
        end GEOTABSWall;

        record GEOTABSCeiling "GEOTABS ceiling"
          extends IDEAS.Buildings.Data.Interfaces.Construction(
            incLastLay = IDEAS.Types.Tilt.Ceiling,
            mats={TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete(d=0.05),
            IDEAS.Buildings.Data.Insulation.Rockwool(d=0.21),
            TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete(d=0.19),
            TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete(d=0.06)});
        end GEOTABSCeiling;

        record GEOTABSFloor "GEOTABS floor"
          extends IDEAS.Buildings.Data.Interfaces.Construction(
            incLastLay = IDEAS.Types.Tilt.Floor,
            locGain={3},
            mats={TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete(d=0.10),
            IDEAS.Buildings.Data.Insulation.Rockwool(d=0.21),
            TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete(d=0.14),
            TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete(d=0.06)});
        end GEOTABSFloor;

        record GEOTABSCeiling_lowC "GEOTABS ceiling"
          extends IDEAS.Buildings.Data.Interfaces.Construction(
            incLastLay = IDEAS.Types.Tilt.Ceiling,
            mats={TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete_lowC(d=0.05),
            IDEAS.Buildings.Data.Insulation.Rockwool(d=0.21),
            TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete_lowC(d=0.19),
            TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete_lowC(d=0.06)});
        end GEOTABSCeiling_lowC;

        record GEOTABSFloor_lowC "GEOTABS floor"
          extends IDEAS.Buildings.Data.Interfaces.Construction(
            incLastLay = IDEAS.Types.Tilt.Floor,
            locGain={3},
            mats={TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete_lowC(d=0.10),
            IDEAS.Buildings.Data.Insulation.Rockwool(d=0.21),
            TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete_lowC(d=0.14),
            TheSysConExe.GEOTABS.BaseClasses.Constructions.Materials.Concrete_lowC(d=0.06)});
        end GEOTABSFloor_lowC;

        package Materials

          record Concrete = IDEAS.Buildings.Data.Interfaces.Material (
              k=1.4,
              c=840,
              rho=2100,
              epsLw=0.88,
              epsSw=0.55) "Dense cast concrete, also for finishing" annotation (
              Documentation(info="<html>
<p>
Thermal properties of concrete.
</p>
</html>"));

          record Concrete_lowC =
                            IDEAS.Buildings.Data.Interfaces.Material (
              k=1.4,
              c=300,
              rho=150,
              epsLw=0.86,
              epsSw=0.44) "Dense cast concrete, also for finishing" annotation (
              Documentation(info="<html>
<p>
Thermal properties of concrete.
</p>
</html>"));
        end Materials;
      end Constructions;
    end BaseClasses;
  end GEOTABS;
  annotation (uses(                                                   IDEAS(
        version="2.1.0"), Modelica(version="3.2.3"),
    Modelica_StateGraph2(version="2.0.4")));
end TheSysConExe;
model TheSysConExe_GEOTABS_Exercises_GEOTABS_LowC
 extends TheSysConExe.GEOTABS.Exercises.GEOTABS_LowC;
  annotation(experiment(
    StopTime=3.1536e+07,
    Interval=3600,
    Tolerance=0.001,
    __Dymola_fixedstepsize=10,
    __Dymola_Algorithm="euler"));
end TheSysConExe_GEOTABS_Exercises_GEOTABS_LowC;
